From jdoyon at berlios.de  Thu May  4 01:47:27 2006
From: jdoyon at berlios.de (jdoyon at BerliOS)
Date: Thu, 4 May 2006 01:47:27 +0200
Subject: [Mapnik-svn] r240 - trunk/src
Message-ID: <200605032347.k43NlRgW014049@sheep.berlios.de>

Author: jdoyon
Date: 2006-05-04 01:46:32 +0200 (Thu, 04 May 2006)
New Revision: 240

Modified:
   trunk/src/image_util.cpp
Log:
Switched from <fstream.h> to <fstream> as per the warning the compiler gave me, and the C++ standard.



Modified: trunk/src/image_util.cpp
===================================================================
--- trunk/src/image_util.cpp	2006-04-22 19:37:59 UTC (rev 239)
+++ trunk/src/image_util.cpp	2006-05-03 23:46:32 UTC (rev 240)
@@ -25,6 +25,8 @@
 #include <string>
 #include <png.h>
 #include <jpeglib.h>
+#include <gif_lib.h>
+#include <fstream>
 #include "graphics.hpp"
 #include "image_util.hpp"
 #include "memory.hpp"
@@ -54,6 +56,10 @@
 	{
 	    save_as_jpeg(filename,85,image);
 	}
+        else if (type=="gif")
+        {
+	    save_as_gif(filename,image);
+        }
     }
 
     void ImageUtils::save_as_png(const std::string& filename,const Image32& image)
@@ -151,4 +157,26 @@
 	fclose(fp);
 	jpeg_destroy_compress(&cinfo);
     }
+
+    void ImageUtils::save_as_gif(const std::string& filename,const Image32& image)
+    {
+        GifFileType *fp=EGifOpenFileName(filename.c_str(),0);
+        if (!fp) return;
+        int width=image.width();
+        int height=image.height();
+ 	ColorMapObject *OutputColorMap = MakeMapObject(256, NULL);
+
+	EGifPutScreenDesc(fp, width, height, 8, 0, OutputColorMap);
+        EGifPutImageDesc(fp, 0, 0, width, height, FALSE, NULL);
+
+	const ImageData32& imageData=image.data();
+
+        for (int i=0;i<height;i++)
+        {
+            EGifPutLine(fp, (GifPixelType*)imageData.getRow(i), width);
+        }
+
+        EGifCloseFile(fp);
+	FreeMapObject(OutputColorMap);
+    }
 }



From jdoyon at berlios.de  Thu May  4 01:56:56 2006
From: jdoyon at berlios.de (jdoyon at BerliOS)
Date: Thu, 4 May 2006 01:56:56 +0200
Subject: [Mapnik-svn] r241 - trunk/src
Message-ID: <200605032356.k43NuuEG016159@sheep.berlios.de>

Author: jdoyon
Date: 2006-05-04 01:56:47 +0200 (Thu, 04 May 2006)
New Revision: 241

Modified:
   trunk/src/image_util.cpp
Log:
Oops, that previous problem was from local modifications, setting everything back to normal.

Sorry!



Modified: trunk/src/image_util.cpp
===================================================================
--- trunk/src/image_util.cpp	2006-05-03 23:46:32 UTC (rev 240)
+++ trunk/src/image_util.cpp	2006-05-03 23:56:47 UTC (rev 241)
@@ -25,8 +25,6 @@
 #include <string>
 #include <png.h>
 #include <jpeglib.h>
-#include <gif_lib.h>
-#include <fstream>
 #include "graphics.hpp"
 #include "image_util.hpp"
 #include "memory.hpp"
@@ -56,10 +54,6 @@
 	{
 	    save_as_jpeg(filename,85,image);
 	}
-        else if (type=="gif")
-        {
-	    save_as_gif(filename,image);
-        }
     }
 
     void ImageUtils::save_as_png(const std::string& filename,const Image32& image)
@@ -157,26 +151,4 @@
 	fclose(fp);
 	jpeg_destroy_compress(&cinfo);
     }
-
-    void ImageUtils::save_as_gif(const std::string& filename,const Image32& image)
-    {
-        GifFileType *fp=EGifOpenFileName(filename.c_str(),0);
-        if (!fp) return;
-        int width=image.width();
-        int height=image.height();
- 	ColorMapObject *OutputColorMap = MakeMapObject(256, NULL);
-
-	EGifPutScreenDesc(fp, width, height, 8, 0, OutputColorMap);
-        EGifPutImageDesc(fp, 0, 0, width, height, FALSE, NULL);
-
-	const ImageData32& imageData=image.data();
-
-        for (int i=0;i<height;i++)
-        {
-            EGifPutLine(fp, (GifPixelType*)imageData.getRow(i), width);
-        }
-
-        EGifCloseFile(fp);
-	FreeMapObject(OutputColorMap);
-    }
 }



From jdoyon at berlios.de  Thu May  4 02:01:53 2006
From: jdoyon at berlios.de (jdoyon at BerliOS)
Date: Thu, 4 May 2006 02:01:53 +0200
Subject: [Mapnik-svn] r242 - trunk/bindings/python
Message-ID: <200605040001.k4401rKe016904@sheep.berlios.de>

Author: jdoyon
Date: 2006-05-04 02:00:20 +0200 (Thu, 04 May 2006)
New Revision: 242

Modified:
   trunk/bindings/python/mapnik_image.cpp
Log:
Make the background property of an Image available to Python.



Modified: trunk/bindings/python/mapnik_image.cpp
===================================================================
--- trunk/bindings/python/mapnik_image.cpp	2006-05-03 23:56:47 UTC (rev 241)
+++ trunk/bindings/python/mapnik_image.cpp	2006-05-04 00:00:20 UTC (rev 242)
@@ -44,6 +44,9 @@
     class_<Image32>("Image","This class represents a 32 bit image.",init<int,int>())
 	.def("width",&Image32::width)
 	.def("height",&Image32::height)
+        .add_property("background",make_function
+                      (&Image32::getBackground,return_value_policy<copy_const_reference>()),
+                       &Image32::setBackground, "The background color of the image.")
 	;    
     def("rawdata",&rawdata);
 }



From pavlenko at berlios.de  Fri May  5 16:29:02 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Fri, 5 May 2006 16:29:02 +0200
Subject: [Mapnik-svn] r243 - trunk/include
Message-ID: <200605051429.k45ET2CB027756@sheep.berlios.de>

Author: pavlenko
Date: 2006-05-05 16:29:01 +0200 (Fri, 05 May 2006)
New Revision: 243

Modified:
   trunk/include/filter_parser.hpp
   trunk/include/mapnik.hpp
Log:
reorder #include 

Modified: trunk/include/filter_parser.hpp
===================================================================
--- trunk/include/filter_parser.hpp	2006-05-04 00:00:20 UTC (rev 242)
+++ trunk/include/filter_parser.hpp	2006-05-05 14:29:01 UTC (rev 243)
@@ -26,6 +26,9 @@
 #ifndef FILTER_PARSER_HPP
 #define FILTER_PARSER_HPP
 
+#include <stack>
+#include <iostream>
+
 #include <boost/shared_ptr.hpp>
 #include <boost/spirit/core.hpp>
 #include <boost/spirit/symbols.hpp>
@@ -39,8 +42,6 @@
 #include "filter.hpp"
 #include "regex_filter.hpp"
 
-#include <stack>
-#include <iostream>
 
 using namespace boost::spirit;
 using std::string;

Modified: trunk/include/mapnik.hpp
===================================================================
--- trunk/include/mapnik.hpp	2006-05-04 00:00:20 UTC (rev 242)
+++ trunk/include/mapnik.hpp	2006-05-05 14:29:01 UTC (rev 243)
@@ -28,6 +28,7 @@
 #include <map>
 #include <vector>
 #include <cassert>
+
 #include "global.hpp"
 #include "factory.hpp"
 #include "filter.hpp"



From pavlenko at berlios.de  Mon May  8 22:34:37 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Mon, 8 May 2006 22:34:37 +0200
Subject: [Mapnik-svn] r245 - trunk/demo/c++
Message-ID: <200605082034.k48KYbF4000197@sheep.berlios.de>

Author: pavlenko
Date: 2006-05-08 22:34:30 +0200 (Mon, 08 May 2006)
New Revision: 245

Added:
   trunk/demo/c++/readme.txt
Log:
added readme.txt with build instructions



Added: trunk/demo/c++/readme.txt
===================================================================
--- trunk/demo/c++/readme.txt	2006-05-08 20:29:13 UTC (rev 244)
+++ trunk/demo/c++/readme.txt	2006-05-08 20:34:30 UTC (rev 245)
@@ -0,0 +1,15 @@
+This directory contains a simple c++ program demonstrating Mapnik API. It mimics python example with couple exceptions.
+
+To build (using GCC/G++ toolkit):
+
+g++ -O3 -I/usr/local/include/mapnik -I/opt/boost/include/boost-1_33_1 -I/usr/include/freetype2  -L/usr/local/lib -lmapnik rundemo.cpp -o rundemo
+
+
+To run:
+
+./rundemo
+
+For more detailed comments have a look in demo/python/rundemo.py
+
+Have fun!
+Artem.



From pavlenko at berlios.de  Mon May  8 22:29:13 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Mon, 8 May 2006 22:29:13 +0200
Subject: [Mapnik-svn] r244 - in trunk/demo: . c++
Message-ID: <200605082029.k48KTDSd032482@sheep.berlios.de>

Author: pavlenko
Date: 2006-05-08 22:29:13 +0200 (Mon, 08 May 2006)
New Revision: 244

Added:
   trunk/demo/c++/
   trunk/demo/c++/rundemo.cpp
Log:
added c++ demo 



Added: trunk/demo/c++/rundemo.cpp
===================================================================
--- trunk/demo/c++/rundemo.cpp	2006-05-05 14:29:01 UTC (rev 243)
+++ trunk/demo/c++/rundemo.cpp	2006-05-08 20:29:13 UTC (rev 244)
@@ -0,0 +1,221 @@
+
+#include <mapnik.hpp>
+#include <iostream>
+
+using namespace mapnik;
+
+// helper function 
+filter_ptr create_filter (std::string const& wkt)
+{
+    filter_factory<Feature> factory;
+    return factory.compile(wkt);
+}
+
+int main ( int argc , char** argv)
+{    
+    std::cout << " running demo ... \n";
+    datasource_cache::instance()->register_datasources("/usr/local/lib/mapnik/input"); 
+    freetype_engine::instance()->register_font("/usr/share/fonts/bitstream-vera/Vera.ttf");
+    
+    Map m(800,600);
+    m.setBackground(color_factory::from_string("white"));
+    
+    // create styles
+
+    // Provinces (polygon)
+    feature_type_style provpoly_style;
+   
+    rule_type provpoly_rule_on;
+    provpoly_rule_on.set_filter(create_filter("[NAME_EN] = 'Ontario'"));
+    provpoly_rule_on.append(polygon_symbolizer(Color(250, 190, 183)));
+    provpoly_style.add_rule(provpoly_rule_on);
+    
+    rule_type provpoly_rule_qc;
+    provpoly_rule_qc.set_filter(create_filter("[NAME_EN] = 'Quebec'"));
+    provpoly_rule_qc.append(polygon_symbolizer(Color(217, 235, 203)));
+    provpoly_style.add_rule(provpoly_rule_qc);
+    
+    m.insert_style("provinces",provpoly_style);
+
+    // Provinces (polyline)
+    feature_type_style provlines_style;
+    
+    stroke provlines_stk (Color(0,0,0),1.0);
+    provlines_stk.add_dash(8, 4);
+    provlines_stk.add_dash(2, 2);
+    provlines_stk.add_dash(2, 2);
+    
+    rule_type provlines_rule;
+    provlines_rule.append(line_symbolizer(provlines_stk));
+    provlines_style.add_rule(provlines_rule);
+    
+    m.insert_style("provlines",provlines_style);
+    
+    // Drainage 
+    feature_type_style qcdrain_style;
+    
+    rule_type qcdrain_rule;
+    qcdrain_rule.set_filter(create_filter("[HYC] = 8"));
+    qcdrain_rule.append(polygon_symbolizer(Color(153, 204, 255)));
+    qcdrain_style.add_rule(qcdrain_rule);
+    
+    m.insert_style("drainage",qcdrain_style);
+    
+    // Roads 3 and 4 (The "grey" roads)
+    feature_type_style roads34_style;    
+    rule_type roads34_rule;
+    roads34_rule.set_filter(create_filter("[CLASS] = 3 or [CLASS] = 4"));
+    stroke roads34_rule_stk(Color(171,158,137),2.0);
+    roads34_rule_stk.set_line_cap(ROUND_CAP);
+    roads34_rule_stk.set_line_join(ROUND_JOIN);
+    roads34_rule.append(line_symbolizer(roads34_rule_stk));
+    roads34_style.add_rule(roads34_rule);
+    
+    m.insert_style("smallroads",roads34_style);
+    
+
+    // Roads 2 (The thin yellow ones)
+    feature_type_style roads2_style_1;
+    rule_type roads2_rule_1;
+    roads2_rule_1.set_filter(create_filter("[CLASS] = 2"));
+    stroke roads2_rule_stk_1(Color(171,158,137),4.0);
+    roads2_rule_stk_1.set_line_cap(ROUND_CAP);
+    roads2_rule_stk_1.set_line_join(ROUND_JOIN);
+    roads2_rule_1.append(line_symbolizer(roads2_rule_stk_1));
+    roads2_style_1.add_rule(roads2_rule_1);
+    
+    m.insert_style("road-border", roads2_style_1);
+    
+    feature_type_style roads2_style_2;
+    rule_type roads2_rule_2;
+    roads2_rule_2.set_filter(create_filter("[CLASS] = 2"));
+    stroke roads2_rule_stk_2(Color(255,250,115),2.0);
+    roads2_rule_stk_2.set_line_cap(ROUND_CAP);
+    roads2_rule_stk_2.set_line_join(ROUND_JOIN);
+    roads2_rule_2.append(line_symbolizer(roads2_rule_stk_2));
+    roads2_style_2.add_rule(roads2_rule_2);
+    
+    m.insert_style("road-fill", roads2_style_2);
+    
+    // Roads 1 (The big orange ones, the highways)
+    feature_type_style roads1_style_1;
+    rule_type roads1_rule_1;
+    roads1_rule_1.set_filter(create_filter("[CLASS] = 1"));
+    stroke roads1_rule_stk_1(Color(188,149,28),7.0);
+    roads1_rule_stk_1.set_line_cap(ROUND_CAP);
+    roads1_rule_stk_1.set_line_join(ROUND_JOIN);
+    roads1_rule_1.append(line_symbolizer(roads1_rule_stk_1));
+    roads1_style_1.add_rule(roads1_rule_1);
+    m.insert_style("highway-border", roads1_style_1);
+    
+    feature_type_style roads1_style_2;
+    rule_type roads1_rule_2;
+    roads1_rule_2.set_filter(create_filter("[CLASS] = 1"));
+    stroke roads1_rule_stk_2(Color(242,191,36),5.0);
+    roads1_rule_stk_2.set_line_cap(ROUND_CAP);
+    roads1_rule_stk_2.set_line_join(ROUND_JOIN);
+    roads1_rule_2.append(line_symbolizer(roads1_rule_stk_2));
+    roads1_style_2.add_rule(roads1_rule_2);
+    m.insert_style("highway-fill", roads1_style_2);
+    
+    // Populated Places
+    
+    feature_type_style popplaces_style;
+    rule_type popplaces_rule;
+    text_symbolizer popplaces_text_symbolizer("GEONAME",10,Color(0,0,0));
+    popplaces_text_symbolizer.set_halo_fill(Color(255,255,200));
+    popplaces_text_symbolizer.set_halo_radius(1);
+    popplaces_rule.append(popplaces_text_symbolizer);
+    popplaces_style.add_rule(popplaces_rule);
+    
+    m.insert_style("popplaces",popplaces_style );
+    
+    // Layers
+    // Provincial  polygons
+    {
+        parameters p;
+        p["name"]="Provinces";
+        p["type"]="shape";
+        p["file"]="../data/boundaries";
+        
+        Layer lyr(p); 
+        lyr.add_style("provinces");    
+        m.addLayer(lyr);
+    }
+    
+    // Drainage
+    {
+        parameters p;
+        p["name"]="Quebec Hydrography";
+        p["type"]="shape";
+        p["file"]="../data/qcdrainage";
+        
+        Layer lyr(p); 
+        lyr.add_style("drainage");    
+        m.addLayer(lyr);
+    }
+    {
+        parameters p;
+        p["name"]="Ontario Hydrography";
+        p["type"]="shape";
+        p["file"]="../data/ontdrainage";
+        
+        Layer lyr(p); 
+        lyr.add_style("drainage");    
+        m.addLayer(lyr);
+    }
+    
+    // Provincial boundaries
+    {
+        parameters p;
+        p["name"]="Provincial borders";
+        p["type"]="shape";
+        p["file"]="../data/boundaries_l";
+        
+        Layer lyr(p); 
+        lyr.add_style("provlines");    
+        m.addLayer(lyr);
+    }
+    
+    // Roads
+    {
+        parameters p;
+        p["name"]="Roads";
+        p["type"]="shape";
+        p["file"]="../data/roads";
+        
+        Layer lyr(p); 
+        lyr.add_style("smallroads");
+        lyr.add_style("road-border");
+        lyr.add_style("road-fill");
+        lyr.add_style("highway-border");
+        lyr.add_style("highway-fill");
+        m.addLayer(lyr);        
+    }
+    // popplaces
+    {
+        parameters p;
+        p["name"]="Populated Places";
+        p["type"]="shape";
+        p["file"]="../data/popplaces";
+        
+        Layer lyr(p); 
+        lyr.add_style("popplaces");    
+        m.addLayer(lyr);
+    }
+    m.zoomToBox(Envelope<double>(1405120.04127408,-247003.813399447,1706357.31328276,-25098.593149577));
+    
+    Image32 buf(m.getWidth(),m.getHeight());
+    agg_renderer<Image32> ren(m,buf);
+    ren.apply();
+    
+    ImageUtils::save_to_file("demo.jpg","jpeg",buf);
+    ImageUtils::save_to_file("demo.png","png",buf);
+    
+    std::cout << "Two maps have been rendered in the current directory:\n"
+        "- demo.jpg\n"
+        "- demo.png\n"
+        "Have a look!\n";
+    
+    return 0;
+}



From jdoyon at berlios.de  Thu May 11 02:30:04 2006
From: jdoyon at berlios.de (jdoyon at BerliOS)
Date: Thu, 11 May 2006 02:30:04 +0200
Subject: [Mapnik-svn] r246 - trunk/bindings/python/mapnik/ogcserver
Message-ID: <200605110030.k4B0U4c9002982@sheep.berlios.de>

Author: jdoyon
Date: 2006-05-11 02:29:39 +0200 (Thu, 11 May 2006)
New Revision: 246

Modified:
   trunk/bindings/python/mapnik/ogcserver/common.py
   trunk/bindings/python/mapnik/ogcserver/wms111.py
   trunk/bindings/python/mapnik/ogcserver/wms130.py
Log:
Remove GIF support.

Modified: trunk/bindings/python/mapnik/ogcserver/common.py
===================================================================
--- trunk/bindings/python/mapnik/ogcserver/common.py	2006-05-08 20:34:30 UTC (rev 245)
+++ trunk/bindings/python/mapnik/ogcserver/common.py	2006-05-11 00:29:39 UTC (rev 246)
@@ -20,7 +20,7 @@
 # $Id$
 
 from exceptions import OGCException, ServerConfigurationError
-from mapnik import Map, Color, Envelope, render, rawdata, Image, Projection
+from mapnik import Map, Color, Envelope, render, rawdata, Image, Projection, render_to_file
 from PIL.Image import fromstring, new
 from PIL.ImageDraw import Draw
 from StringIO import StringIO
@@ -36,7 +36,7 @@
 #                                    'http://www.w3.org/2001/XMLSchema-instance': 'xsi'
 #                                    })
 
-PIL_TYPE_MAPPING = {'image/jpeg': 'JPEG', 'image/png': 'PNG', 'image/gif': 'GIF'}
+PIL_TYPE_MAPPING = {'image/jpeg': 'JPEG', 'image/png': 'PNG'}
 
 class ParameterDefinition:
 
@@ -207,6 +207,8 @@
         m = Map(params['width'], params['height'])
         if params.has_key('transparent') and params['transparent'] == 'FALSE':
             m.background = params['bgcolor']
+        else:
+            m.background = Color(0, 0, 0, 0)
         maplayers = self.mapfactory.layers
         mapstyles = self.mapfactory.styles
         for layername in params['layers']:
@@ -223,9 +225,10 @@
         m.zoom_to_box(Envelope(params['bbox'][0], params['bbox'][1], params['bbox'][2], params['bbox'][3]))
         im = Image(params['width'], params['height'])
         render(m, im)
-        im2 = fromstring('RGBA', (params['width'], params['height']), rawdata(im))
+        render_to_file(m, '/tmp/ogcserver.png', 'png')
+        im = fromstring('RGBA', (params['width'], params['height']), rawdata(im))
         fh = StringIO()
-        im2.save(fh, PIL_TYPE_MAPPING[params['format']])
+        im.save(fh, PIL_TYPE_MAPPING[params['format']], quality=100)
         fh.seek(0)
         return Response(params['format'], fh.read())
 

Modified: trunk/bindings/python/mapnik/ogcserver/wms111.py
===================================================================
--- trunk/bindings/python/mapnik/ogcserver/wms111.py	2006-05-08 20:34:30 UTC (rev 245)
+++ trunk/bindings/python/mapnik/ogcserver/wms111.py	2006-05-11 00:29:39 UTC (rev 246)
@@ -78,7 +78,6 @@
           <GetMap>
             <Format>image/png</Format>
             <Format>image/jpeg</Format>
-            <Format>image/gif</Format>
             <DCPType>
               <HTTP>
                 <Get>

Modified: trunk/bindings/python/mapnik/ogcserver/wms130.py
===================================================================
--- trunk/bindings/python/mapnik/ogcserver/wms130.py	2006-05-08 20:34:30 UTC (rev 245)
+++ trunk/bindings/python/mapnik/ogcserver/wms130.py	2006-05-11 00:29:39 UTC (rev 246)
@@ -84,7 +84,6 @@
           <GetMap>
             <Format>image/png</Format>
             <Format>image/jpeg</Format>
-            <Format>image/gif</Format>
             <DCPType>
               <HTTP>
                 <Get>



From jdoyon at berlios.de  Thu May 11 02:44:56 2006
From: jdoyon at berlios.de (jdoyon at BerliOS)
Date: Thu, 11 May 2006 02:44:56 +0200
Subject: [Mapnik-svn] r247 - trunk/docs/ogcserver
Message-ID: <200605110044.k4B0iuW9005656@sheep.berlios.de>

Author: jdoyon
Date: 2006-05-11 02:44:20 +0200 (Thu, 11 May 2006)
New Revision: 247

Modified:
   trunk/docs/ogcserver/readme.txt
Log:
Finalized ogcserver docs.

Modified: trunk/docs/ogcserver/readme.txt
===================================================================
--- trunk/docs/ogcserver/readme.txt	2006-05-11 00:29:39 UTC (rev 246)
+++ trunk/docs/ogcserver/readme.txt	2006-05-11 00:44:20 UTC (rev 247)
@@ -19,7 +19,7 @@
 - WMS 1.1.1 and 1.3.0
 - CGI/FastCGI
 - GetCapabilities and GetMap support only (NO GetFeatureInfo)
-- GIF/JPEG/PNG output
+- JPEG/PNG output
 - XML/INIMAGE/BLANK error handling
 - No real layer metadata support yet
 - No re-projection support
@@ -115,4 +115,19 @@
 - The layers must have at least one style associated with them (a default).
 - No Map() object is used or needed here.
 - Be sure to call self.finalize() once you've registered everything! This will
-  validate everything and let you know if there's problems.
\ No newline at end of file
+  validate everything and let you know if there's problems.
+- You can associate more styles to a given layer by passing a tuple of style
+  names along with the layer itself to register_layer().  As of this writing
+  this is useless as the core engine doesn't yet support named styles :)
+
+
+Conclusion
+----------
+
+	This is the very first implementation of a WMS for Mapnik.  Although inital
+testing seems to suggest it works well, there may be bugs, and it lacks some
+useful features.  Comments, contributions, and requests for help should all be
+directed to the Mapnik mailing list.
+
+Enjoy!
+J.F.
\ No newline at end of file



From jdoyon at berlios.de  Thu May 11 06:24:54 2006
From: jdoyon at berlios.de (jdoyon at BerliOS)
Date: Thu, 11 May 2006 06:24:54 +0200
Subject: [Mapnik-svn] r248 - in trunk: bindings/python/mapnik/ogcserver bindings/python/pyprojection docs/ogcserver
Message-ID: <200605110424.k4B4OsDA001378@sheep.berlios.de>

Author: jdoyon
Date: 2006-05-11 06:24:51 +0200 (Thu, 11 May 2006)
New Revision: 248

Modified:
   trunk/bindings/python/mapnik/ogcserver/WMS.py
   trunk/bindings/python/mapnik/ogcserver/cgiserver.py
   trunk/bindings/python/mapnik/ogcserver/common.py
   trunk/bindings/python/mapnik/ogcserver/wms111.py
   trunk/bindings/python/mapnik/ogcserver/wms130.py
   trunk/bindings/python/pyprojection/Projection_wrap.c
   trunk/docs/ogcserver/readme.txt
Log:
- Rigidified parameter validation
- Fixed BLANK exception handling bug
- Added STYLES/LAYERS correlation check
- Finalized ogcserver readme.txt
- Got rid of a compiler warning with PyProjection
- Some coding style edits

Modified: trunk/bindings/python/mapnik/ogcserver/WMS.py
===================================================================
--- trunk/bindings/python/mapnik/ogcserver/WMS.py	2006-05-11 00:44:20 UTC (rev 247)
+++ trunk/bindings/python/mapnik/ogcserver/WMS.py	2006-05-11 04:24:51 UTC (rev 248)
@@ -37,11 +37,11 @@
         return ServiceHandler111(conf, mapfactory, onlineresource)
 
 class BaseWMSFactory:
-    
+
     def __init__(self):
         self.layers = {}
         self.styles = {}
-    
+
     def register_layer(self, layer, extrastyles=()):
         layername = layer.name()
         if not layername:
@@ -51,14 +51,14 @@
             layer.wmsextrastyles = extrastyles
         else:
             raise ServerConfigurationError('Layer "%s" was passed an invalid list of extra styles.  List must be a tuple of strings.' % layername)
-    
+
     def register_style(self, name, style):
         if not name:
             raise ServerConfigurationError('Attempted to register a style without providing a name.')
         if not isinstance(style, Style):
             raise ServerConfigurationError('Bad style object passed to register_style() for style "%s".' % name)
         self.styles[name] = style
-    
+
     def finalize(self):
         if len(self.layers) == 0:
             raise ServerConfigurationError('No layers defined!')

Modified: trunk/bindings/python/mapnik/ogcserver/cgiserver.py
===================================================================
--- trunk/bindings/python/mapnik/ogcserver/cgiserver.py	2006-05-11 00:44:20 UTC (rev 247)
+++ trunk/bindings/python/mapnik/ogcserver/cgiserver.py	2006-05-11 04:24:51 UTC (rev 248)
@@ -57,23 +57,30 @@
         onlineresource = 'http://%s:%s%s?' % (req.environ['SERVER_NAME'], req.environ['SERVER_PORT'], req.environ['SCRIPT_NAME'])
         if not reqparams.has_key('request'):
             raise OGCException('Missing request parameter.')
-        if reqparams['request'] == 'GetCapabilities' and not reqparams.has_key('service'):
+        request = reqparams['request']
+        del reqparams['request']
+        if request == 'GetCapabilities' and not reqparams.has_key('service'):
             raise OGCException('Missing service parameter.')
-        if reqparams['request'] in ['GetMap', 'GetFeatureInfo']:
-            reqparams['service'] = 'WMS'
+        if request in ['GetMap', 'GetFeatureInfo']:
+            service = 'WMS'
+        else:
+            service = reqparams['service']
+        if reqparams.has_key('service'):
+            del reqparams['service']
         try:
-            mapnikmodule = __import__('mapnik.ogcserver.' + reqparams['service'])
+            mapnikmodule = __import__('mapnik.ogcserver.' + service)
         except:
-            raise OGCException('Unsupported service "%s".' % reqparams['service'])
-        ServiceHandlerFactory = getattr(mapnikmodule.ogcserver, reqparams['service']).ServiceHandlerFactory
+            raise OGCException('Unsupported service "%s".' % service)
+        ServiceHandlerFactory = getattr(mapnikmodule.ogcserver, service).ServiceHandlerFactory
         servicehandler = ServiceHandlerFactory(self.conf, self.mapfactory, onlineresource, reqparams.get('version', None))
-        if reqparams['request'] not in servicehandler.SERVICE_PARAMS.keys():
-            raise OGCException('Operation "%s" not supported.' % reqparams['request'], 'OperationNotSupported')
-        ogcparams = servicehandler.processParameters(reqparams['request'], reqparams)
+        del reqparams['version']
+        if request not in servicehandler.SERVICE_PARAMS.keys():
+            raise OGCException('Operation "%s" not supported.' % request, 'OperationNotSupported')
+        ogcparams = servicehandler.processParameters(request, reqparams)
         try:
-            requesthandler = getattr(servicehandler, reqparams['request'])
+            requesthandler = getattr(servicehandler, request)
         except:
-            raise OGCException('Operation "%s" not supported.' % reqparams['request'], 'OperationNotSupported')
+            raise OGCException('Operation "%s" not supported.' % request, 'OperationNotSupported')
         response = requesthandler(ogcparams)
         req.set_header('Content-Type', response.content_type)
         req.write(response.content)

Modified: trunk/bindings/python/mapnik/ogcserver/common.py
===================================================================
--- trunk/bindings/python/mapnik/ogcserver/common.py	2006-05-11 00:44:20 UTC (rev 247)
+++ trunk/bindings/python/mapnik/ogcserver/common.py	2006-05-11 04:24:51 UTC (rev 248)
@@ -46,21 +46,21 @@
 
             @param mandatory: Is this parameter required by the request?
             @type mandatory: Boolean.
-            
+
             @param default: Default value to use if one is not provided
                             and the parameter is optional.
             @type default: None or any valid value.
-            
+
             @param allowedvalues: A list of allowed values for the parameter.
                                   If a value is provided that is not in this
                                   list, an error is raised.
             @type allowedvalues: A python tuple of values.
-            
+
             @param fallback: Whether the value of the parameter should fall
                              back to the default should an illegal value be
                              provided.
             @type fallback: Boolean.
-            
+
             @return: A L{ParameterDefinition} instance.
         """
         if mandatory not in [True, False]:
@@ -81,6 +81,9 @@
 
     def processParameters(self, requestname, params):
         finalparams = {}
+        for paramname in params.keys():
+            if paramname not in self.SERVICE_PARAMS[requestname].keys():
+                raise OGCException('Unknown request parameter "%s".' % paramname)
         for paramname, paramdef in self.SERVICE_PARAMS[requestname].items():
             if paramname not in params.keys() and paramdef.mandatory:
                 raise OGCException('Mandatory parameter "%s" missing from request.' % paramname)
@@ -144,10 +147,10 @@
                     return 0
 
 class ListFactory:
-    
+
     def __init__(self, cast):
         self.cast = cast
-    
+
     def __call__(self, string):
         seq = string.split(',')
         return map(self.cast, seq)
@@ -159,15 +162,15 @@
         raise OGCException('Invalid color value. Must be of format "0xFFFFFF".')
 
 class CRS:
-    
+
     def __init__(self, namespace, code):
         self.namespace = namespace
         self.code = int(code)
         self.proj = None
-    
+
     def __repr__(self):
         return '%s:%s' % (self.namespace, self.code)
-    
+
     def __eq__(self, other):
         if str(other) == str(self):
             return True
@@ -177,17 +180,17 @@
         if not self.proj:
             self.proj = Projection(['init=%s' % str(self).lower()])
         return self.proj.Inverse(x, y)
-    
+
     def Forward(self, x, y):
         if not self.proj:
             self.proj = Projection(['init=%s' % str(self).lower()])
         return self.proj.Forward(x, y)
 
 class CRSFactory:
-    
+
     def __init__(self, allowednamespaces):
         self.allowednamespaces = allowednamespaces
-    
+
     def __call__(self, crsstring):
         if not re.match('^[A-Z]{3,5}:\d+$', crsstring):
             raise OGCException('Invalid format for the CRS parameter: %s' % crsstring, 'InvalidCRS')
@@ -198,12 +201,14 @@
             raise OGCException('Invalid CRS Namespace: %s' % crsparts[0], 'InvalidCRS')
 
 class WMSBaseServiceHandler(BaseServiceHandler):
-    
+
     def GetMap(self, params):
         if params['bbox'][0] >= params['bbox'][2]:
             raise OGCException("BBOX values don't make sense.  minx is greater than maxx.")
         if params['bbox'][1] >= params['bbox'][3]:
             raise OGCException("BBOX values don't make sense.  miny is greater than maxy.")
+        if params.has_key('styles') and len(params['styles']) != len(params['layers']):
+            raise OGCException('STYLES length does not match LAYERS length.')
         m = Map(params['width'], params['height'])
         if params.has_key('transparent') and params['transparent'] == 'FALSE':
             m.background = params['bgcolor']
@@ -225,7 +230,6 @@
         m.zoom_to_box(Envelope(params['bbox'][0], params['bbox'][1], params['bbox'][2], params['bbox'][3]))
         im = Image(params['width'], params['height'])
         render(m, im)
-        render_to_file(m, '/tmp/ogcserver.png', 'png')
         im = fromstring('RGBA', (params['width'], params['height']), rawdata(im))
         fh = StringIO()
         im.save(fh, PIL_TYPE_MAPPING[params['format']], quality=100)
@@ -233,10 +237,10 @@
         return Response(params['format'], fh.read())
 
 class BaseExceptionHandler:
-    
+
     def __init__(self, debug):
         self.debug = debug
-    
+
     def getresponse(self, params):
         code = ''
         message = ''
@@ -252,10 +256,10 @@
         if isinstance(excinfo[1], OGCException) and len(excinfo[1].args) > 1:
             code = excinfo[1].args[1]
         exceptions = params.get('exceptions', None)
-        if not exceptions:
+        if not exceptions or not self.handlers.has_key(exceptions):
             exceptions = self.defaulthandler
         return self.handlers[exceptions](self, code, message, params)
-    
+
     def xmlhandler(self, code, message, params):
         ogcexcetree = deepcopy(self.xmltemplate)
         e = ogcexcetree.find(self.xpath)
@@ -274,10 +278,10 @@
         im.save(fh, PIL_TYPE_MAPPING[params['format']])
         fh.seek(0)
         return Response(params['format'], fh.read())
-    
+
     def blankhandler(self, code, message, params):
         bgcolor = params.get('bgcolor', '#FFFFFF')
-        bgcolor.replace('0x', '#')
+        bgcolor = bgcolor.replace('0x', '#')
         transparent = params.get('transparent', 'FALSE')
         if transparent == 'TRUE':
             im = new('RGBA', (int(params['width']), int(params['height'])))
@@ -287,4 +291,4 @@
         fh = StringIO()
         im.save(fh, PIL_TYPE_MAPPING[params['format']])
         fh.seek(0)
-        return Response(params['format'], fh.read())
+        return Response(params['format'], fh.read())
\ No newline at end of file

Modified: trunk/bindings/python/mapnik/ogcserver/wms111.py
===================================================================
--- trunk/bindings/python/mapnik/ogcserver/wms111.py	2006-05-11 00:44:20 UTC (rev 247)
+++ trunk/bindings/python/mapnik/ogcserver/wms111.py	2006-05-11 04:24:51 UTC (rev 248)
@@ -32,17 +32,16 @@
             'updatesequence': ParameterDefinition(False, str)
         },
         'GetMap': {
-            'version': ParameterDefinition(True, Version, allowedvalues=(Version('1.1.1'),)),
             'layers': ParameterDefinition(True, ListFactory(str)),
             'styles': ParameterDefinition(True, ListFactory(str)),
             'srs': ParameterDefinition(True, CRSFactory(['EPSG'])),
             'bbox': ParameterDefinition(True, ListFactory(float)),
             'width': ParameterDefinition(True, int),
             'height': ParameterDefinition(True, int),
-            'format': ParameterDefinition(True, str, allowedvalues=('image/png', 'image/jpeg', 'image/gif')),
+            'format': ParameterDefinition(True, str, allowedvalues=('image/png', 'image/jpeg')),
             'transparent': ParameterDefinition(False, str, 'FALSE', ('TRUE', 'FALSE')),
             'bgcolor': ParameterDefinition(False, ColorFactory, ColorFactory('0xFFFFFF')),
-            'exceptions': ParameterDefinition(False, str, 'application/vnd.ogc.se_xml', ('application/vnd.ogc.se_xml', 'application/vnd.ogc.se_inimage'))
+            'exceptions': ParameterDefinition(False, str, 'application/vnd.ogc.se_xml', ('application/vnd.ogc.se_xml', 'application/vnd.ogc.se_inimage', 'application/vnd.ogc.se_blank'))
         }
     }
 
@@ -113,7 +112,7 @@
             ServerConfigurationError('EPSG code not properly configured.')
 
         capetree = ElementTree.fromstring(self.capabilitiesxmltemplate)
-        
+
         elements = capetree.findall('Capability//OnlineResource')
         for element in elements:
             element.set('{http://www.w3.org/1999/xlink}href', opsonlineresource)
@@ -138,7 +137,7 @@
                         servicee.append(element)
 
         rootlayerelem = capetree.find('Capability/Layer')
-        
+
         rootlayersrs = rootlayerelem.find('SRS')
         rootlayersrs.text = str(self.crs)
 
@@ -177,7 +176,7 @@
                     style.append(styletitle)
                     layere.append(style)
             rootlayerelem.append(layere)
-        
+
         self.capabilities = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n' + ElementTree.tostring(capetree)
 
     def GetCapabilities(self, params):
@@ -190,20 +189,20 @@
         return WMSBaseServiceHandler.GetMap(self, params)
 
 class ExceptionHandler(BaseExceptionHandler):
-    
+
     xmlmimetype = "application/vnd.ogc.se_xml"
-    
+
     xmltemplate = ElementTree.fromstring("""<?xml version='1.0' encoding="UTF-8" standalone="no"?>
     <!DOCTYPE ServiceExceptionReport SYSTEM "http://www.digitalearth.gov/wmt/xml/exception_1_1_1.dtd">
     <ServiceExceptionReport version="1.1.1">
       <ServiceException />
     </ServiceExceptionReport>
     """)
-    
+
     xpath = 'ServiceException'
 
     handlers = {'application/vnd.ogc.se_xml': BaseExceptionHandler.xmlhandler,
                 'application/vnd.ogc.se_inimage': BaseExceptionHandler.inimagehandler,
                 'application/vnd.ogc.se_blank': BaseExceptionHandler.blankhandler}
-    
+
     defaulthandler = 'application/vnd.ogc.se_xml'
\ No newline at end of file

Modified: trunk/bindings/python/mapnik/ogcserver/wms130.py
===================================================================
--- trunk/bindings/python/mapnik/ogcserver/wms130.py	2006-05-11 00:44:20 UTC (rev 247)
+++ trunk/bindings/python/mapnik/ogcserver/wms130.py	2006-05-11 04:24:51 UTC (rev 248)
@@ -33,17 +33,16 @@
             'updatesequence': ParameterDefinition(False, str)
         },
         'GetMap': {
-            'version': ParameterDefinition(True, Version, allowedvalues=(Version('1.3.0'),)),
             'layers': ParameterDefinition(True, ListFactory(str)),
             'styles': ParameterDefinition(True, ListFactory(str)),
             'crs': ParameterDefinition(True, CRSFactory(['EPSG'])),
             'bbox': ParameterDefinition(True, ListFactory(float)),
             'width': ParameterDefinition(True, int),
             'height': ParameterDefinition(True, int),
-            'format': ParameterDefinition(True, str, allowedvalues=('image/gif','image/png', 'image/jpeg')),
+            'format': ParameterDefinition(True, str, allowedvalues=('image/png', 'image/jpeg')),
             'transparent': ParameterDefinition(False, str, 'FALSE', ('TRUE', 'FALSE')),
             'bgcolor': ParameterDefinition(False, ColorFactory, ColorFactory('0xFFFFFF')),
-            'exceptions': ParameterDefinition(False, str, 'XML', ('XML', 'INIMAGE')),
+            'exceptions': ParameterDefinition(False, str, 'XML', ('XML', 'INIMAGE', 'BLANK')),
         }
     }
 
@@ -119,7 +118,7 @@
             raise ServerConfigurationError('EPSG code not properly configured.')
 
         capetree = ElementTree.fromstring(self.capabilitiesxmltemplate)
-        
+
         elements = capetree.findall('{http://www.opengis.net/wms}Capability//{http://www.opengis.net/wms}OnlineResource')
         for element in elements:
             element.set('{http://www.w3.org/1999/xlink}href', opsonlineresource)
@@ -143,12 +142,11 @@
                         element.text = value
                         servicee.append(element)
 
-        
         rootlayerelem = capetree.find('{http://www.opengis.net/wms}Capability/{http://www.opengis.net/wms}Layer')
 
         rootlayercrs = rootlayerelem.find('{http://www.opengis.net/wms}CRS')
         rootlayercrs.text = str(self.crs)
-        
+
         for layer in self.mapfactory.layers.values():
             layername = ElementTree.Element('Name')
             layername.text = layer.name()
@@ -192,13 +190,13 @@
                     style.append(styletitle)
                     layere.append(style)
             rootlayerelem.append(layere)
-        
+
         self.capabilities = '<?xml version="1.0" encoding="UTF-8"?>' + ElementTree.tostring(capetree)
 
     def GetCapabilities(self, params):
         response = Response('text/xml', self.capabilities)
         return response
-        
+
     def GetMap(self, params):
         if params['width'] > int(self.conf.get('service', 'maxwidth')) or params['height'] > int(self.conf.get('service', 'maxheight')):
             raise OGCException('Requested map size exceeds limits set by this server.')
@@ -207,9 +205,9 @@
         return WMSBaseServiceHandler.GetMap(self, params)
 
 class ExceptionHandler(BaseExceptionHandler):
-    
+
     xmlmimetype = "text/xml"
-    
+
     xmltemplate = ElementTree.fromstring("""<?xml version='1.0' encoding="UTF-8"?>
     <ServiceExceptionReport version="1.3.0"
                             xmlns="http://www.opengis.net/ogc"
@@ -218,11 +216,11 @@
       <ServiceException/>
     </ServiceExceptionReport>
     """)
-    
+
     xpath = '{http://www.opengis.net/ogc}ServiceException'
-    
+
     handlers = {'XML': BaseExceptionHandler.xmlhandler,
                 'INIMAGE': BaseExceptionHandler.inimagehandler,
                 'BLANK': BaseExceptionHandler.blankhandler}
-    
+
     defaulthandler = 'XML'
\ No newline at end of file

Modified: trunk/bindings/python/pyprojection/Projection_wrap.c
===================================================================
--- trunk/bindings/python/pyprojection/Projection_wrap.c	2006-05-11 00:44:20 UTC (rev 247)
+++ trunk/bindings/python/pyprojection/Projection_wrap.c	2006-05-11 04:24:51 UTC (rev 248)
@@ -24,6 +24,7 @@
  * this copyright message remains intact.
  ************************************************************************/
 
+#include "Python.h"
 #include <string.h>
 
 #if defined(_WIN32) || defined(__WIN32__)
@@ -173,7 +174,6 @@
  ************************************************************************/
 
 #include <stdlib.h>
-#include "Python.h"
 
 #ifdef __cplusplus
 extern "C" {

Modified: trunk/docs/ogcserver/readme.txt
===================================================================
--- trunk/docs/ogcserver/readme.txt	2006-05-11 00:44:20 UTC (rev 247)
+++ trunk/docs/ogcserver/readme.txt	2006-05-11 04:24:51 UTC (rev 248)
@@ -23,6 +23,7 @@
 - XML/INIMAGE/BLANK error handling
 - No real layer metadata support yet
 - No re-projection support
+- Needs to be able to write to tempfile.gettempdir() (most likely "/tmp")
 
 
 Dependencies
@@ -101,7 +102,8 @@
 		
 		lyr = Layer(name='layername')
 		...
-		self.register_layer(lyr, ('extra', 'style', 'names'))
+		lyr.styles.append('stylename')
+		self.register_layer(lyr)
 		self.finalize()
 		
 The rules for writing this class are:
@@ -116,11 +118,24 @@
 - No Map() object is used or needed here.
 - Be sure to call self.finalize() once you've registered everything! This will
   validate everything and let you know if there's problems.
-- You can associate more styles to a given layer by passing a tuple of style
-  names along with the layer itself to register_layer().  As of this writing
-  this is useless as the core engine doesn't yet support named styles :)
+- Be sure to associate a default style with the layer.  In the future, there
+  will be a mechanism to assign other non-default styles to a layer, to support
+  named styles through the STYLES= parameter.
 
+To Do
+-----
 
+- Named style support.
+- Improve configuration to allow for full server metadata.
+- Add support for richer layer metadata.
+- Investigate moving to cElementTree from lxml.
+- Add some internal "caching" for performance improvements.
+- Support GetFeatureInfo (Requires core changes).
+- Switch to using C/C++ libs for image generation, instead of PIL (also
+  requires core changes). PIL requirement will remain for INIMAGE/BLANK
+  error handling.
+
+
 Conclusion
 ----------
 



From pavlenko at berlios.de  Fri May 12 18:35:38 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Fri, 12 May 2006 18:35:38 +0200
Subject: [Mapnik-svn] r249 - trunk/utils/shapeindex
Message-ID: <200605121635.k4CGZclQ007217@sheep.berlios.de>

Author: pavlenko
Date: 2006-05-12 18:35:36 +0200 (Fri, 12 May 2006)
New Revision: 249

Modified:
   trunk/utils/shapeindex/quadtree.hpp
   trunk/utils/shapeindex/shapeindex.cpp
Log:
fixed



Modified: trunk/utils/shapeindex/quadtree.hpp
===================================================================
--- trunk/utils/shapeindex/quadtree.hpp	2006-05-11 04:24:51 UTC (rev 248)
+++ trunk/utils/shapeindex/quadtree.hpp	2006-05-12 16:35:36 UTC (rev 249)
@@ -44,26 +44,26 @@
 
     ~quadtree_node() 
     {
-	for (int i=0;i<4;++i) 
-	{
-	    if (children_[i]) 
-	    {
-		delete children_[i],children_[i]=0;
-	    }
-	}
+        for (int i=0;i<4;++i) 
+        {
+            if (children_[i]) 
+            {
+                delete children_[i],children_[i]=0;
+            }
+        }
     }
 
     int num_subnodes() const 
     {
-	int count=0;
-	for (int i=0;i<4;++i) 
-	{
-	    if (children_[i]) 
-	    {
-		++count;
-	    }
-	}
-	return count;
+        int count=0;
+        for (int i=0;i<4;++i) 
+        {
+            if (children_[i]) 
+            {
+                ++count;
+            }
+        }
+        return count;
     }     
 };
 
@@ -76,215 +76,221 @@
     const double ratio_;
 public:
     quadtree(const Envelope<double>& extent,int maxdepth,double ratio)
-	: root_(new quadtree_node<T>(extent)),
-	  maxdepth_(maxdepth),
-	  ratio_(ratio){}
+        : root_(new quadtree_node<T>(extent)),
+          maxdepth_(maxdepth),
+          ratio_(ratio) {}
+
     ~quadtree()
     {
-	if (root_) delete root_;
+        if (root_) delete root_;
     }
+    
     void insert(const T& data,const Envelope<double>& item_ext)
     {
-	insert(data,item_ext,root_,maxdepth_);
+        insert(data,item_ext,root_,maxdepth_);
     }
+    
     int count() const
     {
-	return count_nodes(root_);
+        return count_nodes(root_);
     }
+    
     int count_items() const 
     {
-	int count=0;
-	count_items(root_,count);
-	return count;
+        int count=0;
+        count_items(root_,count);
+        return count;
     }
+    
     void print() const
     {
-	print(root_);
+        print(root_);
     }
+    
     void trim() 
     {
-	trim_tree(root_);
+        trim_tree(root_);
     }     
     
     void write(std::ostream& out)
     {
-	char header[16];
-	memset(header,0,16);
-	header[0]='m';
-	header[1]='a';
-	header[2]='p';
-	header[4]='n';
-	header[5]='i';
-	header[6]='k';
-	out.write(header,16);
-	write_node(out,root_);
+        char header[16];
+        memset(header,0,16);
+        header[0]='m';
+        header[1]='a';
+        header[2]='p';
+        header[4]='n';
+        header[5]='i';
+        header[6]='k';
+        out.write(header,16);
+        write_node(out,root_);
     }
 
 private:
 
     void trim_tree(quadtree_node<T>*&  node)
     {   
-	if (node) 
-	{
-	    for (int i=0;i<4;++i)
-	    {	
-		trim_tree(node->children_[i]);	
-	    }
+        if (node) 
+        {
+            for (int i=0;i<4;++i)
+            {	
+                trim_tree(node->children_[i]);	
+            }
 
-	    if (node->num_subnodes()==1 && node->data_.size()==0)
-	    {
-		for (int i=0;i<4;++i) 
-		{
-		    if (node->children_[i])
-		    {   
-			node=node->children_[i];
-			break;	
-		    }
-		}
-	    }	
-	}
+            if (node->num_subnodes()==1 && node->data_.size()==0)
+            {
+                for (int i=0;i<4;++i) 
+                {
+                    if (node->children_[i])
+                    {   
+                        node=node->children_[i];
+                        break;	
+                    }
+                }
+            }	
+        }
     }
 
     int count_nodes(const quadtree_node<T>*  node) const
     {
-	if (!node)
-	{
-	    return 0;
-	}
-	else
-	{
-	    int count = 1;
-	    for (int i=0;i<4;++i)
-	    {
-		count += count_nodes(node->children_[i]);
-	    }
-	    return count;
-	}
+        if (!node)
+        {
+            return 0;
+        }
+        else
+        {
+            int count = 1;
+            for (int i=0;i<4;++i)
+            {
+                count += count_nodes(node->children_[i]);
+            }
+            return count;
+        }
     }
 
     void count_items(const quadtree_node<T>* node,int& count) const
     {
-	if (node)
-	{
-	    count += node->data_.size();    
-	    for (int i=0;i<4;++i)
-	    {
-		count_items(node->children_[i],count);
-	    }    
-	}
+        if (node)
+        {
+            count += node->data_.size();    
+            for (int i=0;i<4;++i)
+            {
+                count_items(node->children_[i],count);
+            }    
+        }
     }
 
     int subnode_offset(const quadtree_node<T>* node) const
     {
-	int offset=0;
-	for (int i=0;i<4;i++)
-	{
-	    if (node->children_[i])
-	    {
-		offset +=sizeof(Envelope<double>)+(node->children_[i]->data_.size()*sizeof(T))+3*sizeof(int);
-		offset +=subnode_offset(node->children_[i]);
-	    }
-	}
-	return offset;
+        int offset=0;
+        for (int i=0;i<4;i++)
+        {
+            if (node->children_[i])
+            {
+                offset +=sizeof(Envelope<double>)+(node->children_[i]->data_.size()*sizeof(T))+3*sizeof(int);
+                offset +=subnode_offset(node->children_[i]);
+            }
+        }
+        return offset;
     }
 
     void write_node(std::ostream& out,const quadtree_node<T>* node) const
     {
-	if (node)
-	{
-	    int offset=subnode_offset(node);
-	    int shape_count=node->data_.size();
-	    int recsize=sizeof(Envelope<double>) + 3 * sizeof(int) + shape_count * sizeof(T);
-	    char* node_record=new char[recsize];
-	    memset(node_record,0,recsize);
-	    memcpy(node_record,&offset,4);
-	    memcpy(node_record+4,&node->ext_,sizeof(Envelope<double>));
-	    memcpy(node_record+36,&shape_count,4);
-	    for (int i=0;i<shape_count;++i)
-	    {
-		memcpy(node_record + 40 + i * sizeof(T),&(node->data_[i]),sizeof(T));
-	    }
-	    int num_subnodes=0;
-	    for (int i=0;i<4;++i)
-	    {
-		if (node->children_[i])
-		{
-		    ++num_subnodes;
-		}
-	    }
-	    memcpy(node_record + 40 + shape_count * sizeof(T),&num_subnodes,4);
-	    out.write(node_record,recsize);
-	    delete [] node_record;
+        if (node)
+        {
+            int offset=subnode_offset(node);
+            int shape_count=node->data_.size();
+            int recsize=sizeof(Envelope<double>) + 3 * sizeof(int) + shape_count * sizeof(T);
+            char* node_record=new char[recsize];
+            memset(node_record,0,recsize);
+            memcpy(node_record,&offset,4);
+            memcpy(node_record+4,&node->ext_,sizeof(Envelope<double>));
+            memcpy(node_record+36,&shape_count,4);
+            for (int i=0;i<shape_count;++i)
+            {
+                memcpy(node_record + 40 + i * sizeof(T),&(node->data_[i]),sizeof(T));
+            }
+            int num_subnodes=0;
+            for (int i=0;i<4;++i)
+            {
+                if (node->children_[i])
+                {
+                    ++num_subnodes;
+                }
+            }
+            memcpy(node_record + 40 + shape_count * sizeof(T),&num_subnodes,4);
+            out.write(node_record,recsize);
+            delete [] node_record;
 
-	    for (int i=0;i<4;++i)
-	    {
-		write_node(out,node->children_[i]);
-	    }
-	}
+            for (int i=0;i<4;++i)
+            {
+                write_node(out,node->children_[i]);
+            }
+        }
     }
 
     void print(const quadtree_node<T>* node,int level=0) const
     {
-	if (node)
-	{
-	    typename std::vector<T>::const_iterator itr=node->data_.begin();
-	    std::string pad;
-	    for (int i=0;i<level;++i)
-	    {
-		pad+=" ";
-	    }
-	    std::clog<<pad<<"node "<<node<<" extent:"<<node->ext_<<std::endl;
-	    std::clog<<pad;
-	    while(itr!=node->data_.end())
-	    {
-		std::clog<<*itr<<" ";
-		++itr;
-	    }
-	    std::clog<<std::endl;
-	    for (int i=0;i<4;++i)
-	    {
-		print(node->children_[i],level+4);
-	    }
-	}
+        if (node)
+        {
+            typename std::vector<T>::const_iterator itr=node->data_.begin();
+            std::string pad;
+            for (int i=0;i<level;++i)
+            {
+                pad+=" ";
+            }
+            std::clog<<pad<<"node "<<node<<" extent:"<<node->ext_<<std::endl;
+            std::clog<<pad;
+            while(itr!=node->data_.end())
+            {
+                std::clog<<*itr<<" ";
+                ++itr;
+            }
+            std::clog<<std::endl;
+            for (int i=0;i<4;++i)
+            {
+                print(node->children_[i],level+4);
+            }
+        }
     }
 
     void insert(const T& data,const Envelope<double>& item_ext,quadtree_node<T>*  node,int maxdepth)
     {
-	if (node && node->ext_.contains(item_ext))
-	{
-	    coord2d c=node->ext_.center();
+        if (node && node->ext_.contains(item_ext))
+        {
+            coord2d c=node->ext_.center();
 
-	    double width=node->ext_.width();
-	    double height=node->ext_.height();
+            double width=node->ext_.width();
+            double height=node->ext_.height();
 
-	    double lox=node->ext_.minx();
-	    double loy=node->ext_.miny();
-	    double hix=node->ext_.maxx();
-	    double hiy=node->ext_.maxy();
+            double lox=node->ext_.minx();
+            double loy=node->ext_.miny();
+            double hix=node->ext_.maxx();
+            double hiy=node->ext_.maxy();
 
-	    Envelope<double> ext[4];
-	    ext[0]=Envelope<double>(lox,loy,lox + width * ratio_,loy + height * ratio_);
-	    ext[1]=Envelope<double>(hix - width * ratio_,loy,hix,loy + height * ratio_);
-	    ext[2]=Envelope<double>(lox,hiy - height*ratio_,lox + width * ratio_,hiy);
-	    ext[3]=Envelope<double>(hix - width * ratio_,hiy - height*ratio_,hix,hiy);
+            Envelope<double> ext[4];
+            ext[0]=Envelope<double>(lox,loy,lox + width * ratio_,loy + height * ratio_);
+            ext[1]=Envelope<double>(hix - width * ratio_,loy,hix,loy + height * ratio_);
+            ext[2]=Envelope<double>(lox,hiy - height*ratio_,lox + width * ratio_,hiy);
+            ext[3]=Envelope<double>(hix - width * ratio_,hiy - height*ratio_,hix,hiy);
 
-	    if (maxdepth > 1)
-	    {
-		for (int i=0;i<4;++i)
-		{
-		    if (ext[i].contains(item_ext))
-		    {
-			if (!node->children_[i])
-			{
-			    node->children_[i]=new quadtree_node<T>(ext[i]);
-			}
-			insert(data,item_ext,node->children_[i],maxdepth-1);
-			return;
-		    }
-		}
-	    }
-	    node->data_.push_back(data);
-	}
+            if (maxdepth > 1)
+            {
+                for (int i=0;i<4;++i)
+                {
+                    if (ext[i].contains(item_ext))
+                    {
+                        if (!node->children_[i])
+                        {
+                            node->children_[i]=new quadtree_node<T>(ext[i]);
+                        }
+                        insert(data,item_ext,node->children_[i],maxdepth-1);
+                        return;
+                    }
+                }
+            }
+            node->data_.push_back(data);
+        }
     }
 };
 #endif                                            //QUADTREE_HH

Modified: trunk/utils/shapeindex/shapeindex.cpp
===================================================================
--- trunk/utils/shapeindex/shapeindex.cpp	2006-05-11 04:24:51 UTC (rev 248)
+++ trunk/utils/shapeindex/shapeindex.cpp	2006-05-12 16:35:36 UTC (rev 249)
@@ -52,51 +52,51 @@
     
     try
     {
-	po::options_description desc("shapeindex utility");
-	desc.add_options()
-	    ("help,h", "produce usage message")
-	    ("version,V","print version string")
-	    ("verbose,v","verbose output")
-	    ("depth,d", po::value<unsigned int>(), "max tree depth\n(default 8)")   
-	    ("ratio,r",po::value<double>(),"split ratio (default 0.55)")
-	    ("shape_files",po::value<vector<string> >(),"shape files to index file1 file2 ...fileN")
-	    ;
+        po::options_description desc("shapeindex utility");
+        desc.add_options()
+            ("help,h", "produce usage message")
+            ("version,V","print version string")
+            ("verbose,v","verbose output")
+            ("depth,d", po::value<unsigned int>(), "max tree depth\n(default 8)")   
+            ("ratio,r",po::value<double>(),"split ratio (default 0.55)")
+            ("shape_files",po::value<vector<string> >(),"shape files to index file1 file2 ...fileN")
+            ;
 	
-	po::positional_options_description p;
-	p.add("shape_files",-1);
-	po::variables_map vm;        
-	po::store(po::command_line_parser(argc, argv).options(desc).positional(p).run(), vm);
-	po::notify(vm);
+        po::positional_options_description p;
+        p.add("shape_files",-1);
+        po::variables_map vm;        
+        po::store(po::command_line_parser(argc, argv).options(desc).positional(p).run(), vm);
+        po::notify(vm);
 	
-	if (vm.count("version"))
-	{
-	    clog<<"version 0.2.0a" <<endl;
-	    return 1;
-	}
+        if (vm.count("version"))
+        {
+            clog<<"version 0.2.0a" <<endl;
+            return 1;
+        }
 
-	if (vm.count("help")) 
-	{
-	    clog << desc << "\n";
-	    return 1;
-	}
-	if (vm.count("depth"))
-	{
-	    depth = vm["depth"].as<unsigned int>();
-	}
-	if (vm.count("ratio"))
-	{
-	    ratio = vm["ratio"].as<double>();
-	}
+        if (vm.count("help")) 
+        {
+            clog << desc << "\n";
+            return 1;
+        }
+        if (vm.count("depth"))
+        {
+            depth = vm["depth"].as<unsigned int>();
+        }
+        if (vm.count("ratio"))
+        {
+            ratio = vm["ratio"].as<double>();
+        }
 	
         if (vm.count("shape_files"))
-	{
-	    shape_files=vm["shape_files"].as< vector<string> >();
-	}
+        {
+            shape_files=vm["shape_files"].as< vector<string> >();
+        }
     }
     catch (...)
     {
-	clog << "Exception of unknown type!"<<endl;
-	return -1;
+        clog << "Exception of unknown type!"<<endl;
+        return -1;
     }
     
     std::clog<<"max tree depth:"<<depth<<std::endl;
@@ -105,107 +105,108 @@
     vector<string>::const_iterator itr=shape_files.begin();
     if (itr==shape_files.end())
     {
-	std::clog << "no shape files to index"<<std::endl;
-	return 0;
+        std::clog << "no shape files to index"<<std::endl;
+        return 0;
     }
     while (itr != shape_files.end())
     {
-	std::clog<<"processing "<<*itr << std::endl;
-	shape_file shp;
-	std::string shapename(*itr++);
-	if (!shp.open(shapename+".shp")) {
-	    std::clog<<"error : cannot open "<< (shapename+".shp") <<"\n";
-	    continue;
-	}
+        std::clog<<"processing "<<*itr << std::endl;
+        shape_file shp;
+        std::string shapename(*itr++);
+        if (!shp.open(shapename+".shp")) {
+            std::clog<<"error : cannot open "<< (shapename+".shp") <<"\n";
+            continue;
+        }
 
-	shp.read_xdr_integer(); //file_code == 9994
-	shp.skip(5*4); 
+        shp.read_xdr_integer(); //file_code == 9994
+        shp.skip(5*4); 
 	
-	int file_length=shp.read_xdr_integer();
-	int version=shp.read_ndr_integer();
-	int shape_type=shp.read_ndr_integer();
-	Envelope<double> extent;
-	shp.read_envelope(extent);
+        int file_length=shp.read_xdr_integer();
+        int version=shp.read_ndr_integer();
+        int shape_type=shp.read_ndr_integer();
+        Envelope<double> extent;
+        shp.read_envelope(extent);
 	
 	
-	std::clog<<"length="<<file_length<<std::endl;
-	std::clog<<"version="<<version<<std::endl;
-	std::clog<<"type="<<shape_type<<std::endl;
-	std::clog<<"extent:"<<extent<<std::endl;
+        std::clog<<"length="<<file_length<<std::endl;
+        std::clog<<"version="<<version<<std::endl;
+        std::clog<<"type="<<shape_type<<std::endl;
+        std::clog<<"extent:"<<extent<<std::endl;
 	  
-	int pos=50;
-	shp.seek(pos*2);  
-	quadtree<int> tree(extent,depth,ratio);
-	int count=0;
-	while (true) {
+        int pos=50;
+        shp.seek(pos*2);  
+        quadtree<int> tree(extent,depth,ratio);
+        int count=0;
+        while (true) {
 	    
-	    int offset=shp.pos();
-	    int record_number=shp.read_xdr_integer();
-	    int content_length=shp.read_xdr_integer();
-	    
-	    shp.skip(4);
-	    std::cout << "offset= "<< offset << std::endl;
-	    
-	    Envelope<double> item_ext;
-	    if (shape_type==shape_io::shape_point)
-	    {
-		double x=shp.read_double();
-		double y=shp.read_double();
-		item_ext=Envelope<double>(x,y,x,y);
+            long offset=shp.pos();
+            int record_number=shp.read_xdr_integer();
+            int content_length=shp.read_xdr_integer();
+            
+            //std::clog << "rec number = "<< record_number << "\n";
+            //std::clog << "content length = "<< content_length << "\n";
+           
+            shp.skip(4);
+            //std::clog << "offset= "<< offset << std::endl;
+	        
+            Envelope<double> item_ext;
+            if (shape_type==shape_io::shape_point)
+            {
+                double x=shp.read_double();
+                double y=shp.read_double();
+                item_ext=Envelope<double>(x,y,x,y);
 	
-	    }
-	    if (shape_type==shape_io::shape_pointm)
-	    {
-		double x=shp.read_double();
-		double y=shp.read_double();
-		shp.read_double();
-		item_ext=Envelope<double>(x,y,x,y);
+            }
+            else if (shape_type==shape_io::shape_pointm)
+            {
+                double x=shp.read_double();
+                double y=shp.read_double();
+                shp.read_double();
+                item_ext=Envelope<double>(x,y,x,y);
 	
-	    }
-	    else if (shape_type==shape_io::shape_pointz)
-	    {
-		double x=shp.read_double();
-		double y=shp.read_double();
-		shp.read_double();
-		shp.read_double();
-		item_ext=Envelope<double>(x,y,x,y);
-	    }
+            }
+            else if (shape_type==shape_io::shape_pointz)
+            {
+                double x=shp.read_double();
+                double y=shp.read_double();
+                shp.read_double();
+                shp.read_double();
+                item_ext=Envelope<double>(x,y,x,y);
+            }
 	
-	    else 
-	    {
-      
-		shp.read_envelope(item_ext);
-		shp.skip(2*content_length-4*8-4);
+            else 
+            {   
+                shp.read_envelope(item_ext);
+                shp.skip(2*content_length-4*8-4);
+            }
+            
+            tree.insert(offset,item_ext);
+            if (verbose) {
+                std::clog<<"record number "<<record_number<<" box="<<item_ext<<std::endl;
+            }
 
-	    }
+            pos+=4+content_length;
+            ++count;
 
-	    tree.insert(offset,item_ext);
-	    if (verbose) {
-		std::clog<<"record number "<<record_number<<" box="<<item_ext<<std::endl;
-	    }
-
-	    pos+=4+content_length;
-	    ++count;
-
-	    if (pos>=file_length) {
-		break;
-	    }  
-	} 
-	shp.close();
+            if (pos>=file_length) {
+                break;
+            }  
+        } 
+        shp.close();
   
-	std::clog<<" number shapes="<<count<<std::endl;  
+        std::clog<<" number shapes="<<count<<std::endl;  
     
-	std::fstream file((shapename+".index").c_str(),
-			  std::ios::in | std::ios::out | std::ios::trunc | std::ios::binary);
-	if (!file) {
-	    std::clog << "cannot open index file for writing file \""
-		      <<(shapename+".index")<<"\""<<std::endl;
-	} else {
-	    tree.trim();
-	    std::clog<<" number nodes="<<tree.count()<<std::endl;
-	    tree.write(file);
-	    file.close();
-	}
+        std::fstream file((shapename+".index").c_str(),
+                          std::ios::in | std::ios::out | std::ios::trunc | std::ios::binary);
+        if (!file) {
+            std::clog << "cannot open index file for writing file \""
+                      <<(shapename+".index")<<"\""<<std::endl;
+        } else {
+            tree.trim();
+            std::clog<<" number nodes="<<tree.count()<<std::endl;
+            tree.write(file);
+            file.close();
+        }
     }
     std::clog<<"done!"<<std::endl;
     return 0;



From pavlenko at berlios.de  Wed May 17 18:41:30 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Wed, 17 May 2006 18:41:30 +0200
Subject: [Mapnik-svn] r250 - trunk/include
Message-ID: <200605171641.k4HGfUfa031347@sheep.berlios.de>

Author: pavlenko
Date: 2006-05-17 18:41:28 +0200 (Wed, 17 May 2006)
New Revision: 250

Modified:
   trunk/include/point_symbolizer.hpp
Log:
replaced tabs with spaces

Modified: trunk/include/point_symbolizer.hpp
===================================================================
--- trunk/include/point_symbolizer.hpp	2006-05-12 16:35:36 UTC (rev 249)
+++ trunk/include/point_symbolizer.hpp	2006-05-17 16:41:28 UTC (rev 250)
@@ -31,13 +31,13 @@
 {   
     struct MAPNIK_DECL point_symbolizer
     {	
-	point_symbolizer(std::string const& file,
-			 std::string const& type,
-			 unsigned width,unsigned height);
-	point_symbolizer(point_symbolizer const& rhs);
-	ImageData32 const& get_data() const;
+        point_symbolizer(std::string const& file,
+                         std::string const& type,
+                         unsigned width,unsigned height);
+        point_symbolizer(point_symbolizer const& rhs);
+        ImageData32 const& get_data() const;
     private:
-	boost::shared_ptr<ImageData32> symbol_;
+        boost::shared_ptr<ImageData32> symbol_;
     };
 }
 



From pavlenko at berlios.de  Fri May 19 10:59:52 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Fri, 19 May 2006 10:59:52 +0200
Subject: [Mapnik-svn] r251 - trunk/include
Message-ID: <200605190859.k4J8xqxC005804@sheep.berlios.de>

Author: pavlenko
Date: 2006-05-19 10:59:50 +0200 (Fri, 19 May 2006)
New Revision: 251

Modified:
   trunk/include/layer.hpp
Log:
added set_name method

Modified: trunk/include/layer.hpp
===================================================================
--- trunk/include/layer.hpp	2006-05-17 16:41:28 UTC (rev 250)
+++ trunk/include/layer.hpp	2006-05-19 08:59:50 UTC (rev 251)
@@ -34,60 +34,63 @@
 {
     class MAPNIK_DECL Layer
     {
-	friend class boost::serialization::access;
-	template <typename Archive>
-	void serialize(Archive & ar, const unsigned int /*version*/)
-	{
-	    ar  & boost::serialization::make_nvp("name",name_)
-		& boost::serialization::make_nvp("params",params_)
-		& boost::serialization::make_nvp("min_zoom",minZoom_)
-		& boost::serialization::make_nvp("max_zoom",maxZoom_)
-		& boost::serialization::make_nvp("active",active_)
-		& boost::serialization::make_nvp("selectable",selectable_)
-		& boost::serialization::make_nvp("styles",styles_)
-		;
-	}
-	parameters params_;
-	std::string name_;
-	double minZoom_;
-	double maxZoom_;
-	bool active_;
-	bool selectable_;
-	mutable datasource_p ds_;
-	std::vector<std::string>  styles_;
-	std::string selection_style_;	
-	mutable std::vector<boost::shared_ptr<Feature> > selection_;
+        friend class boost::serialization::access;
+        template <typename Archive>
+        void serialize(Archive & ar, const unsigned int /*version*/)
+        {
+            ar  & boost::serialization::make_nvp("name",name_)
+                & boost::serialization::make_nvp("params",params_)
+                & boost::serialization::make_nvp("min_zoom",minZoom_)
+                & boost::serialization::make_nvp("max_zoom",maxZoom_)
+                & boost::serialization::make_nvp("active",active_)
+                & boost::serialization::make_nvp("selectable",selectable_)
+                & boost::serialization::make_nvp("styles",styles_)
+                ;
+        }
+        parameters params_;
+        std::string name_;
+        double minZoom_;
+        double maxZoom_;
+        bool active_;
+        bool selectable_;
+	
+        std::vector<std::string>  styles_;
+        std::string selection_style_;
+
+        mutable datasource_p ds_;
+        mutable std::vector<boost::shared_ptr<Feature> > selection_;
         
     public:
-	Layer();
-	explicit Layer(const parameters& params);
-	Layer(Layer const& l);
-	Layer& operator=(Layer const& l);
-	bool operator==(Layer const& other) const;
-	parameters const& params() const;	
-	const std::string& name() const;
-	void add_style(std::string const& stylename);
-	std::vector<std::string> const& styles() const;
-	void selection_style(const std::string& name);
-	const std::string& selection_style() const;
-	void setMinZoom(double minZoom);
-	void setMaxZoom(double maxZoom);
-	double getMinZoom() const;
-	double getMaxZoom() const;
-	void setActive(bool active);
-	bool isActive() const;
-	void setSelectable(bool selectable);
-	bool isSelectable() const;
-	bool isVisible(double scale) const;
-	void add_to_selection(boost::shared_ptr<Feature>& feature) const;
-	std::vector<boost::shared_ptr<Feature> >& selection() const;
-	void clear_selection() const;
-	void set_datasource(datasource_p const& ds);
-	datasource_p const& datasource() const;
-	Envelope<double> envelope() const;
-	virtual ~Layer();
+        Layer();
+        explicit Layer(const parameters& params);
+        Layer(Layer const& l);
+        Layer& operator=(Layer const& l);
+        bool operator==(Layer const& other) const;
+        parameters const& params() const;
+        void set_name(std::string const& name);
+        const std::string& name() const;
+        void add_style(std::string const& stylename);
+        std::vector<std::string> const& styles() const;
+        void selection_style(const std::string& name);
+        const std::string& selection_style() const;
+        void setMinZoom(double minZoom);
+        void setMaxZoom(double maxZoom);
+        double getMinZoom() const;
+        double getMaxZoom() const;
+        void setActive(bool active);
+        bool isActive() const;
+        void setSelectable(bool selectable);
+        bool isSelectable() const;
+        bool isVisible(double scale) const;
+        void add_to_selection(boost::shared_ptr<Feature>& feature) const;
+        std::vector<boost::shared_ptr<Feature> >& selection() const;
+        void clear_selection() const;
+        void set_datasource(datasource_p const& ds);
+        datasource_p const& datasource() const;
+        Envelope<double> envelope() const;
+        virtual ~Layer();
     private:
-	void swap(const Layer& other);
+        void swap(const Layer& other);
     };
 }
 



From pavlenko at berlios.de  Fri May 19 14:26:24 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Fri, 19 May 2006 14:26:24 +0200
Subject: [Mapnik-svn] r252 - trunk/plugins/input/shape
Message-ID: <200605191226.k4JCQOjY009332@sheep.berlios.de>

Author: pavlenko
Date: 2006-05-19 14:26:23 +0200 (Fri, 19 May 2006)
New Revision: 252

Modified:
   trunk/plugins/input/shape/dbffile.cpp
Log:
use boost::lexical_cast for conversions
( thanks to John Leslie <jleslie at placebase.com> )



Modified: trunk/plugins/input/shape/dbffile.cpp
===================================================================
--- trunk/plugins/input/shape/dbffile.cpp	2006-05-19 08:59:50 UTC (rev 251)
+++ trunk/plugins/input/shape/dbffile.cpp	2006-05-19 12:26:23 UTC (rev 252)
@@ -23,6 +23,7 @@
 #include "dbffile.hpp"
 #include "utils.hpp"
 #include <boost/algorithm/string.hpp>
+#include <boost/lexical_cast.hpp>
 #include <string>
 
 dbf_file::dbf_file()
@@ -137,17 +138,29 @@
                     boost::put(f,name,0);
                     break;
                 }
-                if (fields_[col].dec_>0)
+                if ( fields_[col].dec_>0 )
                 {   
-                    double d;
-                    fromString(str,d);
-                    boost::put(f,name,d);
+                    try 
+                    {
+                        double d = boost::lexical_cast<double>(str);
+                        boost::put(f,name,d);
+                    }
+                    catch (boost::bad_lexical_cast &)
+                    {
+                        boost::put(f,name,0.0);
+                    }
                 }
                 else
                 {
-                    int i;
-                    fromString(str,i);
-                    boost::put(f,name,i);
+                    try 
+                    {
+                        int i =  boost::lexical_cast<int>(str); 
+                        boost::put(f,name,i);
+                    }
+                    catch (boost::lexical_cast &)
+                    {
+                        boost::put(f,name,0);
+                    }
                 }
                 break;
             }



From pavlenko at berlios.de  Fri May 19 14:50:41 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Fri, 19 May 2006 14:50:41 +0200
Subject: [Mapnik-svn] r253 - in trunk: include plugins/input/shape
Message-ID: <200605191250.k4JCoflL011800@sheep.berlios.de>

Author: pavlenko
Date: 2006-05-19 14:50:40 +0200 (Fri, 19 May 2006)
New Revision: 253

Modified:
   trunk/include/layer.hpp
   trunk/plugins/input/shape/dbffile.cpp
Log:
oops! added missing bits



Modified: trunk/include/layer.hpp
===================================================================
--- trunk/include/layer.hpp	2006-05-19 12:26:23 UTC (rev 252)
+++ trunk/include/layer.hpp	2006-05-19 12:50:40 UTC (rev 253)
@@ -57,8 +57,8 @@
         std::vector<std::string>  styles_;
         std::string selection_style_;
 
+        mutable std::vector<boost::shared_ptr<Feature> > selection_;
         mutable datasource_p ds_;
-        mutable std::vector<boost::shared_ptr<Feature> > selection_;
         
     public:
         Layer();

Modified: trunk/plugins/input/shape/dbffile.cpp
===================================================================
--- trunk/plugins/input/shape/dbffile.cpp	2006-05-19 12:26:23 UTC (rev 252)
+++ trunk/plugins/input/shape/dbffile.cpp	2006-05-19 12:50:40 UTC (rev 253)
@@ -157,7 +157,7 @@
                         int i =  boost::lexical_cast<int>(str); 
                         boost::put(f,name,i);
                     }
-                    catch (boost::lexical_cast &)
+                    catch (boost::bad_lexical_cast &)
                     {
                         boost::put(f,name,0);
                     }



From pavlenko at berlios.de  Fri May 19 18:07:14 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Fri, 19 May 2006 18:07:14 +0200
Subject: [Mapnik-svn] r254 - trunk/src
Message-ID: <200605191607.k4JG7Ea9003962@sheep.berlios.de>

Author: pavlenko
Date: 2006-05-19 18:07:13 +0200 (Fri, 19 May 2006)
New Revision: 254

Modified:
   trunk/src/layer.cpp
Log:
added set_name method



Modified: trunk/src/layer.cpp
===================================================================
--- trunk/src/layer.cpp	2006-05-19 12:50:40 UTC (rev 253)
+++ trunk/src/layer.cpp	2006-05-19 16:07:13 UTC (rev 254)
@@ -35,35 +35,35 @@
 {
     using namespace std;
     Layer::Layer()
-	: params_(),
-	  name_("uknown"),
-	  minZoom_(0),
-	  maxZoom_(std::numeric_limits<double>::max()),
-	  active_(true),
-	  selectable_(false),
-	  selection_style_("default_selection")
+        : params_(),
+          name_("unknown"),
+          minZoom_(0),
+          maxZoom_(std::numeric_limits<double>::max()),
+          active_(true),
+          selectable_(false),
+          selection_style_("default_selection")
     {}
 
     Layer::Layer(const parameters& params)
         :params_(params),
-	 name_(params_["name"]),
-	 minZoom_(0),
-	 maxZoom_(std::numeric_limits<double>::max()),
-	 active_(true),
-	 selectable_(false),
-	 selection_style_("default_selection")
+         name_(params_["name"]),
+         minZoom_(0),
+         maxZoom_(std::numeric_limits<double>::max()),
+         active_(true),
+         selectable_(false),
+         selection_style_("default_selection")
     {}
     
     Layer::Layer(const Layer& rhs)
         :params_(rhs.params_),
-	 name_(rhs.name_),
-	 minZoom_(rhs.minZoom_),
-	 maxZoom_(rhs.maxZoom_),
-	 active_(rhs.active_),
-	 selectable_(rhs.selectable_),
-	 ds_(rhs.ds_),
-	 styles_(rhs.styles_),
-	 selection_style_(rhs.selection_style_) {}
+         name_(rhs.name_),
+         minZoom_(rhs.minZoom_),
+         maxZoom_(rhs.maxZoom_),
+         active_(rhs.active_),
+         selectable_(rhs.selectable_),
+         ds_(rhs.ds_),
+         styles_(rhs.styles_),
+         selection_style_(rhs.selection_style_) {}
     
     Layer& Layer::operator=(const Layer& rhs)
     {
@@ -74,7 +74,7 @@
 
     bool Layer::operator==(Layer const& other) const
     {
-	return (this == &other);
+        return (this == &other);
     }
     
     void Layer::swap(const Layer& rhs)
@@ -85,11 +85,11 @@
         maxZoom_=rhs.maxZoom_;
         active_=rhs.active_;
         selectable_=rhs.selectable_;
+        //ds_=rhs.ds_;
         styles_=rhs.styles_;
-	ds_=rhs.ds_;
-	selection_style_=rhs.selection_style_;
+        selection_style_=rhs.selection_style_;
     }
-    
+
     Layer::~Layer() {}
 
     parameters const& Layer::params() const
@@ -97,8 +97,13 @@
         return params_;
     }
     
-    const string& Layer::name() const
+    void Layer::set_name( std::string const& name)
     {
+        name_ = name;
+    }
+ 
+    string const& Layer::name() const
+    {
         return name_;
     }
 
@@ -159,57 +164,57 @@
 
     const datasource_p& Layer::datasource() const
     {
-	if (!ds_)
-	{
-	    try
-	    {
-		ds_=datasource_cache::instance()->create(params_);
-	    }
-	    catch (...)
-	    {
-		std::clog << "exception caught : can not create datasource" << std::endl;  
-	    }
-	}
-	return ds_;
+        if (!ds_)
+        {
+            try
+            {
+                ds_=datasource_cache::instance()->create(params_);
+            }
+            catch (...)
+            {
+                std::clog << "exception caught : can not create datasource" << std::endl;  
+            }
+        }
+        return ds_;
     }
     // TODO: !!!!
     void Layer::set_datasource(datasource_p const& ds)
     {
-	ds_ = ds;
+        ds_ = ds;
     }
     
     Envelope<double> Layer::envelope() const
     {
-	datasource_p const& ds = datasource();
-	if (ds)
-	{
-	    return ds->envelope();
-	}
+        datasource_p const& ds = datasource();
+        if (ds)
+        {
+            return ds->envelope();
+        }
     	return Envelope<double>();
     }
 
     void Layer::selection_style(const std::string& name) 
     {
-	selection_style_=name;
+        selection_style_=name;
     }
     
     const std::string& Layer::selection_style() const 
     {
-	return selection_style_;
+        return selection_style_;
     }
 
     void Layer::add_to_selection(shared_ptr<Feature>& feature) const
     {
-	selection_.push_back(feature);
+        selection_.push_back(feature);
     }
  
     vector<shared_ptr<Feature> >& Layer::selection() const
     {
-	return selection_;
+        return selection_;
     }
 
     void Layer::clear_selection() const 
     {
-	selection_.clear();
+        selection_.clear();
     }
 }



From pavlenko at berlios.de  Fri May 19 18:08:42 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Fri, 19 May 2006 18:08:42 +0200
Subject: [Mapnik-svn] r255 - trunk/include
Message-ID: <200605191608.k4JG8gdO004215@sheep.berlios.de>

Author: pavlenko
Date: 2006-05-19 18:08:42 +0200 (Fri, 19 May 2006)
New Revision: 255

Modified:
   trunk/include/stroke.hpp
Log:
explicit black colour in default ctor
 


Modified: trunk/include/stroke.hpp
===================================================================
--- trunk/include/stroke.hpp	2006-05-19 16:07:13 UTC (rev 254)
+++ trunk/include/stroke.hpp	2006-05-19 16:08:42 UTC (rev 255)
@@ -34,135 +34,135 @@
     typedef vector<pair<float,float> > dash_array;
     
     enum line_cap_e
-    {
-	BUTT_CAP,
-	SQUARE_CAP,
-	ROUND_CAP
-    }; 
+        {
+            BUTT_CAP,
+            SQUARE_CAP,
+            ROUND_CAP
+        }; 
     
     enum line_join_e
-    {
-	MITER_JOIN,
-	MITER_REVERT_JOIN,
-	ROUND_JOIN,
-	BEVEL_JOIN
-    };
+        {
+            MITER_JOIN,
+            MITER_REVERT_JOIN,
+            ROUND_JOIN,
+            BEVEL_JOIN
+        };
     
     class stroke
     {	
-	Color c_;
-	float width_;
-	float opacity_; // 0.0 - 1.0
-	line_cap_e  line_cap_;
-	line_join_e line_join_;
-	dash_array dash_;	
+        Color c_;
+        float width_;
+        float opacity_; // 0.0 - 1.0
+        line_cap_e  line_cap_;
+        line_join_e line_join_;
+        dash_array dash_;	
     public:
-	stroke() 
-	    : c_(),
-	      width_(1.0),
-	      opacity_(1.0),
-	      line_cap_(BUTT_CAP),
-	      line_join_(MITER_JOIN),
-	      dash_() {}
+        stroke() 
+            : c_(0,0,0),
+              width_(1.0),
+              opacity_(1.0),
+              line_cap_(BUTT_CAP),
+              line_join_(MITER_JOIN),
+              dash_() {}
 	
-	stroke(Color const& c, float width=1.0)
-	    : c_(c),
-	      width_(width),
-	      opacity_(1.0),
-	      line_cap_(BUTT_CAP),
-	      line_join_(MITER_JOIN),
-	      dash_() {}
+        stroke(Color const& c, float width=1.0)
+            : c_(c),
+              width_(width),
+              opacity_(1.0),
+              line_cap_(BUTT_CAP),
+              line_join_(MITER_JOIN),
+              dash_() {}
 
-	stroke(stroke const& other)
-	    : c_(other.c_),
-	      width_(other.width_),
-	      opacity_(other.opacity_),
-	      line_cap_(other.line_cap_),
-	      line_join_(other.line_join_),
-	      dash_(other.dash_) {}
+        stroke(stroke const& other)
+            : c_(other.c_),
+              width_(other.width_),
+              opacity_(other.opacity_),
+              line_cap_(other.line_cap_),
+              line_join_(other.line_join_),
+              dash_(other.dash_) {}
 	    
-	stroke& operator=(const stroke& rhs)
-	{
-	    stroke tmp(rhs);
-	    swap(tmp);
-	    return *this;
-	}
+        stroke& operator=(const stroke& rhs)
+        {
+            stroke tmp(rhs);
+            swap(tmp);
+            return *this;
+        }
 
-	void set_color(const Color& c) 
-	{
-	    c_=c;
-	}
+        void set_color(const Color& c) 
+        {
+            c_=c;
+        }
 	
-	Color const& get_color() const
-	{
-	    return c_;
-	}
+        Color const& get_color() const
+        {
+            return c_;
+        }
 	
-	float get_width() const
-	{
-	    return width_;
-	}
-	void set_width(float w)
-	{
-	    width_=w;
-	}
+        float get_width() const
+        {
+            return width_;
+        }
+        void set_width(float w)
+        {
+            width_=w;
+        }
 
-	void set_opacity(float opacity)
-	{    
-	    if (opacity > 1.0) opacity_=1.0;
-	    else if (opacity < 0.0) opacity_=0.0;
-	    else opacity_=opacity;
-	}
+        void set_opacity(float opacity)
+        {    
+            if (opacity > 1.0) opacity_=1.0;
+            else if (opacity < 0.0) opacity_=0.0;
+            else opacity_=opacity;
+        }
 
-	float get_opacity() const 
-	{
-	    return opacity_;
-	}
+        float get_opacity() const 
+        {
+            return opacity_;
+        }
 	
-	void set_line_cap(line_cap_e line_cap)
-	{
-	    line_cap_=line_cap;
-	}
+        void set_line_cap(line_cap_e line_cap)
+        {
+            line_cap_=line_cap;
+        }
 
-	line_cap_e get_line_cap() const 
-	{
-	    return line_cap_;
-	}
+        line_cap_e get_line_cap() const 
+        {
+            return line_cap_;
+        }
 	
-	void set_line_join(line_join_e line_join) 
-	{
-	    line_join_=line_join;
-	}
+        void set_line_join(line_join_e line_join) 
+        {
+            line_join_=line_join;
+        }
 	
-	line_join_e get_line_join() const 
-	{
-	    return line_join_;
-	}
+        line_join_e get_line_join() const 
+        {
+            return line_join_;
+        }
 	
-	void add_dash(float dash,float gap)
-	{
-	    dash_.push_back(std::make_pair(dash,gap));
-	}
-	bool has_dash() const 
-	{
-		return dash_.size()>0 ? true : false ;
-	}
+        void add_dash(float dash,float gap)
+        {
+            dash_.push_back(std::make_pair(dash,gap));
+        }
+        bool has_dash() const 
+        {
+            return dash_.size()>0 ? true : false ;
+        }
 	
-	dash_array const& get_dash_array() const
-	{
-	    return  dash_;
-	}
+        dash_array const& get_dash_array() const
+        {
+            return  dash_;
+        }
 	
     private:
-	void swap(const stroke& other) throw()
-	{
-	    c_=other.c_;
-	    width_=other.width_;
-	    opacity_=other.opacity_;
-	    line_cap_=other.line_cap_;
-	    line_join_=other.line_join_;
-	    dash_ = other.dash_;
-	}
+        void swap(const stroke& other) throw()
+        {
+            c_=other.c_;
+            width_=other.width_;
+            opacity_=other.opacity_;
+            line_cap_=other.line_cap_;
+            line_join_=other.line_join_;
+            dash_ = other.dash_;
+        }
     };
 }
 



From pavlenko at berlios.de  Fri May 19 18:09:33 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Fri, 19 May 2006 18:09:33 +0200
Subject: [Mapnik-svn] r256 - trunk/src
Message-ID: <200605191609.k4JG9XNF004278@sheep.berlios.de>

Author: pavlenko
Date: 2006-05-19 18:09:32 +0200 (Fri, 19 May 2006)
New Revision: 256

Modified:
   trunk/src/image_util.cpp
Log:
replaced tabs with spaces



Modified: trunk/src/image_util.cpp
===================================================================
--- trunk/src/image_util.cpp	2006-05-19 16:08:42 UTC (rev 255)
+++ trunk/src/image_util.cpp	2006-05-19 16:09:32 UTC (rev 256)
@@ -45,15 +45,15 @@
     //
     void ImageUtils::save_to_file(const std::string& filename,const std::string& type,const Image32& image)
     {
-	//all that should go into image_writer factory
+        //all that should go into image_writer factory
         if (type=="png")
         {
             save_as_png(filename,image);
         } 
-	else if (type=="jpeg")
-	{
-	    save_as_jpeg(filename,85,image);
-	}
+        else if (type=="jpeg")
+        {
+            save_as_jpeg(filename,85,image);
+        }
     }
 
     void ImageUtils::save_as_png(const std::string& filename,const Image32& image)



From pavlenko at berlios.de  Fri May 19 18:12:00 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Fri, 19 May 2006 18:12:00 +0200
Subject: [Mapnik-svn] r257 - trunk/include
Message-ID: <200605191612.k4JGC0B8004542@sheep.berlios.de>

Author: pavlenko
Date: 2006-05-19 18:11:59 +0200 (Fri, 19 May 2006)
New Revision: 257

Modified:
   trunk/include/fill.hpp
   trunk/include/map.hpp
   trunk/include/polygon_symbolizer.hpp
   trunk/include/rule.hpp
   trunk/include/utils.hpp
Log:
1.added default ctor in polygon_symbolizer (grey fill - RGB (128,128,128)
2.replaced tabs 



Modified: trunk/include/fill.hpp
===================================================================
--- trunk/include/fill.hpp	2006-05-19 16:09:32 UTC (rev 256)
+++ trunk/include/fill.hpp	2006-05-19 16:11:59 UTC (rev 257)
@@ -20,7 +20,6 @@
  *
  *****************************************************************************/
 
-
 //$Id$
 
 #ifndef FILL_HPP
@@ -30,7 +29,7 @@
 {
     class fill 
     {
-	
+        
     };
 }
 

Modified: trunk/include/map.hpp
===================================================================
--- trunk/include/map.hpp	2006-05-19 16:09:32 UTC (rev 256)
+++ trunk/include/map.hpp	2006-05-19 16:11:59 UTC (rev 257)
@@ -34,57 +34,57 @@
 
     class MAPNIK_DECL Map
     {
-	friend class boost::serialization::access;
-	template <typename Archive>
-	void serialize(Archive & ar, const unsigned int /*version*/)
-	{
-	    ar  & boost::serialization::make_nvp("width",width_) 
-		& boost::serialization::make_nvp("height",height_) 
-		& boost::serialization::make_nvp("srid",srid_)
-		& boost::serialization::make_nvp("layers",layers_);
-	}
+        friend class boost::serialization::access;
+        template <typename Archive>
+        void serialize(Archive & ar, const unsigned int /*version*/)
+        {
+            ar  & boost::serialization::make_nvp("width",width_) 
+                & boost::serialization::make_nvp("height",height_) 
+                & boost::serialization::make_nvp("srid",srid_)
+                & boost::serialization::make_nvp("layers",layers_);
+        }
 	
-	static const unsigned MIN_MAPSIZE=16;
-	static const unsigned MAX_MAPSIZE=1024;
-	unsigned width_;
-	unsigned height_;
-	int srid_;
-	Color background_;
-	std::map<std::string,feature_type_style> styles_;
-	std::vector<Layer> layers_;
-	Envelope<double> currentExtent_;
+        static const unsigned MIN_MAPSIZE=16;
+        static const unsigned MAX_MAPSIZE=2048;
+        unsigned width_;
+        unsigned height_;
+        int srid_;
+        Color background_;
+        std::map<std::string,feature_type_style> styles_;
+        std::vector<Layer> layers_;
+        Envelope<double> currentExtent_;
+        
     public:
-	Map();
-	Map(int width,int height,int srid=-1);
-	Map(const Map& rhs);
-	Map& operator=(const Map& rhs);
-
-	bool insert_style(std::string const& name,feature_type_style const& style);
-	void remove_style(const std::string& name);
-	feature_type_style const& find_style(std::string const& name) const;
-	size_t layerCount() const;
-	void addLayer(const Layer& l);
-	const Layer& getLayer(size_t index) const;
-	Layer& getLayer(size_t index);
-	void removeLayer(size_t index);
-	std::vector<Layer> const& layers() const;
-	unsigned getWidth() const;
-	unsigned getHeight() const;
-	void setWidth(unsigned width);
-	void setHeight(unsigned height);
-	void resize(unsigned width,unsigned height);
-	int srid() const;
-	void setBackground(const Color& c);
-	const Color& getBackground() const;
-	void zoom(double zoom);
-	void zoomToBox(const Envelope<double>& box);
-	void pan(int x,int y);
-	void pan_and_zoom(int x,int y,double zoom);
-	const Envelope<double>& getCurrentExtent() const;
-	double scale() const;
-	virtual ~Map();
+        Map();
+        Map(int width,int height,int srid=-1);
+        Map(const Map& rhs);
+        Map& operator=(const Map& rhs);        
+        bool insert_style(std::string const& name,feature_type_style const& style);
+        void remove_style(const std::string& name);
+        feature_type_style const& find_style(std::string const& name) const;
+        size_t layerCount() const;
+        void addLayer(const Layer& l);
+        const Layer& getLayer(size_t index) const;
+        Layer& getLayer(size_t index);
+        void removeLayer(size_t index);
+        std::vector<Layer> const& layers() const;
+        unsigned getWidth() const;
+        unsigned getHeight() const;
+        void setWidth(unsigned width);
+        void setHeight(unsigned height);
+        void resize(unsigned width,unsigned height);
+        int srid() const;
+        void setBackground(const Color& c);
+        const Color& getBackground() const;
+        void zoom(double zoom);
+        void zoomToBox(const Envelope<double>& box);
+        void pan(int x,int y);
+        void pan_and_zoom(int x,int y,double zoom);
+        const Envelope<double>& getCurrentExtent() const;
+        double scale() const;
+        virtual ~Map();
     private:
-	void fixAspectRatio();
+        void fixAspectRatio();
     };
 }
 

Modified: trunk/include/polygon_symbolizer.hpp
===================================================================
--- trunk/include/polygon_symbolizer.hpp	2006-05-19 16:09:32 UTC (rev 256)
+++ trunk/include/polygon_symbolizer.hpp	2006-05-19 16:11:59 UTC (rev 257)
@@ -31,18 +31,21 @@
 {
     struct MAPNIK_DECL polygon_symbolizer
     {
-	polygon_symbolizer(Color const& fill)
-	    : fill_(fill) {}
-	Color const& get_fill() const
-	{
-	    return fill_;
-	}
-	void set_fill(Color const& fill)
-	{
-	    fill_ = fill;
-	}
+        explicit polygon_symbolizer() 
+            : fill_(Color(128,128,128) {}
+
+        polygon_symbolizer(Color const& fill)
+            : fill_(fill) {}
+        Color const& get_fill() const
+        {
+            return fill_;
+        }
+        void set_fill(Color const& fill)
+        {
+            fill_ = fill;
+        }
     private:
-	Color fill_;
+        Color fill_;
     };  
 }
 

Modified: trunk/include/rule.hpp
===================================================================
--- trunk/include/rule.hpp	2006-05-19 16:09:32 UTC (rev 256)
+++ trunk/include/rule.hpp	2006-05-19 16:11:59 UTC (rev 257)
@@ -40,52 +40,52 @@
 namespace mapnik
 {
     inline bool operator==(point_symbolizer const& lhs,
-			   point_symbolizer const& rhs)
+                           point_symbolizer const& rhs)
     {
-	return (&lhs == &rhs); 
+        return (&lhs == &rhs); 
     }
     inline bool operator==(line_symbolizer const& lhs,
-			   line_symbolizer const& rhs)
+                           line_symbolizer const& rhs)
     {
-	return (&lhs == &rhs); 
+        return (&lhs == &rhs); 
     }
     inline bool operator==(line_pattern_symbolizer const& lhs,
-			   line_pattern_symbolizer const& rhs)
+                           line_pattern_symbolizer const& rhs)
     {
-	return (&lhs == &rhs); 
+        return (&lhs == &rhs); 
     }
 
     inline bool operator==(polygon_symbolizer const& lhs,
-			   polygon_symbolizer const& rhs)
+                           polygon_symbolizer const& rhs)
     {
-	return (&lhs == &rhs); 
+        return (&lhs == &rhs); 
     }
     
     inline bool operator==(polygon_pattern_symbolizer const& lhs,
-			   polygon_pattern_symbolizer const& rhs)
+                           polygon_pattern_symbolizer const& rhs)
     {
-	return (&lhs == &rhs); 
+        return (&lhs == &rhs); 
     }
     
     inline bool operator==(raster_symbolizer const& lhs,
-			   raster_symbolizer const& rhs)
+                           raster_symbolizer const& rhs)
     {
-	return (&lhs == &rhs); 
+        return (&lhs == &rhs); 
     }
     
     inline bool operator==(text_symbolizer const& lhs,
-			   text_symbolizer const& rhs)
+                           text_symbolizer const& rhs)
     {
-	return (&lhs == &rhs); 
+        return (&lhs == &rhs); 
     }
     
     typedef boost::variant<point_symbolizer,
-			   line_symbolizer,
-			   line_pattern_symbolizer,
-			   polygon_symbolizer,
-			   polygon_pattern_symbolizer,
-			   raster_symbolizer,
-			   text_symbolizer> symbolizer;
+                           line_symbolizer,
+                           line_pattern_symbolizer,
+                           polygon_symbolizer,
+                           polygon_pattern_symbolizer,
+                           raster_symbolizer,
+                           text_symbolizer> symbolizer;
     
         
     typedef std::vector<symbolizer> symbolizers;    
@@ -94,183 +94,183 @@
     template <typename FeatureT,template <typename> class Filter>
     class rule
     {
-	typedef Filter<FeatureT> filter_type;
-	typedef boost::shared_ptr<filter_type> filter_ptr;
+        typedef Filter<FeatureT> filter_type;
+        typedef boost::shared_ptr<filter_type> filter_ptr;
     private:
 
-	std::string name_;
-	std::string title_;
-	std::string abstract_;
-	double min_scale_;
-	double max_scale_;
+        std::string name_;
+        std::string title_;
+        std::string abstract_;
+        double min_scale_;
+        double max_scale_;
         symbolizers syms_;
-	filter_ptr filter_;
-	bool else_filter_;
+        filter_ptr filter_;
+        bool else_filter_;
     public:
-	rule()
-	    : name_(),
-	      title_(),
-	      abstract_(),
-	      min_scale_(0),
-	      max_scale_(std::numeric_limits<double>::infinity()),
-	      syms_(),
-	      filter_(new all_filter<FeatureT>),
-	      else_filter_(false) {}
+        rule()
+            : name_(),
+              title_(),
+              abstract_(),
+              min_scale_(0),
+              max_scale_(std::numeric_limits<double>::infinity()),
+              syms_(),
+              filter_(new all_filter<FeatureT>),
+              else_filter_(false) {}
                 
-	rule(const std::string& name,
-	     const std::string& title="",
-	     double min_scale_denominator=0,
-	     double max_scale_denominator=std::numeric_limits<double>::infinity())
-	    : name_(name),
-	      title_(title),
-	      min_scale_(min_scale_denominator),
-	      max_scale_(max_scale_denominator),
-	      syms_(),
-	      filter_(new all_filter<FeatureT>),
-	      else_filter_(false) {}
+        rule(const std::string& name,
+             const std::string& title="",
+             double min_scale_denominator=0,
+             double max_scale_denominator=std::numeric_limits<double>::infinity())
+            : name_(name),
+              title_(title),
+              min_scale_(min_scale_denominator),
+              max_scale_(max_scale_denominator),
+              syms_(),
+              filter_(new all_filter<FeatureT>),
+              else_filter_(false) {}
 	    
-	rule(const rule& rhs)    
-	    : name_(rhs.name_),
-	      title_(rhs.title_),
-	      abstract_(rhs.abstract_),
-	      min_scale_(rhs.min_scale_),
-	      max_scale_(rhs.max_scale_),
-	      syms_(rhs.syms_),
-	      filter_(rhs.filter_),
-	      else_filter_(rhs.else_filter_) {}
+        rule(const rule& rhs)    
+            : name_(rhs.name_),
+              title_(rhs.title_),
+              abstract_(rhs.abstract_),
+              min_scale_(rhs.min_scale_),
+              max_scale_(rhs.max_scale_),
+              syms_(rhs.syms_),
+              filter_(rhs.filter_),
+              else_filter_(rhs.else_filter_) {}
 	
         rule& operator=(rule const& rhs) 
-	{
-	    rule tmp(rhs);
-	    swap(tmp);
-	    return *this;
-	}
-	bool operator==(rule const& other)
-	{
-	    return  (this == &other); 
-	}
+        {
+            rule tmp(rhs);
+            swap(tmp);
+            return *this;
+        }
+        bool operator==(rule const& other)
+        {
+            return  (this == &other); 
+        }
 	
-	void set_max_scale(double scale)
-	{
-	    max_scale_=scale;
-	}
+        void set_max_scale(double scale)
+        {
+            max_scale_=scale;
+        }
 
-	double get_min_scale() const
-	{
-	    return min_scale_;
-	}
+        double get_min_scale() const
+        {
+            return min_scale_;
+        }
 
-	double get_max_scale() const
-	{
-	    return max_scale_;
-	}
+        double get_max_scale() const
+        {
+            return max_scale_;
+        }
 
-	void set_min_scale(double scale)
-	{
-	    min_scale_=scale;
-	}
+        void set_min_scale(double scale)
+        {
+            min_scale_=scale;
+        }
 
-	void set_name(std::string const& name)
-	{
-	    name_=name;
-	}
+        void set_name(std::string const& name)
+        {
+            name_=name;
+        }
 	
-	std::string const& get_name() const
-	{
-	    return name_;
-	}
+        std::string const& get_name() const
+        {
+            return name_;
+        }
 	
-	std::string const& get_title() const
-	{
-	    return  title_;
-	}
+        std::string const& get_title() const
+        {
+            return  title_;
+        }
 
-	void set_title(std::string const& title)
-	{
-	    title_=title;
-	}
+        void set_title(std::string const& title)
+        {
+            title_=title;
+        }
   
-	void set_abstract(std::string const& abstract)
-	{
-	    abstract_=abstract;
-	}
+        void set_abstract(std::string const& abstract)
+        {
+            abstract_=abstract;
+        }
 	
-	std::string const& get_abstract() const
-	{
-	    return abstract_;
-	}
+        std::string const& get_abstract() const
+        {
+            return abstract_;
+        }
 		
-	void append(const symbolizer& sym)
-	{
-	    syms_.push_back(sym);
-	}
+        void append(const symbolizer& sym)
+        {
+            syms_.push_back(sym);
+        }
 	
-	void remove_at(size_t index)
-	{
-	    if (index < syms_.size())
-	    {
-		syms_.erase(syms_.begin()+index);
-	    }
-	}
+        void remove_at(size_t index)
+        {
+            if (index < syms_.size())
+            {
+                syms_.erase(syms_.begin()+index);
+            }
+        }
 	
-	const symbolizers& get_symbolizers() const
-	{
-	    return syms_;
-	}
+        const symbolizers& get_symbolizers() const
+        {
+            return syms_;
+        }
 	
-	symbolizers::const_iterator begin()
-	{
-	    return syms_.begin();
-	}
+        symbolizers::const_iterator begin()
+        {
+            return syms_.begin();
+        }
 	
-	symbolizers::const_iterator end()
-	{
-	    return syms_.end();
-	}
+        symbolizers::const_iterator end()
+        {
+            return syms_.end();
+        }
 	
-	void set_filter(const filter_ptr& filter)
-	{
-	    filter_=filter;
-	}
+        void set_filter(const filter_ptr& filter)
+        {
+            filter_=filter;
+        }
 
-	filter_ptr const& get_filter() const
-	{
-	    return filter_;
-	}
+        filter_ptr const& get_filter() const
+        {
+            return filter_;
+        }
 	
-	void set_else(bool else_filter)
-	{
-	    else_filter_=else_filter;
-	}
+        void set_else(bool else_filter)
+        {
+            else_filter_=else_filter;
+        }
      
-	bool has_else_filter() const
-	{
-	    return else_filter_;
-	}
+        bool has_else_filter() const
+        {
+            return else_filter_;
+        }
         
-	bool active(double scale) const
-	{
-	    return ( scale > min_scale_ && scale < max_scale_ );
-	}
+        bool active(double scale) const
+        {
+            return ( scale > min_scale_ && scale < max_scale_ );
+        }
 
-	void accept(filter_visitor<FeatureT>& v) const
-	{
-	    v.visit(*this);
-	}
+        void accept(filter_visitor<FeatureT>& v) const
+        {
+            v.visit(*this);
+        }
 	
     private:
 	
-	void swap(rule& rhs) throw()
-	{
-	    name_=rhs.name_;
-	    title_=rhs.title_;
-	    abstract_=rhs.abstract_;
-	    min_scale_=rhs.min_scale_;
-	    max_scale_=rhs.max_scale_;
-	    syms_=rhs.syms_;
-	    filter_=rhs.filter_;
-	    else_filter_=rhs.else_filter_;
-	}
+        void swap(rule& rhs) throw()
+        {
+            name_=rhs.name_;
+            title_=rhs.title_;
+            abstract_=rhs.abstract_;
+            min_scale_=rhs.min_scale_;
+            max_scale_=rhs.max_scale_;
+            syms_=rhs.syms_;
+            filter_=rhs.filter_;
+            else_filter_=rhs.else_filter_;
+        }
     };
 
     typedef rule<Feature,filter> rule_type;

Modified: trunk/include/utils.hpp
===================================================================
--- trunk/include/utils.hpp	2006-05-19 16:09:32 UTC (rev 256)
+++ trunk/include/utils.hpp	2006-05-19 16:11:59 UTC (rev 257)
@@ -201,21 +201,21 @@
     template <typename T>
     inline std::string toString(const T& x)
     {
-	std::ostringstream o;
-	if (!(o << x))
-	    throw BadConversion(std::string("toString(")
-				+ typeid(x).name() + ")");
-	return o.str();
+        std::ostringstream o;
+        if (!(o << x))
+            throw BadConversion(std::string("toString(")
+                                + typeid(x).name() + ")");
+        return o.str();
     }
     
     template<typename T>
     inline void fromString(const std::string& s, T& x,
-			   bool failIfLeftoverChars = true)
+                           bool failIfLeftoverChars = true)
     {
-	std::istringstream i(s);
-	char c;
-	if (!(i >> x) || (failIfLeftoverChars && i.get(c)))
-	    throw BadConversion("fromString("+s+")");
+        std::istringstream i(s);
+        char c;
+        if (!(i >> x) || (failIfLeftoverChars && i.get(c)))
+            throw BadConversion("fromString("+s+")");
     }
     
     //inline bool space (char c)



From pavlenko at berlios.de  Sun May 21 21:18:00 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Sun, 21 May 2006 21:18:00 +0200
Subject: [Mapnik-svn] r258 - trunk/include
Message-ID: <200605211918.k4LJI0iu022000@sheep.berlios.de>

Author: pavlenko
Date: 2006-05-21 21:17:15 +0200 (Sun, 21 May 2006)
New Revision: 258

Modified:
   trunk/include/polygon_symbolizer.hpp
Log:
corrected ctor

Modified: trunk/include/polygon_symbolizer.hpp
===================================================================
--- trunk/include/polygon_symbolizer.hpp	2006-05-19 16:11:59 UTC (rev 257)
+++ trunk/include/polygon_symbolizer.hpp	2006-05-21 19:17:15 UTC (rev 258)
@@ -32,10 +32,11 @@
     struct MAPNIK_DECL polygon_symbolizer
     {
         explicit polygon_symbolizer() 
-            : fill_(Color(128,128,128) {}
+            : fill_(Color(128,128,128)) {}
 
         polygon_symbolizer(Color const& fill)
             : fill_(fill) {}
+        
         Color const& get_fill() const
         {
             return fill_;



From pavlenko at berlios.de  Mon May 22 11:38:47 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Mon, 22 May 2006 11:38:47 +0200
Subject: [Mapnik-svn] r259 - tags
Message-ID: <200605220938.k4M9cl9g009084@sheep.berlios.de>

Author: pavlenko
Date: 2006-05-22 11:38:46 +0200 (Mon, 22 May 2006)
New Revision: 259

Added:
   tags/release-0.3.0/
Log:
tagging release 0.3.0

Copied: tags/release-0.3.0 (from rev 258, trunk)



From pavlenko at berlios.de  Mon May 22 12:30:58 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Mon, 22 May 2006 12:30:58 +0200
Subject: [Mapnik-svn] r260 - in trunk: include src
Message-ID: <200605221030.k4MAUwoR015735@sheep.berlios.de>

Author: pavlenko
Date: 2006-05-22 12:30:55 +0200 (Mon, 22 May 2006)
New Revision: 260

Modified:
   trunk/include/image_data.hpp
   trunk/include/point_symbolizer.hpp
   trunk/src/point_symbolizer.cpp
Log:
added default point_symbolizer 4x4px black square

Modified: trunk/include/image_data.hpp
===================================================================
--- trunk/include/image_data.hpp	2006-05-22 09:38:46 UTC (rev 259)
+++ trunk/include/image_data.hpp	2006-05-22 10:30:55 UTC (rev 260)
@@ -32,93 +32,93 @@
     template <class T> class ImageData
     {
     private:
-	const unsigned width_;
-	const unsigned height_;
-	T *pData_;
-	ImageData& operator=(const ImageData&);
+        const unsigned width_;
+        const unsigned height_;
+        T *pData_;
+        ImageData& operator=(const ImageData&);
     public:
-	ImageData(unsigned width,unsigned height)
-	    : width_(width),
-	      height_(height),
-	      pData_((width!=0 && height!=0)? static_cast<T*>(::operator new(sizeof(T)*width*height)):0)
-	{
-	    if (pData_) memset(pData_,0,sizeof(T)*width_*height_);
-	}
+        ImageData(unsigned width,unsigned height)
+            : width_(width),
+              height_(height),
+              pData_((width!=0 && height!=0)? static_cast<T*>(::operator new(sizeof(T)*width*height)):0)
+        {
+            if (pData_) memset(pData_,0,sizeof(T)*width_*height_);
+        }
 
-	ImageData(const ImageData<T>& rhs)
-	    :width_(rhs.width_),
-	     height_(rhs.height_),
-	     pData_((rhs.width_!=0 && rhs.height_!=0)? new T[rhs.width_*rhs.height_]:0)
-	{
-	    if (pData_) memcpy(pData_,rhs.pData_,sizeof(T)*rhs.width_* rhs.height_);
-	}
-	inline T& operator() (unsigned i,unsigned j)
-	{
-	    assert(i<width_ && j<height_);
-	    return pData_[j*width_+i];
-	}
-	inline const T& operator() (unsigned i,unsigned j) const
-	{
-	    assert(i<width_ && j<height_);
-	    return pData_[j*width_+i];
-	}
-	inline unsigned width() const
-	{
-	    return width_;
-	}
-	inline unsigned height() const
-	{
-	    return height_;
-	}
-	inline void set(const T& t)
-	{
-	    for (unsigned i=0;i<width_;++i)
-	    {
-		for (unsigned j=0;j<height_;++j)
-		{
-		    (*this)(i,j)=t;
-		}
-	    }
-	}
-	inline const T* getData() const
-	{
-	    return pData_;
-	}
+        ImageData(const ImageData<T>& rhs)
+            :width_(rhs.width_),
+             height_(rhs.height_),
+             pData_((rhs.width_!=0 && rhs.height_!=0)? new T[rhs.width_*rhs.height_]:0)
+        {
+            if (pData_) memcpy(pData_,rhs.pData_,sizeof(T)*rhs.width_* rhs.height_);
+        }
+        inline T& operator() (unsigned i,unsigned j)
+        {
+            assert(i<width_ && j<height_);
+            return pData_[j*width_+i];
+        }
+        inline const T& operator() (unsigned i,unsigned j) const
+        {
+            assert(i<width_ && j<height_);
+            return pData_[j*width_+i];
+        }
+        inline unsigned width() const
+        {
+            return width_;
+        }
+        inline unsigned height() const
+        {
+            return height_;
+        }
+        inline void set(const T& t)
+        {
+            for (unsigned i=0;i<width_;++i)
+            {
+                for (unsigned j=0;j<height_;++j)
+                {
+                    (*this)(i,j)=t;
+                }
+            }
+        }
+        inline const T* getData() const
+        {
+            return pData_;
+        }
 
-	inline T* getData()
-	{
-	    return pData_;
-	}
+        inline T* getData()
+        {
+            return pData_;
+        }
 
-	inline const unsigned char* getBytes() const
-	{
-	    return (unsigned char*)pData_;
-	}
+        inline const unsigned char* getBytes() const
+        {
+            return (unsigned char*)pData_;
+        }
 	
-	inline unsigned char* getBytes()
-	{
-	    return (unsigned char*)pData_;
-	}
+        inline unsigned char* getBytes()
+        {
+            return (unsigned char*)pData_;
+        }
 	
-	inline const T* getRow(unsigned row) const
-	{
-	    return pData_+row*width_;
-	}
-	inline void setRow(unsigned row,const T* buf,unsigned size)
-	{
-	    assert(row<height_);
-	    assert(size<=(width_*sizeof(T)));
-	    memcpy(pData_+row*width_,buf,size*sizeof(T));
-	}
-	inline void setRow(unsigned row,unsigned x0,unsigned x1,const T* buf)
-	{
-	    memcpy(pData_+row*width_+x0,buf,(x1-x0)*sizeof(T));
-	}
+        inline const T* getRow(unsigned row) const
+        {
+            return pData_+row*width_;
+        }
+        inline void setRow(unsigned row,const T* buf,unsigned size)
+        {
+            assert(row<height_);
+            assert(size<=(width_*sizeof(T)));
+            memcpy(pData_+row*width_,buf,size*sizeof(T));
+        }
+        inline void setRow(unsigned row,unsigned x0,unsigned x1,const T* buf)
+        {
+            memcpy(pData_+row*width_+x0,buf,(x1-x0)*sizeof(T));
+        }
 
-	inline ~ImageData()
-	{
-	    ::operator delete(pData_),pData_=0;
-	}
+        inline ~ImageData()
+        {
+            ::operator delete(pData_),pData_=0;
+        }
 	
     };
 

Modified: trunk/include/point_symbolizer.hpp
===================================================================
--- trunk/include/point_symbolizer.hpp	2006-05-22 09:38:46 UTC (rev 259)
+++ trunk/include/point_symbolizer.hpp	2006-05-22 10:30:55 UTC (rev 260)
@@ -31,6 +31,7 @@
 {   
     struct MAPNIK_DECL point_symbolizer
     {	
+        explicit point_symbolizer();
         point_symbolizer(std::string const& file,
                          std::string const& type,
                          unsigned width,unsigned height);

Modified: trunk/src/point_symbolizer.cpp
===================================================================
--- trunk/src/point_symbolizer.cpp	2006-05-22 09:38:46 UTC (rev 259)
+++ trunk/src/point_symbolizer.cpp	2006-05-22 10:30:55 UTC (rev 260)
@@ -22,38 +22,46 @@
 
 //$Id$
 
+#include <boost/scoped_ptr.hpp>
 #include "point_symbolizer.hpp"
 #include "image_data.hpp"
 #include "image_reader.hpp"
 
 namespace mapnik
 {
+    point_symbolizer::point_symbolizer()
+        : symbol_(new ImageData32(4,4))
+    {
+        //default point symbol is black 4x4px square
+        symbol_->set(0xff000000);
+    }
+    
     point_symbolizer::point_symbolizer(std::string const& file,
-				       std::string const& type,
-				       unsigned width,unsigned height) 
-	: symbol_(new ImageData32(width,height))
+                                       std::string const& type,
+                                       unsigned width,unsigned height) 
+        : symbol_(new ImageData32(width,height))
     {
-	try 
-	{
-	    std::auto_ptr<ImageReader> reader(get_image_reader(type,file));
-	    if (reader.get())
-	    {
-		reader->read(0,0,*symbol_);		
-	    }
-	} 
-	catch (...) 
-	{
-	    std::clog<<"exception caught..." << std::endl;
-	}
+        try 
+        {
+            boost::scoped_ptr<ImageReader> reader(get_image_reader(type,file));
+            if (reader.get())
+            {
+                reader->read(0,0,*symbol_);		
+            }
+        } 
+        catch (...) 
+        {
+            std::clog<<"exception caught..." << std::endl;
+        }
     }
     
     point_symbolizer::point_symbolizer(point_symbolizer const& rhs)
-	: symbol_(rhs.symbol_) 
+        : symbol_(rhs.symbol_) 
     {}
     
     ImageData32 const& point_symbolizer::get_data() const
     {
-	return *(symbol_.get());
+        return *(symbol_.get());
     }
 }
 



From jdoyon at berlios.de  Mon May 22 16:45:53 2006
From: jdoyon at berlios.de (jdoyon at BerliOS)
Date: Mon, 22 May 2006 16:45:53 +0200
Subject: [Mapnik-svn] r261 - trunk/bindings/python/mapnik/ogcserver
Message-ID: <200605221445.k4MEjrSj009113@sheep.berlios.de>

Author: jdoyon
Date: 2006-05-22 16:45:52 +0200 (Mon, 22 May 2006)
New Revision: 261

Modified:
   trunk/bindings/python/mapnik/ogcserver/common.py
Log:
Remove an overly restrictive bit of "checking" that did 
not allow clients to feed non-WMS parameters to the server.

Modified: trunk/bindings/python/mapnik/ogcserver/common.py
===================================================================
--- trunk/bindings/python/mapnik/ogcserver/common.py	2006-05-22 10:30:55 UTC (rev 260)
+++ trunk/bindings/python/mapnik/ogcserver/common.py	2006-05-22 14:45:52 UTC (rev 261)
@@ -81,9 +81,6 @@
 
     def processParameters(self, requestname, params):
         finalparams = {}
-        for paramname in params.keys():
-            if paramname not in self.SERVICE_PARAMS[requestname].keys():
-                raise OGCException('Unknown request parameter "%s".' % paramname)
         for paramname, paramdef in self.SERVICE_PARAMS[requestname].items():
             if paramname not in params.keys() and paramdef.mandatory:
                 raise OGCException('Mandatory parameter "%s" missing from request.' % paramname)



From jdoyon at berlios.de  Mon May 22 19:00:40 2006
From: jdoyon at berlios.de (jdoyon at BerliOS)
Date: Mon, 22 May 2006 19:00:40 +0200
Subject: [Mapnik-svn] r262 - in trunk: bindings/python bindings/python/mapnik/ogcserver docs/ogcserver include src
Message-ID: <200605221700.k4MH0e75032038@sheep.berlios.de>

Author: jdoyon
Date: 2006-05-22 19:00:35 +0200 (Mon, 22 May 2006)
New Revision: 262

Modified:
   trunk/bindings/python/mapnik/ogcserver/cgiserver.py
   trunk/bindings/python/mapnik/ogcserver/wms111.py
   trunk/bindings/python/mapnik/ogcserver/wms130.py
   trunk/bindings/python/mapnik_layer.cpp
   trunk/docs/ogcserver/readme.txt
   trunk/include/layer.hpp
   trunk/src/layer.cpp
Log:
- Fix a bug with missing version.
- Add support for layer title and asbtract to c++ and python
- Make WMS server use above changes, edit docs

Modified: trunk/bindings/python/mapnik/ogcserver/cgiserver.py
===================================================================
--- trunk/bindings/python/mapnik/ogcserver/cgiserver.py	2006-05-22 14:45:52 UTC (rev 261)
+++ trunk/bindings/python/mapnik/ogcserver/cgiserver.py	2006-05-22 17:00:35 UTC (rev 262)
@@ -73,7 +73,8 @@
             raise OGCException('Unsupported service "%s".' % service)
         ServiceHandlerFactory = getattr(mapnikmodule.ogcserver, service).ServiceHandlerFactory
         servicehandler = ServiceHandlerFactory(self.conf, self.mapfactory, onlineresource, reqparams.get('version', None))
-        del reqparams['version']
+        if reqparams.has_key('version'):
+            del reqparams['version']
         if request not in servicehandler.SERVICE_PARAMS.keys():
             raise OGCException('Operation "%s" not supported.' % request, 'OperationNotSupported')
         ogcparams = servicehandler.processParameters(request, reqparams)

Modified: trunk/bindings/python/mapnik/ogcserver/wms111.py
===================================================================
--- trunk/bindings/python/mapnik/ogcserver/wms111.py	2006-05-22 14:45:52 UTC (rev 261)
+++ trunk/bindings/python/mapnik/ogcserver/wms111.py	2006-05-22 17:00:35 UTC (rev 262)
@@ -144,8 +144,6 @@
         for layer in self.mapfactory.layers.values():
             layername = ElementTree.Element('Name')
             layername.text = layer.name()
-            layertitle = ElementTree.Element('Title')
-            layertitle.text = layer.name()
             env = layer.envelope()
             llp = self.crs.Inverse(env.minx, env.miny)
             urp = self.crs.Inverse(env.maxx, env.maxy)
@@ -162,7 +160,14 @@
             layerbbox.set('maxy', str(env.maxy))
             layere = ElementTree.Element('Layer')
             layere.append(layername)
-            layere.append(layertitle)
+            if layer.title():
+                layertitle = ElementTree.Element('Title')
+                layertitle.text = layer.title()
+                layere.append(layertitle)
+            if layer.abstract():
+                layerabstract = ElementTree.Element('Abstract')
+                layerabstract.text = layer.abstract()
+                layere.append(layerabstract)
             layere.append(latlonbb)
             layere.append(layerbbox)
             if len(layer.wmsextrastyles) > 0:

Modified: trunk/bindings/python/mapnik/ogcserver/wms130.py
===================================================================
--- trunk/bindings/python/mapnik/ogcserver/wms130.py	2006-05-22 14:45:52 UTC (rev 261)
+++ trunk/bindings/python/mapnik/ogcserver/wms130.py	2006-05-22 17:00:35 UTC (rev 262)
@@ -150,8 +150,6 @@
         for layer in self.mapfactory.layers.values():
             layername = ElementTree.Element('Name')
             layername.text = layer.name()
-            layertitle = ElementTree.Element('Title')
-            layertitle.text = layer.name()
             env = layer.envelope()
             layerexgbb = ElementTree.Element('EX_GeographicBoundingBox')
             ll = self.crs.Inverse(env.minx, env.miny)
@@ -176,7 +174,14 @@
             layerbbox.set('maxy', str(env.maxy))
             layere = ElementTree.Element('Layer')
             layere.append(layername)
-            layere.append(layertitle)
+            if layer.title():
+                layertitle = ElementTree.Element('Title')
+                layertitle.text = layer.title()
+                layere.append(layertitle)
+            if layer.abstract():
+                layerabstract = ElementTree.Element('Abstract')
+                layerabstract.text = layer.abstract()
+                layere.append(layerabstract)
             layere.append(layerexgbb)
             layere.append(layerbbox)
             if len(layer.wmsextrastyles) > 0:

Modified: trunk/bindings/python/mapnik_layer.cpp
===================================================================
--- trunk/bindings/python/mapnik_layer.cpp	2006-05-22 14:45:52 UTC (rev 261)
+++ trunk/bindings/python/mapnik_layer.cpp	2006-05-22 17:00:35 UTC (rev 262)
@@ -109,6 +109,8 @@
     
     class_<Layer>("Layer","A map layer.",no_init)
         .def("name",&Layer::name,return_value_policy<copy_const_reference>(), "Return the name of the layer.")
+        .def("title",&Layer::title,return_value_policy<copy_const_reference>(), "Return the title of the layer.")
+        .def("abstract",&Layer::abstract,return_value_policy<copy_const_reference>(), "Return the abstract of the layer.")
         .def("params",&Layer::params,return_value_policy<reference_existing_object>(), "The configuration parameters of the layer.  These vary depending on the type of data source.")
         .def("envelope",&Layer::envelope, "Return the geographic envelope/bounding box of the data in the layer.")
 	.add_property("minzoom",&Layer::getMinZoom,&Layer::setMinZoom)

Modified: trunk/docs/ogcserver/readme.txt
===================================================================
--- trunk/docs/ogcserver/readme.txt	2006-05-22 14:45:52 UTC (rev 261)
+++ trunk/docs/ogcserver/readme.txt	2006-05-22 17:00:35 UTC (rev 262)
@@ -100,7 +100,7 @@
 		...
 		self.register_style('stylename', sty)
 		
-		lyr = Layer(name='layername')
+		lyr = Layer(name='layername', title='Highways', description='Highways')
 		...
 		lyr.styles.append('stylename')
 		self.register_layer(lyr)
@@ -114,6 +114,8 @@
 - Layers MUST be named with the 'name' parameter to the constructor.
 - style and layer names are meant for machine readability, not human.  Keep
   them short and simple, without spaces or special characters.
+- For human readable info, pass title='' and abstract='' parameters to the
+  Layer() call.
 - The layers must have at least one style associated with them (a default).
 - No Map() object is used or needed here.
 - Be sure to call self.finalize() once you've registered everything! This will
@@ -127,7 +129,6 @@
 
 - Named style support.
 - Improve configuration to allow for full server metadata.
-- Add support for richer layer metadata.
 - Investigate moving to cElementTree from lxml.
 - Add some internal "caching" for performance improvements.
 - Support GetFeatureInfo (Requires core changes).

Modified: trunk/include/layer.hpp
===================================================================
--- trunk/include/layer.hpp	2006-05-22 14:45:52 UTC (rev 261)
+++ trunk/include/layer.hpp	2006-05-22 17:00:35 UTC (rev 262)
@@ -39,6 +39,8 @@
         void serialize(Archive & ar, const unsigned int /*version*/)
         {
             ar  & boost::serialization::make_nvp("name",name_)
+            	& boost::serialization::make_nvp("title",title_)
+            	& boost::serialization::make_nvp("abstract",abstract_)
                 & boost::serialization::make_nvp("params",params_)
                 & boost::serialization::make_nvp("min_zoom",minZoom_)
                 & boost::serialization::make_nvp("max_zoom",maxZoom_)
@@ -49,6 +51,8 @@
         }
         parameters params_;
         std::string name_;
+        std::string title_;
+        std::string abstract_;
         double minZoom_;
         double maxZoom_;
         bool active_;
@@ -69,6 +73,10 @@
         parameters const& params() const;
         void set_name(std::string const& name);
         const std::string& name() const;
+        void set_title(std::string const& title);
+        const std::string& title() const;
+        void set_abstract(std::string const& abstract);
+        const std::string& abstract() const;
         void add_style(std::string const& stylename);
         std::vector<std::string> const& styles() const;
         void selection_style(const std::string& name);

Modified: trunk/src/layer.cpp
===================================================================
--- trunk/src/layer.cpp	2006-05-22 14:45:52 UTC (rev 261)
+++ trunk/src/layer.cpp	2006-05-22 17:00:35 UTC (rev 262)
@@ -37,6 +37,8 @@
     Layer::Layer()
         : params_(),
           name_("unknown"),
+          title_(""),
+          abstract_(""),
           minZoom_(0),
           maxZoom_(std::numeric_limits<double>::max()),
           active_(true),
@@ -47,6 +49,8 @@
     Layer::Layer(const parameters& params)
         :params_(params),
          name_(params_["name"]),
+         title_(params_["title"]),
+         abstract_(params_["abstract"]),
          minZoom_(0),
          maxZoom_(std::numeric_limits<double>::max()),
          active_(true),
@@ -57,6 +61,8 @@
     Layer::Layer(const Layer& rhs)
         :params_(rhs.params_),
          name_(rhs.name_),
+         title_(rhs.title_),
+         abstract_(rhs.abstract_),
          minZoom_(rhs.minZoom_),
          maxZoom_(rhs.maxZoom_),
          active_(rhs.active_),
@@ -81,6 +87,8 @@
     {
         params_=rhs.params_;
         name_=rhs.name_;
+        title_=rhs.title_;
+        abstract_=rhs.abstract_;
         minZoom_=rhs.minZoom_;
         maxZoom_=rhs.maxZoom_;
         active_=rhs.active_;
@@ -107,6 +115,26 @@
         return name_;
     }
 
+    void Layer::set_title( std::string const& title)
+    {
+        title_ = title;
+    }
+ 
+    string const& Layer::title() const
+    {
+        return title_;
+    }
+
+    void Layer::set_abstract( std::string const& abstract)
+    {
+        abstract_ = abstract;
+    }
+ 
+    string const& Layer::abstract() const
+    {
+        return abstract_;
+    }
+
     void Layer::add_style(std::string const& stylename)
     {
         styles_.push_back(stylename);



From jdoyon at berlios.de  Mon May 22 19:07:53 2006
From: jdoyon at berlios.de (jdoyon at BerliOS)
Date: Mon, 22 May 2006 19:07:53 +0200
Subject: [Mapnik-svn] r263 - trunk/docs/ogcserver
Message-ID: <200605221707.k4MH7rDI000351@sheep.berlios.de>

Author: jdoyon
Date: 2006-05-22 19:07:47 +0200 (Mon, 22 May 2006)
New Revision: 263

Modified:
   trunk/docs/ogcserver/readme.txt
Log:
Minor edit to the ogcserver docs.

Modified: trunk/docs/ogcserver/readme.txt
===================================================================
--- trunk/docs/ogcserver/readme.txt	2006-05-22 17:00:35 UTC (rev 262)
+++ trunk/docs/ogcserver/readme.txt	2006-05-22 17:07:47 UTC (rev 263)
@@ -100,7 +100,7 @@
 		...
 		self.register_style('stylename', sty)
 		
-		lyr = Layer(name='layername', title='Highways', description='Highways')
+		lyr = Layer(name='layername', title='Highways', abstract='Highways')
 		...
 		lyr.styles.append('stylename')
 		self.register_layer(lyr)



From pavlenko at berlios.de  Mon May 22 21:38:08 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Mon, 22 May 2006 21:38:08 +0200
Subject: [Mapnik-svn] r264 - tags
Message-ID: <200605221938.k4MJc8ta026616@sheep.berlios.de>

Author: pavlenko
Date: 2006-05-22 21:38:07 +0200 (Mon, 22 May 2006)
New Revision: 264

Removed:
   tags/release-0.3.0/
Log:
removing tag 





From pavlenko at berlios.de  Mon May 22 21:39:02 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Mon, 22 May 2006 21:39:02 +0200
Subject: [Mapnik-svn] r265 - tags
Message-ID: <200605221939.k4MJd2lv029838@sheep.berlios.de>

Author: pavlenko
Date: 2006-05-22 21:38:53 +0200 (Mon, 22 May 2006)
New Revision: 265

Added:
   tags/release-0.3.0/
Log:
tagging release 0.3.0

Copied: tags/release-0.3.0 (from rev 264, trunk)



From pavlenko at berlios.de  Tue May 23 18:52:14 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Tue, 23 May 2006 18:52:14 +0200
Subject: [Mapnik-svn] r266 - in trunk: include plugins/input/postgis plugins/input/raster plugins/input/shape src
Message-ID: <200605231652.k4NGqElb000491@sheep.berlios.de>

Author: pavlenko
Date: 2006-05-23 18:52:10 +0200 (Tue, 23 May 2006)
New Revision: 266

Modified:
   trunk/include/datasource.hpp
   trunk/include/map.hpp
   trunk/include/params.hpp
   trunk/include/point_symbolizer.hpp
   trunk/include/polygon_symbolizer.hpp
   trunk/plugins/input/postgis/postgis.cpp
   trunk/plugins/input/raster/raster_datasource.cpp
   trunk/plugins/input/shape/shape.cpp
   trunk/plugins/input/shape/shape.hpp
   trunk/src/agg_renderer.cpp
   trunk/src/layer.cpp
   trunk/src/map.cpp
   trunk/src/point_symbolizer.cpp
Log:
1. move parameters to datasource
2. general cleanup



Modified: trunk/include/datasource.hpp
===================================================================
--- trunk/include/datasource.hpp	2006-05-22 19:38:53 UTC (rev 265)
+++ trunk/include/datasource.hpp	2006-05-23 16:52:10 UTC (rev 266)
@@ -50,28 +50,38 @@
     private:
         const std::string message_;
     public:
-	datasource_exception(const std::string& message=std::string())
-	    :message_(message) {}
+        datasource_exception(const std::string& message=std::string())
+            :message_(message) {}
 
-	~datasource_exception() throw() {}
-	virtual const char* what() const throw()
-	{
-	    return message_.c_str();
-	}
+        ~datasource_exception() throw() {}
+        virtual const char* what() const throw()
+        {
+            return message_.c_str();
+        }
     };
     
-    class MAPNIK_DECL datasource
+    class MAPNIK_DECL datasource : private boost::noncopyable
     {
-    public:
-	enum {
-	    Vector,
-	    Raster
-	};
-	virtual int type() const=0;
-	virtual featureset_ptr features(const query& q) const=0;
-	virtual Envelope<double> const& envelope() const=0;
-	virtual layer_descriptor const& get_descriptor() const=0;
-	virtual ~datasource() {};
+        parameters params_;
+    public:        
+        enum {
+            Vector,
+            Raster
+        };
+        
+        datasource (parameters const& params)
+            : params_(params) {}
+
+        parameters const& params() const
+        {
+            return params_;
+        }
+        
+        virtual int type() const=0;
+        virtual featureset_ptr features(const query& q) const=0;
+        virtual Envelope<double> const& envelope() const=0;
+        virtual layer_descriptor const& get_descriptor() const=0;
+        virtual ~datasource() {};
     };
     
     typedef std::string datasource_name();
@@ -82,28 +92,28 @@
     class datasource_deleter
     {
     public:
-	void operator() (datasource* ds)
-	{
-	    delete ds;
-	}
+        void operator() (datasource* ds)
+        {
+            delete ds;
+        }
     };
 
     typedef boost::shared_ptr<datasource> datasource_p;
     
     ///////////////////////////////////////////
-    #define DATASOURCE_PLUGIN(classname) \
-        extern "C" MAPNIK_DECL std::string datasource_name() \
-        { \
-        return classname::name();\
-        }\
-        extern "C"  MAPNIK_DECL datasource* create(const parameters &params)	\
-        { \
-	    return new classname(params);	\
-        }\
-        extern "C" MAPNIK_DECL void destroy(datasource *ds) \
-        { \
-        delete ds;\
-        }\
+#define DATASOURCE_PLUGIN(classname)                                    \
+    extern "C" MAPNIK_DECL std::string datasource_name()                \
+    {                                                                   \
+        return classname::name();                                       \
+    }                                                                   \
+        extern "C"  MAPNIK_DECL datasource* create(const parameters &params) \
+        {                                                               \
+            return new classname(params);                               \
+        }                                                               \
+        extern "C" MAPNIK_DECL void destroy(datasource *ds)             \
+        {                                                               \
+            delete ds;                                                  \
+        }                                                               \
         ///////////////////////////////////////////
 }
 #endif                                            //DATASOURCE_HPP

Modified: trunk/include/map.hpp
===================================================================
--- trunk/include/map.hpp	2006-05-22 19:38:53 UTC (rev 265)
+++ trunk/include/map.hpp	2006-05-23 16:52:10 UTC (rev 266)
@@ -78,6 +78,7 @@
         const Color& getBackground() const;
         void zoom(double zoom);
         void zoomToBox(const Envelope<double>& box);
+        void zoom_all();
         void pan(int x,int y);
         void pan_and_zoom(int x,int y,double zoom);
         const Envelope<double>& getCurrentExtent() const;

Modified: trunk/include/params.hpp
===================================================================
--- trunk/include/params.hpp	2006-05-22 19:38:53 UTC (rev 265)
+++ trunk/include/params.hpp	2006-05-23 16:52:10 UTC (rev 266)
@@ -44,47 +44,48 @@
 
     class parameters : public param_map
     {
-	friend class boost::serialization::access;
+        friend class boost::serialization::access;
+        
+        template <typename Archive>
+        void save(Archive & ar, const unsigned int /*version*/) const
+        {
+            const size_t size = param_map::size();
+            ar & boost::serialization::make_nvp("count",size);
+            param_map::const_iterator itr;
+            for (itr=param_map::begin();itr!=param_map::end();++itr)
+            {
+                ar & boost::serialization::make_nvp("name",itr->first);
+                ar & boost::serialization::make_nvp("value",itr->second);
+            }
+        }
 	
-	template <typename Archive>
-	void save(Archive & ar, const unsigned int /*version*/) const
-	{
-	    const size_t size = param_map::size();
-	    ar & boost::serialization::make_nvp("count",size);
-	    param_map::const_iterator itr;
-	    for (itr=param_map::begin();itr!=param_map::end();++itr)
-	    {
-		ar & boost::serialization::make_nvp("name",itr->first);
-		ar & boost::serialization::make_nvp("value",itr->second);
-	    }
-	}
-	
-	template <typename Archive>
-	void load(Archive & ar, const unsigned int /*version*/)
-	{	    
-	    size_t size;
-	    ar & boost::serialization::make_nvp("size",size);
-	    for (size_t i=0;i<size;++i)
-	    {
-		std::string name;
-		std::string value;
-		ar & boost::serialization::make_nvp("name",name);
-		ar & boost::serialization::make_nvp("value",value);
-		param_map::insert(make_pair(name,value));
-	    }
-	}
-	BOOST_SERIALIZATION_SPLIT_MEMBER()
-    public:
-	parameters() {}
-	const std::string get(std::string const& key) const
-	{
-	    param_map::const_iterator itr=find(key);
-	    if (itr != end())
-	    {
-		return itr->second;
-	    }
-	    return std::string();
-	}
+        template <typename Archive>
+        void load(Archive & ar, const unsigned int /*version*/)
+        {	    
+            size_t size;
+            ar & boost::serialization::make_nvp("size",size);
+            for (size_t i=0;i<size;++i)
+            {
+                std::string name;
+                std::string value;
+                ar & boost::serialization::make_nvp("name",name);
+                ar & boost::serialization::make_nvp("value",value);
+                param_map::insert(make_pair(name,value));
+            }
+        }
+        BOOST_SERIALIZATION_SPLIT_MEMBER()
+     public:
+
+        parameters() {}
+        const std::string get(std::string const& key) const
+        {
+            param_map::const_iterator itr=find(key);
+            if (itr != end())
+            {
+                return itr->second;
+            }
+            return std::string();
+        }
     };
 }
 

Modified: trunk/include/point_symbolizer.hpp
===================================================================
--- trunk/include/point_symbolizer.hpp	2006-05-22 19:38:53 UTC (rev 265)
+++ trunk/include/point_symbolizer.hpp	2006-05-23 16:52:10 UTC (rev 266)
@@ -37,8 +37,11 @@
                          unsigned width,unsigned height);
         point_symbolizer(point_symbolizer const& rhs);
         ImageData32 const& get_data() const;
+        void set_allow_overlap(bool overlap);
+        bool get_allow_overlap() const;
     private:
         boost::shared_ptr<ImageData32> symbol_;
+        bool overlap_;
     };
 }
 

Modified: trunk/include/polygon_symbolizer.hpp
===================================================================
--- trunk/include/polygon_symbolizer.hpp	2006-05-22 19:38:53 UTC (rev 265)
+++ trunk/include/polygon_symbolizer.hpp	2006-05-23 16:52:10 UTC (rev 266)
@@ -32,10 +32,12 @@
     struct MAPNIK_DECL polygon_symbolizer
     {
         explicit polygon_symbolizer() 
-            : fill_(Color(128,128,128)) {}
+            : fill_(Color(128,128,128)),
+              opacity_(1.0) {}
 
         polygon_symbolizer(Color const& fill)
-            : fill_(fill) {}
+            : fill_(fill),
+              opacity_(1.0) {}
         
         Color const& get_fill() const
         {
@@ -45,8 +47,17 @@
         {
             fill_ = fill;
         }
+        void set_opacity(float opacity)
+        {
+            opacity_ = opacity;
+        }
+        float get_opacity() const
+        {
+            return opacity_;
+        }
     private:
         Color fill_;
+        float opacity_;
     };  
 }
 

Modified: trunk/plugins/input/postgis/postgis.cpp
===================================================================
--- trunk/plugins/input/postgis/postgis.cpp	2006-05-22 19:38:53 UTC (rev 265)
+++ trunk/plugins/input/postgis/postgis.cpp	2006-05-23 16:52:10 UTC (rev 266)
@@ -43,7 +43,8 @@
 using boost::shared_ptr;
 
 postgis_datasource::postgis_datasource(const parameters& params)
-    : table_(params.get("table")),
+    : datasource (params),
+      table_(params.get("table")),
       type_(datasource::Vector), 
       desc_(params.get("name")),
       creator_(params.get("host"),

Modified: trunk/plugins/input/raster/raster_datasource.cpp
===================================================================
--- trunk/plugins/input/raster/raster_datasource.cpp	2006-05-22 19:38:53 UTC (rev 265)
+++ trunk/plugins/input/raster/raster_datasource.cpp	2006-05-23 16:52:10 UTC (rev 266)
@@ -35,22 +35,23 @@
 using boost::bad_lexical_cast;
 
 raster_datasource::raster_datasource(const parameters& params)
-    : desc_(params.get("name"))
+    : datasource (params),
+      desc_(params.get("name"))
 {
     filename_=params.get("file");
     format_=params.get("format");
     
     try 
     {
-	double lox=lexical_cast<double>(params.get("lox"));
-	double loy=lexical_cast<double>(params.get("loy"));
-	double hix=lexical_cast<double>(params.get("hix"));
-	double hiy=lexical_cast<double>(params.get("hiy"));
-	extent_.init(lox,loy,hix,hiy);
+        double lox=lexical_cast<double>(params.get("lox"));
+        double loy=lexical_cast<double>(params.get("loy"));
+        double hix=lexical_cast<double>(params.get("hix"));
+        double hiy=lexical_cast<double>(params.get("hiy"));
+        extent_.init(lox,loy,hix,hiy);
     }
     catch (bad_lexical_cast& ex)
     {
-	clog << ex.what() << endl;
+        clog << ex.what() << endl;
     }  
 }
 

Modified: trunk/plugins/input/shape/shape.cpp
===================================================================
--- trunk/plugins/input/shape/shape.cpp	2006-05-22 19:38:53 UTC (rev 265)
+++ trunk/plugins/input/shape/shape.cpp	2006-05-23 16:52:10 UTC (rev 266)
@@ -30,12 +30,13 @@
 
 DATASOURCE_PLUGIN(shape_datasource)
 
-    shape_datasource::shape_datasource(const parameters &params)
-	: shape_name_(params.get("file")),
-	  type_(datasource::Vector),
-	  file_length_(0),
-	  indexed_(false),
-	  desc_(params.get("name"))
+shape_datasource::shape_datasource(const parameters &params)
+    : datasource (params) ,
+      shape_name_(params.get("file")),
+      type_(datasource::Vector),
+      file_length_(0),
+      indexed_(false),
+      desc_(params.get("name"))
 {
     try
     {

Modified: trunk/plugins/input/shape/shape.hpp
===================================================================
--- trunk/plugins/input/shape/shape.hpp	2006-05-22 19:38:53 UTC (rev 265)
+++ trunk/plugins/input/shape/shape.hpp	2006-05-23 16:52:10 UTC (rev 266)
@@ -31,15 +31,15 @@
 
 class MAPNIK_DECL shape_datasource : public datasource
 {
-
 public:
+    shape_datasource(const parameters &params);
+    virtual ~shape_datasource();
+ 
     int type() const;
     static std::string name();
     featureset_ptr features(const query& q) const;
     const Envelope<double>& envelope() const;
-    shape_datasource(const parameters &params);
-    layer_descriptor const& get_descriptor() const;
-    virtual ~shape_datasource();
+    layer_descriptor const& get_descriptor() const;   
 private:
     shape_datasource(const shape_datasource&);
     shape_datasource& operator=(const shape_datasource&);
@@ -52,7 +52,6 @@
     bool indexed_;
     layer_descriptor desc_;
     static std::string name_;
-    
 };
 
-#endif                                            //SHAPE_HH
+#endif //SHAPE_HH

Modified: trunk/src/agg_renderer.cpp
===================================================================
--- trunk/src/agg_renderer.cpp	2006-05-22 19:38:53 UTC (rev 265)
+++ trunk/src/agg_renderer.cpp	2006-05-23 16:52:10 UTC (rev 266)
@@ -61,397 +61,398 @@
     class pattern_source : private boost::noncopyable
     {
     public:
-	pattern_source(ImageData32 const& pattern)
-	    : pattern_(pattern) {}
+        pattern_source(ImageData32 const& pattern)
+            : pattern_(pattern) {}
 	
-	unsigned int width() const
-	{
-	    return pattern_.width();
-	}
-	unsigned int height() const
-	{
-	    return pattern_.height();
-	}
-	agg::rgba8 pixel(int x, int y) const
-	{
-	    unsigned c = pattern_(x,y);
-	    return agg::rgba8(c & 0xff, (c >> 8) & 0xff, (c >> 16) & 0xff,(c >> 24) & 0xff);
-	}
+        unsigned int width() const
+        {
+            return pattern_.width();
+        }
+        unsigned int height() const
+        {
+            return pattern_.height();
+        }
+        agg::rgba8 pixel(int x, int y) const
+        {
+            unsigned c = pattern_(x,y);
+            return agg::rgba8(c & 0xff, (c >> 8) & 0xff, (c >> 16) & 0xff,(c >> 24) & 0xff);
+        }
     private:
-	ImageData32 const& pattern_;
+        ImageData32 const& pattern_;
     };
 
     template <typename T>
     agg_renderer<T>::agg_renderer(Map const& m, T & pixmap)
-	: feature_style_processor<agg_renderer>(m),
-	  pixmap_(pixmap),
-	  t_(m.getWidth(),m.getHeight(),m.getCurrentExtent()),
-	  detector_(Envelope<double>(-64 ,-64, m.getWidth() + 64 ,m.getHeight() + 64))
+        : feature_style_processor<agg_renderer>(m),
+          pixmap_(pixmap),
+          t_(m.getWidth(),m.getHeight(),m.getCurrentExtent()),
+          detector_(Envelope<double>(-64 ,-64, m.getWidth() + 64 ,m.getHeight() + 64))
     {
-	Color const& bg=m.getBackground();
-	pixmap_.setBackground(bg);
-	std::clog << "scale="<<m.scale()<<std::endl;
+        Color const& bg=m.getBackground();
+        pixmap_.setBackground(bg);
+        std::clog << "scale="<<m.scale()<<std::endl;
     }
     
     template <typename T>
     void agg_renderer<T>::start_map_processing(Map const& map)
     {
-	std::clog << "start map processing bbox=" << map.getCurrentExtent() <<  std::endl;
+        std::clog << "start map processing bbox=" << map.getCurrentExtent() <<  std::endl;
     }
 
     template <typename T>
     void agg_renderer<T>::end_map_processing(Map const& )
     {
-	std::clog << "end map processing" << std::endl;
+        std::clog << "end map processing" << std::endl;
     }
     
     template <typename T>
     void agg_renderer<T>::start_layer_processing(Layer const& lay)
     {
-	std::clog << "start layer processing : " << lay.name()  << std::endl;
-	std::clog << "datasource = " << lay.datasource().get() << std::endl;
+        std::clog << "start layer processing : " << lay.name()  << std::endl;
+        std::clog << "datasource = " << lay.datasource().get() << std::endl;
     }
     
     template <typename T>
     void agg_renderer<T>::end_layer_processing(Layer const&)
     {
-	std::clog << "end layer processing" << std::endl;
+        std::clog << "end layer processing" << std::endl;
     }
     
     template <typename T>	
     void agg_renderer<T>::process(polygon_symbolizer const& sym,Feature const& feature)
     {
-	typedef  coord_transform<CoordTransform,geometry_type> path_type;
-	typedef agg::renderer_base<agg::pixfmt_rgba32> ren_base;    
-	typedef agg::renderer_scanline_aa_solid<ren_base> renderer;
+        typedef  coord_transform<CoordTransform,geometry_type> path_type;
+        typedef agg::renderer_base<agg::pixfmt_rgba32> ren_base;    
+        typedef agg::renderer_scanline_aa_solid<ren_base> renderer;
 	    
-	Color const& fill_  = sym.get_fill();
+        Color const& fill_  = sym.get_fill();
 	    
-	geometry_ptr const& geom=feature.get_geometry();
-	if (geom && geom->num_points() > 2) 
-	{
-	    unsigned width = pixmap_.width();
-	    unsigned height = pixmap_.height();
-	    path_type path(t_,*geom);
-	    agg::row_ptr_cache<agg::int8u> buf(pixmap_.raw_data(),width,height,width * 4);
-	    agg::pixfmt_rgba32 pixf(buf);
-	    ren_base renb(pixf);	    
+        geometry_ptr const& geom=feature.get_geometry();
+        if (geom && geom->num_points() > 2) 
+        {
+            unsigned width = pixmap_.width();
+            unsigned height = pixmap_.height();
+            path_type path(t_,*geom);
+            agg::row_ptr_cache<agg::int8u> buf(pixmap_.raw_data(),width,height,width * 4);
+            agg::pixfmt_rgba32 pixf(buf);
+            ren_base renb(pixf);	    
 		
-	    unsigned r=fill_.red();
-	    unsigned g=fill_.green();
-	    unsigned b=fill_.blue();
-	    unsigned a=fill_.alpha();
-	    renderer ren(renb);
+            unsigned r=fill_.red();
+            unsigned g=fill_.green();
+            unsigned b=fill_.blue();
+            //unsigned a=fill_.alpha();
+            renderer ren(renb);
 		
-	    agg::rasterizer_scanline_aa<> ras;
-	    agg::scanline_u8 sl;
-	    ras.clip_box(0,0,width,height);
-	    ras.add_path(path);
-	    ren.color(agg::rgba8(r, g, b, a));
-	    agg::render_scanlines(ras, sl, ren);
-	}
+            agg::rasterizer_scanline_aa<> ras;
+            agg::scanline_u8 sl;
+            ras.clip_box(0,0,width,height);
+            ras.add_path(path);
+            ren.color(agg::rgba8(r, g, b, int(255 * sym.get_opacity())));
+            agg::render_scanlines(ras, sl, ren);
+        }
     }
 
     template <typename T>
     void agg_renderer<T>::process(line_symbolizer const& sym,Feature const& feature)
     {   
-	typedef agg::renderer_base<agg::pixfmt_rgba32> ren_base; 
-	typedef coord_transform<CoordTransform,geometry_type> path_type;
-	typedef agg::renderer_outline_aa<ren_base> renderer_oaa;
-	typedef agg::rasterizer_outline_aa<renderer_oaa> rasterizer_outline_aa;
-	typedef agg::renderer_scanline_aa_solid<ren_base> renderer;
+        typedef agg::renderer_base<agg::pixfmt_rgba32> ren_base; 
+        typedef coord_transform<CoordTransform,geometry_type> path_type;
+        typedef agg::renderer_outline_aa<ren_base> renderer_oaa;
+        typedef agg::rasterizer_outline_aa<renderer_oaa> rasterizer_outline_aa;
+        typedef agg::renderer_scanline_aa_solid<ren_base> renderer;
 	    
-	geometry_ptr const& geom=feature.get_geometry();
-	if (geom && geom->num_points() > 1)
-	{
-	    path_type path(t_,*geom);
-	    agg::row_ptr_cache<agg::int8u> buf(pixmap_.raw_data(),pixmap_.width(),pixmap_.height(),
-					       pixmap_.width()*4);
-	    agg::pixfmt_rgba32 pixf(buf);
-	    ren_base renb(pixf);	    
+        geometry_ptr const& geom=feature.get_geometry();
+        if (geom && geom->num_points() > 1)
+        {
+            path_type path(t_,*geom);
+            agg::row_ptr_cache<agg::int8u> buf(pixmap_.raw_data(),pixmap_.width(),pixmap_.height(),
+                                               pixmap_.width()*4);
+            agg::pixfmt_rgba32 pixf(buf);
+            ren_base renb(pixf);	    
 		
-	    mapnik::stroke const&  stroke_ = sym.get_stroke();
+            mapnik::stroke const&  stroke_ = sym.get_stroke();
 		
-	    Color const& col = stroke_.get_color();
-	    unsigned r=col.red();
-	    unsigned g=col.green();
-	    unsigned b=col.blue();	    
+            Color const& col = stroke_.get_color();
+            unsigned r=col.red();
+            unsigned g=col.green();
+            unsigned b=col.blue();	    
 		
-	    if (stroke_.has_dash())
-	    {
-		renderer ren(renb);	
-		agg::rasterizer_scanline_aa<> ras;
-		agg::scanline_u8 sl;
-		agg::conv_dash<path_type> dash(path);
-		dash_array const& d = stroke_.get_dash_array();
-		dash_array::const_iterator itr = d.begin();
-		dash_array::const_iterator end = d.end();
-		while (itr != end)
-		{
-		    dash.add_dash(itr->first, itr->second);
-		    ++itr;
-		}
-		agg::conv_stroke<agg::conv_dash<path_type > > stroke(dash);
+            if (stroke_.has_dash())
+            {
+                renderer ren(renb);	
+                agg::rasterizer_scanline_aa<> ras;
+                agg::scanline_u8 sl;
+                agg::conv_dash<path_type> dash(path);
+                dash_array const& d = stroke_.get_dash_array();
+                dash_array::const_iterator itr = d.begin();
+                dash_array::const_iterator end = d.end();
+                while (itr != end)
+                {
+                    dash.add_dash(itr->first, itr->second);
+                    ++itr;
+                }
+                agg::conv_stroke<agg::conv_dash<path_type > > stroke(dash);
 		    
-		line_join_e join=stroke_.get_line_join();
-		if ( join == MITER_JOIN)
-		    stroke.generator().line_join(agg::miter_join);
-		else if( join == MITER_REVERT_JOIN) 
-		    stroke.generator().line_join(agg::miter_join);
-		else if( join == ROUND_JOIN) 
-		    stroke.generator().line_join(agg::round_join);
-		else
-		    stroke.generator().line_join(agg::bevel_join);
+                line_join_e join=stroke_.get_line_join();
+                if ( join == MITER_JOIN)
+                    stroke.generator().line_join(agg::miter_join);
+                else if( join == MITER_REVERT_JOIN) 
+                    stroke.generator().line_join(agg::miter_join);
+                else if( join == ROUND_JOIN) 
+                    stroke.generator().line_join(agg::round_join);
+                else
+                    stroke.generator().line_join(agg::bevel_join);
 		    
-		line_cap_e cap=stroke_.get_line_cap();
-		if (cap == BUTT_CAP)    
-		    stroke.generator().line_cap(agg::butt_cap);
-		else if (cap == SQUARE_CAP)
-		    stroke.generator().line_cap(agg::square_cap);
-		else 
-		    stroke.generator().line_cap(agg::round_cap);
+                line_cap_e cap=stroke_.get_line_cap();
+                if (cap == BUTT_CAP)    
+                    stroke.generator().line_cap(agg::butt_cap);
+                else if (cap == SQUARE_CAP)
+                    stroke.generator().line_cap(agg::square_cap);
+                else 
+                    stroke.generator().line_cap(agg::round_cap);
 		    
-		stroke.generator().miter_limit(4.0);
-		stroke.generator().width(stroke_.get_width());
+                stroke.generator().miter_limit(4.0);
+                stroke.generator().width(stroke_.get_width());
 		    
-		ras.clip_box(0,0,pixmap_.width(),pixmap_.height());
-		ras.add_path(stroke);
-		ren.color(agg::rgba8(r, g, b, int(255*stroke_.get_opacity())));
-		agg::render_scanlines(ras, sl, ren);
-	    }
-	    else if (stroke_.get_width() <= 1.0)
-	    {
-		agg::line_profile_aa prof;
-		prof.width(stroke_.get_width());
-		renderer_oaa ren_oaa(renb, prof);
-		rasterizer_outline_aa ras_oaa(ren_oaa);
+                ras.clip_box(0,0,pixmap_.width(),pixmap_.height());
+                ras.add_path(stroke);
+                ren.color(agg::rgba8(r, g, b, int(255*stroke_.get_opacity())));
+                agg::render_scanlines(ras, sl, ren);
+            }
+            else if (stroke_.get_width() <= 1.0)
+            {
+                agg::line_profile_aa prof;
+                prof.width(stroke_.get_width());
+                renderer_oaa ren_oaa(renb, prof);
+                rasterizer_outline_aa ras_oaa(ren_oaa);
 		    
-		ren_oaa.color(agg::rgba8(r, g, b, int(255*stroke_.get_opacity())));
-		ren_oaa.clip_box(0,0,pixmap_.width(),pixmap_.height());
-		ras_oaa.add_path(path);		
+                ren_oaa.color(agg::rgba8(r, g, b, int(255*stroke_.get_opacity())));
+                ren_oaa.clip_box(0,0,pixmap_.width(),pixmap_.height());
+                ras_oaa.add_path(path);		
 		    
-	    }
-	    else 
-	    {
-		renderer ren(renb);	
-		agg::rasterizer_scanline_aa<> ras;
-		agg::scanline_p8 sl;
-		agg::conv_stroke<path_type>  stroke(path);
+            }
+            else 
+            {
+                renderer ren(renb);	
+                agg::rasterizer_scanline_aa<> ras;
+                agg::scanline_p8 sl;
+                agg::conv_stroke<path_type>  stroke(path);
 		    
-		line_join_e join=stroke_.get_line_join();
-		if ( join == MITER_JOIN)
-		    stroke.generator().line_join(agg::miter_join);
-		else if( join == MITER_REVERT_JOIN) 
-		    stroke.generator().line_join(agg::miter_join);
-		else if( join == ROUND_JOIN) 
-		    stroke.generator().line_join(agg::round_join);
-		else
-		    stroke.generator().line_join(agg::bevel_join);
+                line_join_e join=stroke_.get_line_join();
+                if ( join == MITER_JOIN)
+                    stroke.generator().line_join(agg::miter_join);
+                else if( join == MITER_REVERT_JOIN) 
+                    stroke.generator().line_join(agg::miter_join);
+                else if( join == ROUND_JOIN) 
+                    stroke.generator().line_join(agg::round_join);
+                else
+                    stroke.generator().line_join(agg::bevel_join);
 		    
-		line_cap_e cap=stroke_.get_line_cap();
-		if (cap == BUTT_CAP)    
-		    stroke.generator().line_cap(agg::butt_cap);
-		else if (cap == SQUARE_CAP)
-		    stroke.generator().line_cap(agg::square_cap);
-		else 
-		    stroke.generator().line_cap(agg::round_cap);
+                line_cap_e cap=stroke_.get_line_cap();
+                if (cap == BUTT_CAP)    
+                    stroke.generator().line_cap(agg::butt_cap);
+                else if (cap == SQUARE_CAP)
+                    stroke.generator().line_cap(agg::square_cap);
+                else 
+                    stroke.generator().line_cap(agg::round_cap);
 		
-		stroke.generator().miter_limit(4.0);
-		stroke.generator().width(stroke_.get_width());
+                stroke.generator().miter_limit(4.0);
+                stroke.generator().width(stroke_.get_width());
 		    
-		ras.clip_box(0,0,pixmap_.width(),pixmap_.height());
-		ras.add_path(stroke);
-		ren.color(agg::rgba8(r, g, b, int(255*stroke_.get_opacity())));
-		agg::render_scanlines(ras, sl, ren);
-	    }
-	}
+                ras.clip_box(0,0,pixmap_.width(),pixmap_.height());
+                ras.add_path(stroke);
+                ren.color(agg::rgba8(r, g, b, int(255*stroke_.get_opacity())));
+                agg::render_scanlines(ras, sl, ren);
+            }
+        }
     }
 
     template <typename T>
     void agg_renderer<T>::process(point_symbolizer const& sym,Feature const& feature)
     {
-	geometry_ptr const& geom=feature.get_geometry();
-	if (geom)
-	{
-	    double x;
-	    double y;
-	    ImageData32 const& data = sym.get_data();
-	    geom->label_position(&x,&y);
-	    t_.forward_x(&x);
-	    t_.forward_y(&y);
-	    int w=data.width();
-	    int h=data.height();
-	    
-	    if (detector_.has_placement(Envelope<double>(floor(x - 0.5 * w),
-							 floor(y - 0.5 * h),
-							 ceil (x + 0.5 * w),
-							 ceil (y + 0.5 * h))))
-	    {
-		int px=int(floor(x - 0.5 * w));
-		int py=int(floor(y - 0.5 * h));
-		pixmap_.set_rectangle_alpha(px,py,data);
-	    }
-	}
+        geometry_ptr const& geom=feature.get_geometry();
+        if (geom)
+        {
+            double x;
+            double y;
+            ImageData32 const& data = sym.get_data();
+            geom->label_position(&x,&y);
+            t_.forward_x(&x);
+            t_.forward_y(&y);
+            int w = data.width();
+            int h = data.height();
+            int px=int(floor(x - 0.5 * w));
+            int py=int(floor(y - 0.5 * h));
+            
+            if (sym.get_allow_overlap() || 
+                detector_.has_placement(Envelope<double>(floor(x - 0.5 * w),
+                                                         floor(y - 0.5 * h),
+                                                         ceil (x + 0.5 * w),
+                                                         ceil (y + 0.5 * h))))
+            {    
+                pixmap_.set_rectangle_alpha(px,py,data);
+            }
+        }
     }
     
     template <typename T>
     void  agg_renderer<T>::process(line_pattern_symbolizer const& sym,Feature const& feature)
     {
-	typedef  coord_transform<CoordTransform,geometry_type> path_type;
-	typedef agg::line_image_pattern<agg::pattern_filter_bilinear_rgba8> pattern_type;
-	typedef agg::renderer_base<agg::pixfmt_rgba32> renderer_base;
-	typedef agg::renderer_outline_image<renderer_base, pattern_type> renderer_type;
-	typedef agg::rasterizer_outline_aa<renderer_type> rasterizer_type;
+        typedef  coord_transform<CoordTransform,geometry_type> path_type;
+        typedef agg::line_image_pattern<agg::pattern_filter_bilinear_rgba8> pattern_type;
+        typedef agg::renderer_base<agg::pixfmt_rgba32> renderer_base;
+        typedef agg::renderer_outline_image<renderer_base, pattern_type> renderer_type;
+        typedef agg::rasterizer_outline_aa<renderer_type> rasterizer_type;
 
-	geometry_ptr const& geom=feature.get_geometry();
-	if (geom && geom->num_points() > 1)
-	{
-	    unsigned width = pixmap_.width();
-	    unsigned height = pixmap_.height();
-	    ImageData32 const& pat = sym.get_pattern();
-	    path_type path(t_,*geom);
-	    agg::row_ptr_cache<agg::int8u> buf(pixmap_.raw_data(), width, height,width*4);
-	    agg::pixfmt_rgba32 pixf(buf);
-	    renderer_base ren_base(pixf);  
-	    agg::pattern_filter_bilinear_rgba8 filter; 
-	    pattern_source source(pat);
-	    pattern_type pattern (filter,source);
-	    renderer_type ren(ren_base, pattern);
-	    ren.clip_box(0,0,width,height);
-	    rasterizer_type ras(ren);	    
-	    ras.add_path(path);    
-	}
+        geometry_ptr const& geom=feature.get_geometry();
+        if (geom && geom->num_points() > 1)
+        {
+            unsigned width = pixmap_.width();
+            unsigned height = pixmap_.height();
+            ImageData32 const& pat = sym.get_pattern();
+            path_type path(t_,*geom);
+            agg::row_ptr_cache<agg::int8u> buf(pixmap_.raw_data(), width, height,width*4);
+            agg::pixfmt_rgba32 pixf(buf);
+            renderer_base ren_base(pixf);  
+            agg::pattern_filter_bilinear_rgba8 filter; 
+            pattern_source source(pat);
+            pattern_type pattern (filter,source);
+            renderer_type ren(ren_base, pattern);
+            ren.clip_box(0,0,width,height);
+            rasterizer_type ras(ren);	    
+            ras.add_path(path);    
+        }
     }
     
     template <typename T>
     void agg_renderer<T>::process(polygon_pattern_symbolizer const& sym,Feature const& feature)
     {
-	typedef  coord_transform<CoordTransform,geometry_type> path_type;
-	typedef agg::renderer_base<agg::pixfmt_rgba32> ren_base; 
-	typedef agg::wrap_mode_repeat wrap_x_type;
-	typedef agg::wrap_mode_repeat wrap_y_type;
-	typedef agg::image_accessor_wrap<agg::pixfmt_rgba32, 
-	    wrap_x_type,
-	    wrap_y_type> img_source_type;
+        typedef  coord_transform<CoordTransform,geometry_type> path_type;
+        typedef agg::renderer_base<agg::pixfmt_rgba32> ren_base; 
+        typedef agg::wrap_mode_repeat wrap_x_type;
+        typedef agg::wrap_mode_repeat wrap_y_type;
+        typedef agg::image_accessor_wrap<agg::pixfmt_rgba32, 
+            wrap_x_type,
+            wrap_y_type> img_source_type;
 	
-	typedef agg::span_pattern_rgba<img_source_type> span_gen_type;
+        typedef agg::span_pattern_rgba<img_source_type> span_gen_type;
 	
-	typedef agg::renderer_scanline_aa<ren_base, 
-	    agg::span_allocator<agg::rgba8>,
-	    span_gen_type> renderer_type;  
-	geometry_ptr const& geom=feature.get_geometry();
-	if (geom && geom->num_points() > 2)
-	{
-	    ImageData32 const& pattern = sym.get_pattern();
+        typedef agg::renderer_scanline_aa<ren_base, 
+            agg::span_allocator<agg::rgba8>,
+            span_gen_type> renderer_type;  
+        geometry_ptr const& geom=feature.get_geometry();
+        if (geom && geom->num_points() > 2)
+        {
+            ImageData32 const& pattern = sym.get_pattern();
 	    
-	    unsigned width = pixmap_.width();
-	    unsigned height = pixmap_.height();
-	    path_type path(t_,*geom);
+            unsigned width = pixmap_.width();
+            unsigned height = pixmap_.height();
+            path_type path(t_,*geom);
 	    
-	    agg::row_ptr_cache<agg::int8u> buf(pixmap_.raw_data(),width,height,width * 4);
-	    agg::pixfmt_rgba32 pixf(buf);
-	    ren_base renb(pixf);
+            agg::row_ptr_cache<agg::int8u> buf(pixmap_.raw_data(),width,height,width * 4);
+            agg::pixfmt_rgba32 pixf(buf);
+            ren_base renb(pixf);
 	
-	    unsigned w=pattern.width();
-	    unsigned h=pattern.height();
-	    agg::row_ptr_cache<agg::int8u> pattern_rbuf((agg::int8u*)pattern.getBytes(),w,h,w*4);  
+            unsigned w=pattern.width();
+            unsigned h=pattern.height();
+            agg::row_ptr_cache<agg::int8u> pattern_rbuf((agg::int8u*)pattern.getBytes(),w,h,w*4);  
 	    
-	    double x0,y0;
-	    path.vertex(&x0,&y0);
-	    path.rewind(0);
+            double x0,y0;
+            path.vertex(&x0,&y0);
+            path.rewind(0);
 	
-	    unsigned offset_x = unsigned(width - x0);
-	    unsigned offset_y = unsigned(height - y0);
+            unsigned offset_x = unsigned(width - x0);
+            unsigned offset_y = unsigned(height - y0);
 	
-	    agg::span_allocator<agg::rgba8> sa;
-	    img_source_type img_src(pattern_rbuf);
-	    span_gen_type sg(img_src, offset_x, offset_y);
-	    renderer_type rp(renb,sa, sg);
+            agg::span_allocator<agg::rgba8> sa;
+            img_source_type img_src(pattern_rbuf);
+            span_gen_type sg(img_src, offset_x, offset_y);
+            renderer_type rp(renb,sa, sg);
 	
-	    agg::rasterizer_scanline_aa<> ras;
-	    agg::scanline_u8 sl;
-	    ras.clip_box(0,0,width,height);
-	    ras.add_path(path);
-	    agg::render_scanlines(ras, sl, rp);   
-	}
+            agg::rasterizer_scanline_aa<> ras;
+            agg::scanline_u8 sl;
+            ras.clip_box(0,0,width,height);
+            ras.add_path(path);
+            agg::render_scanlines(ras, sl, rp);   
+        }
     }
 
     template <typename T>
     void agg_renderer<T>::process(raster_symbolizer const& ,Feature const& feature)
     {
-	// TODO -- at the moment raster_symbolizer is an empty class 
-	// used for type dispatching, but we can have some fancy raster
-	// processing in a future (filters??). Just copy raster into pixmap for now.
-	raster_ptr const& raster=feature.get_raster();
-	if (raster)
-	{
-	    pixmap_.set_rectangle(raster->x_,raster->y_,raster->data_);
-	}
+        // TODO -- at the moment raster_symbolizer is an empty class 
+        // used for type dispatching, but we can have some fancy raster
+        // processing in a future (filters??). Just copy raster into pixmap for now.
+        raster_ptr const& raster=feature.get_raster();
+        if (raster)
+        {
+            pixmap_.set_rectangle(raster->x_,raster->y_,raster->data_);
+        }
     }
     
     template <typename T>
     void agg_renderer<T>::process(text_symbolizer const& sym ,Feature const& feature)
     {
-	typedef  coord_transform<CoordTransform,geometry_type> path_type;
-	geometry_ptr const& geom=feature.get_geometry();
-	if (geom)
-	{
-	    double angle = 0.0;	    
-	    if (sym.get_label_placement() == line_placement && 
-		geom->num_points() > 1)
-	    {
+        typedef  coord_transform<CoordTransform,geometry_type> path_type;
+        geometry_ptr const& geom=feature.get_geometry();
+        if (geom)
+        {
+            double angle = 0.0;	    
+            if (sym.get_label_placement() == line_placement && 
+                geom->num_points() > 1)
+            {
 	       
-		path_type path(t_,*geom);
-		double x0,y0,x1,y1;
-		path.vertex(&x0,&y0);
-		path.vertex(&x1,&y1);
-		double dx = x1 - x0;
-		double dy = ( y1 - y0 > 1e-7 ) ?  y1 - y0 : 1.0;
+                path_type path(t_,*geom);
+                double x0,y0,x1,y1;
+                path.vertex(&x0,&y0);
+                path.vertex(&x1,&y1);
+                double dx = x1 - x0;
+                double dy = ( y1 - y0 > 1e-7 ) ?  y1 - y0 : 1.0;
 	        
-		angle = atan( dx/ dy ) - 0.5 * 3.1459;
+                angle = atan( dx/ dy ) - 0.5 * 3.1459;
 		
-		//TODO!!!!!!!!!!!!!!!!!!!!
-	    }   
+                //TODO!!!!!!!!!!!!!!!!!!!!
+            }   
 	    
-	    std::string text = feature[sym.get_name()].to_string();
-	    if (text.length() > 0)
-	    {
-		Color const& fill  = sym.get_fill();
+            std::string text = feature[sym.get_name()].to_string();
+            if (text.length() > 0)
+            {
+                Color const& fill  = sym.get_fill();
 	
-		double x;
-		double y;
-		geom->label_position(&x,&y);
-		t_.forward_x(&x);
-		t_.forward_y(&y);
+                double x;
+                double y;
+                geom->label_position(&x,&y);
+                t_.forward_x(&x);
+                t_.forward_y(&y);
 
-		face_ptr face = font_manager_.get_face("Bitstream Vera Sans Roman");//TODO
-		//face_ptr face = font_manager_.get_face("Times New Roman Regular");//TODO
-		if (face)
-		{
-		    text_renderer<mapnik::Image32> ren(pixmap_,face);
-		    ren.set_pixel_size(sym.get_text_size());
-		    ren.set_fill(fill);
-		    ren.set_halo_fill(sym.get_halo_fill());
-		    ren.set_halo_radius(sym.get_halo_radius());
-		    ren.set_angle(float(angle));
+                face_ptr face = font_manager_.get_face("Bitstream Vera Sans Roman");//TODO
+                //face_ptr face = font_manager_.get_face("Times New Roman Regular");//TODO
+                if (face)
+                {
+                    text_renderer<mapnik::Image32> ren(pixmap_,face);
+                    ren.set_pixel_size(sym.get_text_size());
+                    ren.set_fill(fill);
+                    ren.set_halo_fill(sym.get_halo_fill());
+                    ren.set_halo_radius(sym.get_halo_radius());
+                    ren.set_angle(float(angle));
 
-		    std::pair<unsigned,unsigned> dim = ren.prepare_glyphs(text);
-		    Envelope<double> text_box(x - 0.5*dim.first,y - 0.5 * dim.second ,
-					      x + 0.5*dim.first,y + 0.5 * dim.second);
+                    std::pair<unsigned,unsigned> dim = ren.prepare_glyphs(text);
+                    Envelope<double> text_box(x - 0.5*dim.first,y - 0.5 * dim.second ,
+                                              x + 0.5*dim.first,y + 0.5 * dim.second);
 		    
-		    if (sym.get_halo_radius() > 0)
-		    {
-			text_box.width(text_box.width() + sym.get_halo_radius()*2);
-			text_box.height(text_box.height() + sym.get_halo_radius()*2);
-		    }
+                    if (sym.get_halo_radius() > 0)
+                    {
+                        text_box.width(text_box.width() + sym.get_halo_radius()*2);
+                        text_box.height(text_box.height() + sym.get_halo_radius()*2);
+                    }
 
-		    if (detector_.has_placement(text_box))
-		    {
-			ren.render(x - 0.5 * dim.first,y + 0.5 * dim.second);
-		    }
-		}
-	    }  
-	}
+                    if (detector_.has_placement(text_box))
+                    {
+                        ren.render(x - 0.5 * dim.first,y + 0.5 * dim.second);
+                    }
+                }
+            }  
+        }
     }
     
     template class agg_renderer<Image32>;

Modified: trunk/src/layer.cpp
===================================================================
--- trunk/src/layer.cpp	2006-05-22 19:38:53 UTC (rev 265)
+++ trunk/src/layer.cpp	2006-05-23 16:52:10 UTC (rev 266)
@@ -37,8 +37,6 @@
     Layer::Layer()
         : params_(),
           name_("unknown"),
-          title_(""),
-          abstract_(""),
           minZoom_(0),
           maxZoom_(std::numeric_limits<double>::max()),
           active_(true),
@@ -49,8 +47,6 @@
     Layer::Layer(const parameters& params)
         :params_(params),
          name_(params_["name"]),
-         title_(params_["title"]),
-         abstract_(params_["abstract"]),
          minZoom_(0),
          maxZoom_(std::numeric_limits<double>::max()),
          active_(true),
@@ -59,17 +55,15 @@
     {}
     
     Layer::Layer(const Layer& rhs)
-        :params_(rhs.params_),
-         name_(rhs.name_),
-         title_(rhs.title_),
-         abstract_(rhs.abstract_),
-         minZoom_(rhs.minZoom_),
-         maxZoom_(rhs.maxZoom_),
-         active_(rhs.active_),
-         selectable_(rhs.selectable_),
-         ds_(rhs.ds_),
-         styles_(rhs.styles_),
-         selection_style_(rhs.selection_style_) {}
+        : params_(rhs.params_),
+          name_(rhs.name_),
+          minZoom_(rhs.minZoom_),
+          maxZoom_(rhs.maxZoom_),
+          active_(rhs.active_),
+          selectable_(rhs.selectable_),
+          styles_(rhs.styles_),
+          selection_style_(rhs.selection_style_), 
+          ds_(rhs.ds_)  {}
     
     Layer& Layer::operator=(const Layer& rhs)
     {
@@ -87,13 +81,11 @@
     {
         params_=rhs.params_;
         name_=rhs.name_;
-        title_=rhs.title_;
-        abstract_=rhs.abstract_;
         minZoom_=rhs.minZoom_;
         maxZoom_=rhs.maxZoom_;
         active_=rhs.active_;
         selectable_=rhs.selectable_;
-        //ds_=rhs.ds_;
+        ds_=rhs.ds_;
         styles_=rhs.styles_;
         selection_style_=rhs.selection_style_;
     }
@@ -115,26 +107,6 @@
         return name_;
     }
 
-    void Layer::set_title( std::string const& title)
-    {
-        title_ = title;
-    }
- 
-    string const& Layer::title() const
-    {
-        return title_;
-    }
-
-    void Layer::set_abstract( std::string const& abstract)
-    {
-        abstract_ = abstract;
-    }
- 
-    string const& Layer::abstract() const
-    {
-        return abstract_;
-    }
-
     void Layer::add_style(std::string const& stylename)
     {
         styles_.push_back(stylename);

Modified: trunk/src/map.cpp
===================================================================
--- trunk/src/map.cpp	2006-05-22 19:38:53 UTC (rev 265)
+++ trunk/src/map.cpp	2006-05-23 16:52:10 UTC (rev 266)
@@ -30,23 +30,23 @@
 namespace mapnik
 {
     Map::Map()
-	: width_(400),
-	  height_(400),
-	  srid_(-1) {}
+        : width_(400),
+          height_(400),
+          srid_(-1) {}
     Map::Map(int width,int height,int srid)
         : width_(width),
-	  height_(height),
-	  srid_(srid),
-	  background_(Color(255,255,255)) {}
+          height_(height),
+          srid_(srid),
+          background_(Color(255,255,255)) {}
 
     Map::Map(const Map& rhs)
         : width_(rhs.width_),
-	  height_(rhs.height_),
-	  srid_(rhs.srid_),
-	  background_(rhs.background_),
-	  styles_(rhs.styles_),
-	  layers_(rhs.layers_),
-	  currentExtent_(rhs.currentExtent_) {}
+          height_(rhs.height_),
+          srid_(rhs.srid_),
+          background_(rhs.background_),
+          styles_(rhs.styles_),
+          layers_(rhs.layers_),
+          currentExtent_(rhs.currentExtent_) {}
     
     Map& Map::operator=(const Map& rhs)
     {
@@ -55,28 +55,28 @@
         height_=rhs.height_;
         srid_=rhs.srid_;
         background_=rhs.background_;
-	styles_=rhs.styles_;
+        styles_=rhs.styles_;
         layers_=rhs.layers_;
         return *this;
     }
 
     bool Map::insert_style(std::string const& name,feature_type_style const& style) 
     {
-	return styles_.insert(make_pair(name,style)).second;
+        return styles_.insert(make_pair(name,style)).second;
     }
     
     void Map::remove_style(std::string const& name) 
     {
-	styles_.erase(name);
+        styles_.erase(name);
     }
     
     feature_type_style const&  Map::find_style(std::string const& name) const
     {
-	std::map<std::string,feature_type_style>::const_iterator itr=styles_.find(name);
-	if (itr!=styles_.end()) 
-	    return itr->second;
-	static feature_type_style default_style;
-	return default_style;
+        std::map<std::string,feature_type_style>::const_iterator itr=styles_.find(name);
+        if (itr!=styles_.end()) 
+            return itr->second;
+        static feature_type_style default_style;
+        return default_style;
     }
     
     size_t Map::layerCount() const
@@ -106,7 +106,7 @@
 
     std::vector<Layer> const& Map::layers() const
     {
-	return layers_;
+        return layers_;
     }
     
     unsigned Map::getWidth() const
@@ -121,30 +121,30 @@
     
     void Map::setWidth(unsigned width)
     {
-	if (width >= MIN_MAPSIZE && width <= MAX_MAPSIZE)
-	{
-	    width_=width;
-	    fixAspectRatio();
-	}	
+        if (width >= MIN_MAPSIZE && width <= MAX_MAPSIZE)
+        {
+            width_=width;
+            fixAspectRatio();
+        }	
     }
 
     void Map::setHeight(unsigned height)
     {
-	if (height >= MIN_MAPSIZE && height <= MAX_MAPSIZE)
-	{
-	    height_=height;
-	    fixAspectRatio();
-	}
+        if (height >= MIN_MAPSIZE && height <= MAX_MAPSIZE)
+        {
+            height_=height;
+            fixAspectRatio();
+        }
     }
     void Map::resize(unsigned width,unsigned height)
     {
-	if (width >= MIN_MAPSIZE && width <= MAX_MAPSIZE &&
-	    height >= MIN_MAPSIZE && height <= MAX_MAPSIZE)
-	{
-	    width_=width;
-	    height_=height;
-	    fixAspectRatio();
-	}
+        if (width >= MIN_MAPSIZE && width <= MAX_MAPSIZE &&
+            height >= MIN_MAPSIZE && height <= MAX_MAPSIZE)
+        {
+            width_=width;
+            height_=height;
+            fixAspectRatio();
+        }
     }
 
     int Map::srid() const
@@ -168,9 +168,30 @@
         double w = factor * currentExtent_.width();
         double h = factor * currentExtent_.height();
         currentExtent_ = Envelope<double>(center.x - 0.5 * w, center.y - 0.5 * h,
-            center.x + 0.5 * w, center.y + 0.5 * h);
-	fixAspectRatio();
+                                          center.x + 0.5 * w, center.y + 0.5 * h);
+        fixAspectRatio();
     }
+    
+    void Map::zoom_all() 
+    {
+        std::vector<Layer>::const_iterator itr = layers_.begin();
+        Envelope<double> ext;
+        bool first = true;
+        while (itr != layers_.end())
+        {
+            if (first)
+            {
+                ext = itr->envelope();
+                first = false;
+            }
+            else 
+            {
+                ext.expand_to_include(itr->envelope());
+            }
+            ++itr;
+        }
+        zoomToBox(ext);
+    }
 
     void Map::zoomToBox(const Envelope<double> &box)
     {
@@ -183,14 +204,14 @@
         double ratio1 = (double) width_ / (double) height_;
         double ratio2 = currentExtent_.width() / currentExtent_.height();
          
-	if (ratio2 > ratio1)
-	{
-	    currentExtent_.height(currentExtent_.width() / ratio1);
-	}
-	else if (ratio2 < ratio1)
-	{
-	    currentExtent_.width(currentExtent_.height() * ratio1);
-	}       
+        if (ratio2 > ratio1)
+        {
+            currentExtent_.height(currentExtent_.width() / ratio1);
+        }
+        else if (ratio2 < ratio1)
+        {
+            currentExtent_.width(currentExtent_.height() * ratio1);
+        }       
     }
 
     const Envelope<double>& Map::getCurrentExtent() const
@@ -201,13 +222,13 @@
     void Map::pan(int x,int y)
     {
         int dx = x - int(0.5 * width_);
-	int dy = int(0.5 * height_) - y;
-	double s = width_/currentExtent_.width();
-	double minx  = currentExtent_.minx() + dx/s;
-	double maxx  = currentExtent_.maxx() + dx/s;
-	double miny  = currentExtent_.miny() + dy/s;
-	double maxy  = currentExtent_.maxy() + dy/s;
-	currentExtent_.init(minx,miny,maxx,maxy);
+        int dy = int(0.5 * height_) - y;
+        double s = width_/currentExtent_.width();
+        double minx  = currentExtent_.minx() + dx/s;
+        double maxx  = currentExtent_.maxx() + dx/s;
+        double miny  = currentExtent_.miny() + dy/s;
+        double maxy  = currentExtent_.maxy() + dy/s;
+        currentExtent_.init(minx,miny,maxx,maxy);
     }
 
     void Map::pan_and_zoom(int x,int y,double factor)

Modified: trunk/src/point_symbolizer.cpp
===================================================================
--- trunk/src/point_symbolizer.cpp	2006-05-22 19:38:53 UTC (rev 265)
+++ trunk/src/point_symbolizer.cpp	2006-05-23 16:52:10 UTC (rev 266)
@@ -30,7 +30,8 @@
 namespace mapnik
 {
     point_symbolizer::point_symbolizer()
-        : symbol_(new ImageData32(4,4))
+        : symbol_(new ImageData32(4,4)),
+          overlap_(false)
     {
         //default point symbol is black 4x4px square
         symbol_->set(0xff000000);
@@ -56,12 +57,23 @@
     }
     
     point_symbolizer::point_symbolizer(point_symbolizer const& rhs)
-        : symbol_(rhs.symbol_) 
+        : symbol_(rhs.symbol_),
+          overlap_(rhs.overlap_)
     {}
     
     ImageData32 const& point_symbolizer::get_data() const
     {
         return *(symbol_.get());
     }
+    
+    void point_symbolizer::set_allow_overlap(bool overlap)
+    {
+        overlap_ = overlap;
+    }
+    
+    bool point_symbolizer::get_allow_overlap() const
+    {
+        return overlap_;
+    }
 }
 



From pavlenko at berlios.de  Tue May 23 18:53:39 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Tue, 23 May 2006 18:53:39 +0200
Subject: [Mapnik-svn] r267 - trunk/include
Message-ID: <200605231653.k4NGrdB9001371@sheep.berlios.de>

Author: pavlenko
Date: 2006-05-23 18:53:38 +0200 (Tue, 23 May 2006)
New Revision: 267

Modified:
   trunk/include/feature_style_processor.hpp
Log:
replace tabs with spaces

Modified: trunk/include/feature_style_processor.hpp
===================================================================
--- trunk/include/feature_style_processor.hpp	2006-05-23 16:52:10 UTC (rev 266)
+++ trunk/include/feature_style_processor.hpp	2006-05-23 16:53:38 UTC (rev 267)
@@ -41,148 +41,148 @@
     template <typename Processor>
     class feature_style_processor 
     {
-	struct symbol_dispatch : public boost::static_visitor<>
-	{
-	    symbol_dispatch (Processor & output,Feature const& f)
-		: output_(output),f_(f) {}
+        struct symbol_dispatch : public boost::static_visitor<>
+        {
+            symbol_dispatch (Processor & output,Feature const& f)
+                : output_(output),f_(f) {}
 	    
-	    template <typename T>
-	    void operator () (T const& sym) const
-	    {
-		output_.process(sym,f_);
-	    }
+            template <typename T>
+            void operator () (T const& sym) const
+            {
+                output_.process(sym,f_);
+            }
 
-	    Processor & output_;
-	    Feature const& f_;
-	};
+            Processor & output_;
+            Feature const& f_;
+        };
     public:
-	feature_style_processor(Map const& m)
-	    : m_(m) {}
+        feature_style_processor(Map const& m)
+            : m_(m) {}
 	
-	void apply()
-	{
-	    timer clock;
-	    Processor & p = static_cast<Processor&>(*this);
+        void apply()
+        {
+            timer clock;
+            Processor & p = static_cast<Processor&>(*this);
 
-	    p.start_map_processing(m_);
+            p.start_map_processing(m_);
 	    
-	    std::vector<Layer>::const_iterator itr = m_.layers().begin();
-	    while (itr != m_.layers().end())
-	    {
-		if (itr->isVisible(m_.scale()) && 
-		    itr->envelope().intersects(m_.getCurrentExtent()))
-		{
-		    apply_to_layer(*itr,p);
-		}
-		++itr;
-	    }
+            std::vector<Layer>::const_iterator itr = m_.layers().begin();
+            while (itr != m_.layers().end())
+            {
+                if (itr->isVisible(m_.scale()) && 
+                    itr->envelope().intersects(m_.getCurrentExtent()))
+                {
+                    apply_to_layer(*itr,p);
+                }
+                ++itr;
+            }
 	    
-	    p.end_map_processing(m_);
+            p.end_map_processing(m_);
 	    
-	    clock.stop();
+            clock.stop();
 	    
-	}	
+        }	
     private:
-	void apply_to_layer(Layer const& lay,Processor & p)
-	{
-	    p.start_layer_processing(lay);
-	    datasource *ds=lay.datasource().get();
-	    if (ds)
-	    {
-		Envelope<double> const& bbox=m_.getCurrentExtent();
-		double scale = m_.scale();
+        void apply_to_layer(Layer const& lay,Processor & p)
+        {
+            p.start_layer_processing(lay);
+            datasource *ds=lay.datasource().get();
+            if (ds)
+            {
+                Envelope<double> const& bbox=m_.getCurrentExtent();
+                double scale = m_.scale();
 	
-		std::vector<std::string> const& style_names = lay.styles();
-		std::vector<std::string>::const_iterator stylesIter = style_names.begin();
-		while (stylesIter != style_names.end())
-		{
-		    std::set<std::string> names;
-		    attribute_collector<Feature> collector(names);
-		    std::vector<rule_type*> if_rules;
-		    std::vector<rule_type*> else_rules;
+                std::vector<std::string> const& style_names = lay.styles();
+                std::vector<std::string>::const_iterator stylesIter = style_names.begin();
+                while (stylesIter != style_names.end())
+                {
+                    std::set<std::string> names;
+                    attribute_collector<Feature> collector(names);
+                    std::vector<rule_type*> if_rules;
+                    std::vector<rule_type*> else_rules;
 		
-		    bool active_rules=false;
+                    bool active_rules=false;
 		    
-		    feature_type_style const& style=m_.find_style(*stylesIter++);
+                    feature_type_style const& style=m_.find_style(*stylesIter++);
 		    
-		    const std::vector<rule_type>& rules=style.get_rules();
-		    std::vector<rule_type>::const_iterator ruleIter=rules.begin();
+                    const std::vector<rule_type>& rules=style.get_rules();
+                    std::vector<rule_type>::const_iterator ruleIter=rules.begin();
 		    
-		    query q(bbox,m_.getWidth(),m_.getHeight());
-		    while (ruleIter!=rules.end())
-		    {
-			if (ruleIter->active(scale))
-			{
-			    active_rules=true;
-			    ruleIter->accept(collector);
+                    query q(bbox,m_.getWidth(),m_.getHeight());
+                    while (ruleIter!=rules.end())
+                    {
+                        if (ruleIter->active(scale))
+                        {
+                            active_rules=true;
+                            ruleIter->accept(collector);
 
-			    if (ruleIter->has_else_filter())
-			    {
-				else_rules.push_back(const_cast<rule_type*>(&(*ruleIter)));
-			    }
-			    else
-			    {
-				if_rules.push_back(const_cast<rule_type*>(&(*ruleIter))); 		    
-			    }
-			}
-			++ruleIter;
-		    }
-		    std::set<std::string>::const_iterator namesIter=names.begin();
-		    // push all property names
-		    while (namesIter!=names.end())
-		    {
-			q.add_property_name(*namesIter);
-			++namesIter;
-		    }
-		    if (active_rules)
-		    {
-			featureset_ptr fs=ds->features(q);
-			if (fs)
-			{   	    
-			    feature_ptr feature;
-			    while ((feature = fs->next()))
-			    {		   
-				bool do_else=true;		    
-				std::vector<rule_type*>::const_iterator itr=if_rules.begin();
-				while (itr!=if_rules.end())
-				{
-				    filter_ptr const& filter=(*itr)->get_filter();    
-				    if (filter->pass(*feature))
-				    {   
-					do_else=false;
-					const symbolizers& symbols = (*itr)->get_symbolizers();
-					symbolizers::const_iterator symIter=symbols.begin();
-					while (symIter!=symbols.end())
-					{   
-					    boost::apply_visitor(symbol_dispatch(p,*feature),*symIter++);
-					}
-				    }			    
-				    ++itr;
-				}
-				if (do_else)
-				{
-				    //else filter
-				    std::vector<rule_type*>::const_iterator itr=else_rules.begin();
-				    while (itr != else_rules.end())
-				    {
-					const symbolizers& symbols = (*itr)->get_symbolizers();
-					symbolizers::const_iterator symIter=symbols.begin();
-					while (symIter!=symbols.end())
-					{
-					    boost::apply_visitor(symbol_dispatch(p,*feature),*symIter++);
-					}
-					++itr;
-				    }
-				}	  
-			    }
-			}
-		    }
-		}
-	    }
-	    p.end_layer_processing(lay);
-	}
+                            if (ruleIter->has_else_filter())
+                            {
+                                else_rules.push_back(const_cast<rule_type*>(&(*ruleIter)));
+                            }
+                            else
+                            {
+                                if_rules.push_back(const_cast<rule_type*>(&(*ruleIter))); 		    
+                            }
+                        }
+                        ++ruleIter;
+                    }
+                    std::set<std::string>::const_iterator namesIter=names.begin();
+                    // push all property names
+                    while (namesIter!=names.end())
+                    {
+                        q.add_property_name(*namesIter);
+                        ++namesIter;
+                    }
+                    if (active_rules)
+                    {
+                        featureset_ptr fs=ds->features(q);
+                        if (fs)
+                        {   	    
+                            feature_ptr feature;
+                            while ((feature = fs->next()))
+                            {		   
+                                bool do_else=true;		    
+                                std::vector<rule_type*>::const_iterator itr=if_rules.begin();
+                                while (itr!=if_rules.end())
+                                {
+                                    filter_ptr const& filter=(*itr)->get_filter();    
+                                    if (filter->pass(*feature))
+                                    {   
+                                        do_else=false;
+                                        const symbolizers& symbols = (*itr)->get_symbolizers();
+                                        symbolizers::const_iterator symIter=symbols.begin();
+                                        while (symIter!=symbols.end())
+                                        {   
+                                            boost::apply_visitor(symbol_dispatch(p,*feature),*symIter++);
+                                        }
+                                    }			    
+                                    ++itr;
+                                }
+                                if (do_else)
+                                {
+                                    //else filter
+                                    std::vector<rule_type*>::const_iterator itr=else_rules.begin();
+                                    while (itr != else_rules.end())
+                                    {
+                                        const symbolizers& symbols = (*itr)->get_symbolizers();
+                                        symbolizers::const_iterator symIter=symbols.begin();
+                                        while (symIter!=symbols.end())
+                                        {
+                                            boost::apply_visitor(symbol_dispatch(p,*feature),*symIter++);
+                                        }
+                                        ++itr;
+                                    }
+                                }	  
+                            }
+                        }
+                    }
+                }
+            }
+            p.end_layer_processing(lay);
+        }
 	
-	Map const& m_;
+        Map const& m_;
     };
 }
 



From pavlenko at berlios.de  Tue May 23 19:23:22 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Tue, 23 May 2006 19:23:22 +0200
Subject: [Mapnik-svn] r268 - in trunk: include src
Message-ID: <200605231723.k4NHNMwb010981@sheep.berlios.de>

Author: pavlenko
Date: 2006-05-23 19:23:20 +0200 (Tue, 23 May 2006)
New Revision: 268

Modified:
   trunk/include/feature_type_style.hpp
   trunk/include/map.hpp
   trunk/src/map.cpp
Log:
added const Style iterators to Map



Modified: trunk/include/feature_type_style.hpp
===================================================================
--- trunk/include/feature_type_style.hpp	2006-05-23 16:53:38 UTC (rev 267)
+++ trunk/include/feature_type_style.hpp	2006-05-23 17:23:20 UTC (rev 268)
@@ -36,31 +36,31 @@
     class feature_type_style
     {
     private:
-	rules  rules_;
+        rules  rules_;
     public:
-	feature_type_style() {}
+        feature_type_style() {}
 
-	feature_type_style(feature_type_style const& rhs)
-	    : rules_(rhs.rules_) {}
+        feature_type_style(feature_type_style const& rhs)
+            : rules_(rhs.rules_) {}
 	
-	feature_type_style& operator=(feature_type_style const& rhs)
-	{
-	    if (this == &rhs) return *this;
-	    rules_=rhs.rules_;
-	    return *this;
-	}
+        feature_type_style& operator=(feature_type_style const& rhs)
+        {
+            if (this == &rhs) return *this;
+            rules_=rhs.rules_;
+            return *this;
+        }
 	
-	void add_rule(rule_type const& rule)
-	{
-	    rules_.push_back(rule);
-	} 
+        void add_rule(rule_type const& rule)
+        {
+            rules_.push_back(rule);
+        } 
 	
-	rules const& get_rules() const
-	{
-	    return rules_;
-	}
+        rules const& get_rules() const
+        {
+            return rules_;
+        }
 	
-	~feature_type_style() {}
+        ~feature_type_style() {}
     };
 }
 

Modified: trunk/include/map.hpp
===================================================================
--- trunk/include/map.hpp	2006-05-23 16:53:38 UTC (rev 267)
+++ trunk/include/map.hpp	2006-05-23 17:23:20 UTC (rev 268)
@@ -55,10 +55,15 @@
         Envelope<double> currentExtent_;
         
     public:
+        
+        typedef  std::map<std::string,feature_type_style>::const_iterator style_iterator;
+        
         Map();
         Map(int width,int height,int srid=-1);
         Map(const Map& rhs);
-        Map& operator=(const Map& rhs);        
+        Map& operator=(const Map& rhs);
+        style_iterator begin_styles() const;
+        style_iterator end_styles() const;
         bool insert_style(std::string const& name,feature_type_style const& style);
         void remove_style(const std::string& name);
         feature_type_style const& find_style(std::string const& name) const;

Modified: trunk/src/map.cpp
===================================================================
--- trunk/src/map.cpp	2006-05-23 16:53:38 UTC (rev 267)
+++ trunk/src/map.cpp	2006-05-23 17:23:20 UTC (rev 268)
@@ -59,7 +59,15 @@
         layers_=rhs.layers_;
         return *this;
     }
-
+    Map::style_iterator  Map::begin_styles() const
+    {
+        return styles_.begin();
+    }
+    Map::style_iterator  Map::end_styles() const
+    {
+        return styles_.end();
+    }
+    
     bool Map::insert_style(std::string const& name,feature_type_style const& style) 
     {
         return styles_.insert(make_pair(name,style)).second;



From pavlenko at berlios.de  Wed May 24 17:13:52 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Wed, 24 May 2006 17:13:52 +0200
Subject: [Mapnik-svn] r269 - trunk/include
Message-ID: <200605241513.k4OFDqtY030238@sheep.berlios.de>

Author: pavlenko
Date: 2006-05-24 17:13:51 +0200 (Wed, 24 May 2006)
New Revision: 269

Modified:
   trunk/include/color.hpp
Log:
implemented to_hex_color() method that returns 
#RRGGBB color representation. 



Modified: trunk/include/color.hpp
===================================================================
--- trunk/include/color.hpp	2006-05-23 17:23:20 UTC (rev 268)
+++ trunk/include/color.hpp	2006-05-24 15:13:51 UTC (rev 269)
@@ -25,6 +25,7 @@
 #ifndef COLOR_HPP
 #define COLOR_HPP
 
+#include <boost/format.hpp>
 #include "config.hpp"
 #include <sstream>
 
@@ -33,78 +34,84 @@
     class MAPNIK_DECL Color
     {
     private:
-	unsigned int rgba_;
+        unsigned int rgba_;
     public:
-	Color()
-	    :rgba_(0xffffffff) {}
+        Color()
+            :rgba_(0xffffffff) {}
 
-	Color(int red,int green,int blue,int alpha=0xff)
-	    : rgba_((alpha&0xff) << 24 | (blue&0xff) << 16 | (green&0xff) << 8 | red&0xff) {}
+        Color(int red,int green,int blue,int alpha=0xff)
+            : rgba_((alpha&0xff) << 24 | (blue&0xff) << 16 | (green&0xff) << 8 | red&0xff) {}
 	
-	explicit Color(int rgba)
-	    : rgba_(rgba) {}
+        explicit Color(int rgba)
+            : rgba_(rgba) {}
 
-	Color(const Color& rhs)
-	    : rgba_(rhs.rgba_) {}
+        Color(const Color& rhs)
+            : rgba_(rhs.rgba_) {}
 
-	Color& operator=(const Color& rhs)
-	{
-	    if (this==&rhs) return *this;
-	    rgba_=rhs.rgba_;
-	    return *this;
-	}
-	inline unsigned int blue() const
-	{
-	    return (rgba_>>16)&0xff;
-	}
-	inline unsigned int green() const
-	{
-	    return (rgba_>>8)&0xff;
-	}
-	inline unsigned int red() const
-	{
-	    return rgba_&0xff;
-	}
+        Color& operator=(const Color& rhs)
+        {
+            if (this==&rhs) return *this;
+            rgba_=rhs.rgba_;
+            return *this;
+        }
+        inline unsigned int blue() const
+        {
+            return (rgba_>>16)&0xff;
+        }
+        inline unsigned int green() const
+        {
+            return (rgba_>>8)&0xff;
+        }
+        inline unsigned int red() const
+        {
+            return rgba_&0xff;
+        }
 	
-	inline void set_red(unsigned int r)
-	{
-	    rgba_ = (rgba_ & 0xffffff00) | (r&0xff);
-	}
+        inline void set_red(unsigned int r)
+        {
+            rgba_ = (rgba_ & 0xffffff00) | (r&0xff);
+        }
 	
-	inline void set_green(unsigned int g)
-	{
-	    rgba_ = (rgba_ & 0xffff00ff) | ((g&0xff) << 8);
-	}
+        inline void set_green(unsigned int g)
+        {
+            rgba_ = (rgba_ & 0xffff00ff) | ((g&0xff) << 8);
+        }
 	
-	inline void set_blue(unsigned int b)
-	{
-	    rgba_ = (rgba_ & 0xff00ffff) | ((b&0xff) << 16);
-	}
+        inline void set_blue(unsigned int b)
+        {
+            rgba_ = (rgba_ & 0xff00ffff) | ((b&0xff) << 16);
+        }
 
-	inline unsigned int alpha() const
-	{
-	    return (rgba_>>24)&0xff;
-	}
+        inline unsigned int alpha() const
+        {
+            return (rgba_>>24)&0xff;
+        }
 	
-	inline unsigned int rgba() const
-	{
-	    return rgba_;
-	}
-	inline void set_bgr(unsigned bgr)
-	{
-	    rgba_ = (rgba_ & 0xff000000) | (bgr & 0xffffff);
-	}
-	inline bool operator==(Color const& other) const
-	{
-	    return rgba_ == other.rgba_;
-	}
+        inline unsigned int rgba() const
+        {
+            return rgba_;
+        }
+        inline void set_bgr(unsigned bgr)
+        {
+            rgba_ = (rgba_ & 0xff000000) | (bgr & 0xffffff);
+        }
+        inline bool operator==(Color const& other) const
+        {
+            return rgba_ == other.rgba_;
+        }
 
-	inline std::string to_string() const
+        inline std::string to_string() const
         {
-	    std::stringstream ss;
-	    ss << "rgb (" << red() << ","  << green() << ","  << blue() <<")";
-	    return ss.str();
-        } 
+            std::stringstream ss;
+            ss << "rgb (" << red() << ","  << green() << ","  << blue() <<")";
+            return ss.str();
+        }
+        inline std::string to_hex_string() const
+        {
+            std::stringstream ss;
+            ss << boost::format("#%1$02x%2$02x%3$02x") % red() % green() % blue();
+            return ss.str();
+        }
     };    
 }
 



From pavlenko at berlios.de  Wed May 24 17:17:17 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Wed, 24 May 2006 17:17:17 +0200
Subject: [Mapnik-svn] r270 - trunk/include
Message-ID: <200605241517.k4OFHHcU030633@sheep.berlios.de>

Author: pavlenko
Date: 2006-05-24 17:17:16 +0200 (Wed, 24 May 2006)
New Revision: 270

Modified:
   trunk/include/rule.hpp
Log:
small cleanup



Modified: trunk/include/rule.hpp
===================================================================
--- trunk/include/rule.hpp	2006-05-24 15:13:51 UTC (rev 269)
+++ trunk/include/rule.hpp	2006-05-24 15:17:16 UTC (rev 270)
@@ -154,22 +154,23 @@
         {
             max_scale_=scale;
         }
-
-        double get_min_scale() const
-        {
-            return min_scale_;
-        }
-
+        
         double get_max_scale() const
         {
             return max_scale_;
         }
-
+        
         void set_min_scale(double scale)
         {
             min_scale_=scale;
         }
 
+        double get_min_scale() const
+        {
+            return min_scale_;
+        }
+
+       
         void set_name(std::string const& name)
         {
             name_=name;



From pavlenko at berlios.de  Thu May 25 00:15:05 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Thu, 25 May 2006 00:15:05 +0200
Subject: [Mapnik-svn] r271 - trunk/src
Message-ID: <200605242215.k4OMF5Wj017328@sheep.berlios.de>

Author: pavlenko
Date: 2006-05-25 00:15:04 +0200 (Thu, 25 May 2006)
New Revision: 271

Modified:
   trunk/src/layer.cpp
Log:
oops..layer.cpp got broken by mistake, reverting back.



Modified: trunk/src/layer.cpp
===================================================================
--- trunk/src/layer.cpp	2006-05-24 15:17:16 UTC (rev 270)
+++ trunk/src/layer.cpp	2006-05-24 22:15:04 UTC (rev 271)
@@ -37,6 +37,8 @@
     Layer::Layer()
         : params_(),
           name_("unknown"),
+          title_(""),
+          abstract_(""),
           minZoom_(0),
           maxZoom_(std::numeric_limits<double>::max()),
           active_(true),
@@ -47,6 +49,8 @@
     Layer::Layer(const parameters& params)
         :params_(params),
          name_(params_["name"]),
+         title_(params_["title"]),
+         abstract_(params_["abstract"]),
          minZoom_(0),
          maxZoom_(std::numeric_limits<double>::max()),
          active_(true),
@@ -55,15 +59,17 @@
     {}
     
     Layer::Layer(const Layer& rhs)
-        : params_(rhs.params_),
-          name_(rhs.name_),
-          minZoom_(rhs.minZoom_),
-          maxZoom_(rhs.maxZoom_),
-          active_(rhs.active_),
-          selectable_(rhs.selectable_),
-          styles_(rhs.styles_),
-          selection_style_(rhs.selection_style_), 
-          ds_(rhs.ds_)  {}
+        :params_(rhs.params_),
+         name_(rhs.name_),
+         title_(rhs.title_),
+         abstract_(rhs.abstract_),
+         minZoom_(rhs.minZoom_),
+         maxZoom_(rhs.maxZoom_),
+         active_(rhs.active_),
+         selectable_(rhs.selectable_),
+         ds_(rhs.ds_),
+         styles_(rhs.styles_),
+         selection_style_(rhs.selection_style_) {}
     
     Layer& Layer::operator=(const Layer& rhs)
     {
@@ -81,11 +87,13 @@
     {
         params_=rhs.params_;
         name_=rhs.name_;
+        title_=rhs.title_;
+        abstract_=rhs.abstract_;
         minZoom_=rhs.minZoom_;
         maxZoom_=rhs.maxZoom_;
         active_=rhs.active_;
         selectable_=rhs.selectable_;
-        ds_=rhs.ds_;
+        //ds_=rhs.ds_;
         styles_=rhs.styles_;
         selection_style_=rhs.selection_style_;
     }
@@ -107,6 +115,26 @@
         return name_;
     }
 
+    void Layer::set_title( std::string const& title)
+    {
+        title_ = title;
+    }
+ 
+    string const& Layer::title() const
+    {
+        return title_;
+    }
+
+    void Layer::set_abstract( std::string const& abstract)
+    {
+        abstract_ = abstract;
+    }
+ 
+    string const& Layer::abstract() const
+    {
+        return abstract_;
+    }
+
     void Layer::add_style(std::string const& stylename)
     {
         styles_.push_back(stylename);



From pavlenko at berlios.de  Thu May 25 16:19:21 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Thu, 25 May 2006 16:19:21 +0200
Subject: [Mapnik-svn] r272 - trunk/include
Message-ID: <200605251419.k4PEJLxE011735@sheep.berlios.de>

Author: pavlenko
Date: 2006-05-25 16:19:21 +0200 (Thu, 25 May 2006)
New Revision: 272

Modified:
   trunk/include/wkb.hpp
Log:
export symbols from wkb

Modified: trunk/include/wkb.hpp
===================================================================
--- trunk/include/wkb.hpp	2006-05-24 22:15:04 UTC (rev 271)
+++ trunk/include/wkb.hpp	2006-05-25 14:19:21 UTC (rev 272)
@@ -30,7 +30,7 @@
 
 namespace mapnik
 {
-    class geometry_utils 
+    class MAPNIK_DECL geometry_utils 
     {
     public:
 	static geometry_ptr from_wkb(const char* wkb, unsigned size,int srid);



From pavlenko at berlios.de  Fri May 26 15:09:00 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Fri, 26 May 2006 15:09:00 +0200
Subject: [Mapnik-svn] r273 - trunk/include
Message-ID: <200605261309.k4QD90aE003426@sheep.berlios.de>

Author: pavlenko
Date: 2006-05-26 15:08:48 +0200 (Fri, 26 May 2006)
New Revision: 273

Modified:
   trunk/include/image_reader.hpp
Log:
added MAPNIK_DECL

Modified: trunk/include/image_reader.hpp
===================================================================
--- trunk/include/image_reader.hpp	2006-05-25 14:19:21 UTC (rev 272)
+++ trunk/include/image_reader.hpp	2006-05-26 13:08:48 UTC (rev 273)
@@ -1,64 +1,66 @@
 /*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
+* 
+* This file is part of Mapnik (c++ mapping toolkit)
+*
+* Copyright (C) 2006 Artem Pavlenko
+*
+* This library is free software; you can redistribute it and/or
+* modify it under the terms of the GNU Lesser General Public
+* License as published by the Free Software Foundation; either
+* version 2.1 of the License, or (at your option) any later version.
+*
+* This library is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* Lesser General Public License for more details.
+*
+* You should have received a copy of the GNU Lesser General Public
+* License along with this library; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*
+*****************************************************************************/
 
 //$Id: image_reader.hpp 39 2005-04-10 20:39:53Z pavlenko $
 
 #ifndef IMAGE_READER_HPP
 #define IMAGE_READER_HPP
 
-#include "image_data.hpp"
 #include <stdexcept>
 #include <string>
 
+#include "image_data.hpp"
+#include "config.hpp"
 
+
 namespace mapnik 
 {
     class ImageReaderException : public std::exception
     {
     private:
-	std::string message_;
+        std::string message_;
     public:
-	ImageReaderException(const std::string& message) 
-	    : message_(message) {}
+        ImageReaderException(const std::string& message) 
+            : message_(message) {}
 
-	~ImageReaderException() throw() {}
+        ~ImageReaderException() throw() {}
 
-	virtual const char* what() const throw()
-	{
-	    return message_.c_str();
-	}
+        virtual const char* what() const throw()
+        {
+            return message_.c_str();
+        }
     };
 
-    struct ImageReader
+    struct MAPNIK_DECL ImageReader
     {
-	virtual unsigned width() const=0;
-	virtual unsigned height() const=0;
-	virtual void read(unsigned x,unsigned y,ImageData32& image)=0;
-	virtual ~ImageReader() {}
+        virtual unsigned width() const=0;
+        virtual unsigned height() const=0;
+        virtual void read(unsigned x,unsigned y,ImageData32& image)=0;
+        virtual ~ImageReader() {}
     };
 
     bool register_image_reader(const std::string& type,ImageReader* (*)(const std::string&));
-    ImageReader* get_image_reader(const std::string& type,const std::string& file);
-    
+    MAPNIK_DECL ImageReader* get_image_reader(const std::string& type,const std::string& file);
+
 }
 
 #endif                                            //IMAGE_READER_HPP



From pavlenko at berlios.de  Fri May 26 15:11:38 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Fri, 26 May 2006 15:11:38 +0200
Subject: [Mapnik-svn] r274 - in trunk: include src
Message-ID: <200605261311.k4QDBcGH004886@sheep.berlios.de>

Author: pavlenko
Date: 2006-05-26 15:11:31 +0200 (Fri, 26 May 2006)
New Revision: 274

Modified:
   trunk/include/datasource_cache.hpp
   trunk/include/point_symbolizer.hpp
   trunk/src/agg_renderer.cpp
   trunk/src/point_symbolizer.cpp
Log:
1. return shared_ptr from point_symbolizer 
2. small cleanup



Modified: trunk/include/datasource_cache.hpp
===================================================================
--- trunk/include/datasource_cache.hpp	2006-05-26 13:08:48 UTC (rev 273)
+++ trunk/include/datasource_cache.hpp	2006-05-26 13:11:31 UTC (rev 274)
@@ -25,12 +25,13 @@
 #ifndef DATASOURCE_CACHE_HPP
 #define DATASOURCE_CACHE_HPP
 
+#include <map>
+#include <boost/shared_ptr.hpp>
+
 #include "utils.hpp"
 #include "params.hpp"
 #include "plugin.hpp"
 #include "datasource.hpp"
-#include <boost/shared_ptr.hpp>
-#include <map>
 
 namespace mapnik
 {
@@ -38,16 +39,16 @@
     {
         friend class CreateStatic<datasource_cache>;
     private:
-	datasource_cache();
-	~datasource_cache();
-	datasource_cache(const datasource_cache&);
-	datasource_cache& operator=(const datasource_cache&);
-	static std::map<std::string,boost::shared_ptr<PluginInfo> > plugins_;
-	static bool registered_;
-	static bool insert(const std::string&  name,const lt_dlhandle module);
+        datasource_cache();
+        ~datasource_cache();
+        datasource_cache(const datasource_cache&);
+        datasource_cache& operator=(const datasource_cache&);
+        static std::map<std::string,boost::shared_ptr<PluginInfo> > plugins_;
+        static bool registered_;
+        static bool insert(const std::string&  name,const lt_dlhandle module);
     public:
-	static void register_datasources(const std::string& path);
-	static boost::shared_ptr<datasource> create(parameters const& params);
+        static void register_datasources(const std::string& path);
+        static boost::shared_ptr<datasource> create(parameters const& params);
     };
 }
 #endif   //DATASOURCE_CACHE_HPP

Modified: trunk/include/point_symbolizer.hpp
===================================================================
--- trunk/include/point_symbolizer.hpp	2006-05-26 13:08:48 UTC (rev 273)
+++ trunk/include/point_symbolizer.hpp	2006-05-26 13:11:31 UTC (rev 274)
@@ -36,9 +36,11 @@
                          std::string const& type,
                          unsigned width,unsigned height);
         point_symbolizer(point_symbolizer const& rhs);
-        ImageData32 const& get_data() const;
+        void set_data (boost::shared_ptr<ImageData32> symbol);
+        boost::shared_ptr<ImageData32> const& get_data() const;        
         void set_allow_overlap(bool overlap);
         bool get_allow_overlap() const;
+        
     private:
         boost::shared_ptr<ImageData32> symbol_;
         bool overlap_;

Modified: trunk/src/agg_renderer.cpp
===================================================================
--- trunk/src/agg_renderer.cpp	2006-05-26 13:08:48 UTC (rev 273)
+++ trunk/src/agg_renderer.cpp	2006-05-26 13:11:31 UTC (rev 274)
@@ -275,22 +275,25 @@
         {
             double x;
             double y;
-            ImageData32 const& data = sym.get_data();
-            geom->label_position(&x,&y);
-            t_.forward_x(&x);
-            t_.forward_y(&y);
-            int w = data.width();
-            int h = data.height();
-            int px=int(floor(x - 0.5 * w));
-            int py=int(floor(y - 0.5 * h));
-            
-            if (sym.get_allow_overlap() || 
-                detector_.has_placement(Envelope<double>(floor(x - 0.5 * w),
-                                                         floor(y - 0.5 * h),
-                                                         ceil (x + 0.5 * w),
-                                                         ceil (y + 0.5 * h))))
-            {    
-                pixmap_.set_rectangle_alpha(px,py,data);
+            boost::shared_ptr<ImageData32> const& data = sym.get_data();
+            if ( data )
+            {
+                geom->label_position(&x,&y);
+                t_.forward_x(&x);
+                t_.forward_y(&y);
+                int w = data->width();
+                int h = data->height();
+                int px=int(floor(x - 0.5 * w));
+                int py=int(floor(y - 0.5 * h));
+                
+                if (sym.get_allow_overlap() || 
+                    detector_.has_placement(Envelope<double>(floor(x - 0.5 * w),
+                                                             floor(y - 0.5 * h),
+                                                             ceil (x + 0.5 * w),
+                                                             ceil (y + 0.5 * h))))
+                {    
+                    pixmap_.set_rectangle_alpha(px,py,*data);
+                }
             }
         }
     }

Modified: trunk/src/point_symbolizer.cpp
===================================================================
--- trunk/src/point_symbolizer.cpp	2006-05-26 13:08:48 UTC (rev 273)
+++ trunk/src/point_symbolizer.cpp	2006-05-26 13:11:31 UTC (rev 274)
@@ -61,10 +61,15 @@
           overlap_(rhs.overlap_)
     {}
     
-    ImageData32 const& point_symbolizer::get_data() const
+    void point_symbolizer::set_data( boost::shared_ptr<ImageData32> symbol)
     {
-        return *(symbol_.get());
+        symbol_ = symbol;
     }
+
+    boost::shared_ptr<ImageData32> const& point_symbolizer::get_data() const
+    {
+        return symbol_;
+    }
     
     void point_symbolizer::set_allow_overlap(bool overlap)
     {



From pavlenko at berlios.de  Tue May 30 15:41:17 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Tue, 30 May 2006 15:41:17 +0200
Subject: [Mapnik-svn] r275 - trunk/include
Message-ID: <200605301341.k4UDfHZ3000412@sheep.berlios.de>

Author: pavlenko
Date: 2006-05-30 15:41:15 +0200 (Tue, 30 May 2006)
New Revision: 275

Modified:
   trunk/include/graphics.hpp
Log:
replaced tabs with spaces

Modified: trunk/include/graphics.hpp
===================================================================
--- trunk/include/graphics.hpp	2006-05-26 13:11:31 UTC (rev 274)
+++ trunk/include/graphics.hpp	2006-05-30 13:41:15 UTC (rev 275)
@@ -38,142 +38,142 @@
     class MAPNIK_DECL Image32
     {
     private:
-	unsigned width_;
-	unsigned height_;
-	Color background_;
-	ImageData32 data_;
+        unsigned width_;
+        unsigned height_;
+        Color background_;
+        ImageData32 data_;
     public:
-	Image32(int width,int height);
-	Image32(const Image32& rhs);
-	~Image32();
-	void setBackground(const Color& background);
-	const Color& getBackground() const;     
-	const ImageData32& data() const;
-	inline ImageData32& data() {
-	    return data_;
-	}
-	inline const unsigned char* raw_data() const
-	{
-	    return data_.getBytes();
-	}
+        Image32(int width,int height);
+        Image32(const Image32& rhs);
+        ~Image32();
+        void setBackground(const Color& background);
+        const Color& getBackground() const;     
+        const ImageData32& data() const;
+        inline ImageData32& data() {
+            return data_;
+        }
+        inline const unsigned char* raw_data() const
+        {
+            return data_.getBytes();
+        }
 	
-	inline unsigned char* raw_data()
-	{
-	    return data_.getBytes();
-	}
+        inline unsigned char* raw_data()
+        {
+            return data_.getBytes();
+        }
 	
-	void saveToFile(const std::string& file,const std::string& format="auto"); 
+        void saveToFile(const std::string& file,const std::string& format="auto"); 
     private:
 
-	inline bool checkBounds(unsigned x, unsigned y) const
-	{
-	    return (x < width_ && y < height_);
-	}
+        inline bool checkBounds(unsigned x, unsigned y) const
+        {
+            return (x < width_ && y < height_);
+        }
 
     public:
-	inline void setPixel(int x,int y,unsigned int rgba)
-	{
-	    if (checkBounds(x,y))
-	    {
-		data_(x,y)=rgba;
-	    }
-	}
-	inline void blendPixel(int x,int y,unsigned int rgba1,int t)
-	{
-	    if (checkBounds(x,y))
-	    {
-		unsigned rgba0 = data_(x,y);	
-		unsigned a1 = t;//(rgba1 >> 24) & 0xff;
-		if (a1 == 0) return;
-		unsigned r1 = rgba1 & 0xff;
-		unsigned g1 = (rgba1 >> 8 ) & 0xff;
-		unsigned b1 = (rgba1 >> 16) & 0xff;
+        inline void setPixel(int x,int y,unsigned int rgba)
+        {
+            if (checkBounds(x,y))
+            {
+                data_(x,y)=rgba;
+            }
+        }
+        inline void blendPixel(int x,int y,unsigned int rgba1,int t)
+        {
+            if (checkBounds(x,y))
+            {
+                unsigned rgba0 = data_(x,y);	
+                unsigned a1 = t;//(rgba1 >> 24) & 0xff;
+                if (a1 == 0) return;
+                unsigned r1 = rgba1 & 0xff;
+                unsigned g1 = (rgba1 >> 8 ) & 0xff;
+                unsigned b1 = (rgba1 >> 16) & 0xff;
 		
-		unsigned a0 = (rgba0 >> 24) & 0xff;
-		unsigned r0 = (rgba0 & 0xff) * a0;
-		unsigned g0 = ((rgba0 >> 8 ) & 0xff) * a0;
-		unsigned b0 = ((rgba0 >> 16) & 0xff) * a0;
+                unsigned a0 = (rgba0 >> 24) & 0xff;
+                unsigned r0 = (rgba0 & 0xff) * a0;
+                unsigned g0 = ((rgba0 >> 8 ) & 0xff) * a0;
+                unsigned b0 = ((rgba0 >> 16) & 0xff) * a0;
 		
 		
-		a0 = ((a1 + a0) << 8) - a0*a1;
+                a0 = ((a1 + a0) << 8) - a0*a1;
 		
-		r0 = ((((r1 << 8) - r0) * a1 + (r0 << 8)) / a0);
-		g0 = ((((g1 << 8) - g0) * a1 + (g0 << 8)) / a0);
-		b0 = ((((b1 << 8) - b0) * a1 + (b0 << 8)) / a0);
-		a0 = a0 >> 8;
-		data_(x,y)= (a0 << 24)| (b0 << 16) |  (g0 << 8) | (r0) ;
-	    }
-	}
+                r0 = ((((r1 << 8) - r0) * a1 + (r0 << 8)) / a0);
+                g0 = ((((g1 << 8) - g0) * a1 + (g0 << 8)) / a0);
+                b0 = ((((b1 << 8) - b0) * a1 + (b0 << 8)) / a0);
+                a0 = a0 >> 8;
+                data_(x,y)= (a0 << 24)| (b0 << 16) |  (g0 << 8) | (r0) ;
+            }
+        }
 
-	inline unsigned width() const
-	{
-	    return width_;
-	}
+        inline unsigned width() const
+        {
+            return width_;
+        }
 	
-	inline unsigned height() const
-	{
-	    return height_;
-	}
+        inline unsigned height() const
+        {
+            return height_;
+        }
 
-	inline void set_rectangle(int x0,int y0,ImageData32 const& data)
-	{
-	    Envelope<int> ext0(0,0,width_,height_);   
-	    Envelope<int> ext1(x0,y0,x0+data.width(),y0+data.height());
+        inline void set_rectangle(int x0,int y0,ImageData32 const& data)
+        {
+            Envelope<int> ext0(0,0,width_,height_);   
+            Envelope<int> ext1(x0,y0,x0+data.width(),y0+data.height());
 	    
-	    if (ext0.intersects(ext1))
-	    {	
-		Envelope<int> box = ext0.intersect(ext1);
-		for (int y = box.miny(); y < box.maxy(); ++y)
-		{
-		    for (int x = box.minx(); x < box.maxx(); ++x)
-		    {
-			if ((data(x-x0,y-y0) & 0xff000000)) 
-			{
-			    data_(x,y)=data(x-x0,y-y0);
-			}
-		    }
-		}   
-	    }
-	}
+            if (ext0.intersects(ext1))
+            {	
+                Envelope<int> box = ext0.intersect(ext1);
+                for (int y = box.miny(); y < box.maxy(); ++y)
+                {
+                    for (int x = box.minx(); x < box.maxx(); ++x)
+                    {
+                        if ((data(x-x0,y-y0) & 0xff000000)) 
+                        {
+                            data_(x,y)=data(x-x0,y-y0);
+                        }
+                    }
+                }   
+            }
+        }
 	
-	inline void set_rectangle_alpha(int x0,int y0,const ImageData32& data)
-	{
-	    Envelope<int> ext0(0,0,width_,height_);   
-	    Envelope<int> ext1(x0,y0,x0 + data.width(),y0 + data.height());
+        inline void set_rectangle_alpha(int x0,int y0,const ImageData32& data)
+        {
+            Envelope<int> ext0(0,0,width_,height_);   
+            Envelope<int> ext1(x0,y0,x0 + data.width(),y0 + data.height());
 	    
-	    if (ext0.intersects(ext1))
-	    {	                		
-		Envelope<int> box = ext0.intersect(ext1);		
-		for (int y = box.miny(); y < box.maxy(); ++y)
-		{
-		    for (int x = box.minx(); x < box.maxx(); ++x)
-		    {
-			unsigned rgba0 = data_(x,y);
-			unsigned rgba1 = data(x-x0,y-y0);
+            if (ext0.intersects(ext1))
+            {	                		
+                Envelope<int> box = ext0.intersect(ext1);		
+                for (int y = box.miny(); y < box.maxy(); ++y)
+                {
+                    for (int x = box.minx(); x < box.maxx(); ++x)
+                    {
+                        unsigned rgba0 = data_(x,y);
+                        unsigned rgba1 = data(x-x0,y-y0);
 		    
-			unsigned a1 = (rgba1 >> 24) & 0xff;
-			if (a1 == 0) continue;
-			unsigned r1 = rgba1 & 0xff;
-			unsigned g1 = (rgba1 >> 8 ) & 0xff;
-			unsigned b1 = (rgba1 >> 16) & 0xff;
+                        unsigned a1 = (rgba1 >> 24) & 0xff;
+                        if (a1 == 0) continue;
+                        unsigned r1 = rgba1 & 0xff;
+                        unsigned g1 = (rgba1 >> 8 ) & 0xff;
+                        unsigned b1 = (rgba1 >> 16) & 0xff;
 		    
-			unsigned a0 = (rgba0 >> 24) & 0xff;
-			unsigned r0 = (rgba0 & 0xff) * a0;
-			unsigned g0 = ((rgba0 >> 8 ) & 0xff) * a0;
-			unsigned b0 = ((rgba0 >> 16) & 0xff) * a0;
+                        unsigned a0 = (rgba0 >> 24) & 0xff;
+                        unsigned r0 = (rgba0 & 0xff) * a0;
+                        unsigned g0 = ((rgba0 >> 8 ) & 0xff) * a0;
+                        unsigned b0 = ((rgba0 >> 16) & 0xff) * a0;
 		    
 		    
-			a0 = ((a1 + a0) << 8) - a0*a1;
+                        a0 = ((a1 + a0) << 8) - a0*a1;
 		    
-			r0 = ((((r1 << 8) - r0) * a1 + (r0 << 8)) / a0);
-			g0 = ((((g1 << 8) - g0) * a1 + (g0 << 8)) / a0);
-			b0 = ((((b1 << 8) - b0) * a1 + (b0 << 8)) / a0);
-			a0 = a0 >> 8;
-			data_(x,y)= (a0 << 24)| (b0 << 16) |  (g0 << 8) | (r0) ;
-		    }
-		}
-	    }
-	}
+                        r0 = ((((r1 << 8) - r0) * a1 + (r0 << 8)) / a0);
+                        g0 = ((((g1 << 8) - g0) * a1 + (g0 << 8)) / a0);
+                        b0 = ((((b1 << 8) - b0) * a1 + (b0 << 8)) / a0);
+                        a0 = a0 >> 8;
+                        data_(x,y)= (a0 << 24)| (b0 << 16) |  (g0 << 8) | (r0) ;
+                    }
+                }
+            }
+        }
     };
 }
 #endif //GRAPHICS_HPP



From pavlenko at berlios.de  Tue May 30 23:58:23 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Tue, 30 May 2006 23:58:23 +0200
Subject: [Mapnik-svn] r276 - trunk/docs/ogcserver
Message-ID: <200605302158.k4ULwNWJ000711@sheep.berlios.de>

Author: pavlenko
Date: 2006-05-30 23:58:22 +0200 (Tue, 30 May 2006)
New Revision: 276

Modified:
   trunk/docs/ogcserver/readme.txt
Log:
corrected WMSFactory example




Modified: trunk/docs/ogcserver/readme.txt
===================================================================
--- trunk/docs/ogcserver/readme.txt	2006-05-30 13:41:15 UTC (rev 275)
+++ trunk/docs/ogcserver/readme.txt	2006-05-30 21:58:22 UTC (rev 276)
@@ -1,149 +1,149 @@
-# $Id$
-
-Mapnik OGC Server
------------------
-
-
-Introduction
-------------
-
-	Mapnik provides a server package to allow the publishing of maps
-through the open and standard WMS interface published by the Open Geospatial
-Consortium (OGC).  It is in implemented in Python, around the core C++
-library.
-
-
-Features/Caveats
-----------------
-
-- WMS 1.1.1 and 1.3.0
-- CGI/FastCGI
-- GetCapabilities and GetMap support only (NO GetFeatureInfo)
-- JPEG/PNG output
-- XML/INIMAGE/BLANK error handling
-- No real layer metadata support yet
-- No re-projection support
-- Needs to be able to write to tempfile.gettempdir() (most likely "/tmp")
-
-
-Dependencies
-------------
-
-Please properly install the following before proceeding further:
-
-- jonpy (http://jonpy.sourceforge.net/)
-- lxml (http://codespeak.net/lxml/)
-- PIL (http://www.pythonware.com/products/pil)
-- PROJ.4 (http://proj.maptools.org/)
-
-
-Installation
-------------
-
-- Make sure you compile or re-compile Mapnik after installing PROJ.4, if this
-  was not done already.  Mapnik includes a Python API to the PROJ.4 library
-  used by the ogcserver.  The PROJ_INCLUDES and PROJ_LIBS parameters can
-  be passed to mapnik's scons build script to help with this.
-  
-  You can test the availability of the PROJ.4 bindings by trying:
-  
-  $ python
-  Python 2.3.4 (#1, Feb 22 2005, 04:09:37)
-  [GCC 3.4.3 20041212 (Red Hat 3.4.3-9.EL4)] on linux2
-  Type "help", "copyright", "credits" or "license" for more information.
-  >>> from mapnik import Projection
-  registered datasource : raster
-  registered datasource : shape
-  registered datasource : postgis
-  >>>
-
-- The executable "ogcserver" in utils/ogcserver will work for both CGI and
-  FastCGI operations.  Where to place it will depend on your server's
-  configuration and is beyond this documentation.  For information on FastCGI
-  go to http://www.fastcgi.com/.
-
-
-Configuring the server
-----------------------
-
-- You will need to edit the ogcserver executable for now.  It is a simple
-  Python text script.
-  
-  1) Edit the path to the interpreter in the first line.
-  2) Edit the path to the config file if you don't like the default.
-  
-- Copy the sample configuration "ogcserver.conf" file in utils/ogcserver to
-  the location you specified in the previous step.
-  
-- Edit the configuration file to your liking, the comments within the file will
-  help you further.  Be sure to at the very minimum edit the "module"
-  parameter, the server will not work without you setting it properly first.
-  
-
-Defining layers and styles for use by the ogcserver
----------------------------------------------------
-
-	The ogcserver obviously needs layers to publish.  For now, with Mapnik, this
-can only be done by writing code. In this case, a Python script will need to be
-written to describe the layers and respective styles.  For information on the Python
-API, look in demo/python, or in docs/epydocs.
-
-The server needs a python module, with code that looks like this:
-
-from mapnik.ogcserver.WMS import BaseWMSFactory
-
-class WMSFactory(BaseWMSFactory):
-
-	def __init(self):
-		BaseWMSFactory.__init__(self)
-		sty = Style()
-		...
-		self.register_style('stylename', sty)
-		
-		lyr = Layer(name='layername', title='Highways', abstract='Highways')
-		...
-		lyr.styles.append('stylename')
-		self.register_layer(lyr)
-		self.finalize()
-		
-The rules for writing this class are:
-
-- It MUST be called 'WMSFactory'.
-- It MUST sub-class mapnik.ogcserver.WMS.BaseWMSFactory.
-- The __init__ MUST call the base class'.
-- Layers MUST be named with the 'name' parameter to the constructor.
-- style and layer names are meant for machine readability, not human.  Keep
-  them short and simple, without spaces or special characters.
-- For human readable info, pass title='' and abstract='' parameters to the
-  Layer() call.
-- The layers must have at least one style associated with them (a default).
-- No Map() object is used or needed here.
-- Be sure to call self.finalize() once you've registered everything! This will
-  validate everything and let you know if there's problems.
-- Be sure to associate a default style with the layer.  In the future, there
-  will be a mechanism to assign other non-default styles to a layer, to support
-  named styles through the STYLES= parameter.
-
-To Do
------
-
-- Named style support.
-- Improve configuration to allow for full server metadata.
-- Investigate moving to cElementTree from lxml.
-- Add some internal "caching" for performance improvements.
-- Support GetFeatureInfo (Requires core changes).
-- Switch to using C/C++ libs for image generation, instead of PIL (also
-  requires core changes). PIL requirement will remain for INIMAGE/BLANK
-  error handling.
-
-
-Conclusion
-----------
-
-	This is the very first implementation of a WMS for Mapnik.  Although inital
-testing seems to suggest it works well, there may be bugs, and it lacks some
-useful features.  Comments, contributions, and requests for help should all be
-directed to the Mapnik mailing list.
-
-Enjoy!
-J.F.
\ No newline at end of file
+# $Id$
+
+Mapnik OGC Server
+-----------------
+
+
+Introduction
+------------
+
+	Mapnik provides a server package to allow the publishing of maps
+through the open and standard WMS interface published by the Open Geospatial
+Consortium (OGC).  It is in implemented in Python, around the core C++
+library.
+
+
+Features/Caveats
+----------------
+
+- WMS 1.1.1 and 1.3.0
+- CGI/FastCGI
+- GetCapabilities and GetMap support only (NO GetFeatureInfo)
+- JPEG/PNG output
+- XML/INIMAGE/BLANK error handling
+- No real layer metadata support yet
+- No re-projection support
+- Needs to be able to write to tempfile.gettempdir() (most likely "/tmp")
+
+
+Dependencies
+------------
+
+Please properly install the following before proceeding further:
+
+- jonpy (http://jonpy.sourceforge.net/)
+- lxml (http://codespeak.net/lxml/)
+- PIL (http://www.pythonware.com/products/pil)
+- PROJ.4 (http://proj.maptools.org/)
+
+
+Installation
+------------
+
+- Make sure you compile or re-compile Mapnik after installing PROJ.4, if this
+  was not done already.  Mapnik includes a Python API to the PROJ.4 library
+  used by the ogcserver.  The PROJ_INCLUDES and PROJ_LIBS parameters can
+  be passed to mapnik's scons build script to help with this.
+  
+  You can test the availability of the PROJ.4 bindings by trying:
+  
+  $ python
+  Python 2.3.4 (#1, Feb 22 2005, 04:09:37)
+  [GCC 3.4.3 20041212 (Red Hat 3.4.3-9.EL4)] on linux2
+  Type "help", "copyright", "credits" or "license" for more information.
+  >>> from mapnik import Projection
+  registered datasource : raster
+  registered datasource : shape
+  registered datasource : postgis
+  >>>
+
+- The executable "ogcserver" in utils/ogcserver will work for both CGI and
+  FastCGI operations.  Where to place it will depend on your server's
+  configuration and is beyond this documentation.  For information on FastCGI
+  go to http://www.fastcgi.com/.
+
+
+Configuring the server
+----------------------
+
+- You will need to edit the ogcserver executable for now.  It is a simple
+  Python text script.
+  
+  1) Edit the path to the interpreter in the first line.
+  2) Edit the path to the config file if you don't like the default.
+  
+- Copy the sample configuration "ogcserver.conf" file in utils/ogcserver to
+  the location you specified in the previous step.
+  
+- Edit the configuration file to your liking, the comments within the file will
+  help you further.  Be sure to at the very minimum edit the "module"
+  parameter, the server will not work without you setting it properly first.
+  
+
+Defining layers and styles for use by the ogcserver
+---------------------------------------------------
+
+	The ogcserver obviously needs layers to publish.  For now, with Mapnik, this
+can only be done by writing code. In this case, a Python script will need to be
+written to describe the layers and respective styles.  For information on the Python
+API, look in demo/python, or in docs/epydocs.
+
+The server needs a python module, with code that looks like this:
+
+from mapnik.ogcserver.WMS import BaseWMSFactory
+
+class WMSFactory(BaseWMSFactory):
+
+	def __init__(self):
+		BaseWMSFactory.__init__(self)
+		sty = Style()
+		...
+		self.register_style('stylename', sty)
+		
+		lyr = Layer(name='layername', title='Highways', abstract='Highways')
+		...
+		lyr.styles.append('stylename')
+		self.register_layer(lyr)
+		self.finalize()
+		
+The rules for writing this class are:
+
+- It MUST be called 'WMSFactory'.
+- It MUST sub-class mapnik.ogcserver.WMS.BaseWMSFactory.
+- The __init__ MUST call the base class'.
+- Layers MUST be named with the 'name' parameter to the constructor.
+- style and layer names are meant for machine readability, not human.  Keep
+  them short and simple, without spaces or special characters.
+- For human readable info, pass title='' and abstract='' parameters to the
+  Layer() call.
+- The layers must have at least one style associated with them (a default).
+- No Map() object is used or needed here.
+- Be sure to call self.finalize() once you've registered everything! This will
+  validate everything and let you know if there's problems.
+- Be sure to associate a default style with the layer.  In the future, there
+  will be a mechanism to assign other non-default styles to a layer, to support
+  named styles through the STYLES= parameter.
+
+To Do
+-----
+
+- Named style support.
+- Improve configuration to allow for full server metadata.
+- Investigate moving to cElementTree from lxml.
+- Add some internal "caching" for performance improvements.
+- Support GetFeatureInfo (Requires core changes).
+- Switch to using C/C++ libs for image generation, instead of PIL (also
+  requires core changes). PIL requirement will remain for INIMAGE/BLANK
+  error handling.
+
+
+Conclusion
+----------
+
+	This is the very first implementation of a WMS for Mapnik.  Although inital
+testing seems to suggest it works well, there may be bugs, and it lacks some
+useful features.  Comments, contributions, and requests for help should all be
+directed to the Mapnik mailing list.
+
+Enjoy!
+J.F.



From pavlenko at berlios.de  Tue May 30 23:59:07 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Tue, 30 May 2006 23:59:07 +0200
Subject: [Mapnik-svn] r277 - trunk/bindings/python/mapnik/ogcserver
Message-ID: <200605302159.k4ULx724000840@sheep.berlios.de>

Author: pavlenko
Date: 2006-05-30 23:59:06 +0200 (Tue, 30 May 2006)
New Revision: 277

Modified:
   trunk/bindings/python/mapnik/ogcserver/WMS.py
Log:
converted to unix



Modified: trunk/bindings/python/mapnik/ogcserver/WMS.py
===================================================================
--- trunk/bindings/python/mapnik/ogcserver/WMS.py	2006-05-30 21:58:22 UTC (rev 276)
+++ trunk/bindings/python/mapnik/ogcserver/WMS.py	2006-05-30 21:59:06 UTC (rev 277)
@@ -1,70 +1,69 @@
-#
-# This file is part of Mapnik (c++ mapping toolkit)
-#
-# Copyright (C) 2006 Jean-Francois Doyon
-#
-# Mapnik is free software; you can redistribute it and/or
-# modify it under the terms of the GNU Lesser General Public
-# License as published by the Free Software Foundation; either
-# version 2.1 of the License, or (at your option) any later version.
-#
-# This library is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-# Lesser General Public License for more details.
-#
-# You should have received a copy of the GNU Lesser General Public
-# License along with this library; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-#
-# $Id$
-
-from common import Version
-from exceptions import OGCException, ServerConfigurationError
-from wms111 import ServiceHandler as ServiceHandler111
-from wms130 import ServiceHandler as ServiceHandler130
-from mapnik import Style, Layer
-
-def ServiceHandlerFactory(conf, mapfactory, onlineresource, version):
-
-    if not version:
-        version = Version('1.3.0')
-    else:
-        version = Version(version)
-    if version >= '1.3.0':
-        return ServiceHandler130(conf, mapfactory, onlineresource)
-    else:
-        return ServiceHandler111(conf, mapfactory, onlineresource)
-
-class BaseWMSFactory:
-
-    def __init__(self):
-        self.layers = {}
-        self.styles = {}
-
-    def register_layer(self, layer, extrastyles=()):
-        layername = layer.name()
-        if not layername:
-            raise ServerConfigurationError('Attempted to register an unnamed layer.')
-        self.layers[layername] = layer
-        if isinstance(extrastyles, tuple):
-            layer.wmsextrastyles = extrastyles
-        else:
-            raise ServerConfigurationError('Layer "%s" was passed an invalid list of extra styles.  List must be a tuple of strings.' % layername)
-
-    def register_style(self, name, style):
-        if not name:
-            raise ServerConfigurationError('Attempted to register a style without providing a name.')
-        if not isinstance(style, Style):
-            raise ServerConfigurationError('Bad style object passed to register_style() for style "%s".' % name)
-        self.styles[name] = style
-
-    def finalize(self):
-        if len(self.layers) == 0:
-            raise ServerConfigurationError('No layers defined!')
-        if len(self.styles) == 0:
-            raise ServerConfigurationError('No styles defined!')
-        for layer in self.layers.values():
-            for style in list(layer.styles) + list(layer.wmsextrastyles):
-                if style not in self.styles.keys():
-                    raise ServerConfigurationError('Layer "%s" refers to undefined style "%s".' % (layer.name(), style))
\ No newline at end of file
+#
+# This file is part of Mapnik (c++ mapping toolkit)
+#
+# Copyright (C) 2006 Jean-Francois Doyon
+#
+# Mapnik is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2.1 of the License, or (at your option) any later version.
+#
+# This library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public
+# License along with this library; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+# $Id$
+
+from common import Version
+from exceptions import OGCException, ServerConfigurationError
+from wms111 import ServiceHandler as ServiceHandler111
+from wms130 import ServiceHandler as ServiceHandler130
+from mapnik import Style, Layer
+
+def ServiceHandlerFactory(conf, mapfactory, onlineresource, version):
+
+    if not version:
+        version = Version('1.3.0')
+    else:
+        version = Version(version)
+    if version >= '1.3.0':
+        return ServiceHandler130(conf, mapfactory, onlineresource)
+    else:
+        return ServiceHandler111(conf, mapfactory, onlineresource)
+
+class BaseWMSFactory:
+    def __init__(self):
+        self.layers = {}
+        self.styles = {}
+
+    def register_layer(self, layer, extrastyles=()):
+        layername = layer.name()
+        if not layername:
+            raise ServerConfigurationError('Attempted to register an unnamed layer.')
+        self.layers[layername] = layer
+        if isinstance(extrastyles, tuple):
+            layer.wmsextrastyles = extrastyles
+        else:
+            raise ServerConfigurationError('Layer "%s" was passed an invalid list of extra styles.  List must be a tuple of strings.' % layername)
+
+    def register_style(self, name, style):
+        if not name:
+            raise ServerConfigurationError('Attempted to register a style without providing a name.')
+        if not isinstance(style, Style):
+            raise ServerConfigurationError('Bad style object passed to register_style() for style "%s".' % name)
+        self.styles[name] = style
+
+    def finalize(self):
+        if len(self.layers) == 0:
+            raise ServerConfigurationError('No layers defined!')
+        if len(self.styles) == 0:
+            raise ServerConfigurationError('No styles defined!')
+        for layer in self.layers.values():
+            for style in list(layer.styles) + list(layer.wmsextrastyles):
+                if style not in self.styles.keys():
+                    raise ServerConfigurationError('Layer "%s" refers to undefined style "%s".' % (layer.name(), style))



From pavlenko at berlios.de  Tue May 30 23:59:47 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Tue, 30 May 2006 23:59:47 +0200
Subject: [Mapnik-svn] r278 - trunk/src
Message-ID: <200605302159.k4ULxlsS000928@sheep.berlios.de>

Author: pavlenko
Date: 2006-05-30 23:59:47 +0200 (Tue, 30 May 2006)
New Revision: 278

Modified:
   trunk/src/layer.cpp
Log:
corrected operator=



Modified: trunk/src/layer.cpp
===================================================================
--- trunk/src/layer.cpp	2006-05-30 21:59:06 UTC (rev 277)
+++ trunk/src/layer.cpp	2006-05-30 21:59:47 UTC (rev 278)
@@ -93,7 +93,7 @@
         maxZoom_=rhs.maxZoom_;
         active_=rhs.active_;
         selectable_=rhs.selectable_;
-        //ds_=rhs.ds_;
+        ds_=rhs.ds_;
         styles_=rhs.styles_;
         selection_style_=rhs.selection_style_;
     }



From pavlenko at berlios.de  Wed May 31 23:25:22 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Wed, 31 May 2006 23:25:22 +0200
Subject: [Mapnik-svn] r279 - in trunk: bindings/python include
Message-ID: <200605312125.k4VLPM0g020006@sheep.berlios.de>

Author: pavlenko
Date: 2006-05-31 23:25:21 +0200 (Wed, 31 May 2006)
New Revision: 279

Modified:
   trunk/bindings/python/mapnik_line_symbolizer.cpp
   trunk/bindings/python/mapnik_point_symbolizer.cpp
   trunk/bindings/python/mapnik_polygon_symbolizer.cpp
   trunk/bindings/python/mapnik_raster_symbolizer.cpp
   trunk/bindings/python/mapnik_rule.cpp
   trunk/bindings/python/mapnik_stroke.cpp
   trunk/include/line_symbolizer.hpp
   trunk/include/stroke.hpp
Log:
1. exposed fill_opacity property in PolygonSymbolizer
2. added default ctors to {Point,Line,Polygon}Symbolizers 



Modified: trunk/bindings/python/mapnik_line_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_line_symbolizer.cpp	2006-05-30 21:59:47 UTC (rev 278)
+++ trunk/bindings/python/mapnik_line_symbolizer.cpp	2006-05-31 21:25:21 UTC (rev 279)
@@ -32,10 +32,13 @@
 {
     using namespace boost::python;
     
-    class_<line_symbolizer>("LineSymbolizer",init<stroke const&>("TODO"))
-	.def(init<Color const& ,float>())
-	.add_property("stroke",make_function
-		      (&line_symbolizer::get_stroke,return_value_policy<reference_existing_object>()),
-		      &line_symbolizer::set_stroke)
+    class_<line_symbolizer>("LineSymbolizer",
+                            init<>("Default LineSymbolizer - 1px solid black"))
+        .def(init<stroke const&>("TODO"))
+        .def(init<Color const& ,float>())
+        .add_property("stroke",make_function
+                      (&line_symbolizer::get_stroke,
+                       return_value_policy<reference_existing_object>()),
+                      &line_symbolizer::set_stroke)
 	;    
 }

Modified: trunk/bindings/python/mapnik_point_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_point_symbolizer.cpp	2006-05-30 21:59:47 UTC (rev 278)
+++ trunk/bindings/python/mapnik_point_symbolizer.cpp	2006-05-31 21:25:21 UTC (rev 279)
@@ -30,8 +30,10 @@
 {
     using namespace boost::python;
     
-    class_<point_symbolizer>("PointSymbolizer",init<std::string const&,
-			     std::string const&,unsigned,unsigned>("TODO"))
-	;
+    class_<point_symbolizer>("PointSymbolizer",
+                             init<>("Default Point Symbolizer - 4x4 black square"))
+        .def (init<std::string const&,
+              std::string const&,unsigned,unsigned>("TODO"))
+        ;
     
 }

Modified: trunk/bindings/python/mapnik_polygon_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_polygon_symbolizer.cpp	2006-05-30 21:59:47 UTC (rev 278)
+++ trunk/bindings/python/mapnik_polygon_symbolizer.cpp	2006-05-31 21:25:21 UTC (rev 279)
@@ -32,11 +32,15 @@
     using namespace boost::python;
     
     class_<polygon_symbolizer>("PolygonSymbolizer",
-				    init<Color const&>("TODO"))
-	.add_property("fill",make_function
-		      (&polygon_symbolizer::get_fill,
-		       return_value_policy<reference_existing_object>()),
-		      &polygon_symbolizer::set_fill)
-	;    
+				    init<>("Default PolygonSymbolizer - solid fill grey"))
+        .def(init<Color const&>("TODO"))
+        .add_property("fill",make_function
+                      (&polygon_symbolizer::get_fill,
+                       return_value_policy<reference_existing_object>()),
+                      &polygon_symbolizer::set_fill)
+        .add_property("fill_opacity",
+                      &polygon_symbolizer::get_opacity,
+                      &polygon_symbolizer::set_opacity)
+        ;    
 
 }

Modified: trunk/bindings/python/mapnik_raster_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_raster_symbolizer.cpp	2006-05-30 21:59:47 UTC (rev 278)
+++ trunk/bindings/python/mapnik_raster_symbolizer.cpp	2006-05-31 21:25:21 UTC (rev 279)
@@ -31,6 +31,6 @@
     using namespace boost::python;
     
     class_<raster_symbolizer>("RasterSymbolizer",
-				    init<>("TODO"))
+				    init<>("Default ctor"))
 	;    
 }

Modified: trunk/bindings/python/mapnik_rule.cpp
===================================================================
--- trunk/bindings/python/mapnik_rule.cpp	2006-05-30 21:59:47 UTC (rev 278)
+++ trunk/bindings/python/mapnik_rule.cpp	2006-05-31 21:25:21 UTC (rev 279)
@@ -59,28 +59,28 @@
     	;
     
     class_<rule_type>("Rule",init<>("default constructor"))
-	.def(init<std::string const&,
-	     boost::python::optional<std::string const&,double,double> >())
-	.add_property("name",make_function
-		      (&rule_type::get_name,
-		       return_value_policy<copy_const_reference>()),
-		      &rule_type::set_name)
-	.add_property("title",make_function
-		      (&rule_type::get_title,return_value_policy<copy_const_reference>()),
-		      &rule_type::set_title)
-	.add_property("abstract",make_function
-		      (&rule_type::get_abstract,return_value_policy<copy_const_reference>()),
-		      &rule_type::set_abstract)
-	.add_property("filter",make_function
-		      (&rule_type::get_filter,return_value_policy<copy_const_reference>()),
-		      &rule_type::set_filter)
-	.add_property("min_scale",&rule_type::get_min_scale,&rule_type::set_min_scale)
-	.add_property("max_scale",&rule_type::get_max_scale,&rule_type::set_max_scale)
-	.def("set_else",&rule_type::set_else)
-	.def("has_else",&rule_type::has_else_filter)
-	.def("active",&rule_type::active)
-	.add_property("symbols",make_function
-		      (&rule_type::get_symbolizers,return_value_policy<reference_existing_object>()))
-	;
+        .def(init<std::string const&,
+             boost::python::optional<std::string const&,double,double> >())
+        .add_property("name",make_function
+                      (&rule_type::get_name,
+                       return_value_policy<copy_const_reference>()),
+                      &rule_type::set_name)
+        .add_property("title",make_function
+                      (&rule_type::get_title,return_value_policy<copy_const_reference>()),
+                      &rule_type::set_title)
+        .add_property("abstract",make_function
+                      (&rule_type::get_abstract,return_value_policy<copy_const_reference>()),
+                      &rule_type::set_abstract)
+        .add_property("filter",make_function
+                      (&rule_type::get_filter,return_value_policy<copy_const_reference>()),
+                      &rule_type::set_filter)
+        .add_property("min_scale",&rule_type::get_min_scale,&rule_type::set_min_scale)
+        .add_property("max_scale",&rule_type::get_max_scale,&rule_type::set_max_scale)
+        .def("set_else",&rule_type::set_else)
+        .def("has_else",&rule_type::has_else_filter)
+        .def("active",&rule_type::active)
+        .add_property("symbols",make_function
+                      (&rule_type::get_symbolizers,return_value_policy<reference_existing_object>()))
+        ;
 }
 

Modified: trunk/bindings/python/mapnik_stroke.cpp
===================================================================
--- trunk/bindings/python/mapnik_stroke.cpp	2006-05-30 21:59:47 UTC (rev 278)
+++ trunk/bindings/python/mapnik_stroke.cpp	2006-05-31 21:25:21 UTC (rev 279)
@@ -30,26 +30,26 @@
     using namespace boost::python;
 
     enum_<line_cap_e>("line_cap")
-	.value("BUTT_CAP",BUTT_CAP)
-	.value("SQUARE_CAP",SQUARE_CAP)
-	.value("ROUND_CAP",ROUND_CAP)
-	;
+        .value("BUTT_CAP",BUTT_CAP)
+        .value("SQUARE_CAP",SQUARE_CAP)
+        .value("ROUND_CAP",ROUND_CAP)
+        ;
     enum_<line_join_e>("line_join")
-	.value("MITER_JOIN",MITER_JOIN)
-	.value("MITER_REVERT_JOIN",MITER_REVERT_JOIN)
-	.value("ROUND_JOIN",ROUND_JOIN)
-	.value("BEVEL_JOIN",BEVEL_JOIN)
-	;
+        .value("MITER_JOIN",MITER_JOIN)
+        .value("MITER_REVERT_JOIN",MITER_REVERT_JOIN)
+        .value("ROUND_JOIN",ROUND_JOIN)
+        .value("BEVEL_JOIN",BEVEL_JOIN)
+        ;
 
     class_<stroke>("Stroke",init<>())
-	.def(init<Color,float>())
-	.add_property("color",make_function
-		      (&stroke::get_color,return_value_policy<reference_existing_object>()),
-		      &stroke::set_color)
-	.add_property("width",&stroke::get_width,&stroke::set_width) 
-	.add_property("opacity",&stroke::get_opacity,&stroke::set_opacity)
-	.add_property("line_cap",&stroke::get_line_cap,&stroke::set_line_cap)
-	.add_property("line_join",&stroke::get_line_join,&stroke::set_line_join)
-	.def("add_dash",&stroke::add_dash)
-	;
+        .def(init<Color,float>())
+        .add_property("color",make_function
+                      (&stroke::get_color,return_value_policy<reference_existing_object>()),
+                      &stroke::set_color)
+        .add_property("width",&stroke::get_width,&stroke::set_width) 
+        .add_property("opacity",&stroke::get_opacity,&stroke::set_opacity)
+        .add_property("line_cap",&stroke::get_line_cap,&stroke::set_line_cap)
+        .add_property("line_join",&stroke::get_line_join,&stroke::set_line_join)
+        .def("add_dash",&stroke::add_dash)
+        ;
 }

Modified: trunk/include/line_symbolizer.hpp
===================================================================
--- trunk/include/line_symbolizer.hpp	2006-05-30 21:59:47 UTC (rev 278)
+++ trunk/include/line_symbolizer.hpp	2006-05-31 21:25:21 UTC (rev 279)
@@ -30,19 +30,22 @@
 {
     struct MAPNIK_DECL line_symbolizer
     {
-	line_symbolizer(stroke const& stroke)
-	    : stroke_(stroke) {}
+        explicit line_symbolizer()
+            : stroke_() {}
+        
+        line_symbolizer(stroke const& stroke)
+            : stroke_(stroke) {}
 	
-	line_symbolizer(const Color& pen,float width=1.0)
-	    : stroke_(pen,width) {}
-	stroke const& get_stroke() const
-	{
-	    return stroke_;
-	}
-	void set_stroke(stroke const& stroke)
-	{
-	    stroke_ = stroke;
-	}
+        line_symbolizer(const Color& pen,float width=1.0)
+            : stroke_(pen,width) {}
+        stroke const& get_stroke() const
+        {
+            return stroke_;
+        }
+        void set_stroke(stroke const& stroke)
+        {
+            stroke_ = stroke;
+        }
 
     private:
 		stroke stroke_;

Modified: trunk/include/stroke.hpp
===================================================================
--- trunk/include/stroke.hpp	2006-05-30 21:59:47 UTC (rev 278)
+++ trunk/include/stroke.hpp	2006-05-31 21:25:21 UTC (rev 279)
@@ -57,7 +57,7 @@
         line_join_e line_join_;
         dash_array dash_;	
     public:
-        stroke() 
+        explicit stroke() 
             : c_(0,0,0),
               width_(1.0),
               opacity_(1.0),



