<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Mapnik-svn] r368 - trunk/agg/include
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/mapnik-svn/2006-November/index.html" >
   <LINK REL="made" HREF="mailto:mapnik-svn%40lists.berlios.de?Subject=Re%3A%20%5BMapnik-svn%5D%20r368%20-%20trunk/agg/include&In-Reply-To=%3C200611092348.kA9NmCGN008055%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000252.html">
   <LINK REL="Next"  HREF="000254.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mapnik-svn] r368 - trunk/agg/include</H1>
    <B>pavlenko at mail.berlios.de</B> 
    <A HREF="mailto:mapnik-svn%40lists.berlios.de?Subject=Re%3A%20%5BMapnik-svn%5D%20r368%20-%20trunk/agg/include&In-Reply-To=%3C200611092348.kA9NmCGN008055%40sheep.berlios.de%3E"
       TITLE="[Mapnik-svn] r368 - trunk/agg/include">pavlenko at mail.berlios.de
       </A><BR>
    <I>Fri Nov 10 00:48:12 CET 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000252.html">[Mapnik-svn] r367 - in trunk: agg/include agg/src demo/python src
</A></li>
        <LI>Next message: <A HREF="000254.html">[Mapnik-svn] r369 - trunk/include/mapnik
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#253">[ date ]</a>
              <a href="thread.html#253">[ thread ]</a>
              <a href="subject.html#253">[ subject ]</a>
              <a href="author.html#253">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: pavlenko
Date: 2006-11-10 00:48:09 +0100 (Fri, 10 Nov 2006)
New Revision: 368

Added:
   trunk/agg/include/agg_blur.h
   trunk/agg/include/agg_gradient_lut.h
   trunk/agg/include/agg_pixfmt_transposer.h
Log:
added missing agg headers

Added: trunk/agg/include/agg_blur.h
===================================================================
--- trunk/agg/include/agg_blur.h	2006-11-09 23:44:34 UTC (rev 367)
+++ trunk/agg/include/agg_blur.h	2006-11-09 23:48:09 UTC (rev 368)
@@ -0,0 +1,1294 @@
+//----------------------------------------------------------------------------
+// Anti-Grain Geometry - Version 2.4
+// Copyright (C) 2002-2005 Maxim Shemanarev (<A HREF="http://www.antigrain.com">http://www.antigrain.com</A>)
+//
+// Permission to copy, use, modify, sell and distribute this software 
+// is granted provided this copyright notice appears in all copies. 
+// This software is provided &quot;as is&quot; without express or implied
+// warranty, and with no claim as to its suitability for any purpose.
+//
+//----------------------------------------------------------------------------
+// Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/mapnik-svn">mcseem at antigrain.com</A>
+//          <A HREF="https://lists.berlios.de/mailman/listinfo/mapnik-svn">mcseemagg at yahoo.com</A>
+//          <A HREF="http://www.antigrain.com">http://www.antigrain.com</A>
+//----------------------------------------------------------------------------
+//
+// The Stack Blur Algorithm was invented by Mario Klingemann, 
+// <A HREF="https://lists.berlios.de/mailman/listinfo/mapnik-svn">mario at quasimondo.com</A> and described here:
+// <A HREF="http://incubator.quasimondo.com/processing/fast_blur_deluxe.php">http://incubator.quasimondo.com/processing/fast_blur_deluxe.php</A>
+// (search phrase &quot;Stackblur: Fast But Goodlooking&quot;). 
+// The major improvement is that there's no more division table
+// that was very expensive to create for large blur radii. Insted, 
+// for 8-bit per channel and radius not exceeding 254 the division is 
+// replaced by multiplication and shift. 
+//
+//----------------------------------------------------------------------------
+
+#ifndef AGG_BLUR_INCLUDED
+#define AGG_BLUR_INCLUDED
+
+#include &quot;agg_array.h&quot;
+#include &quot;agg_pixfmt_transposer.h&quot;
+
+namespace agg
+{
+
+    template&lt;class T&gt; struct stack_blur_tables
+    {
+        static int16u const g_stack_blur8_mul[255];
+        static int8u  const g_stack_blur8_shr[255];
+    };
+
+    //------------------------------------------------------------------------
+    template&lt;class T&gt; 
+    int16u const stack_blur_tables&lt;T&gt;::g_stack_blur8_mul[255] = 
+    {
+        512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,
+        454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,
+        482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,
+        437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,
+        497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,
+        320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,
+        446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,
+        329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,
+        505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,
+        399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,
+        324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,
+        268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,
+        451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,
+        385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,
+        332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,
+        289,287,285,282,280,278,275,273,271,269,267,265,263,261,259
+    };
+
+    //------------------------------------------------------------------------
+    template&lt;class T&gt; 
+    int8u const stack_blur_tables&lt;T&gt;::g_stack_blur8_shr[255] = 
+    {
+          9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 
+         17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 
+         19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,
+         20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,
+         21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
+         21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 
+         22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
+         22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 
+         23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
+         23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
+         23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
+         23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 
+         24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+         24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+         24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+         24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24
+    };
+
+
+
+    //==============================================================stack_blur
+    template&lt;class ColorT, class CalculatorT&gt; class stack_blur
+    {
+    public:
+        typedef ColorT      color_type;
+        typedef CalculatorT calculator_type;
+
+        //--------------------------------------------------------------------
+        template&lt;class Img&gt; void blur_x(Img&amp; img, unsigned radius)
+        {
+            if(radius &lt; 1) return;
+
+            unsigned x, y, xp, i;
+            unsigned stack_ptr;
+            unsigned stack_start;
+
+            color_type      pix;
+            color_type*     stack_pix;
+            calculator_type sum;
+            calculator_type sum_in;
+            calculator_type sum_out;
+
+            unsigned w   = img.width();
+            unsigned h   = img.height();
+            unsigned wm  = w - 1;
+            unsigned div = radius * 2 + 1;
+
+            unsigned div_sum = (radius + 1) * (radius + 1);
+            unsigned mul_sum = 0;
+            unsigned shr_sum = 0;
+            unsigned max_val = color_type::base_mask;
+
+            if(max_val &lt;= 255 &amp;&amp; radius &lt; 255)
+            {
+                mul_sum = stack_blur_tables&lt;int&gt;::g_stack_blur8_mul[radius];
+                shr_sum = stack_blur_tables&lt;int&gt;::g_stack_blur8_shr[radius];
+            }
+
+            m_buf.allocate(w, 128);
+            m_stack.allocate(div, 32);
+
+            for(y = 0; y &lt; h; y++)
+            {
+                sum.clear();
+                sum_in.clear();
+                sum_out.clear();
+
+                pix = img.pixel(0, y);
+                for(i = 0; i &lt;= radius; i++)
+                {
+                    m_stack[i] = pix;
+                    sum.add(pix, i + 1);
+                    sum_out.add(pix);
+                }
+                for(i = 1; i &lt;= radius; i++)
+                {
+                    pix = img.pixel((i &gt; wm) ? wm : i, y);
+                    m_stack[i + radius] = pix;
+                    sum.add(pix, radius + 1 - i);
+                    sum_in.add(pix);
+                }
+
+                stack_ptr = radius;
+                for(x = 0; x &lt; w; x++)
+                {
+                    if(mul_sum) sum.calc_pix(m_buf[x], mul_sum, shr_sum);
+                    else        sum.calc_pix(m_buf[x], div_sum);
+
+                    sum.sub(sum_out);
+           
+                    stack_start = stack_ptr + div - radius;
+                    if(stack_start &gt;= div) stack_start -= div;
+                    stack_pix = &amp;m_stack[stack_start];
+
+                    sum_out.sub(*stack_pix);
+
+                    xp = x + radius + 1;
+                    if(xp &gt; wm) xp = wm;
+                    pix = img.pixel(xp, y);
+            
+                    *stack_pix = pix;
+            
+                    sum_in.add(pix);
+                    sum.add(sum_in);
+            
+                    ++stack_ptr;
+                    if(stack_ptr &gt;= div) stack_ptr = 0;
+                    stack_pix = &amp;m_stack[stack_ptr];
+
+                    sum_out.add(*stack_pix);
+                    sum_in.sub(*stack_pix);
+                }
+                img.copy_color_hspan(0, y, w, &amp;m_buf[0]);
+            }
+        }
+
+        //--------------------------------------------------------------------
+        template&lt;class Img&gt; void blur_y(Img&amp; img, unsigned radius)
+        {
+            pixfmt_transposer&lt;Img&gt; img2(img);
+            blur_x(img2, radius);
+        }
+
+        //--------------------------------------------------------------------
+        template&lt;class Img&gt; void blur(Img&amp; img, unsigned radius)
+        {
+            blur_x(img, radius);
+            pixfmt_transposer&lt;Img&gt; img2(img);
+            blur_x(img2, radius);
+        }
+
+    private:
+        pod_vector&lt;color_type&gt; m_buf;
+        pod_vector&lt;color_type&gt; m_stack;
+    };
+
+    //====================================================stack_blur_calc_rgba
+    template&lt;class T=unsigned&gt; struct stack_blur_calc_rgba
+    {
+        typedef T value_type;
+        value_type r,g,b,a;
+
+        AGG_INLINE void clear() 
+        { 
+            r = g = b = a = 0; 
+        }
+
+        template&lt;class ArgT&gt; AGG_INLINE void add(const ArgT&amp; v)
+        {
+            r += v.r;
+            g += v.g;
+            b += v.b;
+            a += v.a;
+        }
+
+        template&lt;class ArgT&gt; AGG_INLINE void add(const ArgT&amp; v, unsigned k)
+        {
+            r += v.r * k;
+            g += v.g * k;
+            b += v.b * k;
+            a += v.a * k;
+        }
+
+        template&lt;class ArgT&gt; AGG_INLINE void sub(const ArgT&amp; v)
+        {
+            r -= v.r;
+            g -= v.g;
+            b -= v.b;
+            a -= v.a;
+        }
+
+        template&lt;class ArgT&gt; AGG_INLINE void calc_pix(ArgT&amp; v, unsigned div)
+        {
+            typedef typename ArgT::value_type value_type;
+            v.r = value_type(r / div);
+            v.g = value_type(g / div);
+            v.b = value_type(b / div);
+            v.a = value_type(a / div);
+        }
+
+        template&lt;class ArgT&gt; 
+        AGG_INLINE void calc_pix(ArgT&amp; v, unsigned mul, unsigned shr)
+        {
+            typedef typename ArgT::value_type value_type;
+            v.r = value_type((r * mul) &gt;&gt; shr);
+            v.g = value_type((g * mul) &gt;&gt; shr);
+            v.b = value_type((b * mul) &gt;&gt; shr);
+            v.a = value_type((a * mul) &gt;&gt; shr);
+        }
+    };
+
+
+    //=====================================================stack_blur_calc_rgb
+    template&lt;class T=unsigned&gt; struct stack_blur_calc_rgb
+    {
+        typedef T value_type;
+        value_type r,g,b;
+
+        AGG_INLINE void clear() 
+        { 
+            r = g = b = 0; 
+        }
+
+        template&lt;class ArgT&gt; AGG_INLINE void add(const ArgT&amp; v)
+        {
+            r += v.r;
+            g += v.g;
+            b += v.b;
+        }
+
+        template&lt;class ArgT&gt; AGG_INLINE void add(const ArgT&amp; v, unsigned k)
+        {
+            r += v.r * k;
+            g += v.g * k;
+            b += v.b * k;
+        }
+
+        template&lt;class ArgT&gt; AGG_INLINE void sub(const ArgT&amp; v)
+        {
+            r -= v.r;
+            g -= v.g;
+            b -= v.b;
+        }
+
+        template&lt;class ArgT&gt; AGG_INLINE void calc_pix(ArgT&amp; v, unsigned div)
+        {
+            typedef typename ArgT::value_type value_type;
+            v.r = value_type(r / div);
+            v.g = value_type(g / div);
+            v.b = value_type(b / div);
+        }
+
+        template&lt;class ArgT&gt; 
+        AGG_INLINE void calc_pix(ArgT&amp; v, unsigned mul, unsigned shr)
+        {
+            typedef typename ArgT::value_type value_type;
+            v.r = value_type((r * mul) &gt;&gt; shr);
+            v.g = value_type((g * mul) &gt;&gt; shr);
+            v.b = value_type((b * mul) &gt;&gt; shr);
+        }
+    };
+
+
+    //====================================================stack_blur_calc_gray
+    template&lt;class T=unsigned&gt; struct stack_blur_calc_gray
+    {
+        typedef T value_type;
+        value_type v;
+
+        AGG_INLINE void clear() 
+        { 
+            v = 0; 
+        }
+
+        template&lt;class ArgT&gt; AGG_INLINE void add(const ArgT&amp; a)
+        {
+            v += a.v;
+        }
+
+        template&lt;class ArgT&gt; AGG_INLINE void add(const ArgT&amp; a, unsigned k)
+        {
+            v += a.v * k;
+        }
+
+        template&lt;class ArgT&gt; AGG_INLINE void sub(const ArgT&amp; a)
+        {
+            v -= a.v;
+        }
+
+        template&lt;class ArgT&gt; AGG_INLINE void calc_pix(ArgT&amp; a, unsigned div)
+        {
+            typedef typename ArgT::value_type value_type;
+            a.v = value_type(v / div);
+        }
+
+        template&lt;class ArgT&gt; 
+        AGG_INLINE void calc_pix(ArgT&amp; a, unsigned mul, unsigned shr)
+        {
+            typedef typename ArgT::value_type value_type;
+            a.v = value_type((v * mul) &gt;&gt; shr);
+        }
+    };
+
+
+
+    //========================================================stack_blur_gray8
+    template&lt;class Img&gt; 
+    void stack_blur_gray8(Img&amp; img, unsigned rx, unsigned ry)
+    {
+        unsigned x, y, xp, yp, i;
+        unsigned stack_ptr;
+        unsigned stack_start;
+
+        const int8u* src_pix_ptr;
+              int8u* dst_pix_ptr;
+        unsigned pix;
+        unsigned stack_pix;
+        unsigned sum;
+        unsigned sum_in;
+        unsigned sum_out;
+
+        unsigned w   = img.width();
+        unsigned h   = img.height();
+        unsigned wm  = w - 1;
+        unsigned hm  = h - 1;
+
+        unsigned div;
+        unsigned mul_sum;
+        unsigned shr_sum;
+
+        pod_vector&lt;int8u&gt; stack;
+
+        if(rx &gt; 0)
+        {
+            if(rx &gt; 254) rx = 254;
+            div = rx * 2 + 1;
+            mul_sum = stack_blur_tables&lt;int&gt;::g_stack_blur8_mul[rx];
+            shr_sum = stack_blur_tables&lt;int&gt;::g_stack_blur8_shr[rx];
+            stack.allocate(div);
+
+            for(y = 0; y &lt; h; y++)
+            {
+                sum = sum_in = sum_out = 0;
+
+                src_pix_ptr = img.pix_ptr(0, y);
+                pix = *src_pix_ptr;
+                for(i = 0; i &lt;= rx; i++)
+                {
+                    stack[i] = pix;
+                    sum     += pix * (i + 1);
+                    sum_out += pix;
+                }
+                for(i = 1; i &lt;= rx; i++)
+                {
+                    if(i &lt;= wm) src_pix_ptr += Img::pix_step; 
+                    pix = *src_pix_ptr; 
+                    stack[i + rx] = pix;
+                    sum    += pix * (rx + 1 - i);
+                    sum_in += pix;
+                }
+
+                stack_ptr = rx;
+                xp = rx;
+                if(xp &gt; wm) xp = wm;
+                src_pix_ptr = img.pix_ptr(xp, y);
+                dst_pix_ptr = img.pix_ptr(0, y);
+                for(x = 0; x &lt; w; x++)
+                {
+                    *dst_pix_ptr = (sum * mul_sum) &gt;&gt; shr_sum;
+                    dst_pix_ptr += Img::pix_step;
+
+                    sum -= sum_out;
+       
+                    stack_start = stack_ptr + div - rx;
+                    if(stack_start &gt;= div) stack_start -= div;
+                    sum_out -= stack[stack_start];
+
+                    if(xp &lt; wm) 
+                    {
+                        src_pix_ptr += Img::pix_step;
+                        pix = *src_pix_ptr;
+                        ++xp;
+                    }
+        
+                    stack[stack_start] = pix;
+        
+                    sum_in += pix;
+                    sum    += sum_in;
+        
+                    ++stack_ptr;
+                    if(stack_ptr &gt;= div) stack_ptr = 0;
+                    stack_pix = stack[stack_ptr];
+
+                    sum_out += stack_pix;
+                    sum_in  -= stack_pix;
+                }
+            }
+        }
+
+        if(ry &gt; 0)
+        {
+            if(ry &gt; 254) ry = 254;
+            div = ry * 2 + 1;
+            mul_sum = stack_blur_tables&lt;int&gt;::g_stack_blur8_mul[ry];
+            shr_sum = stack_blur_tables&lt;int&gt;::g_stack_blur8_shr[ry];
+            stack.allocate(div);
+
+            int stride = img.stride();
+            for(x = 0; x &lt; w; x++)
+            {
+                sum = sum_in = sum_out = 0;
+
+                src_pix_ptr = img.pix_ptr(x, 0);
+                pix = *src_pix_ptr;
+                for(i = 0; i &lt;= ry; i++)
+                {
+                    stack[i] = pix;
+                    sum     += pix * (i + 1);
+                    sum_out += pix;
+                }
+                for(i = 1; i &lt;= ry; i++)
+                {
+                    if(i &lt;= hm) src_pix_ptr += stride; 
+                    pix = *src_pix_ptr; 
+                    stack[i + ry] = pix;
+                    sum    += pix * (ry + 1 - i);
+                    sum_in += pix;
+                }
+
+                stack_ptr = ry;
+                yp = ry;
+                if(yp &gt; hm) yp = hm;
+                src_pix_ptr = img.pix_ptr(x, yp);
+                dst_pix_ptr = img.pix_ptr(x, 0);
+                for(y = 0; y &lt; h; y++)
+                {
+                    *dst_pix_ptr = (sum * mul_sum) &gt;&gt; shr_sum;
+                    dst_pix_ptr += stride;
+
+                    sum -= sum_out;
+       
+                    stack_start = stack_ptr + div - ry;
+                    if(stack_start &gt;= div) stack_start -= div;
+                    sum_out -= stack[stack_start];
+
+                    if(yp &lt; hm) 
+                    {
+                        src_pix_ptr += stride;
+                        pix = *src_pix_ptr;
+                        ++yp;
+                    }
+        
+                    stack[stack_start] = pix;
+        
+                    sum_in += pix;
+                    sum    += sum_in;
+        
+                    ++stack_ptr;
+                    if(stack_ptr &gt;= div) stack_ptr = 0;
+                    stack_pix = stack[stack_ptr];
+
+                    sum_out += stack_pix;
+                    sum_in  -= stack_pix;
+                }
+            }
+        }
+    }
+
+
+
+    //========================================================stack_blur_rgb24
+    template&lt;class Img&gt; 
+    void stack_blur_rgb24(Img&amp; img, unsigned rx, unsigned ry)
+    {
+        typedef typename Img::color_type color_type;
+        typedef typename Img::order_type order_type;
+        enum order_e 
+        { 
+            R = order_type::R, 
+            G = order_type::G, 
+            B = order_type::B 
+        };
+
+        unsigned x, y, xp, yp, i;
+        unsigned stack_ptr;
+        unsigned stack_start;
+
+        const int8u* src_pix_ptr;
+              int8u* dst_pix_ptr;
+        color_type*  stack_pix_ptr;
+
+        unsigned sum_r;
+        unsigned sum_g;
+        unsigned sum_b;
+        unsigned sum_in_r;
+        unsigned sum_in_g;
+        unsigned sum_in_b;
+        unsigned sum_out_r;
+        unsigned sum_out_g;
+        unsigned sum_out_b;
+
+        unsigned w   = img.width();
+        unsigned h   = img.height();
+        unsigned wm  = w - 1;
+        unsigned hm  = h - 1;
+
+        unsigned div;
+        unsigned mul_sum;
+        unsigned shr_sum;
+
+        pod_vector&lt;color_type&gt; stack;
+
+        if(rx &gt; 0)
+        {
+            if(rx &gt; 254) rx = 254;
+            div = rx * 2 + 1;
+            mul_sum = stack_blur_tables&lt;int&gt;::g_stack_blur8_mul[rx];
+            shr_sum = stack_blur_tables&lt;int&gt;::g_stack_blur8_shr[rx];
+            stack.allocate(div);
+
+            for(y = 0; y &lt; h; y++)
+            {
+                sum_r = 
+                sum_g = 
+                sum_b = 
+                sum_in_r = 
+                sum_in_g = 
+                sum_in_b = 
+                sum_out_r = 
+                sum_out_g = 
+                sum_out_b = 0;
+
+                src_pix_ptr = img.pix_ptr(0, y);
+                for(i = 0; i &lt;= rx; i++)
+                {
+                    stack_pix_ptr    = &amp;stack[i];
+                    stack_pix_ptr-&gt;r = src_pix_ptr[R];
+                    stack_pix_ptr-&gt;g = src_pix_ptr[G];
+                    stack_pix_ptr-&gt;b = src_pix_ptr[B];
+                    sum_r           += src_pix_ptr[R] * (i + 1);
+                    sum_g           += src_pix_ptr[G] * (i + 1);
+                    sum_b           += src_pix_ptr[B] * (i + 1);
+                    sum_out_r       += src_pix_ptr[R];
+                    sum_out_g       += src_pix_ptr[G];
+                    sum_out_b       += src_pix_ptr[B];
+                }
+                for(i = 1; i &lt;= rx; i++)
+                {
+                    if(i &lt;= wm) src_pix_ptr += Img::pix_width; 
+                    stack_pix_ptr = &amp;stack[i + rx];
+                    stack_pix_ptr-&gt;r = src_pix_ptr[R];
+                    stack_pix_ptr-&gt;g = src_pix_ptr[G];
+                    stack_pix_ptr-&gt;b = src_pix_ptr[B];
+                    sum_r           += src_pix_ptr[R] * (rx + 1 - i);
+                    sum_g           += src_pix_ptr[G] * (rx + 1 - i);
+                    sum_b           += src_pix_ptr[B] * (rx + 1 - i);
+                    sum_in_r        += src_pix_ptr[R];
+                    sum_in_g        += src_pix_ptr[G];
+                    sum_in_b        += src_pix_ptr[B];
+                }
+
+                stack_ptr = rx;
+                xp = rx;
+                if(xp &gt; wm) xp = wm;
+                src_pix_ptr = img.pix_ptr(xp, y);
+                dst_pix_ptr = img.pix_ptr(0, y);
+                for(x = 0; x &lt; w; x++)
+                {
+                    dst_pix_ptr[R] = (sum_r * mul_sum) &gt;&gt; shr_sum;
+                    dst_pix_ptr[G] = (sum_g * mul_sum) &gt;&gt; shr_sum;
+                    dst_pix_ptr[B] = (sum_b * mul_sum) &gt;&gt; shr_sum;
+                    dst_pix_ptr   += Img::pix_width;
+
+                    sum_r -= sum_out_r;
+                    sum_g -= sum_out_g;
+                    sum_b -= sum_out_b;
+       
+                    stack_start = stack_ptr + div - rx;
+                    if(stack_start &gt;= div) stack_start -= div;
+                    stack_pix_ptr = &amp;stack[stack_start];
+
+                    sum_out_r -= stack_pix_ptr-&gt;r;
+                    sum_out_g -= stack_pix_ptr-&gt;g;
+                    sum_out_b -= stack_pix_ptr-&gt;b;
+
+                    if(xp &lt; wm) 
+                    {
+                        src_pix_ptr += Img::pix_width;
+                        ++xp;
+                    }
+        
+                    stack_pix_ptr-&gt;r = src_pix_ptr[R];
+                    stack_pix_ptr-&gt;g = src_pix_ptr[G];
+                    stack_pix_ptr-&gt;b = src_pix_ptr[B];
+        
+                    sum_in_r += src_pix_ptr[R];
+                    sum_in_g += src_pix_ptr[G];
+                    sum_in_b += src_pix_ptr[B];
+                    sum_r    += sum_in_r;
+                    sum_g    += sum_in_g;
+                    sum_b    += sum_in_b;
+        
+                    ++stack_ptr;
+                    if(stack_ptr &gt;= div) stack_ptr = 0;
+                    stack_pix_ptr = &amp;stack[stack_ptr];
+
+                    sum_out_r += stack_pix_ptr-&gt;r;
+                    sum_out_g += stack_pix_ptr-&gt;g;
+                    sum_out_b += stack_pix_ptr-&gt;b;
+                    sum_in_r  -= stack_pix_ptr-&gt;r;
+                    sum_in_g  -= stack_pix_ptr-&gt;g;
+                    sum_in_b  -= stack_pix_ptr-&gt;b;
+                }
+            }
+        }
+
+        if(ry &gt; 0)
+        {
+            if(ry &gt; 254) ry = 254;
+            div = ry * 2 + 1;
+            mul_sum = stack_blur_tables&lt;int&gt;::g_stack_blur8_mul[ry];
+            shr_sum = stack_blur_tables&lt;int&gt;::g_stack_blur8_shr[ry];
+            stack.allocate(div);
+
+            int stride = img.stride();
+            for(x = 0; x &lt; w; x++)
+            {
+                sum_r = 
+                sum_g = 
+                sum_b = 
+                sum_in_r = 
+                sum_in_g = 
+                sum_in_b = 
+                sum_out_r = 
+                sum_out_g = 
+                sum_out_b = 0;
+
+                src_pix_ptr = img.pix_ptr(x, 0);
+                for(i = 0; i &lt;= ry; i++)
+                {
+                    stack_pix_ptr    = &amp;stack[i];
+                    stack_pix_ptr-&gt;r = src_pix_ptr[R];
+                    stack_pix_ptr-&gt;g = src_pix_ptr[G];
+                    stack_pix_ptr-&gt;b = src_pix_ptr[B];
+                    sum_r           += src_pix_ptr[R] * (i + 1);
+                    sum_g           += src_pix_ptr[G] * (i + 1);
+                    sum_b           += src_pix_ptr[B] * (i + 1);
+                    sum_out_r       += src_pix_ptr[R];
+                    sum_out_g       += src_pix_ptr[G];
+                    sum_out_b       += src_pix_ptr[B];
+                }
+                for(i = 1; i &lt;= ry; i++)
+                {
+                    if(i &lt;= hm) src_pix_ptr += stride; 
+                    stack_pix_ptr = &amp;stack[i + ry];
+                    stack_pix_ptr-&gt;r = src_pix_ptr[R];
+                    stack_pix_ptr-&gt;g = src_pix_ptr[G];
+                    stack_pix_ptr-&gt;b = src_pix_ptr[B];
+                    sum_r           += src_pix_ptr[R] * (ry + 1 - i);
+                    sum_g           += src_pix_ptr[G] * (ry + 1 - i);
+                    sum_b           += src_pix_ptr[B] * (ry + 1 - i);
+                    sum_in_r        += src_pix_ptr[R];
+                    sum_in_g        += src_pix_ptr[G];
+                    sum_in_b        += src_pix_ptr[B];
+                }
+
+                stack_ptr = ry;
+                yp = ry;
+                if(yp &gt; hm) yp = hm;
+                src_pix_ptr = img.pix_ptr(x, yp);
+                dst_pix_ptr = img.pix_ptr(x, 0);
+                for(y = 0; y &lt; h; y++)
+                {
+                    dst_pix_ptr[R] = (sum_r * mul_sum) &gt;&gt; shr_sum;
+                    dst_pix_ptr[G] = (sum_g * mul_sum) &gt;&gt; shr_sum;
+                    dst_pix_ptr[B] = (sum_b * mul_sum) &gt;&gt; shr_sum;
+                    dst_pix_ptr += stride;
+
+                    sum_r -= sum_out_r;
+                    sum_g -= sum_out_g;
+                    sum_b -= sum_out_b;
+       
+                    stack_start = stack_ptr + div - ry;
+                    if(stack_start &gt;= div) stack_start -= div;
+
+                    stack_pix_ptr = &amp;stack[stack_start];
+                    sum_out_r -= stack_pix_ptr-&gt;r;
+                    sum_out_g -= stack_pix_ptr-&gt;g;
+                    sum_out_b -= stack_pix_ptr-&gt;b;
+
+                    if(yp &lt; hm) 
+                    {
+                        src_pix_ptr += stride;
+                        ++yp;
+                    }
+        
+                    stack_pix_ptr-&gt;r = src_pix_ptr[R];
+                    stack_pix_ptr-&gt;g = src_pix_ptr[G];
+                    stack_pix_ptr-&gt;b = src_pix_ptr[B];
+        
+                    sum_in_r += src_pix_ptr[R];
+                    sum_in_g += src_pix_ptr[G];
+                    sum_in_b += src_pix_ptr[B];
+                    sum_r    += sum_in_r;
+                    sum_g    += sum_in_g;
+                    sum_b    += sum_in_b;
+        
+                    ++stack_ptr;
+                    if(stack_ptr &gt;= div) stack_ptr = 0;
+                    stack_pix_ptr = &amp;stack[stack_ptr];
+
+                    sum_out_r += stack_pix_ptr-&gt;r;
+                    sum_out_g += stack_pix_ptr-&gt;g;
+                    sum_out_b += stack_pix_ptr-&gt;b;
+                    sum_in_r  -= stack_pix_ptr-&gt;r;
+                    sum_in_g  -= stack_pix_ptr-&gt;g;
+                    sum_in_b  -= stack_pix_ptr-&gt;b;
+                }
+            }
+        }
+    }
+
+
+
+    //=======================================================stack_blur_rgba32
+    template&lt;class Img&gt; 
+    void stack_blur_rgba32(Img&amp; img, unsigned rx, unsigned ry)
+    {
+        typedef typename Img::color_type color_type;
+        typedef typename Img::order_type order_type;
+        enum order_e 
+        { 
+            R = order_type::R, 
+            G = order_type::G, 
+            B = order_type::B,
+            A = order_type::A 
+        };
+
+        unsigned x, y, xp, yp, i;
+        unsigned stack_ptr;
+        unsigned stack_start;
+
+        const int8u* src_pix_ptr;
+              int8u* dst_pix_ptr;
+        color_type*  stack_pix_ptr;
+
+        unsigned sum_r;
+        unsigned sum_g;
+        unsigned sum_b;
+        unsigned sum_a;
+        unsigned sum_in_r;
+        unsigned sum_in_g;
+        unsigned sum_in_b;
+        unsigned sum_in_a;
+        unsigned sum_out_r;
+        unsigned sum_out_g;
+        unsigned sum_out_b;
+        unsigned sum_out_a;
+
+        unsigned w   = img.width();
+        unsigned h   = img.height();
+        unsigned wm  = w - 1;
+        unsigned hm  = h - 1;
+
+        unsigned div;
+        unsigned mul_sum;
+        unsigned shr_sum;
+
+        pod_vector&lt;color_type&gt; stack;
+
+        if(rx &gt; 0)
+        {
+            if(rx &gt; 254) rx = 254;
+            div = rx * 2 + 1;
+            mul_sum = stack_blur_tables&lt;int&gt;::g_stack_blur8_mul[rx];
+            shr_sum = stack_blur_tables&lt;int&gt;::g_stack_blur8_shr[rx];
+            stack.allocate(div);
+
+            for(y = 0; y &lt; h; y++)
+            {
+                sum_r = 
+                sum_g = 
+                sum_b = 
+                sum_a = 
+                sum_in_r = 
+                sum_in_g = 
+                sum_in_b = 
+                sum_in_a = 
+                sum_out_r = 
+                sum_out_g = 
+                sum_out_b = 
+                sum_out_a = 0;
+
+                src_pix_ptr = img.pix_ptr(0, y);
+                for(i = 0; i &lt;= rx; i++)
+                {
+                    stack_pix_ptr    = &amp;stack[i];
+                    stack_pix_ptr-&gt;r = src_pix_ptr[R];
+                    stack_pix_ptr-&gt;g = src_pix_ptr[G];
+                    stack_pix_ptr-&gt;b = src_pix_ptr[B];
+                    stack_pix_ptr-&gt;a = src_pix_ptr[A];
+                    sum_r           += src_pix_ptr[R] * (i + 1);
+                    sum_g           += src_pix_ptr[G] * (i + 1);
+                    sum_b           += src_pix_ptr[B] * (i + 1);
+                    sum_a           += src_pix_ptr[A] * (i + 1);
+                    sum_out_r       += src_pix_ptr[R];
+                    sum_out_g       += src_pix_ptr[G];
+                    sum_out_b       += src_pix_ptr[B];
+                    sum_out_a       += src_pix_ptr[A];
+                }
+                for(i = 1; i &lt;= rx; i++)
+                {
+                    if(i &lt;= wm) src_pix_ptr += Img::pix_width; 
+                    stack_pix_ptr = &amp;stack[i + rx];
+                    stack_pix_ptr-&gt;r = src_pix_ptr[R];
+                    stack_pix_ptr-&gt;g = src_pix_ptr[G];
+                    stack_pix_ptr-&gt;b = src_pix_ptr[B];
+                    stack_pix_ptr-&gt;a = src_pix_ptr[A];
+                    sum_r           += src_pix_ptr[R] * (rx + 1 - i);
+                    sum_g           += src_pix_ptr[G] * (rx + 1 - i);
+                    sum_b           += src_pix_ptr[B] * (rx + 1 - i);
+                    sum_a           += src_pix_ptr[A] * (rx + 1 - i);
+                    sum_in_r        += src_pix_ptr[R];
+                    sum_in_g        += src_pix_ptr[G];
+                    sum_in_b        += src_pix_ptr[B];
+                    sum_in_a        += src_pix_ptr[A];
+                }
+
+                stack_ptr = rx;
+                xp = rx;
+                if(xp &gt; wm) xp = wm;
+                src_pix_ptr = img.pix_ptr(xp, y);
+                dst_pix_ptr = img.pix_ptr(0, y);
+                for(x = 0; x &lt; w; x++)
+                {
+                    dst_pix_ptr[R] = (sum_r * mul_sum) &gt;&gt; shr_sum;
+                    dst_pix_ptr[G] = (sum_g * mul_sum) &gt;&gt; shr_sum;
+                    dst_pix_ptr[B] = (sum_b * mul_sum) &gt;&gt; shr_sum;
+                    dst_pix_ptr[A] = (sum_a * mul_sum) &gt;&gt; shr_sum;
+                    dst_pix_ptr += Img::pix_width;
+
+                    sum_r -= sum_out_r;
+                    sum_g -= sum_out_g;
+                    sum_b -= sum_out_b;
+                    sum_a -= sum_out_a;
+       
+                    stack_start = stack_ptr + div - rx;
+                    if(stack_start &gt;= div) stack_start -= div;
+                    stack_pix_ptr = &amp;stack[stack_start];
+
+                    sum_out_r -= stack_pix_ptr-&gt;r;
+                    sum_out_g -= stack_pix_ptr-&gt;g;
+                    sum_out_b -= stack_pix_ptr-&gt;b;
+                    sum_out_a -= stack_pix_ptr-&gt;a;
+
+                    if(xp &lt; wm) 
+                    {
+                        src_pix_ptr += Img::pix_width;
+                        ++xp;
+                    }
+        
+                    stack_pix_ptr-&gt;r = src_pix_ptr[R];
+                    stack_pix_ptr-&gt;g = src_pix_ptr[G];
+                    stack_pix_ptr-&gt;b = src_pix_ptr[B];
+                    stack_pix_ptr-&gt;a = src_pix_ptr[A];
+        
+                    sum_in_r += src_pix_ptr[R];
+                    sum_in_g += src_pix_ptr[G];
+                    sum_in_b += src_pix_ptr[B];
+                    sum_in_a += src_pix_ptr[A];
+                    sum_r    += sum_in_r;
+                    sum_g    += sum_in_g;
+                    sum_b    += sum_in_b;
+                    sum_a    += sum_in_a;
+        
+                    ++stack_ptr;
+                    if(stack_ptr &gt;= div) stack_ptr = 0;
+                    stack_pix_ptr = &amp;stack[stack_ptr];
+
+                    sum_out_r += stack_pix_ptr-&gt;r;
+                    sum_out_g += stack_pix_ptr-&gt;g;
+                    sum_out_b += stack_pix_ptr-&gt;b;
+                    sum_out_a += stack_pix_ptr-&gt;a;
+                    sum_in_r  -= stack_pix_ptr-&gt;r;
+                    sum_in_g  -= stack_pix_ptr-&gt;g;
+                    sum_in_b  -= stack_pix_ptr-&gt;b;
+                    sum_in_a  -= stack_pix_ptr-&gt;a;
+                }
+            }
+        }
+
+        if(ry &gt; 0)
+        {
+            if(ry &gt; 254) ry = 254;
+            div = ry * 2 + 1;
+            mul_sum = stack_blur_tables&lt;int&gt;::g_stack_blur8_mul[ry];
+            shr_sum = stack_blur_tables&lt;int&gt;::g_stack_blur8_shr[ry];
+            stack.allocate(div);
+
+            int stride = img.stride();
+            for(x = 0; x &lt; w; x++)
+            {
+                sum_r = 
+                sum_g = 
+                sum_b = 
+                sum_a = 
+                sum_in_r = 
+                sum_in_g = 
+                sum_in_b = 
+                sum_in_a = 
+                sum_out_r = 
+                sum_out_g = 
+                sum_out_b = 
+                sum_out_a = 0;
+
+                src_pix_ptr = img.pix_ptr(x, 0);
+                for(i = 0; i &lt;= ry; i++)
+                {
+                    stack_pix_ptr    = &amp;stack[i];
+                    stack_pix_ptr-&gt;r = src_pix_ptr[R];
+                    stack_pix_ptr-&gt;g = src_pix_ptr[G];
+                    stack_pix_ptr-&gt;b = src_pix_ptr[B];
+                    stack_pix_ptr-&gt;a = src_pix_ptr[A];
+                    sum_r           += src_pix_ptr[R] * (i + 1);
+                    sum_g           += src_pix_ptr[G] * (i + 1);
+                    sum_b           += src_pix_ptr[B] * (i + 1);
+                    sum_a           += src_pix_ptr[A] * (i + 1);
+                    sum_out_r       += src_pix_ptr[R];
+                    sum_out_g       += src_pix_ptr[G];
+                    sum_out_b       += src_pix_ptr[B];
+                    sum_out_a       += src_pix_ptr[A];
+                }
+                for(i = 1; i &lt;= ry; i++)
+                {
+                    if(i &lt;= hm) src_pix_ptr += stride; 
+                    stack_pix_ptr = &amp;stack[i + ry];
+                    stack_pix_ptr-&gt;r = src_pix_ptr[R];
+                    stack_pix_ptr-&gt;g = src_pix_ptr[G];
+                    stack_pix_ptr-&gt;b = src_pix_ptr[B];
+                    stack_pix_ptr-&gt;a = src_pix_ptr[A];
+                    sum_r           += src_pix_ptr[R] * (ry + 1 - i);
+                    sum_g           += src_pix_ptr[G] * (ry + 1 - i);
+                    sum_b           += src_pix_ptr[B] * (ry + 1 - i);
+                    sum_a           += src_pix_ptr[A] * (ry + 1 - i);
+                    sum_in_r        += src_pix_ptr[R];
+                    sum_in_g        += src_pix_ptr[G];
+                    sum_in_b        += src_pix_ptr[B];
+                    sum_in_a        += src_pix_ptr[A];
+                }
+
+                stack_ptr = ry;
+                yp = ry;
+                if(yp &gt; hm) yp = hm;
+                src_pix_ptr = img.pix_ptr(x, yp);
+                dst_pix_ptr = img.pix_ptr(x, 0);
+                for(y = 0; y &lt; h; y++)
+                {
+                    dst_pix_ptr[R] = (sum_r * mul_sum) &gt;&gt; shr_sum;
+                    dst_pix_ptr[G] = (sum_g * mul_sum) &gt;&gt; shr_sum;
+                    dst_pix_ptr[B] = (sum_b * mul_sum) &gt;&gt; shr_sum;
+                    dst_pix_ptr[A] = (sum_a * mul_sum) &gt;&gt; shr_sum;
+                    dst_pix_ptr += stride;
+
+                    sum_r -= sum_out_r;
+                    sum_g -= sum_out_g;
+                    sum_b -= sum_out_b;
+                    sum_a -= sum_out_a;
+       
+                    stack_start = stack_ptr + div - ry;
+                    if(stack_start &gt;= div) stack_start -= div;
+
+                    stack_pix_ptr = &amp;stack[stack_start];
+                    sum_out_r -= stack_pix_ptr-&gt;r;
+                    sum_out_g -= stack_pix_ptr-&gt;g;
+                    sum_out_b -= stack_pix_ptr-&gt;b;
+                    sum_out_a -= stack_pix_ptr-&gt;a;
+
+                    if(yp &lt; hm) 
+                    {
+                        src_pix_ptr += stride;
+                        ++yp;
+                    }
+        
+                    stack_pix_ptr-&gt;r = src_pix_ptr[R];
+                    stack_pix_ptr-&gt;g = src_pix_ptr[G];
+                    stack_pix_ptr-&gt;b = src_pix_ptr[B];
+                    stack_pix_ptr-&gt;a = src_pix_ptr[A];
+        
+                    sum_in_r += src_pix_ptr[R];
+                    sum_in_g += src_pix_ptr[G];
+                    sum_in_b += src_pix_ptr[B];
+                    sum_in_a += src_pix_ptr[A];
+                    sum_r    += sum_in_r;
+                    sum_g    += sum_in_g;
+                    sum_b    += sum_in_b;
+                    sum_a    += sum_in_a;
+        
+                    ++stack_ptr;
+                    if(stack_ptr &gt;= div) stack_ptr = 0;
+                    stack_pix_ptr = &amp;stack[stack_ptr];
+
+                    sum_out_r += stack_pix_ptr-&gt;r;
+                    sum_out_g += stack_pix_ptr-&gt;g;
+                    sum_out_b += stack_pix_ptr-&gt;b;
+                    sum_out_a += stack_pix_ptr-&gt;a;
+                    sum_in_r  -= stack_pix_ptr-&gt;r;
+                    sum_in_g  -= stack_pix_ptr-&gt;g;
+                    sum_in_b  -= stack_pix_ptr-&gt;b;
+                    sum_in_a  -= stack_pix_ptr-&gt;a;
+                }
+            }
+        }
+    }
+
+
+
+    //===========================================================recursive_blur
+    template&lt;class ColorT, class CalculatorT&gt; class recursive_blur
+    {
+    public:
+        typedef ColorT color_type;
+        typedef CalculatorT calculator_type;
+        typedef typename color_type::value_type value_type;
+        typedef typename calculator_type::value_type calc_type;
+
+        //--------------------------------------------------------------------
+        template&lt;class Img&gt; void blur_x(Img&amp; img, double radius)
+        {
+            if(radius &lt; 0.62) return;
+            if(img.width() &lt; 3) return;
+
+            calc_type s = calc_type(radius * 0.5);
+            calc_type q = calc_type((s &lt; 2.5) ?
+                                    3.97156 - 4.14554 * sqrt(1 - 0.26891 * s) :
+                                    0.98711 * s - 0.96330);
+
+            calc_type q2 = calc_type(q * q);
+            calc_type q3 = calc_type(q2 * q);
+
+            calc_type b0 = calc_type(1.0 / (1.578250 + 
+                                            2.444130 * q + 
+                                            1.428100 * q2 + 
+                                            0.422205 * q3));
+
+            calc_type b1 = calc_type( 2.44413 * q + 
+                                      2.85619 * q2 + 
+                                      1.26661 * q3);
+
+            calc_type b2 = calc_type(-1.42810 * q2 + 
+                                     -1.26661 * q3);
+
+            calc_type b3 = calc_type(0.422205 * q3);
+
+            calc_type b  = calc_type(1 - (b1 + b2 + b3) * b0);
+
+            b1 *= b0;
+            b2 *= b0;
+            b3 *= b0;
+
+            int w = img.width();
+            int h = img.height();
+            int wm = w-1;
+            int x, y;
+
+            m_sum1.allocate(w);
+            m_sum2.allocate(w);
+            m_buf.allocate(w);
+
+            for(y = 0; y &lt; h; y++)
+            {
+                calculator_type c;
+                c.from_pix(img.pixel(0, y));
+                m_sum1[0].calc(b, b1, b2, b3, c, c, c, c);
+                c.from_pix(img.pixel(1, y));
+                m_sum1[1].calc(b, b1, b2, b3, c, m_sum1[0], m_sum1[0], m_sum1[0]);
+                c.from_pix(img.pixel(2, y));
+                m_sum1[2].calc(b, b1, b2, b3, c, m_sum1[1], m_sum1[0], m_sum1[0]);
+
+                for(x = 3; x &lt; w; ++x)
+                {
+                    c.from_pix(img.pixel(x, y));
+                    m_sum1[x].calc(b, b1, b2, b3, c, m_sum1[x-1], m_sum1[x-2], m_sum1[x-3]);
+                }
+    
+                m_sum2[wm  ].calc(b, b1, b2, b3, m_sum1[wm  ], m_sum1[wm  ], m_sum1[wm], m_sum1[wm]);
+                m_sum2[wm-1].calc(b, b1, b2, b3, m_sum1[wm-1], m_sum2[wm  ], m_sum2[wm], m_sum2[wm]);
+                m_sum2[wm-2].calc(b, b1, b2, b3, m_sum1[wm-2], m_sum2[wm-1], m_sum2[wm], m_sum2[wm]);
+                m_sum2[wm  ].to_pix(m_buf[wm  ]);
+                m_sum2[wm-1].to_pix(m_buf[wm-1]);
+                m_sum2[wm-2].to_pix(m_buf[wm-2]);
+
+                for(x = wm-3; x &gt;= 0; --x)
+                {
+                    m_sum2[x].calc(b, b1, b2, b3, m_sum1[x], m_sum2[x+1], m_sum2[x+2], m_sum2[x+3]);
+                    m_sum2[x].to_pix(m_buf[x]);
+                }
+                img.copy_color_hspan(0, y, w, &amp;m_buf[0]);
+            }
+        }
+
+        //--------------------------------------------------------------------
+        template&lt;class Img&gt; void blur_y(Img&amp; img, double radius)
+        {
+            pixfmt_transposer&lt;Img&gt; img2(img);
+            blur_x(img2, radius);
+        }
+
+        //--------------------------------------------------------------------
+        template&lt;class Img&gt; void blur(Img&amp; img, double radius)
+        {
+            blur_x(img, radius);
+            pixfmt_transposer&lt;Img&gt; img2(img);
+            blur_x(img2, radius);
+        }
+
+    private:
+        agg::pod_vector&lt;calculator_type&gt; m_sum1;
+        agg::pod_vector&lt;calculator_type&gt; m_sum2;
+        agg::pod_vector&lt;color_type&gt;      m_buf;
+    };
+
+
+    //=================================================recursive_blur_calc_rgba
+    template&lt;class T=double&gt; struct recursive_blur_calc_rgba
+    {
+        typedef T value_type;
+        typedef recursive_blur_calc_rgba&lt;T&gt; self_type;
+
+        value_type r,g,b,a;
+
+        template&lt;class ColorT&gt; 
+        AGG_INLINE void from_pix(const ColorT&amp; c)
+        {
+            r = c.r;
+            g = c.g;
+            b = c.b;
+            a = c.a;
+        }
+
+        AGG_INLINE void calc(value_type b1, 
+                             value_type b2, 
+                             value_type b3, 
+                             value_type b4,
+                             const self_type&amp; c1, 
+                             const self_type&amp; c2, 
+                             const self_type&amp; c3, 
+                             const self_type&amp; c4)
+        {
+            r = b1*c1.r + b2*c2.r + b3*c3.r + b4*c4.r;
+            g = b1*c1.g + b2*c2.g + b3*c3.g + b4*c4.g;
+            b = b1*c1.b + b2*c2.b + b3*c3.b + b4*c4.b;
+            a = b1*c1.a + b2*c2.a + b3*c3.a + b4*c4.a;
+        }
+
+        template&lt;class ColorT&gt; 
+        AGG_INLINE void to_pix(ColorT&amp; c) const
+        {
+            typedef typename ColorT::value_type cv_type;
+            c.r = (cv_type)uround(r);
+            c.g = (cv_type)uround(g);
+            c.b = (cv_type)uround(b);
+            c.a = (cv_type)uround(a);
+        }
+    };
+
+
+    //=================================================recursive_blur_calc_rgb
+    template&lt;class T=double&gt; struct recursive_blur_calc_rgb
+    {
+        typedef T value_type;
+        typedef recursive_blur_calc_rgb&lt;T&gt; self_type;
+
+        value_type r,g,b;
+
+        template&lt;class ColorT&gt; 
+        AGG_INLINE void from_pix(const ColorT&amp; c)
+        {
+            r = c.r;
+            g = c.g;
+            b = c.b;
+        }
+
+        AGG_INLINE void calc(value_type b1, 
+                             value_type b2, 
+                             value_type b3, 
+                             value_type b4,
+                             const self_type&amp; c1, 
+                             const self_type&amp; c2, 
+                             const self_type&amp; c3, 
+                             const self_type&amp; c4)
+        {
+            r = b1*c1.r + b2*c2.r + b3*c3.r + b4*c4.r;
+            g = b1*c1.g + b2*c2.g + b3*c3.g + b4*c4.g;
+            b = b1*c1.b + b2*c2.b + b3*c3.b + b4*c4.b;
+        }
+
+        template&lt;class ColorT&gt; 
+        AGG_INLINE void to_pix(ColorT&amp; c) const
+        {
+            typedef typename ColorT::value_type cv_type;
+            c.r = (cv_type)uround(r);
+            c.g = (cv_type)uround(g);
+            c.b = (cv_type)uround(b);
+        }
+    };
+
+
+    //================================================recursive_blur_calc_gray
+    template&lt;class T=double&gt; struct recursive_blur_calc_gray
+    {
+        typedef T value_type;
+        typedef recursive_blur_calc_gray&lt;T&gt; self_type;
+
+        value_type v;
+
+        template&lt;class ColorT&gt; 
+        AGG_INLINE void from_pix(const ColorT&amp; c)
+        {
+            v = c.v;
+        }
+
+        AGG_INLINE void calc(value_type b1, 
+                             value_type b2, 
+                             value_type b3, 
+                             value_type b4,
+                             const self_type&amp; c1, 
+                             const self_type&amp; c2, 
+                             const self_type&amp; c3, 
+                             const self_type&amp; c4)
+        {
+            v = b1*c1.v + b2*c2.v + b3*c3.v + b4*c4.v;
+        }
+
+        template&lt;class ColorT&gt; 
+        AGG_INLINE void to_pix(ColorT&amp; c) const
+        {
+            typedef typename ColorT::value_type cv_type;
+            c.v = (cv_type)uround(v);
+        }
+    };
+
+}
+
+
+
+
+#endif

Added: trunk/agg/include/agg_gradient_lut.h
===================================================================
--- trunk/agg/include/agg_gradient_lut.h	2006-11-09 23:44:34 UTC (rev 367)
+++ trunk/agg/include/agg_gradient_lut.h	2006-11-09 23:48:09 UTC (rev 368)
@@ -0,0 +1,244 @@
+//----------------------------------------------------------------------------
+// Anti-Grain Geometry - Version 2.4
+// Copyright (C) 2002-2005 Maxim Shemanarev (<A HREF="http://www.antigrain.com">http://www.antigrain.com</A>)
+//
+// Permission to copy, use, modify, sell and distribute this software 
+// is granted provided this copyright notice appears in all copies. 
+// This software is provided &quot;as is&quot; without express or implied
+// warranty, and with no claim as to its suitability for any purpose.
+//
+//----------------------------------------------------------------------------
+// Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/mapnik-svn">mcseem at antigrain.com</A>
+//          <A HREF="https://lists.berlios.de/mailman/listinfo/mapnik-svn">mcseemagg at yahoo.com</A>
+//          <A HREF="http://www.antigrain.com">http://www.antigrain.com</A>
+//----------------------------------------------------------------------------
+
+#ifndef AGG_GRADIENT_LUT_INCLUDED
+#define AGG_GRADIENT_LUT_INCLUDED
+
+#include &quot;agg_array.h&quot;
+#include &quot;agg_dda_line.h&quot;
+#include &quot;agg_color_rgba.h&quot;
+#include &quot;agg_color_gray.h&quot;
+
+namespace agg
+{
+
+    //======================================================color_interpolator
+    template&lt;class ColorT&gt; struct color_interpolator
+    {
+    public:
+        typedef ColorT color_type;
+
+        color_interpolator(const color_type&amp; c1, 
+                           const color_type&amp; c2, 
+                           unsigned len) :
+            m_c1(c1),
+            m_c2(c2),
+            m_len(len),
+            m_count(0)
+        {}
+
+        void operator ++ ()
+        {
+            ++m_count;
+        }
+
+        color_type color() const
+        {
+            return m_c1.gradient(m_c2, double(m_count) / m_len);
+        }
+
+    private:
+        color_type m_c1;
+        color_type m_c2;
+        unsigned   m_len;
+        unsigned   m_count;
+    };
+
+    //========================================================================
+    // Fast specialization for rgba8
+    template&lt;&gt; struct color_interpolator&lt;rgba8&gt;
+    {
+    public:
+        typedef rgba8 color_type;
+
+        color_interpolator(const color_type&amp; c1, 
+                           const color_type&amp; c2, 
+                           unsigned len) :
+            r(c1.r, c2.r, len),
+            g(c1.g, c2.g, len),
+            b(c1.b, c2.b, len),
+            a(c1.a, c2.a, len)
+        {}
+
+        void operator ++ ()
+        {
+            ++r; ++g; ++b; ++a;
+        }
+
+        color_type color() const
+        {
+            return color_type(r.y(), g.y(), b.y(), a.y());
+        }
+
+    private:
+        agg::dda_line_interpolator&lt;14&gt; r, g, b, a;
+    };
+
+    //========================================================================
+    // Fast specialization for gray8
+    template&lt;&gt; struct color_interpolator&lt;gray8&gt;
+    {
+    public:
+        typedef gray8 color_type;
+
+        color_interpolator(const color_type&amp; c1, 
+                           const color_type&amp; c2, 
+                           unsigned len) :
+            v(c1.v, c2.v, len),
+            a(c1.a, c2.a, len)
+        {}
+
+        void operator ++ ()
+        {
+            ++v; ++a;
+        }
+
+        color_type color() const
+        {
+            return color_type(v.y(), a.y());
+        }
+
+    private:
+        agg::dda_line_interpolator&lt;14&gt; v,a;
+    };
+
+    //============================================================gradient_lut
+    template&lt;class ColorInterpolator, 
+             unsigned ColorLutSize=256&gt; class gradient_lut
+    {
+    public:
+        typedef ColorInterpolator interpolator_type;
+        typedef typename interpolator_type::color_type color_type;
+        enum { color_lut_size = ColorLutSize };
+
+        //--------------------------------------------------------------------
+        gradient_lut() : m_color_lut(color_lut_size) {}
+
+        // Build Gradient Lut
+        // First, call remove_all(), then add_color() at least twice, 
+        // then build_lut(). Argument &quot;offset&quot; in add_color must be 
+        // in range [0...1] and defines a color stop as it is described 
+        // in SVG specification, section Gradients and Patterns. 
+        // The simplest linear gradient is:
+        //    gradient_lut.add_color(0.0, start_color);
+        //    gradient_lut.add_color(1.0, end_color);
+        //--------------------------------------------------------------------
+        void remove_all();
+        void add_color(double offset, const color_type&amp; color);
+        void build_lut();
+
+        // Size-index Interface. This class can be used directly as the 
+        // ColorF in span_gradient. All it needs is two access methods 
+        // size() and operator [].
+        //--------------------------------------------------------------------
+        static unsigned size() 
+        { 
+            return color_lut_size; 
+        }
+        const color_type&amp; operator [] (unsigned i) const 
+        { 
+            return m_color_lut[i]; 
+        }
+
+    private:
+        //--------------------------------------------------------------------
+        struct color_point
+        {
+            double     offset;
+            color_type color;
+
+            color_point() {}
+            color_point(double off, const color_type&amp; c) : 
+                offset(off), color(c)
+            {
+                if(offset &lt; 0.0) offset = 0.0;
+                if(offset &gt; 1.0) offset = 1.0;
+            }
+        };
+        typedef agg::pod_bvector&lt;color_point, 4&gt; color_profile_type;
+        typedef agg::pod_array&lt;color_type&gt;       color_lut_type;
+
+        static bool offset_less(const color_point&amp; a, const color_point&amp; b)
+        {
+            return a.offset &lt; b.offset;
+        }
+        static bool offset_equal(const color_point&amp; a, const color_point&amp; b)
+        {
+            return a.offset == b.offset;
+        }
+
+        //--------------------------------------------------------------------
+        color_profile_type  m_color_profile;
+        color_lut_type      m_color_lut;
+    };
+
+
+
+    //------------------------------------------------------------------------
+    template&lt;class T, unsigned S&gt;
+    void gradient_lut&lt;T,S&gt;::remove_all()
+    { 
+        m_color_profile.remove_all(); 
+    }
+
+    //------------------------------------------------------------------------
+    template&lt;class T, unsigned S&gt;
+    void gradient_lut&lt;T,S&gt;::add_color(double offset, const color_type&amp; color)
+    {
+        m_color_profile.add(color_point(offset, color));
+    }
+
+    //------------------------------------------------------------------------
+    template&lt;class T, unsigned S&gt;
+    void gradient_lut&lt;T,S&gt;::build_lut()
+    {
+        quick_sort(m_color_profile, offset_less);
+        m_color_profile.cut_at(remove_duplicates(m_color_profile, offset_equal));
+        if(m_color_profile.size() &gt;= 2)
+        {
+            unsigned i;
+            unsigned start = uround(m_color_profile[0].offset * color_lut_size);
+            unsigned end;
+            color_type c = m_color_profile[0].color;
+            for(i = 0; i &lt; start; i++) 
+            {
+                m_color_lut[i] = c;
+            }
+            for(i = 1; i &lt; m_color_profile.size(); i++)
+            {
+                end  = uround(m_color_profile[i].offset * color_lut_size);
+                interpolator_type ci(m_color_profile[i-1].color, 
+                                     m_color_profile[i  ].color, 
+                                     end - start + 1);
+                while(start &lt; end)
+                {
+                    m_color_lut[start] = ci.color();
+                    ++ci;
+                    ++start;
+                }
+            }
+            c = m_color_profile.last().color;
+            for(; end &lt; m_color_lut.size(); end++)
+            {
+                m_color_lut[end] = c;
+            }
+        }
+    }
+}
+
+
+
+
+#endif

Added: trunk/agg/include/agg_pixfmt_transposer.h
===================================================================
--- trunk/agg/include/agg_pixfmt_transposer.h	2006-11-09 23:44:34 UTC (rev 367)
+++ trunk/agg/include/agg_pixfmt_transposer.h	2006-11-09 23:48:09 UTC (rev 368)
@@ -0,0 +1,157 @@
+//----------------------------------------------------------------------------
+// Anti-Grain Geometry - Version 2.4
+// Copyright (C) 2002-2005 Maxim Shemanarev (<A HREF="http://www.antigrain.com">http://www.antigrain.com</A>)
+//
+// Permission to copy, use, modify, sell and distribute this software 
+// is granted provided this copyright notice appears in all copies. 
+// This software is provided &quot;as is&quot; without express or implied
+// warranty, and with no claim as to its suitability for any purpose.
+//
+//----------------------------------------------------------------------------
+// Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/mapnik-svn">mcseem at antigrain.com</A>
+//          <A HREF="https://lists.berlios.de/mailman/listinfo/mapnik-svn">mcseemagg at yahoo.com</A>
+//          <A HREF="http://www.antigrain.com">http://www.antigrain.com</A>
+//----------------------------------------------------------------------------
+
+#ifndef AGG_PIXFMT_TRANSPOSER_INCLUDED
+#define AGG_PIXFMT_TRANSPOSER_INCLUDED
+
+#include &quot;agg_basics.h&quot;
+
+namespace agg
+{
+    //=======================================================pixfmt_transposer
+    template&lt;class PixFmt&gt; class pixfmt_transposer
+    {
+    public:
+        typedef PixFmt pixfmt_type;
+        typedef typename pixfmt_type::color_type color_type;
+        typedef typename pixfmt_type::row_data row_data;
+        typedef typename color_type::value_type value_type;
+        typedef typename color_type::calc_type calc_type;
+
+        //--------------------------------------------------------------------
+        pixfmt_transposer() : m_pixf(0) {}
+        explicit pixfmt_transposer(pixfmt_type&amp; pixf) : m_pixf(&amp;pixf) {}
+        void attach(pixfmt_type&amp; pixf) { m_pixf = &pixf; }
+
+        //--------------------------------------------------------------------
+        AGG_INLINE unsigned width()  const { return m_pixf-&gt;height();  }
+        AGG_INLINE unsigned height() const { return m_pixf-&gt;width(); }
+
+        //--------------------------------------------------------------------
+        AGG_INLINE color_type pixel(int x, int y) const
+        {
+            return m_pixf-&gt;pixel(y, x);
+        }
+
+        //--------------------------------------------------------------------
+        AGG_INLINE void copy_pixel(int x, int y, const color_type&amp; c)
+        {
+            m_pixf-&gt;copy_pixel(y, x, c);
+        }
+
+        //--------------------------------------------------------------------
+        AGG_INLINE void blend_pixel(int x, int y, 
+                                    const color_type&amp; c, 
+                                    int8u cover)
+        {
+            m_pixf-&gt;blend_pixel(y, x, c, cover);
+        }
+
+        //--------------------------------------------------------------------
+        AGG_INLINE void copy_hline(int x, int y, 
+                                   unsigned len, 
+                                   const color_type&amp; c)
+        {
+            m_pixf-&gt;copy_vline(y, x, len, c);
+        }
+
+        //--------------------------------------------------------------------
+        AGG_INLINE void copy_vline(int x, int y,
+                                   unsigned len, 
+                                   const color_type&amp; c)
+        {
+            m_pixf-&gt;copy_hline(y, x, len, c);
+        }
+
+        //--------------------------------------------------------------------
+        AGG_INLINE void blend_hline(int x, int y,
+                                    unsigned len, 
+                                    const color_type&amp; c,
+                                    int8u cover)
+        {
+            m_pixf-&gt;blend_vline(y, x, len, c, cover);
+        }
+
+        //--------------------------------------------------------------------
+        AGG_INLINE void blend_vline(int x, int y,
+                                    unsigned len, 
+                                    const color_type&amp; c,
+                                    int8u cover)
+        {
+            m_pixf-&gt;blend_hline(y, x, len, c, cover);
+        }
+
+        //--------------------------------------------------------------------
+        AGG_INLINE void blend_solid_hspan(int x, int y,
+                                          unsigned len, 
+                                          const color_type&amp; c,
+                                          const int8u* covers)
+        {
+            m_pixf-&gt;blend_solid_vspan(y, x, len, c, covers);
+        }
+
+        //--------------------------------------------------------------------
+        AGG_INLINE void blend_solid_vspan(int x, int y,
+                                          unsigned len, 
+                                          const color_type&amp; c,
+                                          const int8u* covers)
+        {
+            m_pixf-&gt;blend_solid_hspan(y, x, len, c, covers);
+        }
+
+        //--------------------------------------------------------------------
+        AGG_INLINE void copy_color_hspan(int x, int y,
+                                         unsigned len, 
+                                         const color_type* colors)
+        {
+            m_pixf-&gt;copy_color_vspan(y, x, len, colors);
+        }
+
+        //--------------------------------------------------------------------
+        AGG_INLINE void copy_color_vspan(int x, int y,
+                                         unsigned len, 
+                                         const color_type* colors)
+        {
+            m_pixf-&gt;copy_color_hspan(y, x, len, colors);
+        }
+
+        //--------------------------------------------------------------------
+        AGG_INLINE void blend_color_hspan(int x, int y,
+                                          unsigned len, 
+                                          const color_type* colors,
+                                          const int8u* covers,
+                                          int8u cover)
+        {
+            m_pixf-&gt;blend_color_vspan(y, x, len, colors, covers, cover);
+        }
+
+        //--------------------------------------------------------------------
+        AGG_INLINE void blend_color_vspan(int x, int y,
+                               unsigned len, 
+                               const color_type* colors,
+                               const int8u* covers,
+                               int8u cover)
+        {
+            m_pixf-&gt;blend_color_hspan(y, x, len, colors, covers, cover);
+        }
+
+    private:
+        pixfmt_type* m_pixf;
+    };
+}
+
+#endif
+
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000252.html">[Mapnik-svn] r367 - in trunk: agg/include agg/src demo/python src
</A></li>
	<LI>Next message: <A HREF="000254.html">[Mapnik-svn] r369 - trunk/include/mapnik
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#253">[ date ]</a>
              <a href="thread.html#253">[ thread ]</a>
              <a href="subject.html#253">[ subject ]</a>
              <a href="author.html#253">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/mapnik-svn">More information about the Mapnik-svn
mailing list</a><br>
</body></html>
