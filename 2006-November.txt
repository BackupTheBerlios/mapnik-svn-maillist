From jdoyon at mail.berlios.de  Wed Nov  1 03:04:01 2006
From: jdoyon at mail.berlios.de (jdoyon at BerliOS)
Date: Wed, 1 Nov 2006 03:04:01 +0100
Subject: [Mapnik-svn] r363 - trunk/utils/ogcserver
Message-ID: <200611010204.kA1241Rn027402@sheep.berlios.de>

Author: jdoyon
Date: 2006-11-01 03:04:01 +0100 (Wed, 01 Nov 2006)
New Revision: 363

Modified:
   trunk/utils/ogcserver/ogcserver.conf
Log:
- Change default ogcserver.conf to reflect new projection support.

Modified: trunk/utils/ogcserver/ogcserver.conf
===================================================================
--- trunk/utils/ogcserver/ogcserver.conf	2006-10-27 22:13:13 UTC (rev 362)
+++ trunk/utils/ogcserver/ogcserver.conf	2006-11-01 02:04:01 UTC (rev 363)
@@ -27,10 +27,10 @@
 maxheight=1024
 maxwidth=1024
 
-# epsg:  The epsg code defining the projection of the source data used in the
-#        map.
+# allowedepsgcodes:  The comma seperated list of epsg codes we want the server
+#                    to support and advertise as supported in GetCapabilities.
 
-epsg=4326
+allowedepsgcodes=4326
 
 # onlineresource:  A service level URL most likely pointing to the web site
 #                  supporting the service for example.  This is NOT the online
@@ -53,7 +53,7 @@
 
 accessconstraints=
 
-# contact: Contact information.  Provides niformation to service users on who
+# contact: Contact information.  Provides information to service users on who
 #          to contact for help on or details about the service.
 
 [contact]



From pavlenko at mail.berlios.de  Thu Nov  2 00:17:11 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Thu, 2 Nov 2006 00:17:11 +0100
Subject: [Mapnik-svn] r364 - in trunk: bindings/python demo/python
	include/mapnik plugins/input/postgis src
Message-ID: <200611012317.kA1NHBQ7032323@sheep.berlios.de>

Author: pavlenko
Date: 2006-11-02 00:17:05 +0100 (Thu, 02 Nov 2006)
New Revision: 364

Modified:
   trunk/bindings/python/mapnik_text_symbolizer.cpp
   trunk/demo/python/rundemo.py
   trunk/include/mapnik/placement_finder.hpp
   trunk/include/mapnik/text_path.hpp
   trunk/include/mapnik/text_symbolizer.hpp
   trunk/plugins/input/postgis/postgis.cpp
   trunk/src/agg_renderer.cpp
   trunk/src/load_map.cpp
   trunk/src/placement_finder.cpp
   trunk/src/text_symbolizer.cpp
Log:
1. patch from Toby that allows repeated labels to be placed on a line
geometry (such as roads)
2. restored text labels for point geometry.
3. process 'spacing' attribute in load_map.cpp
 



Modified: trunk/bindings/python/mapnik_text_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_text_symbolizer.cpp	2006-11-01 02:04:01 UTC (rev 363)
+++ trunk/bindings/python/mapnik_text_symbolizer.cpp	2006-11-01 23:17:05 UTC (rev 364)
@@ -49,6 +49,9 @@
         .add_property("text_ratio",
                       &text_symbolizer::get_text_ratio,
                       &text_symbolizer::set_text_ratio)
+        .add_property("label_spacing",
+                      &text_symbolizer::get_label_spacing,
+                      &text_symbolizer::set_label_spacing)
         .add_property("halo_radius",
                       &text_symbolizer::get_halo_radius, 
                       &text_symbolizer::set_halo_radius)

Modified: trunk/demo/python/rundemo.py
===================================================================
--- trunk/demo/python/rundemo.py	2006-11-01 02:04:01 UTC (rev 363)
+++ trunk/demo/python/rundemo.py	2006-11-01 23:17:05 UTC (rev 364)
@@ -280,11 +280,13 @@
 # The first parameter is the name of the attribute to use as the source of the
 # text to label with.  Then there is font size in points (I think?), and colour.
 
-popplaces_text_symbolizer = TextSymbolizer('GEONAME', 10, Color('black'))
+popplaces_text_symbolizer = TextSymbolizer('GEONAME',
+                                           'Bitstream Vera Sans Roman',
+                                           10, Color('black'))
 
 # We set a "halo" around the text, which looks like an outline if thin enough,
 # or an outright background if large enough.
-
+popplaces_text_symbolizer.set_label_placement=label_placement.POINT_PLACEMENT
 popplaces_text_symbolizer.halo_fill = Color('white')
 popplaces_text_symbolizer.halo_radius = 1
 popplaces_rule.symbols.append(popplaces_text_symbolizer)

Modified: trunk/include/mapnik/placement_finder.hpp
===================================================================
--- trunk/include/mapnik/placement_finder.hpp	2006-11-01 02:04:01 UTC (rev 363)
+++ trunk/include/mapnik/placement_finder.hpp	2006-11-01 23:17:05 UTC (rev 364)
@@ -36,6 +36,15 @@
 
 namespace mapnik
 {
+
+    struct placement_element
+    {
+        double starting_x;
+        double starting_y;
+    
+        text_path path;
+    };
+
   struct placement
   {
     typedef  coord_transform2<CoordTransform,geometry_type> path_type;
@@ -48,7 +57,8 @@
     
     ~placement();
 
-    string_info *info;
+      unsigned path_size() const;
+      string_info *info;
     
     CoordTransform *ctrans;
     const proj_transform *proj_trans;
@@ -63,11 +73,10 @@
     std::queue< Envelope<double> > envelopes;
     
     //output
-    double starting_x;
-    double starting_y;
-    
-    text_path path;
+    std::vector<placement_element> placements;
 
+    // caching output
+    placement_element current_placement;
     
     //helpers
     std::pair<double, double> get_position_at_distance(double target_distance);
@@ -78,14 +87,18 @@
     
     int wrap_width;
     int text_ratio;
+
+    int label_spacing; // distance between repeated labels on a single geometry
   };
+
+
   
   class placement_finder : boost::noncopyable
   {
   public:
     placement_finder(Envelope<double> e);
   
-    bool find_placement(placement *placement);
+    bool find_placements(placement *p);
     
   protected:
     bool find_placement_follow(placement *p);

Modified: trunk/include/mapnik/text_path.hpp
===================================================================
--- trunk/include/mapnik/text_path.hpp	2006-11-01 02:04:01 UTC (rev 363)
+++ trunk/include/mapnik/text_path.hpp	2006-11-01 23:17:05 UTC (rev 364)
@@ -93,9 +93,9 @@
       }
     };
     
-    struct text_path : private boost::noncopyable
+    struct text_path 
     {
-        struct character_node : boost::noncopyable
+        struct character_node
         {
             int c;
             double x, y, angle;
@@ -112,7 +112,7 @@
             }
         };
 
-        typedef boost::ptr_vector<character_node> character_nodes_t;
+        typedef std::vector<character_node> character_nodes_t;
         
         character_nodes_t nodes_;
         int itr_;
@@ -120,11 +120,17 @@
         std::pair<unsigned,unsigned> string_dimensions;
         
         text_path() :  itr_(0) {} 
+        text_path(const text_path & other) : itr_(0)
+        {
+            nodes_ = other.nodes_;
+            string_dimensions = other.string_dimensions;
+        }
+ 
         ~text_path() {}
           
         void add_node(int c, double x, double y, double angle)
         {
-            nodes_.push_back(new character_node(c, x, y, angle));
+            nodes_.push_back(character_node(c, x, y, angle));
         }
         
         void vertex(int *c, double *x, double *y, double *angle)

Modified: trunk/include/mapnik/text_symbolizer.hpp
===================================================================
--- trunk/include/mapnik/text_symbolizer.hpp	2006-11-01 02:04:01 UTC (rev 363)
+++ trunk/include/mapnik/text_symbolizer.hpp	2006-11-01 23:17:05 UTC (rev 364)
@@ -45,8 +45,10 @@
         std::string const& get_name() const;
         unsigned get_text_ratio() const; // target ratio for text bounding box in pixels
         void set_text_ratio(unsigned ratio);
-        unsigned get_wrap_width() const; // target ratio for text bounding box in pixels
+        unsigned get_wrap_width() const; // width to wrap text at, or trigger ratio
         void set_wrap_width(unsigned ratio);
+        unsigned get_label_spacing() const; // spacing between repeated labels on lines
+        void set_label_spacing(unsigned spacing);
         unsigned get_text_size() const;
         std::string const& get_face_name() const;
         Color const& get_fill() const;
@@ -66,6 +68,7 @@
         unsigned size_;
         unsigned text_ratio_;
         unsigned wrap_width_;
+        unsigned label_spacing_;
         Color fill_;
         Color halo_fill_;
         unsigned halo_radius_;

Modified: trunk/plugins/input/postgis/postgis.cpp
===================================================================
--- trunk/plugins/input/postgis/postgis.cpp	2006-11-01 02:04:01 UTC (rev 363)
+++ trunk/plugins/input/postgis/postgis.cpp	2006-11-01 23:17:05 UTC (rev 364)
@@ -148,7 +148,7 @@
                         desc_.add_descriptor(attribute_descriptor(fld_name,mapnik::Double,false,length));
                     case 1042:  // bpchar
                     case 1043:  // varchar
-                    case 25:   // text
+                    case 25:    // text
                         desc_.add_descriptor(attribute_descriptor(fld_name,mapnik::String));
                         break;
                     default: // shouldn't get here

Modified: trunk/src/agg_renderer.cpp
===================================================================
--- trunk/src/agg_renderer.cpp	2006-11-01 02:04:01 UTC (rev 363)
+++ trunk/src/agg_renderer.cpp	2006-11-01 23:17:05 UTC (rev 364)
@@ -346,24 +346,26 @@
                  
                     placement text_placement(&info, &t_, &prj_trans, geom, std::pair<double, double>(w, h) );
                     
-                    bool found = finder_.find_placement(&text_placement);
+                    bool found = finder_.find_placements(&text_placement);
                     if (!found) {
                       return;
                     }
                     
-                    double x = text_placement.starting_x;
-                    double y = text_placement.starting_y;
-                    
-                    int px=int(floor(x - 0.5 * w));
-                    int py=int(floor(y - 0.5 * h));
-                    
-                    pixmap_.set_rectangle_alpha(px,py,*data);
-            
-                    Envelope<double> dim = ren.prepare_glyphs(&text_placement.path);
-                    
-                    //If has_placement 
-                    
-                    ren.render(x,y);
+
+                    for (unsigned int ii = 0; ii < text_placement.placements.size(); ++ ii)
+                    {
+                        double x = text_placement.placements[ii].starting_x;
+                        double y = text_placement.placements[ii].starting_y;
+
+                        int px=int(floor(x - 0.5 * w));
+                        int py=int(floor(y - 0.5 * h));
+                        
+                        pixmap_.set_rectangle_alpha(px,py,*data);
+                        
+                        Envelope<double> dim = ren.prepare_glyphs(&text_placement.placements[ii].path);
+                        
+                        ren.render(x,y);
+                    }
                 }
             }
         }
@@ -496,33 +498,37 @@
                     ren.set_fill(fill);
                     ren.set_halo_fill(sym.get_halo_fill());
                     ren.set_halo_radius(sym.get_halo_radius());
-
+                    
                     string_info info;
-                  
+                    
                     ren.get_string_info(text, &info);
-                 
+                    
                     placement text_placement(&info, &t_, &prj_trans, geom, sym.get_label_placement());
                     text_placement.text_ratio = sym.get_text_ratio();
                     text_placement.wrap_width = sym.get_wrap_width();
-                  
-                    bool found = finder_.find_placement(&text_placement);
+                    text_placement.label_spacing = sym.get_label_spacing();
+                    
+                    bool found = finder_.find_placements(&text_placement);
                     if (!found) {
                       return;
                     }
                     
-                    double x = text_placement.starting_x;
-                    double y = text_placement.starting_y;
-                    
-                    Envelope<double> dim = ren.prepare_glyphs(&text_placement.path);
-                    
-                    Envelope<double> text_box(x + dim.minx() ,y - dim.maxy(), x + dim.maxx(),y - dim.miny());
-		    
-                    if (sym.get_halo_radius() > 0)
+                    for (unsigned int ii = 0; ii < text_placement.placements.size(); ++ ii)
                     {
-                        text_box.width(text_box.width() + sym.get_halo_radius()*2);
-                        text_box.height(text_box.height() + sym.get_halo_radius()*2);
+                        double x = text_placement.placements[ii].starting_x;
+                        double y = text_placement.placements[ii].starting_y;
+                        
+                        Envelope<double> dim = ren.prepare_glyphs(&text_placement.placements[ii].path);
+                        
+                        Envelope<double> text_box(x + dim.minx() ,y - dim.maxy(), x + dim.maxx(),y - dim.miny());
+		        
+                        if (sym.get_halo_radius() > 0)
+                        {
+                            text_box.width(text_box.width() + sym.get_halo_radius()*2);
+                            text_box.height(text_box.height() + sym.get_halo_radius()*2);
+                        }
+                        ren.render(x,y);
                     }
-                    ren.render(x,y);
                 }
             }  
         }

Modified: trunk/src/load_map.cpp
===================================================================
--- trunk/src/load_map.cpp	2006-11-01 02:04:01 UTC (rev 363)
+++ trunk/src/load_map.cpp	2006-11-01 23:17:05 UTC (rev 364)
@@ -126,7 +126,16 @@
                             
                             if ( sym.first == "PointSymbolizer")
                             {
-                                std::cout << sym.first << "\n";
+                                std::string file =  
+                                    sym.second.get<std::string>("<xmlattr>.file"); 
+                                std::string type =  
+                                    sym.second.get<std::string>("<xmlattr>.type");
+                                unsigned width =  
+                                    sym.second.get<unsigned>("<xmlattr>.width");
+                                unsigned height =  
+                                    sym.second.get<unsigned>("<xmlattr>.height");
+                                
+                                rule.append(point_symbolizer(file,type,width,height));
                             } 
                             else if ( sym.first == "LinePatternSymbolizer")
                             {
@@ -163,6 +172,7 @@
                                 {
                                     text_symbol.set_label_placement(line_placement);
                                 }
+                                
                                 // halo fill and radius
                                 boost::optional<std::string> halo_fill = 
                                     sym.second.get_optional<std::string>("<xmlattr>.halo_fill");
@@ -195,6 +205,13 @@
                                     text_symbol.set_wrap_width(*wrap_width);
                                 }
                                 
+                                // spacing between repeated labels on lines
+                                boost::optional<unsigned> spacing = 
+                                    sym.second.get_optional<unsigned>("<xmlattr>.spacing");
+                                if (spacing)
+                                {
+                                    text_symbol.set_label_spacing(*spacing);
+                                }
                                 rule.append(text_symbol);
                             }
                             else if ( sym.first == "ShieldSymbolizer")

Modified: trunk/src/placement_finder.cpp
===================================================================
--- trunk/src/placement_finder.cpp	2006-11-01 02:04:01 UTC (rev 363)
+++ trunk/src/placement_finder.cpp	2006-11-01 23:17:05 UTC (rev 364)
@@ -41,26 +41,31 @@
 namespace mapnik
 {
     placement::placement(string_info *info_, CoordTransform *ctrans_, const proj_transform *proj_trans_, geometry_ptr geom_, std::pair<double, double> dimensions_)
-        : info(info_), ctrans(ctrans_), proj_trans(proj_trans_), geom(geom_), label_placement(point_placement), dimensions(dimensions_), has_dimensions(true), shape_path(*ctrans_, *geom_, *proj_trans_), total_distance_(-1.0), wrap_width(0), text_ratio(0)
+        : info(info_), ctrans(ctrans_), proj_trans(proj_trans_), geom(geom_), label_placement(point_placement), dimensions(dimensions_), has_dimensions(true), shape_path(*ctrans_, *geom_, *proj_trans_), total_distance_(-1.0), wrap_width(0), text_ratio(0), label_spacing(0)
     {
     }
-  
+
     //For text
     placement::placement(string_info *info_, CoordTransform *ctrans_, const proj_transform *proj_trans_, geometry_ptr geom_, label_placement_e placement_)
-        : info(info_), ctrans(ctrans_), proj_trans(proj_trans_), geom(geom_), label_placement(placement_), has_dimensions(false), shape_path(*ctrans_, *geom_, *proj_trans_), total_distance_(-1.0), wrap_width(0), text_ratio(0)
+        : info(info_), ctrans(ctrans_), proj_trans(proj_trans_), geom(geom_), label_placement(placement_), has_dimensions(false), shape_path(*ctrans_, *geom_, *proj_trans_), total_distance_(-1.0), wrap_width(0), text_ratio(0), label_spacing(0)
     {
     }
   
     placement::~placement()
     {
     }
-
+    
+    unsigned placement::path_size() const
+    {
+        return geom->num_points();
+    }
+    
     std::pair<double, double> placement::get_position_at_distance(double target_distance)
     {
         double old_x, old_y, new_x, new_y;
         double x, y;
         x = y = 0.0;
-    
+        
         double distance = 0.0;
     
         shape_path.rewind(0);
@@ -132,11 +137,12 @@
   
   
     placement_finder::placement_finder(Envelope<double> e)
-        : detector_(e)
+      : detector_(e)
     {
     }
 
-    bool placement_finder::find_placement(placement *p)
+
+    bool placement_finder::find_placements(placement *p)
     {
         if (p->label_placement == point_placement)
         {
@@ -156,37 +162,76 @@
         double string_width = string_dimensions.first;
         //    double string_height = string_dimensions.second;
     
+
+        std::clog << "trying to place string: ";
+        for (unsigned int ii = 0; ii < p->info->num_characters(); ++ii)
+            std::clog << static_cast<char> (p->info->at(ii).character);
+        std::clog << std::endl;
+
         double distance = p->get_total_distance();
     
-        //~ double delta = string_width/distance;
-        double delta = distance/100.0;
+        if (string_width > distance)
+        {
+            std::clog << "String longer than segment, bailing" << std::endl;
+            return false;
+        }
+
     
-        for (double i = 0; i < (distance - string_width)/2.0; i += delta)
+        int num_labels = 0;
+        if (p->label_spacing)
+            num_labels = static_cast<int> (floor(distance / (p->label_spacing + string_width)));
+        if (num_labels == 0)
+            num_labels = 1;
+
+        double ideal_spacing = distance/num_labels;
+        std::vector<double> ideal_label_distances;
+        for (double label_pos = ideal_spacing/2; label_pos < distance; label_pos += ideal_spacing)
+            ideal_label_distances.push_back(label_pos);
+
+        double delta = distance/100.0;
+        bool FoundPlacement = false;
+        for (std::vector<double>::const_iterator itr = ideal_label_distances.begin(); itr < ideal_label_distances.end(); ++itr)
         {
-            p->clear_envelopes();
-      
-            if ( build_path_follow(p, (distance - string_width)/2.0 + i) ) {
-                update_detector(p);
-                return true;
+            std::clog << "Trying to find txt placement at distance: " << *itr << std::endl;
+            for (double i = 0; i < ideal_spacing; i += delta)
+            {
+                p->clear_envelopes();
+        
+                // check position +- delta for valid placement
+                if ( build_path_follow(p, *itr - string_width/2 + i)) {
+                    update_detector(p);
+                    FoundPlacement = true;
+                    break;
+                }
+
+                p->clear_envelopes();
+                if (build_path_follow(p, *itr - string_width/2 - i) ) {
+                    update_detector(p);
+                    FoundPlacement = true;
+                    break;
+                }
             }
-      
-            p->clear_envelopes();
-      
-            if ( build_path_follow(p, (distance - string_width)/2.0 - i) ) {
-                update_detector(p);
-                return true;
-            }
-        }
+        }    
     
-        p->starting_x = 0;
-        p->starting_y = 0;
-    
-        return false;
+        if (FoundPlacement)
+            std::clog << "Found Placement" << string_width << " " << distance << std::endl;
+
+        return FoundPlacement;
     }
   
     bool placement_finder::find_placement_horizontal(placement *p)
     {
-        double distance = p->get_total_distance();
+        if (p->path_size() == 1) // point geometry
+        {
+            if ( build_path_horizontal(p, 0) ) 
+            {
+                update_detector(p);
+                return true;
+            }
+            return false;
+        }
+        
+        double distance = p->get_total_distance();    
         //~ double delta = string_width/distance;
         double delta = distance/100.0;
     
@@ -206,10 +251,6 @@
                 return true;
             }
         }
-    
-        p->starting_x = 0;
-        p->starting_y = 0;
-    
         return false;
     }
   
@@ -226,14 +267,14 @@
     }
 
     bool placement_finder::build_path_follow(placement *p, double target_distance)
-    {
+     {
         double new_x, new_y, old_x, old_y;
         unsigned cur_node = 0;
 
         double angle = 0.0;
         int orientation = 0;
     
-        p->path.clear();
+        p->current_placement.path.clear();
     
         double x, y;
         x = y = 0.0;
@@ -265,9 +306,9 @@
             distance += segment_length;
             if (distance > target_distance)
             {
-                p->starting_x = new_x - dx*(distance - target_distance)/segment_length;
-                p->starting_y = new_y - dy*(distance - target_distance)/segment_length;
-
+                p->current_placement.starting_x = new_x - dx*(distance - target_distance)/segment_length;
+                p->current_placement.starting_y = new_y - dy*(distance - target_distance)/segment_length;
+    
                 angle = atan2(-dy, dx);
 
                 if (angle > M_PI/2 || angle <= -M_PI/2) {
@@ -282,13 +323,14 @@
                 break;
             }
         }
-
+    
         for (unsigned i = 0; i < p->info->num_characters(); i++)
         {
             character_info ci;
             unsigned c;
-      
-            while (distance <= 0) {
+    
+            while (distance <= 0) 
+            {
                 double dx, dy;
 
                 cur_node++;
@@ -332,7 +374,7 @@
                 //Center the text on the line.
                 x += (((double)string_height/2.0) - 1.0)*cos(angle+M_PI/2);
                 y -= (((double)string_height/2.0) - 1.0)*sin(angle+M_PI/2);
-          
+        
                 if (!p->has_dimensions)
                 {
                     e.init(x, y, x + ci.width*cos(angle+M_PI), y - ci.width*sin(angle+M_PI));
@@ -364,87 +406,26 @@
         
             p->envelopes.push(e);
         
-            p->path.add_node(c, x - p->starting_x, -y + p->starting_y, (orientation == -1 ? angle + M_PI : angle));
+            p->current_placement.path.add_node(c, x - p->current_placement.starting_x, -y + p->current_placement.starting_y, (orientation == -1 ? angle + M_PI : angle));
         
             distance -= ci.width;
         }
-    
+        p->placements.push_back(p->current_placement);
+
         return true;
     }
 
-    /*
-   bool placement_finder::build_path_horizontal(placement *p, double target_distance)
-  {
-    double x, y;
-  
-    p->path.clear();
-    
-    std::pair<double, double> string_dimensions = p->info->get_dimensions();
-    double string_width = string_dimensions.first;
-    double string_height = string_dimensions.second;
-    
-    x = -string_width/2.0;
-    y = -string_height/2.0 + 1.0;
-    
-    if (p->geom->type() == LineString)
-    {
-      std::pair<double, double> starting_pos = p->get_position_at_distance(target_distance);
-      
-      p->starting_x = starting_pos.first;
-      p->starting_y = starting_pos.second;
-    }
-    else
-    {
-      p->geom->label_position(&p->starting_x, &p->starting_y);
-      //  TODO: 
-      //  We would only want label position in final 'paper' coords.
-      //  Move view and proj transforms to e.g. label_position(x,y,proj_trans,ctrans)?
-      double z=0;  
-      p->proj_trans->backward(p->starting_x, p->starting_y, z);
-      p->ctrans->forward(&p->starting_x, &p->starting_y);
-    }
-    
-    for (unsigned i = 0; i < p->info->num_characters(); i++)
-    {
-        character_info ci;;
-        ci = p->info->at(i);
-        
-        unsigned c = ci.character;
-      
-        p->path.add_node(c, x, y, 0.0);
 
-        Envelope<double> e;
-        if (p->has_dimensions)
-        {
-            e.init(p->starting_x - (p->dimensions.first/2.0), p->starting_y - (p->dimensions.second/2.0), p->starting_x + (p->dimensions.first/2.0), p->starting_y + (p->dimensions.second/2.0));
-        }
-        else
-        {
-          e.init(p->starting_x + x, p->starting_y - y, p->starting_x + x + ci.width, p->starting_y - y - ci.height);
-        }
-        
-        if (!detector_.has_placement(e))
-        {
-          return false;
-        }
-        
-        p->envelopes.push(e);
-      
-        x += ci.width;
-    }
-    return true;
-  }
-    */
-    
     bool placement_finder::build_path_horizontal(placement *p, double target_distance)
     {
+        double x, y;
     
-        p->path.clear();
-    
+        p->current_placement.path.clear();
+        
         std::pair<double, double> string_dimensions = p->info->get_dimensions();
         double string_width = string_dimensions.first;
         double string_height = string_dimensions.second;
-    
+        
         // check if we need to wrap the string
         double wrap_at = string_width + 1;
         if (p->wrap_width && string_width > p->wrap_width)
@@ -455,7 +436,7 @@
                 wrap_at = p->wrap_width;
             //std::clog << "Wrapping string at" << wrap_at << std::endl;
         }
-
+    
         // work out where our line breaks need to be
         std::vector<int> line_breaks;
         std::vector<double> line_widths;
@@ -471,14 +452,14 @@
             double word_height = 0;
             for (unsigned int ii = 0; ii < p->info->num_characters(); ii++)
             {
-                character_info ci;
+                character_info ci;;
                 ci = p->info->at(ii);
-            
+                
                 unsigned c = ci.character;
                 word_width += ci.width;
                 word_height = word_height > ci.height ? word_height : ci.height;
                 ++line_count;
-    
+        
                 if (c == ' ')
                 {
                     last_space = ii;
@@ -511,42 +492,42 @@
             line_breaks.push_back(p->info->num_characters() + 1);
             line_widths.push_back(string_width);
         }
-
-        p->info->set_dimensions(string_width, string_height);
     
+        p->info->set_dimensions(string_width, string_height);
+        
         if (p->geom->type() == LineString)
         {
             std::pair<double, double> starting_pos = p->get_position_at_distance(target_distance);
-      
-            p->starting_x = starting_pos.first;
-            p->starting_y = starting_pos.second;
+            
+            p->current_placement.starting_x = starting_pos.first;
+            p->current_placement.starting_y = starting_pos.second;
         }
         else
         {
-            p->geom->label_position(&p->starting_x, &p->starting_y);
+            p->geom->label_position(&p->current_placement.starting_x, &p->current_placement.starting_y);
             //  TODO: 
             //  We would only want label position in final 'paper' coords.
             //  Move view and proj transforms to e.g. label_position(x,y,proj_trans,ctrans)?
             double z=0;  
-            p->proj_trans->backward(p->starting_x, p->starting_y, z);
-            p->ctrans->forward(&p->starting_x, &p->starting_y);
+            p->proj_trans->backward(p->current_placement.starting_x, p->current_placement.starting_y, z);
+            p->ctrans->forward(&p->current_placement.starting_x, &p->current_placement.starting_y);
         }
-    
+        
         double line_height = 0;
         unsigned int line_number = 0;
         unsigned int index_to_wrap_at = line_breaks[line_number];
         double line_width = line_widths[line_number];
-
-        double x = -line_width/2.0;
-        double y = -string_height/2.0 + 1.0;
     
+        x = -line_width/2.0;
+        y = string_height/2.0;
+    
         for (unsigned i = 0; i < p->info->num_characters(); i++)
         {
-            character_info ci;
+            character_info ci;;
             ci = p->info->at(i);
-        
+            
             unsigned c = ci.character;
-      
+        
             if (i == index_to_wrap_at)
             {
                 index_to_wrap_at = line_breaks[++line_number];
@@ -558,35 +539,31 @@
             }
             else
             {
-                p->path.add_node(c, x, y, 0.0);
-
+                p->current_placement.path.add_node(c, x, y, 0.0);
+    
                 Envelope<double> e;
                 if (p->has_dimensions)
                 {
-                    e.init(p->starting_x - (p->dimensions.first/2.0), 
-                           p->starting_y - (p->dimensions.second/2.0), 
-                           p->starting_x + (p->dimensions.first/2.0), 
-                           p->starting_y + (p->dimensions.second/2.0));
+                    e.init(p->current_placement.starting_x - (p->dimensions.first/2.0), p->current_placement.starting_y - (p->dimensions.second/2.0), p->current_placement.starting_x + (p->dimensions.first/2.0), p->current_placement.starting_y + (p->dimensions.second/2.0));
                 }
                 else
                 {
-                    e.init(p->starting_x + x, 
-                           p->starting_y - y, 
-                           p->starting_x + x + ci.width, 
-                           p->starting_y - y - ci.height);
+                    e.init(p->current_placement.starting_x + x, p->current_placement.starting_y - y, p->current_placement.starting_x + x + ci.width, p->current_placement.starting_y - y - ci.height);
                 }
-            
+                
                 if (!detector_.has_placement(e))
                 {
                     return false;
                 }
-            
+                
                 p->envelopes.push(e);
             }
             x += ci.width;
             line_height = line_height > ci.height ? line_height : ci.height;
         }
+        p->placements.push_back(p->current_placement);
+    
         return true;
     }
-}
 
+} // namespace

Modified: trunk/src/text_symbolizer.cpp
===================================================================
--- trunk/src/text_symbolizer.cpp	2006-11-01 02:04:01 UTC (rev 363)
+++ trunk/src/text_symbolizer.cpp	2006-11-01 23:17:05 UTC (rev 364)
@@ -35,6 +35,7 @@
           size_(size),
           text_ratio_(0),
           wrap_width_(0),
+          label_spacing_(0),
           fill_(fill),
           halo_fill_(Color(255,255,255)),
           halo_radius_(0),
@@ -48,6 +49,7 @@
           size_(rhs.size_),
           text_ratio_(rhs.text_ratio_),
           wrap_width_(rhs.wrap_width_),
+          label_spacing_(rhs.label_spacing_),
           fill_(rhs.fill_),
           halo_fill_(rhs.halo_fill_),
           halo_radius_(rhs.halo_radius_),
@@ -64,6 +66,7 @@
         size_ = other.size_;
         text_ratio_ = other.text_ratio_;
         wrap_width_ = other.wrap_width_;
+        label_spacing_ = other.label_spacing_;
         fill_ = other.fill_;
         halo_fill_ = other.halo_fill_;
         halo_radius_ = other.halo_radius_;
@@ -85,7 +88,7 @@
     
     unsigned  text_symbolizer::get_text_ratio() const
     {
-        return text_ratio_;
+    return text_ratio_;
     }
 
     void  text_symbolizer::set_text_ratio(unsigned ratio) 
@@ -95,14 +98,24 @@
 
     unsigned  text_symbolizer::get_wrap_width() const
     {
-        return wrap_width_;
+    return wrap_width_;
     }
 
     void  text_symbolizer::set_wrap_width(unsigned width) 
     {
         wrap_width_ = width;
+    }    
+
+    unsigned  text_symbolizer::get_label_spacing() const
+    {
+    return label_spacing_;
     }
 
+    void  text_symbolizer::set_label_spacing(unsigned spacing) 
+    {
+        label_spacing_ = spacing;
+    }
+
     unsigned  text_symbolizer::get_text_size() const
     {
         return size_;



From pavlenko at mail.berlios.de  Sat Nov  4 11:38:29 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Sat, 4 Nov 2006 11:38:29 +0100
Subject: [Mapnik-svn] r365 - in trunk: bindings/python demo/python
	include/mapnik src
Message-ID: <200611041038.kA4AcTk1012263@sheep.berlios.de>

Author: pavlenko
Date: 2006-11-04 11:38:24 +0100 (Sat, 04 Nov 2006)
New Revision: 365

Modified:
   trunk/bindings/python/mapnik_text_symbolizer.cpp
   trunk/demo/python/rundemo.py
   trunk/include/mapnik/placement_finder.hpp
   trunk/include/mapnik/text_symbolizer.hpp
   trunk/src/agg_renderer.cpp
   trunk/src/placement_finder.cpp
   trunk/src/text_symbolizer.cpp
Log:
Patch from Toby: adds a maximum angle delta for text placement (if the
angle changes too much between characters it finds an alternate
placement), this is specified in the max_char_angle_delta property in
radians (feel free to change it to degrees).

It also improves the text placement around corners trying to minimise
the distance between the center of the character and the line on each
side. This is the major portion of the patch. 



Modified: trunk/bindings/python/mapnik_text_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_text_symbolizer.cpp	2006-11-01 23:17:05 UTC (rev 364)
+++ trunk/bindings/python/mapnik_text_symbolizer.cpp	2006-11-04 10:38:24 UTC (rev 365)
@@ -43,6 +43,9 @@
                       &text_symbolizer::get_halo_fill,
                       return_value_policy<copy_const_reference>()),
                       &text_symbolizer::set_halo_fill)
+        .add_property("halo_radius",
+                      &text_symbolizer::get_halo_radius, 
+                      &text_symbolizer::set_halo_radius)
         .add_property("wrap_width",
                       &text_symbolizer::get_wrap_width,
                       &text_symbolizer::set_wrap_width)
@@ -52,9 +55,9 @@
         .add_property("label_spacing",
                       &text_symbolizer::get_label_spacing,
                       &text_symbolizer::set_label_spacing)
-        .add_property("halo_radius",
-                      &text_symbolizer::get_halo_radius, 
-                      &text_symbolizer::set_halo_radius)
+        .add_property("max_char_angle_delta",
+                      &text_symbolizer::get_max_char_angle_delta,
+                      &text_symbolizer::set_max_char_angle_delta)
         .def("set_label_placement",&text_symbolizer::set_label_placement,
              "Set the placement of the label")
 	;

Modified: trunk/demo/python/rundemo.py
===================================================================
--- trunk/demo/python/rundemo.py	2006-11-01 23:17:05 UTC (rev 364)
+++ trunk/demo/python/rundemo.py	2006-11-04 10:38:24 UTC (rev 365)
@@ -290,6 +290,8 @@
 popplaces_text_symbolizer.halo_fill = Color('white')
 popplaces_text_symbolizer.halo_radius = 1
 popplaces_rule.symbols.append(popplaces_text_symbolizer)
+popplaces_rule.symbols.append(PointSymbolizer("/home/artem/dot.png","png",10,10))
+
 popplaces_style.rules.append(popplaces_rule)
 
 m.append_style('popplaces', popplaces_style)

Modified: trunk/include/mapnik/placement_finder.hpp
===================================================================
--- trunk/include/mapnik/placement_finder.hpp	2006-11-01 23:17:05 UTC (rev 364)
+++ trunk/include/mapnik/placement_finder.hpp	2006-11-04 10:38:24 UTC (rev 365)
@@ -89,6 +89,8 @@
     int text_ratio;
 
     int label_spacing; // distance between repeated labels on a single geometry
+
+    double max_char_angle_delta;
   };
 
 
@@ -110,6 +112,7 @@
     void update_detector(placement *p);
   
     label_collision_detector3 detector_;
+
   };
   
 }

Modified: trunk/include/mapnik/text_symbolizer.hpp
===================================================================
--- trunk/include/mapnik/text_symbolizer.hpp	2006-11-01 23:17:05 UTC (rev 364)
+++ trunk/include/mapnik/text_symbolizer.hpp	2006-11-04 10:38:24 UTC (rev 365)
@@ -49,6 +49,8 @@
         void set_wrap_width(unsigned ratio);
         unsigned get_label_spacing() const; // spacing between repeated labels on lines
         void set_label_spacing(unsigned spacing);
+        double get_max_char_angle_delta() const; // maximum change in angle between adjacent characters
+        void set_max_char_angle_delta(double angle);
         unsigned get_text_size() const;
         std::string const& get_face_name() const;
         Color const& get_fill() const;
@@ -69,6 +71,7 @@
         unsigned text_ratio_;
         unsigned wrap_width_;
         unsigned label_spacing_;
+        double max_char_angle_delta_;
         Color fill_;
         Color halo_fill_;
         unsigned halo_radius_;

Modified: trunk/src/agg_renderer.cpp
===================================================================
--- trunk/src/agg_renderer.cpp	2006-11-01 23:17:05 UTC (rev 364)
+++ trunk/src/agg_renderer.cpp	2006-11-04 10:38:24 UTC (rev 365)
@@ -507,7 +507,8 @@
                     text_placement.text_ratio = sym.get_text_ratio();
                     text_placement.wrap_width = sym.get_wrap_width();
                     text_placement.label_spacing = sym.get_label_spacing();
-                    
+                    text_placement.max_char_angle_delta = sym.get_max_char_angle_delta();
+                  
                     bool found = finder_.find_placements(&text_placement);
                     if (!found) {
                       return;

Modified: trunk/src/placement_finder.cpp
===================================================================
--- trunk/src/placement_finder.cpp	2006-11-01 23:17:05 UTC (rev 364)
+++ trunk/src/placement_finder.cpp	2006-11-04 10:38:24 UTC (rev 365)
@@ -41,13 +41,13 @@
 namespace mapnik
 {
     placement::placement(string_info *info_, CoordTransform *ctrans_, const proj_transform *proj_trans_, geometry_ptr geom_, std::pair<double, double> dimensions_)
-        : info(info_), ctrans(ctrans_), proj_trans(proj_trans_), geom(geom_), label_placement(point_placement), dimensions(dimensions_), has_dimensions(true), shape_path(*ctrans_, *geom_, *proj_trans_), total_distance_(-1.0), wrap_width(0), text_ratio(0), label_spacing(0)
+        : info(info_), ctrans(ctrans_), proj_trans(proj_trans_), geom(geom_), label_placement(point_placement), dimensions(dimensions_), has_dimensions(true), shape_path(*ctrans_, *geom_, *proj_trans_), total_distance_(-1.0), wrap_width(0), text_ratio(0), label_spacing(0), max_char_angle_delta(0.0)
     {
     }
 
     //For text
     placement::placement(string_info *info_, CoordTransform *ctrans_, const proj_transform *proj_trans_, geometry_ptr geom_, label_placement_e placement_)
-        : info(info_), ctrans(ctrans_), proj_trans(proj_trans_), geom(geom_), label_placement(placement_), has_dimensions(false), shape_path(*ctrans_, *geom_, *proj_trans_), total_distance_(-1.0), wrap_width(0), text_ratio(0), label_spacing(0)
+        : info(info_), ctrans(ctrans_), proj_trans(proj_trans_), geom(geom_), label_placement(placement_), has_dimensions(false), shape_path(*ctrans_, *geom_, *proj_trans_), total_distance_(-1.0), wrap_width(0), text_ratio(0), label_spacing(0), max_char_angle_delta(0.0)
     {
     }
   
@@ -162,17 +162,15 @@
         double string_width = string_dimensions.first;
         //    double string_height = string_dimensions.second;
     
+//         for (unsigned int ii = 0; ii < p->info->num_characters(); ++ii)
+//             std::clog << static_cast<char> (p->info->at(ii).character);
+//         std::clog << std::endl;
 
-        std::clog << "trying to place string: ";
-        for (unsigned int ii = 0; ii < p->info->num_characters(); ++ii)
-            std::clog << static_cast<char> (p->info->at(ii).character);
-        std::clog << std::endl;
-
         double distance = p->get_total_distance();
     
         if (string_width > distance)
         {
-            std::clog << "String longer than segment, bailing" << std::endl;
+            //std::clog << "String longer than segment, bailing" << std::endl;
             return false;
         }
 
@@ -192,7 +190,7 @@
         bool FoundPlacement = false;
         for (std::vector<double>::const_iterator itr = ideal_label_distances.begin(); itr < ideal_label_distances.end(); ++itr)
         {
-            std::clog << "Trying to find txt placement at distance: " << *itr << std::endl;
+            //std::clog << "Trying to find txt placement at distance: " << *itr << std::endl;
             for (double i = 0; i < ideal_spacing; i += delta)
             {
                 p->clear_envelopes();
@@ -213,8 +211,8 @@
             }
         }    
     
-        if (FoundPlacement)
-            std::clog << "Found Placement" << string_width << " " << distance << std::endl;
+//         if (FoundPlacement)
+//             std::clog << "Found Placement" << string_width << " " << distance << std::endl;
 
         return FoundPlacement;
     }
@@ -270,6 +268,8 @@
      {
         double new_x, new_y, old_x, old_y;
         unsigned cur_node = 0;
+        double next_char_x = 0;
+        double next_char_y = 0;
 
         double angle = 0.0;
         int orientation = 0;
@@ -285,8 +285,11 @@
         //    double string_width = string_dimensions.first;
         double string_height = string_dimensions.second;
     
+        // find the segment that our text should start on
         p->shape_path.rewind(0);
         p->shape_path.vertex(&new_x,&new_y);
+        old_x = new_x;
+        old_y = new_y;
         for (unsigned i = 0; i < p->geom->num_points() - 1; i++)
         {
             double dx, dy;
@@ -306,60 +309,73 @@
             distance += segment_length;
             if (distance > target_distance)
             {
+                // this segment is greater that the target starting distance so start here
                 p->current_placement.starting_x = new_x - dx*(distance - target_distance)/segment_length;
                 p->current_placement.starting_y = new_y - dy*(distance - target_distance)/segment_length;
     
+                // angle text starts at and orientation
                 angle = atan2(-dy, dx);
+                orientation = fabs(angle) > M_PI/2 ? -1 : 1;
 
-                if (angle > M_PI/2 || angle <= -M_PI/2) {
-                    orientation = -1;
-                }
-                else {
-                    orientation = 1;
-                }
-
                 distance -= target_distance;
             
                 break;
             }
         }
     
+        // now find the placement of each character starting from our initial segment
+        // determined above
+        double last_angle = angle; 
         for (unsigned i = 0; i < p->info->num_characters(); i++)
         {
             character_info ci;
             unsigned c;
+
+            // grab the next character according to the orientation
+            ci = orientation > 0 ? p->info->at(i) : p->info->at(p->info->num_characters() - i - 1);
+            c = ci.character;
     
-            while (distance <= 0) 
+            double angle_delta = 0;
+
+            // if the distance remaining in this segment is less than the character width
+            // move to the next segment
+            if (distance <= ci.width) 
             {
-                double dx, dy;
+                last_angle = angle;
+                while (distance <= ci.width) 
+                {
+                    double dx, dy;
+    
+                    cur_node++;
+                
+                    if (cur_node >= p->geom->num_points()) {
+                        break;
+                    }
+                    
+                    old_x = new_x;
+                    old_y = new_y;
 
-                cur_node++;
-            
-                if (cur_node >= p->geom->num_points()) {
-                    break;
+                    p->shape_path.vertex(&new_x,&new_y);
+    
+                    dx = new_x - old_x;
+                    dy = new_y - old_y;
+    
+                    angle = atan2(-dy, dx );
+                    distance += sqrt(dx*dx+dy*dy);
                 }
-            
-                old_x = new_x;
-                old_y = new_y;
+                // since our rendering angle has changed then check against our
+                // max allowable angle change.
+                angle_delta = last_angle - angle;
+                // normalise between -180 and 180
+                while (angle_delta > M_PI)
+                    angle_delta -= M_PI;
+                while (angle_delta < -M_PI)
+                    angle_delta += M_PI;
+                if (p->max_char_angle_delta > 0 && fabs(angle_delta) > p->max_char_angle_delta)
+                    return false;
 
-                p->shape_path.vertex(&new_x,&new_y);
-
-                dx = new_x - old_x;
-                dy = new_y - old_y;
-
-                angle = atan2(-dy, dx );
-            
-                distance += sqrt(dx*dx+dy*dy);
             }
 
-            if (orientation == -1) {
-                ci = p->info->at(p->info->num_characters() - i - 1);
-            }
-            else
-            {
-                ci = p->info->at(i);
-            }
-            c = ci.character;
 
             Envelope<double> e;
             if (p->has_dimensions)
@@ -367,48 +383,114 @@
                 e.init(x, y, x + p->dimensions.first, y + p->dimensions.second);
             }
 
-            if (orientation == -1) {
-                x = new_x - (distance - ci.width)*cos(angle);
-                y = new_y + (distance - ci.width)*sin(angle);
 
-                //Center the text on the line.
-                x += (((double)string_height/2.0) - 1.0)*cos(angle+M_PI/2);
-                y -= (((double)string_height/2.0) - 1.0)*sin(angle+M_PI/2);
-        
-                if (!p->has_dimensions)
+            double render_angle = angle;
+
+            if (fabs(angle_delta) > 0.05 && i > 0)
+            {
+                // paramatise the new line segment
+                double last_dist_from_line = string_height;
+                double line_origin_x = sqrt(pow(old_x-x,2)+pow(old_y-y,2));
+                double line_origin_y = 0;
+                double closest_lp_x = cos(fabs(angle_delta));
+                double closest_lp_y = sin(fabs(angle_delta));
+
+                // iterate over placement points to find the angle to actually render the letter at
+                for (double pax = 0; pax < string_height/2 && pax < line_origin_x; pax += 0.1)
                 {
-                    e.init(x, y, x + ci.width*cos(angle+M_PI), y - ci.width*sin(angle+M_PI));
-                    e.expand_to_include(x - ci.height*sin(angle+M_PI), y - ci.height*cos(angle+M_PI));
-                    e.expand_to_include(x + (ci.width*cos(angle+M_PI) - ci.height*sin(angle+M_PI)), y - (ci.width*sin(angle+M_PI) + ci.height*cos(angle+M_PI)));
+                    // calculate dependant parameters
+                    double letter_angle = asin(pax/(string_height/2));
+                    double pbx = pax+ci.width*cos(letter_angle);
+                    double pby = ci.width*sin(letter_angle);
+
+                    // find closest point on the new segment
+                    double closest_param = ((pbx - line_origin_x)*closest_lp_x + (pby - line_origin_y)*closest_lp_y)/(closest_lp_x*closest_lp_x + closest_lp_y*closest_lp_y);
+                    double closest_point_x = line_origin_x + closest_param*closest_lp_x;
+                    double closest_point_y = line_origin_y + closest_param*closest_lp_y;
+
+                    // calculate the error between this and the letter
+                    double dist_from_line = sqrt(pow(pbx - closest_point_x,2) + pow(pby - closest_point_y,2));
+
+                    // if  our error is getting worse then stop
+                    if (dist_from_line > last_dist_from_line)
+                    {
+                        double pcx, pcy;
+                        double extra_space = (ci.height/2)*sin(fabs(angle_delta)-letter_angle);
+                        double extra_space_x = extra_space * cos(fabs(angle_delta));
+                        double extra_space_y = extra_space * sin(fabs(angle_delta));
+                        // remove extra distance used in corner
+                        distance -= line_origin_x + closest_param + extra_space;
+
+                        // transform local calculation space to a global position for placement
+                        if (angle_delta < 0)
+                        {
+                            // left turn
+                            render_angle = letter_angle + last_angle;
+                            pcx = 2*pax;
+                            pcy = 0;//-(ci.height/2)*cos(letter_angle);
+                        }
+                        else
+                        {   // right turn
+                            render_angle = -letter_angle + last_angle;
+                            pcx = 0;
+                            pcy = 0;//-(ci.height/2)*cos(letter_angle);
+                        }
+                        double rdx = pcx * cos(-last_angle) - pcy*sin(-last_angle);
+                        double rdy = pcy*cos(-last_angle) + pcx * sin(-last_angle);
+                        x += rdx;
+                        y += rdy;
+                        next_char_x = (ci.width+extra_space_x)*cos(render_angle) - extra_space_y*sin(render_angle);
+                        next_char_y = (ci.width+extra_space_x)*sin(render_angle) + extra_space_y*cos(render_angle);
+
+                        //distance -= 5;
+                        break;
+
+                    }
+                    last_dist_from_line = dist_from_line;
                 }
             }
             else
             {
-                x = new_x - distance*cos(angle);
-                y = new_y + distance*sin(angle);
-
+                x = new_x - (distance)*cos(angle);
+                y = new_y + (distance)*sin(angle);
                 //Center the text on the line.
-                x += (((double)string_height/2.0) - 1.0)*cos(angle-M_PI/2);
-                y -= (((double)string_height/2.0) - 1.0)*sin(angle-M_PI/2);
+                x -= (((double)string_height/2.0) - 1.0)*cos(render_angle+M_PI/2);
+                y += (((double)string_height/2.0) - 1.0)*sin(render_angle+M_PI/2);
+                distance -= ci.width;
+                next_char_x = ci.width*cos(render_angle);
+                next_char_y = ci.width*sin(render_angle);
+            }
 
-                if (!p->has_dimensions)
-                {
-                    e.init(x, y, x + ci.width*cos(angle), y - ci.width*sin(angle));
-                    e.expand_to_include(x - ci.height*sin(angle), y - ci.height*cos(angle));
-                    e.expand_to_include(x + (ci.width*cos(angle) - ci.height*sin(angle)), y - (ci.width*sin(angle) + ci.height*cos(angle)));
-                }
+            double render_x = x;
+            double render_y = y;
+
+            if (!p->has_dimensions)
+            {
+                // put four corners of the letter into envelope
+                e.init(render_x, render_y, render_x + ci.width*cos(render_angle), render_y - ci.width*sin(render_angle));
+                e.expand_to_include(render_x - ci.height*sin(render_angle), render_y - ci.height*cos(render_angle));
+                e.expand_to_include(render_x + (ci.width*cos(render_angle) - ci.height*sin(render_angle)), render_y - (ci.width*sin(render_angle) + ci.height*cos(render_angle)));
             }
-        
+
             if (!detector_.has_placement(e))
             {
                 return false;
             }
         
             p->envelopes.push(e);
+
+            if (orientation < 0)
+            {
+                // rotate in place
+                render_x += ci.width*cos(render_angle) - (string_height-2)*sin(render_angle);
+                render_y -= ci.width*sin(render_angle) + (string_height-2)*cos(render_angle);
+                render_angle += M_PI;
+            }
+
         
-            p->current_placement.path.add_node(c, x - p->current_placement.starting_x, -y + p->current_placement.starting_y, (orientation == -1 ? angle + M_PI : angle));
-        
-            distance -= ci.width;
+            p->current_placement.path.add_node(c, render_x - p->current_placement.starting_x, -render_y + p->current_placement.starting_y, render_angle);
+            x += next_char_x;
+            y -= next_char_y;
         }
         p->placements.push_back(p->current_placement);
 
@@ -434,7 +516,6 @@
                 for (int i = 1; ((wrap_at = string_width/i)/(string_height*i)) > p->text_ratio && (string_width/i) > p->wrap_width; ++i);
             else
                 wrap_at = p->wrap_width;
-            //std::clog << "Wrapping string at" << wrap_at << std::endl;
         }
     
         // work out where our line breaks need to be
@@ -492,7 +573,7 @@
             line_breaks.push_back(p->info->num_characters() + 1);
             line_widths.push_back(string_width);
         }
-    
+        
         p->info->set_dimensions(string_width, string_height);
         
         if (p->geom->type() == LineString)
@@ -527,7 +608,6 @@
             ci = p->info->at(i);
             
             unsigned c = ci.character;
-        
             if (i == index_to_wrap_at)
             {
                 index_to_wrap_at = line_breaks[++line_number];

Modified: trunk/src/text_symbolizer.cpp
===================================================================
--- trunk/src/text_symbolizer.cpp	2006-11-01 23:17:05 UTC (rev 364)
+++ trunk/src/text_symbolizer.cpp	2006-11-04 10:38:24 UTC (rev 365)
@@ -30,18 +30,19 @@
 namespace mapnik
 {
     text_symbolizer::text_symbolizer(std::string const& name, std::string const& face_name, unsigned size,Color const& fill)
-        : name_(name),
+	: name_(name),
           face_name_(face_name),
-          size_(size),
+	  size_(size),
           text_ratio_(0),
           wrap_width_(0),
           label_spacing_(0),
-          fill_(fill),
-          halo_fill_(Color(255,255,255)),
-          halo_radius_(0),
-          label_p_(point_placement),
-          anchor_(0.0,0.5),
-          displacement_(0.0,0.0)  {}
+          max_char_angle_delta_(0),
+	  fill_(fill),
+	  halo_fill_(Color(255,255,255)),
+	  halo_radius_(0),
+	  label_p_(point_placement),
+	  anchor_(0.0,0.5),
+	  displacement_(0.0,0.0)  {}
            
     text_symbolizer::text_symbolizer(text_symbolizer const& rhs)
         : name_(rhs.name_),
@@ -50,6 +51,7 @@
           text_ratio_(rhs.text_ratio_),
           wrap_width_(rhs.wrap_width_),
           label_spacing_(rhs.label_spacing_),
+          max_char_angle_delta_(rhs.max_char_angle_delta_),
           fill_(rhs.fill_),
           halo_fill_(rhs.halo_fill_),
           halo_radius_(rhs.halo_radius_),
@@ -67,6 +69,7 @@
         text_ratio_ = other.text_ratio_;
         wrap_width_ = other.wrap_width_;
         label_spacing_ = other.label_spacing_;
+        max_char_angle_delta_ = other.max_char_angle_delta_;
         fill_ = other.fill_;
         halo_fill_ = other.halo_fill_;
         halo_radius_ = other.halo_radius_;
@@ -108,7 +111,7 @@
 
     unsigned  text_symbolizer::get_label_spacing() const
     {
-    return label_spacing_;
+        return label_spacing_;
     }
 
     void  text_symbolizer::set_label_spacing(unsigned spacing) 
@@ -116,6 +119,16 @@
         label_spacing_ = spacing;
     }
 
+    double text_symbolizer::get_max_char_angle_delta() const
+    {
+        return max_char_angle_delta_;
+    }
+
+    void text_symbolizer::set_max_char_angle_delta(double angle) 
+    {
+        max_char_angle_delta_ = angle;
+    }
+
     unsigned  text_symbolizer::get_text_size() const
     {
         return size_;



From pavlenko at mail.berlios.de  Wed Nov  8 21:58:42 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Wed, 8 Nov 2006 21:58:42 +0100
Subject: [Mapnik-svn] r366 - trunk/src
Message-ID: <200611082058.kA8KwgvO021883@sheep.berlios.de>

Author: pavlenko
Date: 2006-11-08 21:58:40 +0100 (Wed, 08 Nov 2006)
New Revision: 366

Modified:
   trunk/src/placement_finder.cpp
   trunk/src/point_symbolizer.cpp
Log:
1. fixed vertical alignement (??)
2. initialize overlap_ in ctor



Modified: trunk/src/placement_finder.cpp
===================================================================
--- trunk/src/placement_finder.cpp	2006-11-04 10:38:24 UTC (rev 365)
+++ trunk/src/placement_finder.cpp	2006-11-08 20:58:40 UTC (rev 366)
@@ -600,7 +600,7 @@
         double line_width = line_widths[line_number];
     
         x = -line_width/2.0;
-        y = string_height/2.0;
+        y = -string_height/2.0 + 1.0;
     
         for (unsigned i = 0; i < p->info->num_characters(); i++)
         {

Modified: trunk/src/point_symbolizer.cpp
===================================================================
--- trunk/src/point_symbolizer.cpp	2006-11-04 10:38:24 UTC (rev 365)
+++ trunk/src/point_symbolizer.cpp	2006-11-08 20:58:40 UTC (rev 366)
@@ -43,7 +43,8 @@
     point_symbolizer::point_symbolizer(std::string const& file,
                                        std::string const& type,
                                        unsigned width,unsigned height) 
-        : symbol_(new ImageData32(width,height))
+        : symbol_(new ImageData32(width,height)),
+          overlap_(false)
     {
         try 
         {



From pavlenko at mail.berlios.de  Fri Nov 10 00:45:06 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Fri, 10 Nov 2006 00:45:06 +0100
Subject: [Mapnik-svn] r367 - in trunk: agg/include agg/src demo/python src
Message-ID: <200611092345.kA9Nj6xF002101@sheep.berlios.de>

Author: pavlenko
Date: 2006-11-10 00:44:34 +0100 (Fri, 10 Nov 2006)
New Revision: 367

Modified:
   trunk/agg/include/agg_alpha_mask_u8.h
   trunk/agg/include/agg_array.h
   trunk/agg/include/agg_basics.h
   trunk/agg/include/agg_bspline.h
   trunk/agg/include/agg_color_gray.h
   trunk/agg/include/agg_color_rgba.h
   trunk/agg/include/agg_config.h
   trunk/agg/include/agg_conv_adaptor_vcgen.h
   trunk/agg/include/agg_conv_adaptor_vpgen.h
   trunk/agg/include/agg_conv_close_polygon.h
   trunk/agg/include/agg_conv_concat.h
   trunk/agg/include/agg_conv_curve.h
   trunk/agg/include/agg_conv_gpc.h
   trunk/agg/include/agg_conv_transform.h
   trunk/agg/include/agg_conv_unclose_polygon.h
   trunk/agg/include/agg_curves.h
   trunk/agg/include/agg_font_cache_manager.h
   trunk/agg/include/agg_gamma_lut.h
   trunk/agg/include/agg_gsv_text.h
   trunk/agg/include/agg_image_accessors.h
   trunk/agg/include/agg_image_filters.h
   trunk/agg/include/agg_line_aa_basics.h
   trunk/agg/include/agg_math.h
   trunk/agg/include/agg_math_stroke.h
   trunk/agg/include/agg_path_storage.h
   trunk/agg/include/agg_pixfmt_amask_adaptor.h
   trunk/agg/include/agg_pixfmt_gray.h
   trunk/agg/include/agg_pixfmt_rgb.h
   trunk/agg/include/agg_pixfmt_rgb_packed.h
   trunk/agg/include/agg_pixfmt_rgba.h
   trunk/agg/include/agg_rasterizer_cells_aa.h
   trunk/agg/include/agg_rasterizer_compound_aa.h
   trunk/agg/include/agg_rasterizer_outline.h
   trunk/agg/include/agg_rasterizer_outline_aa.h
   trunk/agg/include/agg_rasterizer_scanline_aa.h
   trunk/agg/include/agg_renderer_base.h
   trunk/agg/include/agg_renderer_markers.h
   trunk/agg/include/agg_renderer_mclip.h
   trunk/agg/include/agg_renderer_outline_aa.h
   trunk/agg/include/agg_renderer_outline_image.h
   trunk/agg/include/agg_renderer_primitives.h
   trunk/agg/include/agg_renderer_raster_text.h
   trunk/agg/include/agg_renderer_scanline.h
   trunk/agg/include/agg_rendering_buffer.h
   trunk/agg/include/agg_rendering_buffer_dynarow.h
   trunk/agg/include/agg_scanline_bin.h
   trunk/agg/include/agg_scanline_p.h
   trunk/agg/include/agg_scanline_storage_aa.h
   trunk/agg/include/agg_scanline_u.h
   trunk/agg/include/agg_span_allocator.h
   trunk/agg/include/agg_span_converter.h
   trunk/agg/include/agg_span_gradient.h
   trunk/agg/include/agg_span_image_filter.h
   trunk/agg/include/agg_span_image_filter_gray.h
   trunk/agg/include/agg_span_image_filter_rgb.h
   trunk/agg/include/agg_span_image_filter_rgba.h
   trunk/agg/include/agg_span_pattern_gray.h
   trunk/agg/include/agg_span_pattern_rgb.h
   trunk/agg/include/agg_span_pattern_rgba.h
   trunk/agg/include/agg_trans_affine.h
   trunk/agg/include/agg_trans_perspective.h
   trunk/agg/include/agg_trans_warp_magnifier.h
   trunk/agg/include/agg_vcgen_contour.h
   trunk/agg/include/agg_vcgen_stroke.h
   trunk/agg/include/agg_vertex_sequence.h
   trunk/agg/src/agg_bspline.cpp
   trunk/agg/src/agg_curves.cpp
   trunk/agg/src/agg_gsv_text.cpp
   trunk/agg/src/agg_image_filters.cpp
   trunk/agg/src/agg_line_aa_basics.cpp
   trunk/agg/src/agg_line_profile_aa.cpp
   trunk/agg/src/agg_sqrt_tables.cpp
   trunk/agg/src/agg_trans_affine.cpp
   trunk/agg/src/agg_trans_warp_magnifier.cpp
   trunk/agg/src/agg_vcgen_contour.cpp
   trunk/agg/src/agg_vcgen_stroke.cpp
   trunk/demo/python/rundemo.py
   trunk/src/agg_renderer.cpp
   trunk/src/load_map.cpp
Log:
1.upgrade to latest agg2.4
2.added default PointSymbolizer in load_map.cpp



Modified: trunk/agg/include/agg_alpha_mask_u8.h
===================================================================
--- trunk/agg/include/agg_alpha_mask_u8.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_alpha_mask_u8.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -57,7 +57,7 @@
         };
 
         alpha_mask_u8() : m_rbuf(0) {}
-        alpha_mask_u8(rendering_buffer& rbuf) : m_rbuf(&rbuf) {}
+        explicit alpha_mask_u8(rendering_buffer& rbuf) : m_rbuf(&rbuf) {}
 
         void attach(rendering_buffer& rbuf) { m_rbuf = &rbuf; }
 
@@ -70,7 +70,7 @@
         {
             if(x >= 0 && y >= 0 && 
                x < (int)m_rbuf->width() && 
-               y <= (int)m_rbuf->height())
+               y < (int)m_rbuf->height())
             {
                 return (cover_type)m_mask_function.calculate(
                                         m_rbuf->row_ptr(y) + x * Step + Offset);
@@ -83,7 +83,7 @@
         {
             if(x >= 0 && y >= 0 && 
                x < (int)m_rbuf->width() && 
-               y <= (int)m_rbuf->height())
+               y < (int)m_rbuf->height())
             {
                 return (cover_type)((cover_full + val * 
                                      m_mask_function.calculate(
@@ -361,7 +361,7 @@
         };
 
         amask_no_clip_u8() : m_rbuf(0) {}
-        amask_no_clip_u8(rendering_buffer& rbuf) : m_rbuf(&rbuf) {}
+        explicit amask_no_clip_u8(rendering_buffer& rbuf) : m_rbuf(&rbuf) {}
 
         void attach(rendering_buffer& rbuf) { m_rbuf = &rbuf; }
 

Modified: trunk/agg/include/agg_array.h
===================================================================
--- trunk/agg/include/agg_array.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_array.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -109,20 +109,27 @@
         typedef T value_type;
         typedef pod_array<T> self_type;
 
-        ~pod_array() { delete [] m_array; }
+        ~pod_array() { pod_allocator<T>::deallocate(m_array, m_size); }
         pod_array() : m_array(0), m_size(0) {}
-        pod_array(unsigned size) : m_array(new T[size]), m_size(size) {}
+
+        pod_array(unsigned size) : 
+            m_array(pod_allocator<T>::allocate(size)), 
+            m_size(size) 
+        {}
+
         pod_array(const self_type& v) : 
-            m_array(new T[v.m_size]), m_size(v.m_size) 
+            m_array(pod_allocator<T>::allocate(v.m_size)), 
+            m_size(v.m_size) 
         {
             memcpy(m_array, v.m_array, sizeof(T) * m_size);
         }
+
         void resize(unsigned size)
         {
             if(size != m_size)
             {
-                delete [] m_array;
-                m_array = new T[m_size = size];
+                pod_allocator<T>::deallocate(m_array, m_size);
+                m_array = pod_allocator<T>::allocate(m_size = size);
             }
         }
         const self_type& operator = (const self_type& v)
@@ -157,7 +164,7 @@
     public:
         typedef T value_type;
 
-        ~pod_vector() { delete [] m_array; }
+        ~pod_vector() { pod_allocator<T>::deallocate(m_array, m_capacity); }
         pod_vector() : m_size(0), m_capacity(0), m_array(0) {}
         pod_vector(unsigned cap, unsigned extra_tail=0);
 
@@ -215,9 +222,9 @@
         m_size = 0;
         if(cap > m_capacity)
         {
-            delete [] m_array;
+            pod_allocator<T>::deallocate(m_array, m_capacity);
             m_capacity = cap + extra_tail;
-            m_array = m_capacity ? new T [m_capacity] : 0;
+            m_array = m_capacity ? pod_allocator<T>::allocate(m_capacity) : 0;
         }
     }
 
@@ -238,9 +245,9 @@
         {
             if(new_size > m_capacity)
             {
-                T* data = new T[new_size];
+                T* data = pod_allocator<T>::allocate(new_size);
                 memcpy(data, m_array, m_size * sizeof(T));
-                delete [] m_array;
+                pod_allocator<T>::deallocate(m_array, m_capacity);
                 m_array = data;
             }
         }
@@ -252,13 +259,15 @@
 
     //------------------------------------------------------------------------
     template<class T> pod_vector<T>::pod_vector(unsigned cap, unsigned extra_tail) :
-        m_size(0), m_capacity(cap + extra_tail), m_array(new T[m_capacity]) {}
+        m_size(0), 
+        m_capacity(cap + extra_tail), 
+        m_array(pod_allocator<T>::allocate(m_capacity)) {}
 
     //------------------------------------------------------------------------
     template<class T> pod_vector<T>::pod_vector(const pod_vector<T>& v) :
         m_size(v.m_size),
         m_capacity(v.m_capacity),
-        m_array(v.m_capacity ? new T [v.m_capacity] : 0)
+        m_array(v.m_capacity ? pod_allocator<T>::allocate(v.m_capacity) : 0)
     {
         memcpy(m_array, v.m_array, sizeof(T) * v.m_size);
     }
@@ -509,11 +518,11 @@
             T** blk = m_blocks + m_num_blocks - 1;
             while(m_num_blocks--)
             {
-                delete [] *blk;
+                pod_allocator<T>::deallocate(*blk, block_size);
                 --blk;
             }
-            delete [] m_blocks;
         }
+        pod_allocator<T*>::deallocate(m_blocks, m_max_blocks);
     }
 
 
@@ -526,8 +535,14 @@
             unsigned nb = (size + block_mask) >> block_shift;
             while(m_num_blocks > nb)
             {
-                delete [] m_blocks[--m_num_blocks];
+                pod_allocator<T>::deallocate(m_blocks[--m_num_blocks], block_size);
             }
+            if(m_num_blocks == 0)
+            {
+                pod_allocator<T*>::deallocate(m_blocks, m_max_blocks);
+                m_blocks = 0;
+                m_max_blocks = 0;
+            }
             m_size = size;
         }
     }
@@ -562,13 +577,15 @@
         m_size(v.m_size),
         m_num_blocks(v.m_num_blocks),
         m_max_blocks(v.m_max_blocks),
-        m_blocks(v.m_max_blocks ? new T* [v.m_max_blocks] : 0),
+        m_blocks(v.m_max_blocks ? 
+                 pod_allocator<T*>::allocate(v.m_max_blocks) : 
+                 0),
         m_block_ptr_inc(v.m_block_ptr_inc)
     {
         unsigned i;
         for(i = 0; i < v.m_num_blocks; ++i)
         {
-            m_blocks[i] = new T [block_size];
+            m_blocks[i] = pod_allocator<T>::allocate(block_size);
             memcpy(m_blocks[i], v.m_blocks[i], block_size * sizeof(T));
         }
     }
@@ -599,7 +616,7 @@
     {
         if(nb >= m_max_blocks) 
         {
-            T** new_blocks = new T* [m_max_blocks + m_block_ptr_inc];
+            T** new_blocks = pod_allocator<T*>::allocate(m_max_blocks + m_block_ptr_inc);
 
             if(m_blocks)
             {
@@ -607,12 +624,12 @@
                        m_blocks, 
                        m_num_blocks * sizeof(T*));
 
-                delete [] m_blocks;
+                pod_allocator<T*>::deallocate(m_blocks, m_max_blocks);
             }
             m_blocks = new_blocks;
             m_max_blocks += m_block_ptr_inc;
         }
-        m_blocks[nb] = new T [block_size];
+        m_blocks[nb] = pod_allocator<T>::allocate(block_size);
         m_num_blocks++;
     }
 
@@ -753,7 +770,7 @@
     }
 
 
-    //-----------------------------------------------------------pod_allocator
+    //---------------------------------------------------------block_allocator
     // Allocator for arbitrary POD data. Most usable in different cache
     // systems for efficient memory allocations. 
     // Memory is allocated with blocks of fixed size ("block_size" in
@@ -761,20 +778,26 @@
     // creates a new block of the required size. However, the most efficient
     // use is when the average reqired size is much less than the block size. 
     //------------------------------------------------------------------------
-    class pod_allocator
+    class block_allocator
     {
+        struct block_type
+        {
+            int8u*   data;
+            unsigned size;
+        };
+
     public:
         void remove_all()
         {
             if(m_num_blocks)
             {
-                int8u** blk = m_blocks + m_num_blocks - 1;
+                block_type* blk = m_blocks + m_num_blocks - 1;
                 while(m_num_blocks--)
                 {
-                    delete [] *blk;
+                    pod_allocator<int8u>::deallocate(blk->data, blk->size);
                     --blk;
                 }
-                delete [] m_blocks;
+                pod_allocator<block_type>::deallocate(m_blocks, m_max_blocks);
             }
             m_num_blocks = 0;
             m_max_blocks = 0;
@@ -783,12 +806,12 @@
             m_rest = 0;
         }
 
-        ~pod_allocator()
+        ~block_allocator()
         {
             remove_all();
         }
 
-        pod_allocator(unsigned block_size, unsigned block_ptr_inc=256-8) :
+        block_allocator(unsigned block_size, unsigned block_ptr_inc=256-8) :
             m_block_size(block_size),
             m_block_ptr_inc(block_ptr_inc),
             m_num_blocks(0),
@@ -808,7 +831,9 @@
                 int8u* ptr = m_buf_ptr;
                 if(alignment > 1)
                 {
-                    unsigned align = (alignment - unsigned((size_t)ptr) % alignment) % alignment;
+                    unsigned align = 
+                        (alignment - unsigned((size_t)ptr) % alignment) % alignment;
+
                     size += align;
                     ptr += align;
                     if(size <= m_rest)
@@ -835,31 +860,36 @@
             if(size < m_block_size) size = m_block_size;
             if(m_num_blocks >= m_max_blocks) 
             {
-                int8u** new_blocks = new int8u* [m_max_blocks + m_block_ptr_inc];
+                block_type* new_blocks = 
+                    pod_allocator<block_type>::allocate(m_max_blocks + m_block_ptr_inc);
 
                 if(m_blocks)
                 {
                     memcpy(new_blocks, 
                            m_blocks, 
-                           m_num_blocks * sizeof(int8u*));
-
-                    delete [] m_blocks;
+                           m_num_blocks * sizeof(block_type));
+                    pod_allocator<block_type>::deallocate(m_blocks, m_max_blocks);
                 }
                 m_blocks = new_blocks;
                 m_max_blocks += m_block_ptr_inc;
             }
-            m_blocks[m_num_blocks] = m_buf_ptr = new int8u [size];
+
+            m_blocks[m_num_blocks].size = size;
+            m_blocks[m_num_blocks].data = 
+                m_buf_ptr =
+                pod_allocator<int8u>::allocate(size);
+
             m_num_blocks++;
             m_rest = size;
         }
 
-        unsigned m_block_size;
-        unsigned m_block_ptr_inc;
-        unsigned m_num_blocks;
-        unsigned m_max_blocks;
-        int8u**  m_blocks;
-        int8u*   m_buf_ptr;
-        unsigned m_rest;
+        unsigned    m_block_size;
+        unsigned    m_block_ptr_inc;
+        unsigned    m_num_blocks;
+        unsigned    m_max_blocks;
+        block_type* m_blocks;
+        int8u*      m_buf_ptr;
+        unsigned    m_rest;
     };
 
 
@@ -1014,7 +1044,6 @@
         return j;
     }
 
-
     //--------------------------------------------------------invert_container
     template<class Array> void invert_container(Array& arr)
     {
@@ -1026,7 +1055,6 @@
         }
     }
 
-
     //------------------------------------------------------binary_search_pos
     template<class Array, class Value, class Less>
     unsigned binary_search_pos(const Array& arr, const Value& val, Less less)
@@ -1052,6 +1080,40 @@
         return end;
     }
 
+    //----------------------------------------------------------range_adaptor
+    template<class Array> class range_adaptor
+    {
+    public:
+        typedef typename Array::value_type value_type;
+
+        range_adaptor(Array& array, unsigned start, unsigned size) :
+            m_array(array), m_start(start), m_size(size)
+        {}
+
+        unsigned size() const { return m_size; }
+        const value_type& operator [] (unsigned i) const { return m_array[m_start + i]; }
+              value_type& operator [] (unsigned i)       { return m_array[m_start + i]; }
+        const value_type& at(unsigned i) const           { return m_array[m_start + i]; }
+              value_type& at(unsigned i)                 { return m_array[m_start + i]; }
+        value_type  value_at(unsigned i) const           { return m_array[m_start + i]; }
+
+    private:
+        Array& m_array;
+        unsigned m_start;
+        unsigned m_size;
+    };
+
+    //---------------------------------------------------------------int_less
+    inline bool int_less(int a, int b) { return a < b; }
+
+    //------------------------------------------------------------int_greater
+    inline bool int_greater(int a, int b) { return a > b; }
+
+    //----------------------------------------------------------unsigned_less
+    inline bool unsigned_less(unsigned a, unsigned b) { return a < b; }
+
+    //-------------------------------------------------------unsigned_greater
+    inline bool unsigned_greater(unsigned a, unsigned b) { return a > b; }
 }
 
 #endif

Modified: trunk/agg/include/agg_basics.h
===================================================================
--- trunk/agg/include/agg_basics.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_basics.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -19,6 +19,43 @@
 #include <math.h>
 #include "agg_config.h"
 
+//---------------------------------------------------------AGG_CUSTOM_ALLOCATOR
+#ifdef AGG_CUSTOM_ALLOCATOR
+#include "agg_allocator.h"
+#else
+namespace agg
+{
+    // The policy of all AGG containers and memory allocation strategy 
+    // in general is that no allocated data requires explicit construction.
+    // It means that the allocator can be really simple; you can even
+    // replace new/delete to malloc/free. The constructors and destructors 
+    // won't be called in this case, however everything will remain working. 
+    // The second argument of deallocate() is the size of the allocated 
+    // block. You can use this information if you wish.
+    //------------------------------------------------------------pod_allocator
+    template<class T> struct pod_allocator
+    {
+        static T*   allocate(unsigned num)       { return new T [num]; }
+        static void deallocate(T* ptr, unsigned) { delete [] ptr;      }
+    };
+
+    // Single object allocator. It's also can be replaced with your custom
+    // allocator. The difference is that it can only allocate a single 
+    // object and the constructor and destructor must be called. 
+    // In AGG there is no need to allocate an array of objects with
+    // calling their constructors (only single ones). So that, if you
+    // replace these new/delete to malloc/free make sure that the in-place
+    // new is called and take care of calling the destructor too.
+    //------------------------------------------------------------obj_allocator
+    template<class T> struct obj_allocator
+    {
+        static T*   allocate()         { return new T; }
+        static void deallocate(T* ptr) { delete ptr;   }
+    };
+}
+#endif
+
+
 //-------------------------------------------------------- Default basic types
 //
 // If the compiler has different capacity of the basic types you can redefine
@@ -93,15 +130,17 @@
 #pragma warning(disable : 4035) //Disable warning "no return value"
     AGG_INLINE int iround(double v)              //-------iround
     {
+        int t;
         __asm fld   qword ptr [v]
-        __asm fistp dword ptr [ebp-8]
-        __asm mov eax, dword ptr [ebp-8]
+        __asm fistp dword ptr [t]
+        __asm mov eax, dword ptr [t]
     }
     AGG_INLINE unsigned uround(double v)         //-------uround
     {
+        unsigned t;
         __asm fld   qword ptr [v]
-        __asm fistp dword ptr [ebp-8]
-        __asm mov eax, dword ptr [ebp-8]
+        __asm fistp dword ptr [t]
+        __asm mov eax, dword ptr [t]
     }
 #pragma warning(pop)
     AGG_INLINE unsigned ufloor(double v)         //-------ufloor
@@ -218,16 +257,19 @@
     //----------------------------------------------------------------rect_base
     template<class T> struct rect_base
     {
+        typedef T            value_type;
         typedef rect_base<T> self_type;
-        T x1;
-        T y1;
-        T x2;
-        T y2;
+        T x1, y1, x2, y2;
 
         rect_base() {}
         rect_base(T x1_, T y1_, T x2_, T y2_) :
             x1(x1_), y1(y1_), x2(x2_), y2(y2_) {}
 
+        void init(T x1_, T y1_, T x2_, T y2_) 
+        {
+            x1 = x1_; y1 = y1_; x2 = x2_; y2 = y2_; 
+        }
+
         const self_type& normalize()
         {
             T t;
@@ -249,6 +291,11 @@
         {
             return x1 <= x2 && y1 <= y2;
         }
+
+        bool hit_test(T x, T y) const
+        {
+            return (x >= x1 && x <= x2 && y >= y1 && y <= y2);
+        }
     };
 
     //-----------------------------------------------------intersect_rectangles
@@ -451,6 +498,31 @@
     typedef vertex_base<float>  vertex_f; //-----vertex_f
     typedef vertex_base<double> vertex_d; //-----vertex_d
 
+    //----------------------------------------------------------------row_info
+    template<class T> struct row_info
+    {
+        int x1, x2;
+        T* ptr;
+        row_info() {}
+        row_info(int x1_, int x2_, T* ptr_) : x1(x1_), x2(x2_), ptr(ptr_) {}
+    };
+
+    //----------------------------------------------------------const_row_info
+    template<class T> struct const_row_info
+    {
+        int x1, x2;
+        const T* ptr;
+        const_row_info() {}
+        const_row_info(int x1_, int x2_, const T* ptr_) : 
+            x1(x1_), x2(x2_), ptr(ptr_) {}
+    };
+
+    //------------------------------------------------------------is_equal_eps
+    template<class T> inline bool is_equal_eps(T v1, T v2, T epsilon)
+    {
+        return fabs(v1 - v2) <= double(epsilon);
+    }
+
 }
 
 

Modified: trunk/agg/include/agg_bspline.h
===================================================================
--- trunk/agg/include/agg_bspline.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_bspline.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -20,7 +20,7 @@
 #ifndef AGG_BSPLINE_INCLUDED
 #define AGG_BSPLINE_INCLUDED
 
-#include "agg_basics.h"
+#include "agg_array.h"
 
 namespace agg
 {
@@ -40,7 +40,6 @@
     class bspline 
     {
     public:
-        ~bspline();
         bspline();
         bspline(int num);
         bspline(int num, const double* x, const double* y);
@@ -63,12 +62,12 @@
         double extrapolation_right(double x) const;
         double interpolation(double x, int i) const;
 
-        int     m_max;
-        int     m_num;
-        double* m_x;
-        double* m_y;
-        double* m_am;
-        mutable int m_last_idx;
+        int               m_max;
+        int               m_num;
+        double*           m_x;
+        double*           m_y;
+        pod_array<double> m_am;
+        mutable int       m_last_idx;
     };
 
 

Modified: trunk/agg/include/agg_color_gray.h
===================================================================
--- trunk/agg/include/agg_color_gray.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_color_gray.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -148,7 +148,7 @@
                 return *this;
             }
             calc_type v_ = (calc_type(v) * base_mask) / a;
-            v = value_type((v_ > base_mask) ? base_mask : v_);
+            v = value_type((v_ > base_mask) ? (value_type)base_mask : v_);
             return *this;
         }
 
@@ -163,6 +163,31 @@
         }
 
         //--------------------------------------------------------------------
+        AGG_INLINE void add(const self_type& c, unsigned cover)
+        {
+            calc_type cv, ca;
+            if(cover == cover_mask)
+            {
+                if(c.a == base_mask) 
+                {
+                    *this = c;
+                }
+                else
+                {
+                    cv = v + c.v; v = (cv > calc_type(base_mask)) ? calc_type(base_mask) : cv;
+                    ca = a + c.a; a = (ca > calc_type(base_mask)) ? calc_type(base_mask) : ca;
+                }
+            }
+            else
+            {
+                cv = v + ((c.v * cover + cover_mask/2) >> cover_shift);
+                ca = a + ((c.a * cover + cover_mask/2) >> cover_shift);
+                v = (cv > calc_type(base_mask)) ? calc_type(base_mask) : cv;
+                a = (ca > calc_type(base_mask)) ? calc_type(base_mask) : ca;
+            }
+        }
+
+        //--------------------------------------------------------------------
         static self_type no_color() { return self_type(0,0); }
     };
 
@@ -325,6 +350,31 @@
         }
 
         //--------------------------------------------------------------------
+        AGG_INLINE void add(const self_type& c, unsigned cover)
+        {
+            calc_type cv, ca;
+            if(cover == cover_mask)
+            {
+                if(c.a == base_mask) 
+                {
+                    *this = c;
+                }
+                else
+                {
+                    cv = v + c.v; v = (cv > calc_type(base_mask)) ? calc_type(base_mask) : cv;
+                    ca = a + c.a; a = (ca > calc_type(base_mask)) ? calc_type(base_mask) : ca;
+                }
+            }
+            else
+            {
+                cv = v + ((c.v * cover + cover_mask/2) >> cover_shift);
+                ca = a + ((c.a * cover + cover_mask/2) >> cover_shift);
+                v = (cv > calc_type(base_mask)) ? calc_type(base_mask) : cv;
+                a = (ca > calc_type(base_mask)) ? calc_type(base_mask) : ca;
+            }
+        }
+
+        //--------------------------------------------------------------------
         static self_type no_color() { return self_type(0,0); }
     };
 

Modified: trunk/agg/include/agg_color_rgba.h
===================================================================
--- trunk/agg/include/agg_color_rgba.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_color_rgba.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -443,32 +443,43 @@
     }
 
 
-    //-----------------------------------------------------------rgb8_packed
+    //-------------------------------------------------------------rgb8_packed
     inline rgba8 rgb8_packed(unsigned v)
     {
         return rgba8((v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF);
     }
 
-    //-----------------------------------------------------------bgr8_packed
+    //-------------------------------------------------------------bgr8_packed
     inline rgba8 bgr8_packed(unsigned v)
     {
         return rgba8(v & 0xFF, (v >> 8) & 0xFF, (v >> 16) & 0xFF);
     }
 
-    //----------------------------------------------------------argb8_packed
+    //------------------------------------------------------------argb8_packed
     inline rgba8 argb8_packed(unsigned v)
     {
         return rgba8((v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF, v >> 24);
     }
 
+    //---------------------------------------------------------rgba8_gamma_dir
+    template<class GammaLUT>
+    rgba8 rgba8_gamma_dir(rgba8 c, const GammaLUT& gamma)
+    {
+        return rgba8(gamma.dir(c.r), gamma.dir(c.g), gamma.dir(c.b), c.a);
+    }
 
+    //---------------------------------------------------------rgba8_gamma_inv
+    template<class GammaLUT>
+    rgba8 rgba8_gamma_inv(rgba8 c, const GammaLUT& gamma)
+    {
+        return rgba8(gamma.inv(c.r), gamma.inv(c.g), gamma.inv(c.b), c.a);
+    }
 
 
 
 
 
-
-    //=================================================================rgba16
+    //==================================================================rgba16
     struct rgba16
     {
         typedef int16u value_type;
@@ -709,6 +720,22 @@
         return rgba16(c,a).premultiply();
     }
 
+
+    //------------------------------------------------------rgba16_gamma_dir
+    template<class GammaLUT>
+    rgba16 rgba16_gamma_dir(rgba16 c, const GammaLUT& gamma)
+    {
+        return rgba16(gamma.dir(c.r), gamma.dir(c.g), gamma.dir(c.b), c.a);
+    }
+
+    //------------------------------------------------------rgba16_gamma_inv
+    template<class GammaLUT>
+    rgba16 rgba16_gamma_inv(rgba16 c, const GammaLUT& gamma)
+    {
+        return rgba16(gamma.inv(c.r), gamma.inv(c.g), gamma.inv(c.b), c.a);
+    }
+
+
 }
 
 

Modified: trunk/agg/include/agg_config.h
===================================================================
--- trunk/agg/include/agg_config.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_config.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -1,7 +1,10 @@
 #ifndef AGG_CONFIG_INCLUDED
 #define AGG_CONFIG_INCLUDED
 
-// This file can be used to redefine the default basic types such as:
+// This file can be used to redefine certain data types.
+
+//---------------------------------------
+// 1. Default basic types such as:
 // 
 // AGG_INT8
 // AGG_INT8U
@@ -23,4 +26,20 @@
 // but it won't result any crash and the rest of the library will remain 
 // fully functional.
 
+
+//---------------------------------------
+// 2. Default rendering_buffer type. Can be:
+//
+// Provides faster access for massive pixel operations, 
+// such as blur, image filtering:
+
+// #define AGG_RENDERING_BUFFER row_ptr_cache<int8u>
+// 
+// Provides cheaper creation and destruction (no mem allocs):
+#define AGG_RENDERING_BUFFER row_accessor<int8u>
+//
+// You can still use both of them simultaneouslyin your applications 
+// This #define is used only for default rendering_buffer type,
+// in short hand typedefs like pixfmt_rgba32.
+
 #endif

Modified: trunk/agg/include/agg_conv_adaptor_vcgen.h
===================================================================
--- trunk/agg/include/agg_conv_adaptor_vcgen.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_conv_adaptor_vcgen.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -45,13 +45,12 @@
         };
 
     public:
-        conv_adaptor_vcgen(VertexSource& source) :
+        explicit conv_adaptor_vcgen(VertexSource& source) :
             m_source(&source), 
             m_status(initial)
         {}
+        void attach(VertexSource& source) { m_source = &source; }
 
-        void set_source(VertexSource& source) { m_source = &source; }
-
         Generator& generator() { return m_generator; }
         const Generator& generator() const { return m_generator; }
 

Modified: trunk/agg/include/agg_conv_adaptor_vpgen.h
===================================================================
--- trunk/agg/include/agg_conv_adaptor_vpgen.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_conv_adaptor_vpgen.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -25,10 +25,9 @@
     template<class VertexSource, class VPGen> class conv_adaptor_vpgen
     {
     public:
-        conv_adaptor_vpgen(VertexSource& source) : m_source(&source) {}
+        explicit conv_adaptor_vpgen(VertexSource& source) : m_source(&source) {}
+        void attach(VertexSource& source) { m_source = &source; }
 
-        void set_source(VertexSource& source) { m_source = &source; }
-
         VPGen& vpgen() { return m_vpgen; }
         const VPGen& vpgen() const { return m_vpgen; }
 

Modified: trunk/agg/include/agg_conv_close_polygon.h
===================================================================
--- trunk/agg/include/agg_conv_close_polygon.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_conv_close_polygon.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -25,10 +25,9 @@
     template<class VertexSource> class conv_close_polygon
     {
     public:
-        conv_close_polygon(VertexSource& vs) : m_source(&vs) {}
+        explicit conv_close_polygon(VertexSource& vs) : m_source(&vs) {}
+        void attach(VertexSource& source) { m_source = &source; }
 
-        void set_source(VertexSource& source) { m_source = &source; }
-
         void rewind(unsigned path_id);
         unsigned vertex(double* x, double* y);
 

Modified: trunk/agg/include/agg_conv_concat.h
===================================================================
--- trunk/agg/include/agg_conv_concat.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_conv_concat.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -28,11 +28,10 @@
     public:
         conv_concat(VS1& source1, VS2& source2) :
             m_source1(&source1), m_source2(&source2), m_status(2) {}
+        void attach1(VS1& source) { m_source1 = &source; }
+        void attach2(VS2& source) { m_source2 = &source; }
 
-        void set_source1(VS1& source) { m_source1 = &source; }
-        void set_source2(VS2& source) { m_source2 = &source; }
 
-
         void rewind(unsigned path_id)
         { 
             m_source1->rewind(path_id);

Modified: trunk/agg/include/agg_conv_curve.h
===================================================================
--- trunk/agg/include/agg_conv_curve.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_conv_curve.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -60,11 +60,10 @@
         typedef Curve4 curve4_type;
         typedef conv_curve<VertexSource, Curve3, Curve4> self_type;
 
-        conv_curve(VertexSource& source) :
+        explicit conv_curve(VertexSource& source) :
           m_source(&source), m_last_x(0.0), m_last_y(0.0) {}
+        void attach(VertexSource& source) { m_source = &source; }
 
-        void set_source(VertexSource& source) { m_source = &source; }
-
         void approximation_method(curve_approximation_method_e v) 
         { 
             m_curve3.approximation_method(v);

Modified: trunk/agg/include/agg_conv_gpc.h
===================================================================
--- trunk/agg/include/agg_conv_gpc.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_conv_gpc.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -89,8 +89,8 @@
             memset(&m_result, 0, sizeof(m_result));
         }
 
-        void set_source1(VSA& source) { m_src_a = &source; }
-        void set_source2(VSB& source) { m_src_b = &source; }
+        void attach1(VSA& source) { m_src_a = &source; }
+        void attach2(VSB& source) { m_src_b = &source; }
 
         void operation(gpc_op_e v) { m_operation = v; }
 
@@ -191,10 +191,10 @@
         int i;
         for(i = 0; i < p.num_contours; i++)
         {
-            delete [] p.contour[i].vertex;
+            pod_allocator<gpc_vertex>::deallocate(p.contour[i].vertex, 
+                                                  p.contour[i].num_vertices);
         }
-        delete [] p.hole;
-        delete [] p.contour;
+        pod_allocator<gpc_vertex_list>::deallocate(p.contour, p.num_contours);
         memset(&p, 0, sizeof(gpc_polygon));
     }
 
@@ -260,7 +260,7 @@
                 // TO DO: Clarify the "holes"
                 //if(is_cw(orientation)) h.hole_flag = 1;
 
-                h.vertices = new gpc_vertex [h.num_vertices];
+                h.vertices = pod_allocator<gpc_vertex>::allocate(h.num_vertices);
                 gpc_vertex* d = h.vertices;
                 int i;
                 for(i = 0; i < h.num_vertices; i++)
@@ -288,19 +288,14 @@
         {
             p.num_contours = m_contour_accumulator.size();
 
-            // TO DO: Clarify the "holes"
-            //p.hole = new int[p.num_contours];
             p.hole = 0;
+            p.contour = pod_allocator<gpc_vertex_list>::allocate(p.num_contours);
 
-            p.contour = new gpc_vertex_list[p.num_contours];
-
             int i;
-            //int* ph = p.hole;
             gpc_vertex_list* pv = p.contour;
             for(i = 0; i < p.num_contours; i++)
             {
                 const contour_header_type& h = m_contour_accumulator[i];
-                // *ph++ = h.hole_flag;
                 pv->num_vertices = h.num_vertices;
                 pv->vertex = h.vertices;
                 ++pv;

Modified: trunk/agg/include/agg_conv_transform.h
===================================================================
--- trunk/agg/include/agg_conv_transform.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_conv_transform.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -31,9 +31,8 @@
     public:
         conv_transform(VertexSource& source, const Transformer& tr) :
             m_source(&source), m_trans(&tr) {}
+        void attach(VertexSource& source) { m_source = &source; }
 
-        void set_source(VertexSource& source) { m_source = &source; }
-
         void rewind(unsigned path_id) 
         { 
             m_source->rewind(path_id); 

Modified: trunk/agg/include/agg_conv_unclose_polygon.h
===================================================================
--- trunk/agg/include/agg_conv_unclose_polygon.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_conv_unclose_polygon.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -24,10 +24,9 @@
     template<class VertexSource> class conv_unclose_polygon
     {
     public:
-        conv_unclose_polygon(VertexSource& vs) : m_source(&vs) {}
+        explicit conv_unclose_polygon(VertexSource& vs) : m_source(&vs) {}
+        void attach(VertexSource& source) { m_source = &source; }
 
-        void set_source(VertexSource& source) { m_source = &source; }
-
         void rewind(unsigned path_id)
         {
             m_source->rewind(path_id);

Modified: trunk/agg/include/agg_curves.h
===================================================================
--- trunk/agg/include/agg_curves.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_curves.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -152,7 +152,6 @@
 
         double               m_approximation_scale;
         double               m_distance_tolerance_square;
-        double               m_distance_tolerance_manhattan;
         double               m_angle_tolerance;
         unsigned             m_count;
         pod_bvector<point_d> m_points;
@@ -464,7 +463,6 @@
 
         double               m_approximation_scale;
         double               m_distance_tolerance_square;
-        double               m_distance_tolerance_manhattan;
         double               m_angle_tolerance;
         double               m_cusp_limit;
         unsigned             m_count;

Modified: trunk/agg/include/agg_font_cache_manager.h
===================================================================
--- trunk/agg/include/agg_font_cache_manager.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_font_cache_manager.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -52,9 +52,13 @@
         enum block_size_e { block_size = 16384-16 };
 
         //--------------------------------------------------------------------
-        font_cache(const char* font_signature) : 
+        font_cache() : 
             m_allocator(block_size),
             m_font_signature(0)
+        {}
+
+        //--------------------------------------------------------------------
+        void signature(const char* font_signature)
         {
             m_font_signature = (char*)m_allocator.allocate(strlen(font_signature) + 1);
             strcpy(m_font_signature, font_signature);
@@ -103,18 +107,18 @@
                 (glyph_cache*)m_allocator.allocate(sizeof(glyph_cache),
                                                    sizeof(double));
 
-            glyph->glyph_index = glyph_index;
-            glyph->data        = m_allocator.allocate(data_size);
-            glyph->data_size   = data_size;
-            glyph->data_type   = data_type;
-            glyph->bounds      = bounds;
-            glyph->advance_x   = advance_x;
-            glyph->advance_y   = advance_y;
+            glyph->glyph_index        = glyph_index;
+            glyph->data               = m_allocator.allocate(data_size);
+            glyph->data_size          = data_size;
+            glyph->data_type          = data_type;
+            glyph->bounds             = bounds;
+            glyph->advance_x          = advance_x;
+            glyph->advance_y          = advance_y;
             return m_glyphs[msb][lsb] = glyph;
         }
 
     private:
-        pod_allocator   m_allocator;
+        block_allocator m_allocator;
         glyph_cache**   m_glyphs[256];
         char*           m_font_signature;
     };
@@ -135,14 +139,14 @@
             unsigned i;
             for(i = 0; i < m_num_fonts; ++i)
             {
-                delete m_fonts[i];
+                obj_allocator<font_cache>::deallocate(m_fonts[i]);
             }
-            delete [] m_fonts;
+            pod_allocator<font_cache*>::deallocate(m_fonts, m_max_fonts);
         }
 
         //--------------------------------------------------------------------
         font_cache_pool(unsigned max_fonts=32) : 
-            m_fonts(new font_cache* [max_fonts]),
+            m_fonts(pod_allocator<font_cache*>::allocate(max_fonts)),
             m_max_fonts(max_fonts),
             m_num_fonts(0),
             m_cur_font(0)
@@ -157,8 +161,9 @@
             {
                 if(reset_cache)
                 {
-                    delete m_fonts[idx];
-                    m_fonts[idx] = new font_cache(font_signature);
+                    obj_allocator<font_cache>::deallocate(m_fonts[idx]);
+                    m_fonts[idx] = obj_allocator<font_cache>::allocate();
+                    m_fonts[idx]->signature(font_signature);
                 }
                 m_cur_font = m_fonts[idx];
             }
@@ -166,13 +171,14 @@
             {
                 if(m_num_fonts >= m_max_fonts)
                 {
-                    delete m_fonts[0];
+                    obj_allocator<font_cache>::deallocate(m_fonts[0]);
                     memcpy(m_fonts, 
                            m_fonts + 1, 
                            (m_max_fonts - 1) * sizeof(font_cache*));
                     m_num_fonts = m_max_fonts - 1;
                 }
-                m_fonts[m_num_fonts] = new font_cache(font_signature);
+                m_fonts[m_num_fonts] = obj_allocator<font_cache>::allocate();
+                m_fonts[m_num_fonts]->signature(font_signature);
                 m_cur_font = m_fonts[m_num_fonts];
                 ++m_num_fonts;
             }
@@ -270,6 +276,12 @@
         {}
 
         //--------------------------------------------------------------------
+        void reset_last_glyph()
+        {
+            m_prev_glyph = m_last_glyph = 0;
+        }
+
+        //--------------------------------------------------------------------
         const glyph_cache* glyph(unsigned glyph_code)
         {
             synchronize();

Modified: trunk/agg/include/agg_gamma_lut.h
===================================================================
--- trunk/agg/include/agg_gamma_lut.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_gamma_lut.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -45,14 +45,14 @@
 
         ~gamma_lut()
         {
-            delete [] m_inv_gamma;
-            delete [] m_dir_gamma;
+            pod_allocator<LoResT>::deallocate(m_inv_gamma, hi_res_size);
+            pod_allocator<HiResT>::deallocate(m_dir_gamma, gamma_size);
         }
 
         gamma_lut() : 
             m_gamma(1.0), 
-            m_dir_gamma(new HiResT[gamma_size]),
-            m_inv_gamma(new LoResT[hi_res_size])
+            m_dir_gamma(pod_allocator<HiResT>::allocate(gamma_size)),
+            m_inv_gamma(pod_allocator<LoResT>::allocate(hi_res_size))
         {
             unsigned i;
             for(i = 0; i < gamma_size; i++)
@@ -68,8 +68,8 @@
 
         gamma_lut(double g) :
             m_gamma(1.0), 
-            m_dir_gamma(new HiResT[gamma_size]),
-            m_inv_gamma(new LoResT[hi_res_size])
+            m_dir_gamma(pod_allocator<HiResT>::allocate(gamma_size)),
+            m_inv_gamma(pod_allocator<LoResT>::allocate(hi_res_size))
         {
             gamma(g);
         }

Modified: trunk/agg/include/agg_gsv_text.h
===================================================================
--- trunk/agg/include/agg_gsv_text.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_gsv_text.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -20,7 +20,7 @@
 #ifndef AGG_GSV_TEXT_INCLUDED
 #define AGG_GSV_TEXT_INCLUDED
 
-#include "agg_basics.h"
+#include "agg_array.h"
 #include "agg_conv_stroke.h"
 #include "agg_conv_transform.h"
 
@@ -43,7 +43,6 @@
         };
 
     public:
-        ~gsv_text();
         gsv_text();
 
         void font(const void* font);
@@ -54,6 +53,8 @@
         void line_space(double line_space);
         void start_point(double x, double y);
         void text(const char* text);
+        
+        double text_width();
 
         void rewind(unsigned path_id);
         unsigned vertex(double* x, double* y);
@@ -80,30 +81,28 @@
         }
 
     private:
-        double      m_x;
-        double      m_y;
-        double      m_start_x;
-        double      m_width;
-        double      m_height;
-        double      m_space;
-        double      m_line_space;
-        char        m_chr[2];
-        char*       m_text;
-        char*       m_text_buf;
-        unsigned    m_buf_size;
-        char*       m_cur_chr;
-        const void* m_font;
-        char*       m_loaded_font;
-        status      m_status;
-        bool        m_big_endian;
-        bool        m_flip;
-
-        int8u*      m_indices;
-        int8*       m_glyphs;
-        int8*       m_bglyph;
-        int8*       m_eglyph;
-        double      m_w;
-        double      m_h;
+        double          m_x;
+        double          m_y;
+        double          m_start_x;
+        double          m_width;
+        double          m_height;
+        double          m_space;
+        double          m_line_space;
+        char            m_chr[2];
+        char*           m_text;
+        pod_array<char> m_text_buf;
+        char*           m_cur_chr;
+        const void*     m_font;
+        pod_array<char> m_loaded_font;
+        status          m_status;
+        bool            m_big_endian;
+        bool            m_flip;
+        int8u*          m_indices;
+        int8*           m_glyphs;
+        int8*           m_bglyph;
+        int8*           m_eglyph;
+        double          m_w;
+        double          m_h;
     };
 
 

Modified: trunk/agg/include/agg_image_accessors.h
===================================================================
--- trunk/agg/include/agg_image_accessors.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_image_accessors.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -32,13 +32,14 @@
         enum pix_width_e { pix_width = pixfmt_type::pix_width };
 
         image_accessor_clip() {}
-        image_accessor_clip(const pixfmt_type& pixf, const color_type& bk) : 
+        explicit image_accessor_clip(const pixfmt_type& pixf, 
+                                     const color_type& bk) : 
             m_pixf(&pixf)
         {
             pixfmt_type::make_pix(m_bk_buf, bk);
         }
 
-        void set_source(const pixfmt_type& pixf)
+        void attach(const pixfmt_type& pixf)
         {
             m_pixf = &pixf;
         }
@@ -65,7 +66,7 @@
             m_x = m_x0 = x;
             m_y = y;
             if(y >= 0 && y < (int)m_pixf->height() &&
-               x >= 0 && x+len <= (int)m_pixf->width())
+               x >= 0 && x+(int)len <= (int)m_pixf->width())
             {
                 return m_pix_ptr = m_pixf->pix_ptr(x, y);
             }
@@ -114,9 +115,11 @@
         enum pix_width_e { pix_width = pixfmt_type::pix_width };
 
         image_accessor_no_clip() {}
-        image_accessor_no_clip(const pixfmt_type& pixf) : m_pixf(&pixf) {}
+        explicit image_accessor_no_clip(const pixfmt_type& pixf) : 
+            m_pixf(&pixf) 
+        {}
 
-        void set_source(const pixfmt_type& pixf)
+        void attach(const pixfmt_type& pixf)
         {
             m_pixf = &pixf;
         }
@@ -159,9 +162,11 @@
         enum pix_width_e { pix_width = pixfmt_type::pix_width };
 
         image_accessor_clone() {}
-        image_accessor_clone(const pixfmt_type& pixf) : m_pixf(&pixf) {}
+        explicit image_accessor_clone(const pixfmt_type& pixf) : 
+            m_pixf(&pixf) 
+        {}
 
-        void set_source(const pixfmt_type& pixf)
+        void attach(const pixfmt_type& pixf)
         {
             m_pixf = &pixf;
         }
@@ -233,13 +238,13 @@
         enum pix_width_e { pix_width = pixfmt_type::pix_width };
 
         image_accessor_wrap() {}
-        image_accessor_wrap(const pixfmt_type& pixf) : 
+        explicit image_accessor_wrap(const pixfmt_type& pixf) : 
             m_pixf(&pixf), 
             m_wrap_x(pixf.width()), 
             m_wrap_y(pixf.height())
         {}
 
-        void set_source(const pixfmt_type& pixf)
+        void attach(const pixfmt_type& pixf)
         {
             m_pixf = &pixf;
         }

Modified: trunk/agg/include/agg_image_filters.h
===================================================================
--- trunk/agg/include/agg_image_filters.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_image_filters.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -20,6 +20,7 @@
 #ifndef AGG_IMAGE_FILTERS_INCLUDED
 #define AGG_IMAGE_FILTERS_INCLUDED
 
+#include "agg_array.h"
 #include "agg_math.h"
 
 namespace agg
@@ -46,9 +47,6 @@
     class image_filter_lut
     {
     public:
-        ~image_filter_lut();
-        image_filter_lut();
-
         template<class FilterF> void calculate(const FilterF& filter,
                                                bool normalization=true)
         {
@@ -71,18 +69,18 @@
             }
         }
 
+        image_filter_lut() : m_radius(0), m_diameter(0), m_start(0) {}
+
         template<class FilterF> image_filter_lut(const FilterF& filter, 
-                                                 bool normalization=true) : 
-            m_weight_array(0),
-            m_max_size(0)
+                                                 bool normalization=true)
         {
             calculate(filter, normalization);
         }
 
-        double       radius()       const { return m_radius;       }
-        unsigned     diameter()     const { return m_diameter;     }
-        int          start()        const { return m_start;        }
-        const int16* weight_array() const { return m_weight_array; }
+        double       radius()       const { return m_radius;   }
+        unsigned     diameter()     const { return m_diameter; }
+        int          start()        const { return m_start;    }
+        const int16* weight_array() const { return &m_weight_array[0]; }
         void         normalize();
 
     private:
@@ -90,11 +88,10 @@
         image_filter_lut(const image_filter_lut&);
         const image_filter_lut& operator = (const image_filter_lut&);
 
-        double   m_radius;
-        unsigned m_diameter;
-        int      m_start;
-        int16*   m_weight_array;
-        unsigned m_max_size;
+        double           m_radius;
+        unsigned         m_diameter;
+        int              m_start;
+        pod_array<int16> m_weight_array;
     };
 
 

Modified: trunk/agg/include/agg_line_aa_basics.h
===================================================================
--- trunk/agg/include/agg_line_aa_basics.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_line_aa_basics.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -142,8 +142,8 @@
         int octant;
 
         //---------------------------------------------------------------------
-        static int8u s_orthogonal_quadrant[8];
-        static int8u s_diagonal_quadrant[8];
+        static const int8u s_orthogonal_quadrant[8];
+        static const int8u s_diagonal_quadrant[8];
     };
 
 

Modified: trunk/agg/include/agg_math.h
===================================================================
--- trunk/agg/include/agg_math.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_math.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -41,7 +41,6 @@
         return (x - x2) * (y2 - y1) - (y - y2) * (x2 - x1);
     }
 
-
     //--------------------------------------------------------point_in_triangle
     AGG_INLINE bool point_in_triangle(double x1, double y1, 
                                       double x2, double y2, 
@@ -54,7 +53,6 @@
         return cp1 == cp2 && cp2 == cp3 && cp3 == cp1;
     }
 
-
     //-----------------------------------------------------------calc_distance
     AGG_INLINE double calc_distance(double x1, double y1, double x2, double y2)
     {
@@ -63,6 +61,13 @@
         return sqrt(dx * dx + dy * dy);
     }
 
+    //--------------------------------------------------------calc_sq_distance
+    AGG_INLINE double calc_sq_distance(double x1, double y1, double x2, double y2)
+    {
+        double dx = x2-x1;
+        double dy = y2-y1;
+        return dx * dx + dy * dy;
+    }
 
     //------------------------------------------------calc_line_point_distance
     AGG_INLINE double calc_line_point_distance(double x1, double y1, 
@@ -79,7 +84,54 @@
         return ((x - x2) * dy - (y - y2) * dx) / d;
     }
 
+    //-------------------------------------------------------calc_line_point_u
+    AGG_INLINE double calc_segment_point_u(double x1, double y1, 
+                                           double x2, double y2, 
+                                           double x,  double y)
+    {
+        double dx = x2 - x1;
+        double dy = y2 - y1;
 
+        if(dx == 0 && dy == 0)
+        {
+	        return 0;
+        }
+
+        double pdx = x - x1;
+        double pdy = y - y1;
+
+        return (pdx * dx + pdy * dy) / (dx * dx + dy * dy);
+    }
+
+    //---------------------------------------------calc_line_point_sq_distance
+    AGG_INLINE double calc_segment_point_sq_distance(double x1, double y1, 
+                                                     double x2, double y2, 
+                                                     double x,  double y,
+                                                     double u)
+    {
+        if(u <= 0)
+        {
+	        return calc_sq_distance(x, y, x1, y1);
+        }
+        else 
+        if(u >= 1)
+        {
+	        return calc_sq_distance(x, y, x2, y2);
+        }
+        return calc_sq_distance(x, y, x1 + u * (x2 - x1), y1 + u * (y2 - y1));
+    }
+
+    //---------------------------------------------calc_line_point_sq_distance
+    AGG_INLINE double calc_segment_point_sq_distance(double x1, double y1, 
+                                                     double x2, double y2, 
+                                                     double x,  double y)
+    {
+        return 
+            calc_segment_point_sq_distance(
+                x1, y1, x2, y2, x, y,
+                calc_segment_point_u(x1, y1, x2, y2, x, y));
+    }
+
     //-------------------------------------------------------calc_intersection
     AGG_INLINE bool calc_intersection(double ax, double ay, double bx, double by,
                                       double cx, double cy, double dx, double dy,
@@ -94,7 +146,6 @@
         return true;
     }
 
-
     //-----------------------------------------------------intersection_exists
     AGG_INLINE bool intersection_exists(double x1, double y1, double x2, double y2,
                                         double x3, double y3, double x4, double y4)
@@ -122,7 +173,6 @@
         //return ua >= 0.0 && ua <= 1.0 && ub >= 0.0 && ub <= 1.0;
     }
 
-
     //--------------------------------------------------------calc_orthogonal
     AGG_INLINE void calc_orthogonal(double thickness,
                                     double x1, double y1,
@@ -132,11 +182,10 @@
         double dx = x2 - x1;
         double dy = y2 - y1;
         double d = sqrt(dx*dx + dy*dy); 
-        *x = thickness * dy / d;
-        *y = thickness * dx / d;
+        *x =  thickness * dy / d;
+        *y = -thickness * dx / d;
     }
 
-
     //--------------------------------------------------------dilate_triangle
     AGG_INLINE void dilate_triangle(double x1, double y1,
                                     double x2, double y2,
@@ -161,12 +210,12 @@
             calc_orthogonal(d, x2, y2, x3, y3, &dx2, &dy2);
             calc_orthogonal(d, x3, y3, x1, y1, &dx3, &dy3);
         }
-        *x++ = x1 + dx1;  *y++ = y1 - dy1;
-        *x++ = x2 + dx1;  *y++ = y2 - dy1;
-        *x++ = x2 + dx2;  *y++ = y2 - dy2;
-        *x++ = x3 + dx2;  *y++ = y3 - dy2;
-        *x++ = x3 + dx3;  *y++ = y3 - dy3;
-        *x++ = x1 + dx3;  *y++ = y1 - dy3;
+        *x++ = x1 + dx1;  *y++ = y1 + dy1;
+        *x++ = x2 + dx1;  *y++ = y2 + dy1;
+        *x++ = x2 + dx2;  *y++ = y2 + dy2;
+        *x++ = x3 + dx2;  *y++ = y3 + dy2;
+        *x++ = x3 + dx3;  *y++ = y3 + dy3;
+        *x++ = x1 + dx3;  *y++ = y1 + dy3;
     }
 
     //------------------------------------------------------calc_triangle_area
@@ -177,7 +226,6 @@
         return (x1*y2 - x2*y1 + x2*y3 - x3*y2 + x3*y1 - x1*y3) * 0.5;
     }
 
-
     //-------------------------------------------------------calc_polygon_area
     template<class Storage> double calc_polygon_area(const Storage& st)
     {
@@ -274,7 +322,7 @@
             }
         }
 
-        //This is calculation sqrt itself.
+        //This code calculates the sqrt.
         bit -= 9;
         if(bit > 0)
         {

Modified: trunk/agg/include/agg_math_stroke.h
===================================================================
--- trunk/agg/include/agg_math_stroke.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_math_stroke.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -53,75 +53,176 @@
         inner_round
     };
 
-    // Minimal angle to calculate round joins, less than 0.1 degree.
-    const double stroke_theta = 0.001;       //----stroke_theta
-
-    //--------------------------------------------------------stroke_calc_arc
-    template<class VertexConsumer>
-    void stroke_calc_arc(VertexConsumer& out_vertices,
-                         double x,   double y, 
-                         double dx1, double dy1, 
-                         double dx2, double dy2,
-                         double width,
-                         double approximation_scale)
+    //------------------------------------------------------------math_stroke
+    template<class VertexConsumer> class math_stroke
     {
+    public:
         typedef typename VertexConsumer::value_type coord_type;
 
-        double a1 = atan2(dy1, dx1);
-        double a2 = atan2(dy2, dx2);
-        double da = a1 - a2;
+        math_stroke();
 
-        bool ccw = da > 0.0 && da < pi;
+        void line_cap(line_cap_e lc)     { m_line_cap = lc; }
+        void line_join(line_join_e lj)   { m_line_join = lj; }
+        void inner_join(inner_join_e ij) { m_inner_join = ij; }
 
-        if(width < 0) width = -width;
-        da = acos(width / (width + 0.125 / approximation_scale)) * 2;
+        line_cap_e   line_cap()   const { return m_line_cap; }
+        line_join_e  line_join()  const { return m_line_join; }
+        inner_join_e inner_join() const { return m_inner_join; }
 
-        out_vertices.add(coord_type(x + dx1, y + dy1));
-        if(!ccw)
+        void width(double w);
+        void miter_limit(double ml) { m_miter_limit = ml; }
+        void miter_limit_theta(double t);
+        void inner_miter_limit(double ml) { m_inner_miter_limit = ml; }
+        void approximation_scale(double as) { m_approx_scale = as; }
+
+        double width() const { return m_width * 2.0; }
+        double miter_limit() const { return m_miter_limit; }
+        double inner_miter_limit() const { return m_inner_miter_limit; }
+        double approximation_scale() const { return m_approx_scale; }
+
+        void calc_cap(VertexConsumer& vc,
+                      const vertex_dist& v0, 
+                      const vertex_dist& v1, 
+                      double len);
+
+        void calc_join(VertexConsumer& vc,
+                       const vertex_dist& v0, 
+                       const vertex_dist& v1, 
+                       const vertex_dist& v2,
+                       double len1, 
+                       double len2);
+
+    private:
+        AGG_INLINE void add_vertex(VertexConsumer& vc, double x, double y)
         {
+            vc.add(coord_type(x, y));
+        }
+
+        void calc_arc(VertexConsumer& vc,
+                      double x,   double y, 
+                      double dx1, double dy1, 
+                      double dx2, double dy2);
+
+        void calc_miter(VertexConsumer& vc,
+                        const vertex_dist& v0, 
+                        const vertex_dist& v1, 
+                        const vertex_dist& v2,
+                        double dx1, double dy1, 
+                        double dx2, double dy2,
+                        line_join_e lj,
+                        double mlimit,
+                        double dbevel);
+
+        double       m_width;
+        double       m_width_abs;
+        double       m_width_eps;
+        int          m_width_sign;
+        double       m_miter_limit;
+        double       m_inner_miter_limit;
+        double       m_approx_scale;
+        line_cap_e   m_line_cap;
+        line_join_e  m_line_join;
+        inner_join_e m_inner_join;
+    };
+
+    //-----------------------------------------------------------------------
+    template<class VC> math_stroke<VC>::math_stroke() :
+        m_width(0.5),
+        m_width_abs(0.5),
+        m_width_eps(0.5/1024.0),
+        m_width_sign(1),
+        m_miter_limit(4.0),
+        m_inner_miter_limit(1.01),
+        m_approx_scale(1.0),
+        m_line_cap(butt_cap),
+        m_line_join(miter_join),
+        m_inner_join(inner_miter)
+    {
+    }
+
+    //-----------------------------------------------------------------------
+    template<class VC> void math_stroke<VC>::width(double w)
+    { 
+        m_width = w * 0.5; 
+        if(m_width < 0)
+        {
+            m_width_abs  = -m_width;
+            m_width_sign = -1;
+        }
+        else
+        {
+            m_width_abs  = m_width;
+            m_width_sign = 1;
+        }
+        m_width_eps = m_width / 1024.0;
+    }
+
+    //-----------------------------------------------------------------------
+    template<class VC> void math_stroke<VC>::miter_limit_theta(double t)
+    { 
+        m_miter_limit = 1.0 / sin(t * 0.5) ;
+    }
+
+    //-----------------------------------------------------------------------
+    template<class VC> 
+    void math_stroke<VC>::calc_arc(VC& vc,
+                                   double x,   double y, 
+                                   double dx1, double dy1, 
+                                   double dx2, double dy2)
+    {
+        double a1 = atan2(dy1 * m_width_sign, dx1 * m_width_sign);
+        double a2 = atan2(dy2 * m_width_sign, dx2 * m_width_sign);
+        double da = a1 - a2;
+        int i, n;
+
+        da = acos(m_width_abs / (m_width_abs + 0.125 / m_approx_scale)) * 2;
+
+        add_vertex(vc, x + dx1, y + dy1);
+        if(m_width_sign > 0)
+        {
             if(a1 > a2) a2 += 2 * pi;
-            a2 -= da / 4;
+            n = int((a2 - a1) / da);
+            da = (a2 - a1) / (n + 1);
             a1 += da;
-            while(a1 < a2)
+            for(i = 0; i < n; i++)
             {
-                out_vertices.add(coord_type(x + cos(a1) * width, y + sin(a1) * width));
+                add_vertex(vc, x + cos(a1) * m_width, y + sin(a1) * m_width);
                 a1 += da;
             }
         }
         else
         {
             if(a1 < a2) a2 -= 2 * pi;
-            a2 += da / 4;
+            n = int((a1 - a2) / da);
+            da = (a1 - a2) / (n + 1);
             a1 -= da;
-            while(a1 > a2)
+            for(i = 0; i < n; i++)
             {
-                out_vertices.add(coord_type(x + cos(a1) * width, y + sin(a1) * width));
+                add_vertex(vc, x + cos(a1) * m_width, y + sin(a1) * m_width);
                 a1 -= da;
             }
         }
-        out_vertices.add(coord_type(x + dx2, y + dy2));
+        add_vertex(vc, x + dx2, y + dy2);
     }
 
-
-
-    //-------------------------------------------------------stroke_calc_miter
-    template<class VertexConsumer>
-    void stroke_calc_miter(VertexConsumer& out_vertices,
-                           const vertex_dist& v0, 
-                           const vertex_dist& v1, 
-                           const vertex_dist& v2,
-                           double dx1, double dy1, 
-                           double dx2, double dy2,
-                           double width,
-                           line_join_e line_join,
-                           double miter_limit,
-                           double approximation_scale)
+    //-----------------------------------------------------------------------
+    template<class VC> 
+    void math_stroke<VC>::calc_miter(VC& vc,
+                                     const vertex_dist& v0, 
+                                     const vertex_dist& v1, 
+                                     const vertex_dist& v2,
+                                     double dx1, double dy1, 
+                                     double dx2, double dy2,
+                                     line_join_e lj,
+                                     double mlimit,
+                                     double dbevel)
     {
-        typedef typename VertexConsumer::value_type coord_type;
-
-        double xi = v1.x;
-        double yi = v1.y;
+        double xi  = v1.x;
+        double yi  = v1.y;
+        double di  = 1;
+        double lim = m_width_abs * mlimit;
         bool miter_limit_exceeded = true; // Assume the worst
+        bool intersection_failed  = true; // Assume the worst
 
         if(calc_intersection(v0.x + dx1, v0.y - dy1,
                              v1.x + dx1, v1.y - dy1,
@@ -131,15 +232,15 @@
         {
             // Calculation of the intersection succeeded
             //---------------------
-            double d1 = calc_distance(v1.x, v1.y, xi, yi);
-            double lim = width * miter_limit;
-            if(d1 <= lim)
+            di = calc_distance(v1.x, v1.y, xi, yi);
+            if(di <= lim)
             {
                 // Inside the miter limit
                 //---------------------
-                out_vertices.add(coord_type(xi, yi));
+                add_vertex(vc, xi, yi);
                 miter_limit_exceeded = false;
             }
+            intersection_failed = false;
         }
         else
         {
@@ -153,13 +254,13 @@
             //----------------
             double x2 = v1.x + dx1;
             double y2 = v1.y - dy1;
-            if(((x2 - v0.x)*dy1 - (v0.y - y2)*dx1 < 0.0) !=
-               ((x2 - v2.x)*dy1 - (v2.y - y2)*dx1 < 0.0))
+            if((cross_product(v0.x, v0.y, v1.x, v1.y, x2, y2) < 0.0) == 
+               (cross_product(v1.x, v1.y, v2.x, v2.y, x2, y2) < 0.0))
             {
                 // This case means that the next segment continues 
                 // the previous one (straight line)
                 //-----------------
-                out_vertices.add(coord_type(v1.x + dx1, v1.y - dy1));
+                add_vertex(vc, v1.x + dx1, v1.y - dy1);
                 miter_limit_exceeded = false;
             }
         }
@@ -168,171 +269,177 @@
         {
             // Miter limit exceeded
             //------------------------
-            switch(line_join)
+            switch(lj)
             {
             case miter_join_revert:
                 // For the compatibility with SVG, PDF, etc, 
                 // we use a simple bevel join instead of
                 // "smart" bevel
                 //-------------------
-                out_vertices.add(coord_type(v1.x + dx1, v1.y - dy1));
-                out_vertices.add(coord_type(v1.x + dx2, v1.y - dy2));
+                add_vertex(vc, v1.x + dx1, v1.y - dy1);
+                add_vertex(vc, v1.x + dx2, v1.y - dy2);
                 break;
 
             case miter_join_round:
-                stroke_calc_arc(out_vertices, 
-                                v1.x, v1.y, dx1, -dy1, dx2, -dy2, 
-                                width, approximation_scale);
+                calc_arc(vc, v1.x, v1.y, dx1, -dy1, dx2, -dy2);
                 break;
 
             default:
                 // If no miter-revert, calculate new dx1, dy1, dx2, dy2
                 //----------------
-                out_vertices.add(coord_type(v1.x + dx1 + dy1 * miter_limit, 
-                                            v1.y - dy1 + dx1 * miter_limit));
-                out_vertices.add(coord_type(v1.x + dx2 - dy2 * miter_limit, 
-                                            v1.y - dy2 - dx2 * miter_limit));
+                if(intersection_failed)
+                {
+                    mlimit *= m_width_sign;
+                    add_vertex(vc, v1.x + dx1 + dy1 * mlimit, 
+                                   v1.y - dy1 + dx1 * mlimit);
+                    add_vertex(vc, v1.x + dx2 - dy2 * mlimit, 
+                                   v1.y - dy2 - dx2 * mlimit);
+                }
+                else
+                {
+                    double x1 = v1.x + dx1;
+                    double y1 = v1.y - dy1;
+                    double x2 = v1.x + dx2;
+                    double y2 = v1.y - dy2;
+                    di = (lim - dbevel) / (di - dbevel);
+                    add_vertex(vc, x1 + (xi - x1) * di, 
+                                   y1 + (yi - y1) * di);
+                    add_vertex(vc, x2 + (xi - x2) * di, 
+                                   y2 + (yi - y2) * di);
+                }
                 break;
             }
         }
     }
 
-
-
-
-
-
     //--------------------------------------------------------stroke_calc_cap
-    template<class VertexConsumer>
-    void stroke_calc_cap(VertexConsumer& out_vertices,
-                         const vertex_dist& v0, 
-                         const vertex_dist& v1, 
-                         double len,
-                         line_cap_e line_cap,
-                         double width,
-                         double approximation_scale)
+    template<class VC> 
+    void math_stroke<VC>::calc_cap(VC& vc,
+                                   const vertex_dist& v0, 
+                                   const vertex_dist& v1, 
+                                   double len)
     {
-        typedef typename VertexConsumer::value_type coord_type;
+        vc.remove_all();
 
-        out_vertices.remove_all();
-
         double dx1 = (v1.y - v0.y) / len;
         double dy1 = (v1.x - v0.x) / len;
         double dx2 = 0;
         double dy2 = 0;
 
-        dx1 *= width;
-        dy1 *= width;
+        dx1 *= m_width;
+        dy1 *= m_width;
 
-        if(line_cap != round_cap)
+        if(m_line_cap != round_cap)
         {
-            if(line_cap == square_cap)
+            if(m_line_cap == square_cap)
             {
-                dx2 = dy1;
-                dy2 = dx1;
+                dx2 = dy1 * m_width_sign;
+                dy2 = dx1 * m_width_sign;
             }
-            out_vertices.add(coord_type(v0.x - dx1 - dx2, v0.y + dy1 - dy2));
-            out_vertices.add(coord_type(v0.x + dx1 - dx2, v0.y - dy1 - dy2));
+            add_vertex(vc, v0.x - dx1 - dx2, v0.y + dy1 - dy2);
+            add_vertex(vc, v0.x + dx1 - dx2, v0.y - dy1 - dy2);
         }
         else
         {
-            double a1 = atan2(dy1, -dx1);
-            double a2 = a1 + pi;
-            double da = acos(width / (width + 0.125 / approximation_scale)) * 2;
-            out_vertices.add(coord_type(v0.x - dx1, v0.y + dy1));
-            a1 += da;
-            a2 -= da/4;
-            while(a1 < a2)
+            double da = acos(m_width_abs / (m_width_abs + 0.125 / m_approx_scale)) * 2;
+            double a1;
+            int i;
+            int n = int(pi / da);
+
+            da = pi / (n + 1);
+            add_vertex(vc, v0.x - dx1, v0.y + dy1);
+            if(m_width_sign > 0)
             {
-                out_vertices.add(coord_type(v0.x + cos(a1) * width, 
-                                            v0.y + sin(a1) * width));
+                a1 = atan2(dy1, -dx1);
                 a1 += da;
+                for(i = 0; i < n; i++)
+                {
+                    add_vertex(vc, v0.x + cos(a1) * m_width, 
+                                   v0.y + sin(a1) * m_width);
+                    a1 += da;
+                }
             }
-            out_vertices.add(coord_type(v0.x + dx1, v0.y - dy1));
+            else
+            {
+                a1 = atan2(-dy1, dx1);
+                a1 -= da;
+                for(i = 0; i < n; i++)
+                {
+                    add_vertex(vc, v0.x + cos(a1) * m_width, 
+                                   v0.y + sin(a1) * m_width);
+                    a1 -= da;
+                }
+            }
+            add_vertex(vc, v0.x + dx1, v0.y - dy1);
         }
     }
 
-
-
-    //-------------------------------------------------------stroke_calc_join
-    template<class VertexConsumer>
-    void stroke_calc_join(VertexConsumer& out_vertices,
-                          const vertex_dist& v0, 
-                          const vertex_dist& v1, 
-                          const vertex_dist& v2,
-                          double len1, 
-                          double len2,
-                          double width, 
-                          line_join_e line_join,
-                          inner_join_e inner_join,
-                          double miter_limit,
-                          double inner_miter_limit,
-                          double approximation_scale)
+    //-----------------------------------------------------------------------
+    template<class VC> 
+    void math_stroke<VC>::calc_join(VC& vc,
+                                    const vertex_dist& v0, 
+                                    const vertex_dist& v1, 
+                                    const vertex_dist& v2,
+                                    double len1, 
+                                    double len2)
     {
-        typedef typename VertexConsumer::value_type coord_type;
+        double dx1 = m_width * (v1.y - v0.y) / len1;
+        double dy1 = m_width * (v1.x - v0.x) / len1;
+        double dx2 = m_width * (v2.y - v1.y) / len2;
+        double dy2 = m_width * (v2.x - v1.x) / len2;
 
-        double dx1, dy1, dx2, dy2;
-        double d;
+        vc.remove_all();
 
-        dx1 = width * (v1.y - v0.y) / len1;
-        dy1 = width * (v1.x - v0.x) / len1;
-
-        dx2 = width * (v2.y - v1.y) / len2;
-        dy2 = width * (v2.x - v1.x) / len2;
-
-        out_vertices.remove_all();
-
-        if(cross_product(v0.x, v0.y, v1.x, v1.y, v2.x, v2.y) > 0)
+        double cp = cross_product(v0.x, v0.y, v1.x, v1.y, v2.x, v2.y);
+        if(cp != 0 && (cp > 0) == (m_width > 0))
         {
             // Inner join
             //---------------
-            switch(inner_join)
+            double limit = ((len1 < len2) ? len1 : len2) / m_width_abs;
+            if(limit < m_inner_miter_limit)
             {
+                limit = m_inner_miter_limit;
+            }
+
+            switch(m_inner_join)
+            {
             default: // inner_bevel
-                out_vertices.add(coord_type(v1.x + dx1, v1.y - dy1));
-                out_vertices.add(coord_type(v1.x + dx2, v1.y - dy2));
+                add_vertex(vc, v1.x + dx1, v1.y - dy1);
+                add_vertex(vc, v1.x + dx2, v1.y - dy2);
                 break;
 
             case inner_miter:
-                stroke_calc_miter(out_vertices,
-                                  v0, v1, v2, dx1, dy1, dx2, dy2, 
-                                  width,                                   
-                                  miter_join_revert, 
-                                  inner_miter_limit,
-                                  1.0);
+                calc_miter(vc,
+                           v0, v1, v2, dx1, dy1, dx2, dy2, 
+                           miter_join_revert, 
+                           limit, 0);
                 break;
 
             case inner_jag:
             case inner_round:
+                cp = (dx1-dx2) * (dx1-dx2) + (dy1-dy2) * (dy1-dy2);
+                if(cp < len1 * len1 && cp < len2 * len2)
                 {
-                    d = (dx1-dx2) * (dx1-dx2) + (dy1-dy2) * (dy1-dy2);
-                    if(d < len1 * len1 && d < len2 * len2)
+                    calc_miter(vc,
+                               v0, v1, v2, dx1, dy1, dx2, dy2, 
+                               miter_join_revert, 
+                               limit, 0);
+                }
+                else
+                {
+                    if(m_inner_join == inner_jag)
                     {
-                        stroke_calc_miter(out_vertices,
-                                          v0, v1, v2, dx1, dy1, dx2, dy2, 
-                                          width,                                   
-                                          miter_join_revert, 
-                                          inner_miter_limit,
-                                          1.0);
+                        add_vertex(vc, v1.x + dx1, v1.y - dy1);
+                        add_vertex(vc, v1.x,       v1.y      );
+                        add_vertex(vc, v1.x + dx2, v1.y - dy2);
                     }
                     else
                     {
-                        if(inner_join == inner_jag)
-                        {
-                            out_vertices.add(coord_type(v1.x + dx1, v1.y - dy1));
-                            out_vertices.add(coord_type(v1.x,       v1.y      ));
-                            out_vertices.add(coord_type(v1.x + dx2, v1.y - dy2));
-                        }
-                        else
-                        {
-                            out_vertices.add(coord_type(v1.x + dx1, v1.y - dy1));
-                            out_vertices.add(coord_type(v1.x,       v1.y      ));
-                            stroke_calc_arc(out_vertices, 
-                                            v1.x, v1.y, dx2, -dy2, dx1, -dy1, 
-                                            width, approximation_scale);
-                            out_vertices.add(coord_type(v1.x,       v1.y      ));
-                            out_vertices.add(coord_type(v1.x + dx2, v1.y - dy2));
-                        }
+                        add_vertex(vc, v1.x + dx1, v1.y - dy1);
+                        add_vertex(vc, v1.x,       v1.y      );
+                        calc_arc(vc, v1.x, v1.y, dx2, -dy2, dx1, -dy1);
+                        add_vertex(vc, v1.x,       v1.y      );
+                        add_vertex(vc, v1.x + dx2, v1.y - dy2);
                     }
                 }
                 break;
@@ -342,10 +449,18 @@
         {
             // Outer join
             //---------------
-            if(line_join == round_join || line_join == bevel_join)
+
+            // Calculate the distance between v1 and 
+            // the central point of the bevel line segment
+            //---------------
+            double dx = (dx1 + dx2) / 2;
+            double dy = (dy1 + dy2) / 2;
+            double dbevel = sqrt(dx * dx + dy * dy);
+
+            if(m_line_join == round_join || m_line_join == bevel_join)
             {
                 // This is an optimization that reduces the number of points 
-                // in cases of almost collonear segments. If there's no
+                // in cases of almost collinear segments. If there's no
                 // visible difference between bevel and miter joins we'd rather
                 // use miter join because it adds only one point instead of two. 
                 //
@@ -354,44 +469,50 @@
                 // At outer joins this distance always less than stroke width, 
                 // because it's actually the height of an isosceles triangle of
                 // v1 and its two bevel points. If the difference between this
-                // width and this value is small (no visible bevel) we can switch
-                // to the miter join. 
+                // width and this value is small (no visible bevel) we can 
+                // add just one point. 
                 //
                 // The constant in the expression makes the result approximately 
-                // the same as in round joins and caps. One can safely comment 
-                // out this "if".
+                // the same as in round joins and caps. You can safely comment 
+                // out this entire "if".
                 //-------------------
-                double dx = (dx1 + dx2) / 2;
-                double dy = (dy1 + dy2) / 2;
-                d = width - sqrt(dx * dx + dy * dy);
-                if(d < 0.0625 / approximation_scale)
+                if(m_approx_scale * (m_width_abs - dbevel) < m_width_eps)
                 {
-                    line_join = miter_join;
+                    if(calc_intersection(v0.x + dx1, v0.y - dy1,
+                                         v1.x + dx1, v1.y - dy1,
+                                         v1.x + dx2, v1.y - dy2,
+                                         v2.x + dx2, v2.y - dy2,
+                                         &dx, &dy))
+                    {
+                        add_vertex(vc, dx, dy);
+                    }
+                    else
+                    {
+                        add_vertex(vc, v1.x + dx1, v1.y - dy1);
+                    }
+                    return;
                 }
             }
 
-            switch(line_join)
+            switch(m_line_join)
             {
             case miter_join:
             case miter_join_revert:
             case miter_join_round:
-                stroke_calc_miter(out_vertices, 
-                                  v0, v1, v2, dx1, dy1, dx2, dy2, 
-                                  width,                                   
-                                  line_join, 
-                                  miter_limit,
-                                  approximation_scale);
+                calc_miter(vc, 
+                           v0, v1, v2, dx1, dy1, dx2, dy2, 
+                           m_line_join, 
+                           m_miter_limit,
+                           dbevel);
                 break;
 
             case round_join:
-                stroke_calc_arc(out_vertices, 
-                                v1.x, v1.y, dx1, -dy1, dx2, -dy2, 
-                                width, approximation_scale);
+                calc_arc(vc, v1.x, v1.y, dx1, -dy1, dx2, -dy2);
                 break;
 
             default: // Bevel join
-                out_vertices.add(coord_type(v1.x + dx1, v1.y - dy1));
-                out_vertices.add(coord_type(v1.x + dx2, v1.y - dy2));
+                add_vertex(vc, v1.x + dx1, v1.y - dy1);
+                add_vertex(vc, v1.x + dx2, v1.y - dy2);
                 break;
             }
         }

Modified: trunk/agg/include/agg_path_storage.h
===================================================================
--- trunk/agg/include/agg_path_storage.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_path_storage.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -90,10 +90,13 @@
             T** coord_blk = m_coord_blocks + m_total_blocks - 1;
             while(m_total_blocks--)
             {
-                delete [] *coord_blk;
+                pod_allocator<T>::deallocate(
+                    *coord_blk,
+                    block_size * 2 + 
+                    block_size / (sizeof(T) / sizeof(unsigned char)));
                 --coord_blk;
             }
-            delete [] m_coord_blocks;
+            pod_allocator<T*>::deallocate(m_coord_blocks, m_max_blocks * 2);
             m_total_blocks   = 0;
             m_max_blocks     = 0;
             m_coord_blocks   = 0;
@@ -145,7 +148,7 @@
             unsigned cmd = v.vertex(i, &x, &y);
             add_vertex(x, y, cmd);
         }
-	return *this;
+	    return *this;
     }
 
     //------------------------------------------------------------------------
@@ -298,7 +301,7 @@
         if(nb >= m_max_blocks) 
         {
             T** new_coords = 
-                new T* [(m_max_blocks + block_pool) * 2];
+                pod_allocator<T*>::allocate((m_max_blocks + block_pool) * 2);
 
             unsigned char** new_cmds = 
                 (unsigned char**)(new_coords + m_max_blocks + block_pool);
@@ -313,15 +316,15 @@
                        m_cmd_blocks, 
                        m_max_blocks * sizeof(unsigned char*));
 
-                delete [] m_coord_blocks;
+                pod_allocator<T*>::deallocate(m_coord_blocks, m_max_blocks * 2);
             }
             m_coord_blocks = new_coords;
-            m_cmd_blocks = new_cmds;
-            m_max_blocks += block_pool;
+            m_cmd_blocks   = new_cmds;
+            m_max_blocks  += block_pool;
         }
         m_coord_blocks[nb] = 
-            new T [block_size * 2 + 
-                   block_size / (sizeof(T) / sizeof(unsigned char))];
+            pod_allocator<T>::allocate(block_size * 2 + 
+                   block_size / (sizeof(T) / sizeof(unsigned char)));
 
         m_cmd_blocks[nb]  = 
             (unsigned char*)(m_coord_blocks[nb] + block_size * 2);
@@ -766,7 +769,7 @@
                 while(!is_stop(cmd = vs.vertex(&x, &y)))
                 {
                     m_vertices.add_vertex(x, y, is_move_to(cmd) ? 
-                                                    path_cmd_line_to : 
+                                                    unsigned(path_cmd_line_to) : 
                                                     cmd);
                 }
             }
@@ -792,7 +795,47 @@
             join_path(poly);
         }
 
+        //--------------------------------------------------------------------
+        void translate(double dx, double dy, unsigned path_id=0);
+        void translate_all_paths(double dx, double dy);
 
+        //--------------------------------------------------------------------
+        template<class Trans>
+        void transform(const Trans& trans, unsigned path_id=0)
+        {
+            unsigned num_ver = m_vertices.total_vertices();
+            for(; path_id < num_ver; path_id++)
+            {
+                double x, y;
+                unsigned cmd = m_vertices.vertex(path_id, &x, &y);
+                if(is_stop(cmd)) break;
+                if(is_vertex(cmd))
+                {
+                    trans.transform(&x, &y);
+                    m_vertices.modify_vertex(path_id, x, y);
+                }
+            }
+        }
+
+        //--------------------------------------------------------------------
+        template<class Trans>
+        void transform_all_paths(const Trans& trans)
+        {
+            unsigned idx;
+            unsigned num_ver = m_vertices.total_vertices();
+            for(idx = 0; idx < num_ver; idx++)
+            {
+                double x, y;
+                if(is_vertex(m_vertices.vertex(idx, &x, &y)))
+                {
+                    trans.transform(&x, &y);
+                    m_vertices.modify_vertex(idx, x, y);
+                }
+            }
+        }
+
+
+
     private:
         unsigned perceive_polygon_orientation(unsigned start, unsigned end);
         void     invert_polygon(unsigned start, unsigned end);
@@ -1167,7 +1210,6 @@
         return m_vertices.vertex(m_iterator++, x, y);
     }
 
-
     //------------------------------------------------------------------------
     template<class VC> 
     unsigned path_base<VC>::perceive_polygon_orientation(unsigned start,
@@ -1188,7 +1230,6 @@
         return (area < 0.0) ? path_flags_cw : path_flags_ccw;
     }
 
-
     //------------------------------------------------------------------------
     template<class VC> 
     void path_base<VC>::invert_polygon(unsigned start, unsigned end)
@@ -1232,10 +1273,7 @@
         while(end < m_vertices.total_vertices() && 
               !is_next_poly(m_vertices.command(end))) ++end;
 
-        if(end - start > 2)
-        {
-            invert_polygon(start, end);
-        }
+        invert_polygon(start, end);
     }
 
     //------------------------------------------------------------------------
@@ -1276,7 +1314,6 @@
         return end;
     }
 
-
     //------------------------------------------------------------------------
     template<class VC> 
     unsigned path_base<VC>::arrange_orientations(unsigned start, 
@@ -1297,7 +1334,6 @@
         return start;
     }
 
-
     //------------------------------------------------------------------------
     template<class VC> 
     void path_base<VC>::arrange_orientations_all_paths(path_flags_e orientation)
@@ -1312,7 +1348,6 @@
         }
     }
 
-
     //------------------------------------------------------------------------
     template<class VC> 
     void path_base<VC>::flip_x(double x1, double x2)
@@ -1329,7 +1364,6 @@
         }
     }
 
-
     //------------------------------------------------------------------------
     template<class VC> 
     void path_base<VC>::flip_y(double y1, double y2)
@@ -1346,10 +1380,43 @@
         }
     }
 
+    //------------------------------------------------------------------------
+    template<class VC> 
+    void path_base<VC>::translate(double dx, double dy, unsigned path_id)
+    {
+        unsigned num_ver = m_vertices.total_vertices();
+        for(; path_id < num_ver; path_id++)
+        {
+            double x, y;
+            unsigned cmd = m_vertices.vertex(path_id, &x, &y);
+            if(is_stop(cmd)) break;
+            if(is_vertex(cmd))
+            {
+                x += dx;
+                y += dy;
+                m_vertices.modify_vertex(path_id, x, y);
+            }
+        }
+    }
 
+    //------------------------------------------------------------------------
+    template<class VC> 
+    void path_base<VC>::translate_all_paths(double dx, double dy)
+    {
+        unsigned idx;
+        unsigned num_ver = m_vertices.total_vertices();
+        for(idx = 0; idx < num_ver; idx++)
+        {
+            double x, y;
+            if(is_vertex(m_vertices.vertex(idx, &x, &y)))
+            {
+                x += dx;
+                y += dy;
+                m_vertices.modify_vertex(idx, x, y);
+            }
+        }
+    }
 
-
-
     //-----------------------------------------------------vertex_stl_storage
     template<class Container> class vertex_stl_storage
     {

Modified: trunk/agg/include/agg_pixfmt_amask_adaptor.h
===================================================================
--- trunk/agg/include/agg_pixfmt_amask_adaptor.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_pixfmt_amask_adaptor.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -18,6 +18,7 @@
 
 
 #include <string.h>
+#include "agg_array.h"
 #include "agg_rendering_buffer.h"
 
 
@@ -38,39 +39,41 @@
 
         void realloc_span(unsigned len)
         {
-            if(len > m_max_len)
+            if(len > m_span.size())
             {
-                delete [] m_span;
-                m_span = new cover_type[m_max_len = len + span_extra_tail];
+                m_span.resize(len + span_extra_tail);
             }
         }
 
         void init_span(unsigned len)
         {
             realloc_span(len);
-
-            // ATTN! May work incorrectly if cover_type is more that one byte
-            memset(m_span, amask_type::cover_full, len * sizeof(cover_type));
+            memset(&m_span[0], amask_type::cover_full, len * sizeof(cover_type));
         }
 
         void init_span(unsigned len, const cover_type* covers)
         {
             realloc_span(len);
-            memcpy(m_span, covers, len * sizeof(cover_type));
+            memcpy(&m_span[0], covers, len * sizeof(cover_type));
         }
 
 
     public:
-        ~pixfmt_amask_adaptor() { delete [] m_span; }
-
         pixfmt_amask_adaptor(pixfmt_type& pixf, const amask_type& mask) :
-            m_pixf(&pixf), m_mask(&mask), m_span(0), m_max_len(0)
+            m_pixf(&pixf), m_mask(&mask), m_span()
         {}
 
         void attach_pixfmt(pixfmt_type& pixf)          { m_pixf = &pixf; }
         void attach_alpha_mask(const amask_type& mask) { m_mask = &mask; }
 
         //--------------------------------------------------------------------
+        template<class PixFmt2>
+        bool attach_pixfmt(PixFmt2& pixf, int x1, int y1, int x2, int y2)
+        {
+            return m_pixf->attach(pixf, x1, y1, x2, y2);
+        }
+
+        //--------------------------------------------------------------------
         unsigned width()  const { return m_pixf->width();  }
         unsigned height() const { return m_pixf->height(); }
 
@@ -98,8 +101,8 @@
                         const color_type& c)
         {
             realloc_span(len);
-            m_mask->fill_hspan(x, y, m_span, len);
-            m_pixf->blend_solid_hspan(x, y, len, c, m_span);
+            m_mask->fill_hspan(x, y, &m_span[0], len);
+            m_pixf->blend_solid_hspan(x, y, len, c, &m_span[0]);
         }
 
         //--------------------------------------------------------------------
@@ -109,8 +112,8 @@
                          cover_type cover)
         {
             init_span(len);
-            m_mask->combine_hspan(x, y, m_span, len);
-            m_pixf->blend_solid_hspan(x, y, len, c, m_span);
+            m_mask->combine_hspan(x, y, &m_span[0], len);
+            m_pixf->blend_solid_hspan(x, y, len, c, &m_span[0]);
         }
 
         //--------------------------------------------------------------------
@@ -119,8 +122,8 @@
                         const color_type& c)
         {
             realloc_span(len);
-            m_mask->fill_vspan(x, y, m_span, len);
-            m_pixf->blend_solid_vspan(x, y, len, c, m_span);
+            m_mask->fill_vspan(x, y, &m_span[0], len);
+            m_pixf->blend_solid_vspan(x, y, len, c, &m_span[0]);
         }
 
         //--------------------------------------------------------------------
@@ -130,8 +133,8 @@
                          cover_type cover)
         {
             init_span(len);
-            m_mask->combine_vspan(x, y, m_span, len);
-            m_pixf->blend_solid_vspan(x, y, len, c, m_span);
+            m_mask->combine_vspan(x, y, &m_span[0], len);
+            m_pixf->blend_solid_vspan(x, y, len, c, &m_span[0]);
         }
 
         //--------------------------------------------------------------------
@@ -151,8 +154,8 @@
                                const cover_type* covers)
         {
             init_span(len, covers);
-            m_mask->combine_hspan(x, y, m_span, len);
-            m_pixf->blend_solid_hspan(x, y, len, c, m_span);
+            m_mask->combine_hspan(x, y, &m_span[0], len);
+            m_pixf->blend_solid_hspan(x, y, len, c, &m_span[0]);
         }
 
 
@@ -163,8 +166,8 @@
                                const cover_type* covers)
         {
             init_span(len, covers);
-            m_mask->combine_vspan(x, y, m_span, len);
-            m_pixf->blend_solid_vspan(x, y, len, c, m_span);
+            m_mask->combine_vspan(x, y, &m_span[0], len);
+            m_pixf->blend_solid_vspan(x, y, len, c, &m_span[0]);
         }
 
 
@@ -172,10 +175,17 @@
         void copy_color_hspan(int x, int y, unsigned len, const color_type* colors)
         {
             realloc_span(len);
-            m_mask->fill_hspan(x, y, m_span, len);
-            m_pixf->blend_color_hspan(x, y, len, colors, m_span, cover_full);
+            m_mask->fill_hspan(x, y, &m_span[0], len);
+            m_pixf->blend_color_hspan(x, y, len, colors, &m_span[0], cover_full);
         }
 
+        //--------------------------------------------------------------------
+        void copy_color_vspan(int x, int y, unsigned len, const color_type* colors)
+        {
+            realloc_span(len);
+            m_mask->fill_vspan(x, y, &m_span[0], len);
+            m_pixf->blend_color_vspan(x, y, len, colors, &m_span[0], cover_full);
+        }
 
         //--------------------------------------------------------------------
         void blend_color_hspan(int x, int y,
@@ -187,14 +197,14 @@
             if(covers) 
             {
                 init_span(len, covers);
-                m_mask->combine_hspan(x, y, m_span, len);
+                m_mask->combine_hspan(x, y, &m_span[0], len);
             }
             else
             {
                 realloc_span(len);
-                m_mask->fill_hspan(x, y, m_span, len);
+                m_mask->fill_hspan(x, y, &m_span[0], len);
             }
-            m_pixf->blend_color_hspan(x, y, len, colors, m_span, cover);
+            m_pixf->blend_color_hspan(x, y, len, colors, &m_span[0], cover);
         }
 
 
@@ -208,22 +218,20 @@
             if(covers) 
             {
                 init_span(len, covers);
-                m_mask->combine_vspan(x, y, m_span, len);
+                m_mask->combine_vspan(x, y, &m_span[0], len);
             }
             else
             {
                 realloc_span(len);
-                m_mask->fill_vspan(x, y, m_span, len);
+                m_mask->fill_vspan(x, y, &m_span[0], len);
             }
-            m_pixf->blend_color_vspan(x, y, len, colors, m_span, cover);
+            m_pixf->blend_color_vspan(x, y, len, colors, &m_span[0], cover);
         }
 
     private:
-        pixfmt_type*      m_pixf;
-        const amask_type* m_mask;
-
-        cover_type*       m_span;
-        unsigned          m_max_len;
+        pixfmt_type*          m_pixf;
+        const amask_type*     m_mask;
+        pod_array<cover_type> m_span;
     };
 
 }

Modified: trunk/agg/include/agg_pixfmt_gray.h
===================================================================
--- trunk/agg/include/agg_pixfmt_gray.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_pixfmt_gray.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -128,7 +128,9 @@
             base_shift = color_type::base_shift,
             base_scale = color_type::base_scale,
             base_mask  = color_type::base_mask,
-            pix_width  = sizeof(value_type)
+            pix_width  = sizeof(value_type),
+            pix_step   = Step,
+            pix_offset = Offset
         };
 
     private:
@@ -171,30 +173,46 @@
 
     public:
         //--------------------------------------------------------------------
-        pixfmt_alpha_blend_gray(rbuf_type& rb) :
+        explicit pixfmt_alpha_blend_gray(rbuf_type& rb) :
             m_rbuf(&rb)
         {}
+        void attach(rbuf_type& rb) { m_rbuf = &rb; }
+        //--------------------------------------------------------------------
 
+        template<class PixFmt>
+        bool attach(PixFmt& pixf, int x1, int y1, int x2, int y2)
+        {
+            rect_i r(x1, y1, x2, y2);
+            if(r.clip(rect_i(0, 0, pixf.width()-1, pixf.height()-1)))
+            {
+                int stride = pixf.stride();
+                m_rbuf->attach(pixf.pix_ptr(r.x1, stride < 0 ? r.y2 : r.y1), 
+                               (r.x2 - r.x1) + 1,
+                               (r.y2 - r.y1) + 1,
+                               stride);
+                return true;
+            }
+            return false;
+        }
+
         //--------------------------------------------------------------------
         AGG_INLINE unsigned width()  const { return m_rbuf->width();  }
         AGG_INLINE unsigned height() const { return m_rbuf->height(); }
+        AGG_INLINE int      stride() const { return m_rbuf->stride(); }
 
         //--------------------------------------------------------------------
-        const int8u* row_ptr(int y) const
-        {
-            return m_rbuf->row_ptr(y);
-        }
+              int8u* row_ptr(int y)       { return m_rbuf->row_ptr(y); }
+        const int8u* row_ptr(int y) const { return m_rbuf->row_ptr(y); }
+        row_data     row(int y)     const { return m_rbuf->row(y); }
 
-        //--------------------------------------------------------------------
         const int8u* pix_ptr(int x, int y) const
         {
-            return m_rbuf->row_ptr(y) + x * pix_width;
+            return m_rbuf->row_ptr(y) + x * Step + Offset;
         }
 
-        //--------------------------------------------------------------------
-        row_data row(int x, int y) const
+        int8u* pix_ptr(int x, int y)
         {
-            return m_rbuf->row(y);
+            return m_rbuf->row_ptr(y) + x * Step + Offset;
         }
 
         //--------------------------------------------------------------------
@@ -206,7 +224,7 @@
         //--------------------------------------------------------------------
         AGG_INLINE color_type pixel(int x, int y) const
         {
-            value_type* p = (value_type*)m_rbuf->row(y) + x * Step + Offset;
+            value_type* p = (value_type*)m_rbuf->row_ptr(y) + x * Step + Offset;
             return color_type(*p);
         }
 
@@ -399,14 +417,30 @@
 
             do 
             {
-                *p++ = colors->v;
+                *p = colors->v;
+                p += Step;
                 ++colors;
             }
             while(--len);
         }
 
 
+        //--------------------------------------------------------------------
+        void copy_color_vspan(int x, int y,
+                              unsigned len, 
+                              const color_type* colors)
+        {
+            do 
+            {
+                value_type* p = (value_type*)
+                    m_rbuf->row_ptr(x, y++, 1) + x * Step + Offset;
+                *p = colors->v;
+                ++colors;
+            }
+            while(--len);
+        }
 
+
         //--------------------------------------------------------------------
         void blend_color_hspan(int x, int y,
                                unsigned len, 
@@ -565,6 +599,58 @@
             }
         }
 
+        //--------------------------------------------------------------------
+        template<class SrcPixelFormatRenderer>
+        void blend_from_color(const SrcPixelFormatRenderer& from, 
+                              const color_type& color,
+                              int xdst, int ydst,
+                              int xsrc, int ysrc,
+                              unsigned len,
+                              int8u cover)
+        {
+            typedef typename SrcPixelFormatRenderer::value_type src_value_type;
+            const src_value_type* psrc = (src_value_type*)from.row_ptr(ysrc);
+            if(psrc)
+            {
+                value_type* pdst = 
+                    (value_type*)m_rbuf->row_ptr(xdst, ydst, len) + xdst;
+                do 
+                {
+                    copy_or_blend_pix(pdst, 
+                                      color, 
+                                      (*psrc * cover + base_mask) >> base_shift);
+                    ++psrc;
+                    ++pdst;
+                }
+                while(--len);
+            }
+        }
+
+        //--------------------------------------------------------------------
+        template<class SrcPixelFormatRenderer>
+        void blend_from_lut(const SrcPixelFormatRenderer& from, 
+                            const color_type* color_lut,
+                            int xdst, int ydst,
+                            int xsrc, int ysrc,
+                            unsigned len,
+                            int8u cover)
+        {
+            typedef typename SrcPixelFormatRenderer::value_type src_value_type;
+            const src_value_type* psrc = (src_value_type*)from.row_ptr(ysrc);
+            if(psrc)
+            {
+                value_type* pdst = 
+                    (value_type*)m_rbuf->row_ptr(xdst, ydst, len) + xdst;
+                do 
+                {
+                    copy_or_blend_pix(pdst, color_lut[*psrc], cover);
+                    ++psrc;
+                    ++pdst;
+                }
+                while(--len);
+            }
+        }
+
     private:
         rbuf_type* m_rbuf;
     };

Modified: trunk/agg/include/agg_pixfmt_rgb.h
===================================================================
--- trunk/agg/include/agg_pixfmt_rgb.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_pixfmt_rgb.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -173,8 +173,8 @@
     {
     public:
         typedef RenBuf   rbuf_type;
+        typedef Blender  blender_type;
         typedef typename rbuf_type::row_data row_data;
-        typedef Blender  blender_type;
         typedef typename blender_type::color_type color_type;
         typedef typename blender_type::order_type order_type;
         typedef typename color_type::value_type value_type;
@@ -231,33 +231,50 @@
 
     public:
         //--------------------------------------------------------------------
-        pixfmt_alpha_blend_rgb(rbuf_type& rb) :
+        explicit pixfmt_alpha_blend_rgb(rbuf_type& rb) :
             m_rbuf(&rb)
         {}
+        void attach(rbuf_type& rb) { m_rbuf = &rb; }
 
         //--------------------------------------------------------------------
+        template<class PixFmt>
+        bool attach(PixFmt& pixf, int x1, int y1, int x2, int y2)
+        {
+            rect_i r(x1, y1, x2, y2);
+            if(r.clip(rect_i(0, 0, pixf.width()-1, pixf.height()-1)))
+            {
+                int stride = pixf.stride();
+                m_rbuf->attach(pixf.pix_ptr(r.x1, stride < 0 ? r.y2 : r.y1), 
+                               (r.x2 - r.x1) + 1,
+                               (r.y2 - r.y1) + 1,
+                               stride);
+                return true;
+            }
+            return false;
+        }
+
+        //--------------------------------------------------------------------
         Blender& blender() { return m_blender; }
 
         //--------------------------------------------------------------------
         AGG_INLINE unsigned width()  const { return m_rbuf->width();  }
         AGG_INLINE unsigned height() const { return m_rbuf->height(); }
+        AGG_INLINE int      stride() const { return m_rbuf->stride(); }
 
         //--------------------------------------------------------------------
-        const int8u* row_ptr(int y) const
-        {
-            return m_rbuf->row_ptr(y);
-        }
+        AGG_INLINE       int8u* row_ptr(int y)       { return m_rbuf->row_ptr(y); }
+        AGG_INLINE const int8u* row_ptr(int y) const { return m_rbuf->row_ptr(y); }
+        AGG_INLINE row_data     row(int y)     const { return m_rbuf->row(y); }
 
         //--------------------------------------------------------------------
-        const int8u* pix_ptr(int x, int y) const
-        {
-            return m_rbuf->row_ptr(y) + x * pix_width;
+        AGG_INLINE int8u* pix_ptr(int x, int y) 
+        { 
+            return m_rbuf->row_ptr(y) + x * pix_width; 
         }
 
-        //--------------------------------------------------------------------
-        row_data row(int x, int y) const
-        {
-            return m_rbuf->row(y);
+        AGG_INLINE const int8u* pix_ptr(int x, int y) const 
+        { 
+            return m_rbuf->row_ptr(y) + x * pix_width; 
         }
 
         //--------------------------------------------------------------------
@@ -485,6 +502,24 @@
 
 
         //--------------------------------------------------------------------
+        void copy_color_vspan(int x, int y,
+                              unsigned len, 
+                              const color_type* colors)
+        {
+            do 
+            {
+                value_type* p = (value_type*)
+                    m_rbuf->row_ptr(x, y++, 1) + x + x + x;
+                p[order_type::R] = colors->r;
+                p[order_type::G] = colors->g;
+                p[order_type::B] = colors->b;
+                ++colors;
+            }
+            while(--len);
+        }
+
+
+        //--------------------------------------------------------------------
         void blend_color_hspan(int x, int y,
                                unsigned len, 
                                const color_type* colors,
@@ -687,6 +722,74 @@
             }
         }
 
+        //--------------------------------------------------------------------
+        template<class SrcPixelFormatRenderer>
+        void blend_from_color(const SrcPixelFormatRenderer& from, 
+                              const color_type& color,
+                              int xdst, int ydst,
+                              int xsrc, int ysrc,
+                              unsigned len,
+                              int8u cover)
+        {
+            typedef typename SrcPixelFormatRenderer::value_type src_value_type;
+            const src_value_type* psrc = (src_value_type*)from.row_ptr(ysrc);
+            if(psrc)
+            {
+                value_type* pdst = 
+                    (value_type*)m_rbuf->row_ptr(xdst, ydst, len) + xdst * 3;
+                do 
+                {
+                    copy_or_blend_pix(pdst, 
+                                      color, 
+                                      (*psrc * cover + base_mask) >> base_shift);
+                    ++psrc;
+                    pdst += 3;
+                }
+                while(--len);
+            }
+        }
+
+        //--------------------------------------------------------------------
+        template<class SrcPixelFormatRenderer>
+        void blend_from_lut(const SrcPixelFormatRenderer& from, 
+                            const color_type* color_lut,
+                            int xdst, int ydst,
+                            int xsrc, int ysrc,
+                            unsigned len,
+                            int8u cover)
+        {
+            typedef typename SrcPixelFormatRenderer::value_type src_value_type;
+            const src_value_type* psrc = (src_value_type*)from.row_ptr(ysrc);
+            if(psrc)
+            {
+                value_type* pdst = 
+                    (value_type*)m_rbuf->row_ptr(xdst, ydst, len) + xdst * 3;
+
+                if(cover == 255)
+                {
+                    do 
+                    {
+                        const color_type& color = color_lut[*psrc];
+                        m_blender.blend_pix(pdst, 
+                                            color.r, color.g, color.b, color.a);
+                        ++psrc;
+                        pdst += 3;
+                    }
+                    while(--len);
+                }
+                else
+                {
+                    do 
+                    {
+                        copy_or_blend_pix(pdst, color_lut[*psrc], cover);
+                        ++psrc;
+                        pdst += 3;
+                    }
+                    while(--len);
+                }
+            }
+        }
+
     private:
         rbuf_type* m_rbuf;
         Blender    m_blender;

Modified: trunk/agg/include/agg_pixfmt_rgb_packed.h
===================================================================
--- trunk/agg/include/agg_pixfmt_rgb_packed.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_pixfmt_rgb_packed.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -828,29 +828,47 @@
 
     public:
         //--------------------------------------------------------------------
-        pixfmt_alpha_blend_rgb_packed(rbuf_type& rb) : m_rbuf(&rb) {}
+        explicit pixfmt_alpha_blend_rgb_packed(rbuf_type& rb) : m_rbuf(&rb) {}
+        void attach(rbuf_type& rb) { m_rbuf = &rb; }
+
+        //--------------------------------------------------------------------
+        template<class PixFmt>
+        bool attach(PixFmt& pixf, int x1, int y1, int x2, int y2)
+        {
+            rect_i r(x1, y1, x2, y2);
+            if(r.clip(rect_i(0, 0, pixf.width()-1, pixf.height()-1)))
+            {
+                int stride = pixf.stride();
+                m_rbuf->attach(pixf.pix_ptr(r.x1, stride < 0 ? r.y2 : r.y1), 
+                               (r.x2 - r.x1) + 1,
+                               (r.y2 - r.y1) + 1,
+                               stride);
+                return true;
+            }
+            return false;
+        }
+
         Blender& blender() { return m_blender; }
 
         //--------------------------------------------------------------------
         AGG_INLINE unsigned width()  const { return m_rbuf->width();  }
         AGG_INLINE unsigned height() const { return m_rbuf->height(); }
+        AGG_INLINE int      stride() const { return m_rbuf->stride(); }
 
         //--------------------------------------------------------------------
-        const int8u* row_ptr(int y) const
-        {
-            return m_rbuf->row_ptr(y);
-        }
+        AGG_INLINE       int8u* row_ptr(int y)       { return m_rbuf->row_ptr(y); }
+        AGG_INLINE const int8u* row_ptr(int y) const { return m_rbuf->row_ptr(y); }
+        AGG_INLINE row_data     row(int y)     const { return m_rbuf->row(y); }
 
         //--------------------------------------------------------------------
-        const int8u* pix_ptr(int x, int y) const
+        AGG_INLINE int8u* pix_ptr(int x, int y)
         {
             return m_rbuf->row_ptr(y) + x * pix_width;
         }
 
-        //--------------------------------------------------------------------
-        row_data row(int x, int y) const
+        AGG_INLINE const int8u* pix_ptr(int x, int y) const
         {
-            return m_rbuf->row(y);
+            return m_rbuf->row_ptr(y) + x * pix_width;
         }
 
         //--------------------------------------------------------------------
@@ -1013,6 +1031,20 @@
         }
 
         //--------------------------------------------------------------------
+        void copy_color_vspan(int x, int y,
+                              unsigned len, 
+                              const color_type* colors)
+        {
+            do 
+            {
+                pixel_type* p = (pixel_type*)m_rbuf->row_ptr(x, y++, 1) + x;
+                *p = m_blender.make_pix(colors->r, colors->g, colors->b);
+                ++colors;
+            }
+            while(--len);
+        }
+
+        //--------------------------------------------------------------------
         void blend_color_hspan(int x, int y,
                                unsigned len, 
                                const color_type* colors,
@@ -1102,6 +1134,65 @@
             }
         }
 
+        //--------------------------------------------------------------------
+        template<class SrcPixelFormatRenderer>
+        void blend_from_color(const SrcPixelFormatRenderer& from, 
+                              const color_type& color,
+                              int xdst, int ydst,
+                              int xsrc, int ysrc,
+                              unsigned len,
+                              int8u cover)
+        {
+            typedef typename SrcPixelFormatRenderer::value_type src_value_type;
+            const src_value_type* psrc = (src_value_type*)from.row_ptr(ysrc);
+            if(psrc)
+            {
+                pixel_type* pdst = 
+                    (pixel_type*)m_rbuf->row_ptr(xdst, ydst, len) + xdst;
+
+                do 
+                {
+                    m_blender.blend_pix(pdst, 
+                                        color.r, color.g, color.b, color.a,
+                                        cover);
+                    ++psrc;
+                    ++pdst;
+                }
+                while(--len);
+            }
+        }
+
+        //--------------------------------------------------------------------
+        template<class SrcPixelFormatRenderer>
+        void blend_from_lut(const SrcPixelFormatRenderer& from, 
+                            const color_type* color_lut,
+                            int xdst, int ydst,
+                            int xsrc, int ysrc,
+                            unsigned len,
+                            int8u cover)
+        {
+            typedef typename SrcPixelFormatRenderer::value_type src_value_type;
+            const src_value_type* psrc = (src_value_type*)from.row_ptr(ysrc);
+            if(psrc)
+            {
+                pixel_type* pdst = 
+                    (pixel_type*)m_rbuf->row_ptr(xdst, ydst, len) + xdst;
+
+                do 
+                {
+                    const color_type& color = color_lut[*psrc];
+                    m_blender.blend_pix(pdst, 
+                                        color.r, color.g, color.b, color.a,
+                                        cover);
+                    ++psrc;
+                    ++pdst;
+                }
+                while(--len);
+            }
+        }
+
+
+
     private:
         rbuf_type* m_rbuf;
         Blender    m_blender;

Modified: trunk/agg/include/agg_pixfmt_rgba.h
===================================================================
--- trunk/agg/include/agg_pixfmt_rgba.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_pixfmt_rgba.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -614,12 +614,15 @@
                 sb = (sb * cover + 255) >> 8;
                 sa = (sa * cover + 255) >> 8;
             }
-            calc_type s1a = base_mask - sa;
-            calc_type d1a = base_mask - p[Order::A];
-            p[Order::R] = (value_type)((p[Order::R] * s1a + sr * d1a + base_mask) >> base_shift);
-            p[Order::G] = (value_type)((p[Order::G] * s1a + sg * d1a + base_mask) >> base_shift);
-            p[Order::B] = (value_type)((p[Order::B] * s1a + sb * d1a + base_mask) >> base_shift);
-            p[Order::A] = (value_type)(sa + p[Order::A] - ((sa * p[Order::A] + base_mask/2) >> (base_shift - 1)));
+            if(sa)
+            {
+                calc_type s1a = base_mask - sa;
+                calc_type d1a = base_mask - p[Order::A];
+                p[Order::R] = (value_type)((p[Order::R] * s1a + sr * d1a + base_mask) >> base_shift);
+                p[Order::G] = (value_type)((p[Order::G] * s1a + sg * d1a + base_mask) >> base_shift);
+                p[Order::B] = (value_type)((p[Order::B] * s1a + sb * d1a + base_mask) >> base_shift);
+                p[Order::A] = (value_type)(sa + p[Order::A] - ((sa * p[Order::A] + base_mask/2) >> (base_shift - 1)));
+            }
         }
     };
 
@@ -649,14 +652,17 @@
                 sb = (sb * cover + 255) >> 8;
                 sa = (sa * cover + 255) >> 8;
             }
-            calc_type dr = p[Order::R] + sr;
-            calc_type dg = p[Order::G] + sg;
-            calc_type db = p[Order::B] + sb;
-            calc_type da = p[Order::A] + sa;
-            p[Order::R] = (dr > base_mask) ? base_mask : dr;
-            p[Order::G] = (dg > base_mask) ? base_mask : dg;
-            p[Order::B] = (db > base_mask) ? base_mask : db;
-            p[Order::A] = (da > base_mask) ? base_mask : da;
+            if(sa)
+            {
+                calc_type dr = p[Order::R] + sr;
+                calc_type dg = p[Order::G] + sg;
+                calc_type db = p[Order::B] + sb;
+                calc_type da = p[Order::A] + sa;
+                p[Order::R] = (dr > base_mask) ? (value_type)base_mask : dr;
+                p[Order::G] = (dg > base_mask) ? (value_type)base_mask : dg;
+                p[Order::B] = (db > base_mask) ? (value_type)base_mask : db;
+                p[Order::A] = (da > base_mask) ? (value_type)base_mask : da;
+            }
         }
     };
 
@@ -686,13 +692,17 @@
                 sb = (sb * cover + 255) >> 8;
                 sa = (sa * cover + 255) >> 8;
             }
-            calc_type dr = p[Order::R] - sr;
-            calc_type dg = p[Order::G] - sg;
-            calc_type db = p[Order::B] - sb;
-            p[Order::R] = (dr > base_mask) ? 0 : dr;
-            p[Order::G] = (dg > base_mask) ? 0 : dg;
-            p[Order::B] = (db > base_mask) ? 0 : db;
-            p[Order::A] = (value_type)(base_mask - (((base_mask - sa) * (base_mask - p[Order::A]) + base_mask) >> base_shift));
+            if(sa)
+            {
+                calc_type dr = p[Order::R] - sr;
+                calc_type dg = p[Order::G] - sg;
+                calc_type db = p[Order::B] - sb;
+                p[Order::R] = (dr > base_mask) ? 0 : dr;
+                p[Order::G] = (dg > base_mask) ? 0 : dg;
+                p[Order::B] = (db > base_mask) ? 0 : db;
+                p[Order::A] = (value_type)(sa + p[Order::A] - ((sa * p[Order::A] + base_mask) >> base_shift));
+                //p[Order::A] = (value_type)(base_mask - (((base_mask - sa) * (base_mask - p[Order::A]) + base_mask) >> base_shift));
+            }
         }
     };
 
@@ -722,15 +732,18 @@
                 sb = (sb * cover + 255) >> 8;
                 sa = (sa * cover + 255) >> 8;
             }
-            calc_type s1a = base_mask - sa;
-            calc_type d1a = base_mask - p[Order::A];
-            calc_type dr = p[Order::R];
-            calc_type dg = p[Order::G];
-            calc_type db = p[Order::B];
-            p[Order::R] = (value_type)((sr * dr + sr * d1a + dr * s1a + base_mask) >> base_shift);
-            p[Order::G] = (value_type)((sg * dg + sg * d1a + dg * s1a + base_mask) >> base_shift);
-            p[Order::B] = (value_type)((sb * db + sb * d1a + db * s1a + base_mask) >> base_shift);
-            p[Order::A] = (value_type)(sa + p[Order::A] - ((sa * p[Order::A] + base_mask) >> base_shift));
+            if(sa)
+            {
+                calc_type s1a = base_mask - sa;
+                calc_type d1a = base_mask - p[Order::A];
+                calc_type dr = p[Order::R];
+                calc_type dg = p[Order::G];
+                calc_type db = p[Order::B];
+                p[Order::R] = (value_type)((sr * dr + sr * d1a + dr * s1a + base_mask) >> base_shift);
+                p[Order::G] = (value_type)((sg * dg + sg * d1a + dg * s1a + base_mask) >> base_shift);
+                p[Order::B] = (value_type)((sb * db + sb * d1a + db * s1a + base_mask) >> base_shift);
+                p[Order::A] = (value_type)(sa + p[Order::A] - ((sa * p[Order::A] + base_mask) >> base_shift));
+            }
         }
     };
 
@@ -760,14 +773,17 @@
                 sb = (sb * cover + 255) >> 8;
                 sa = (sa * cover + 255) >> 8;
             }
-            calc_type dr = p[Order::R];
-            calc_type dg = p[Order::G];
-            calc_type db = p[Order::B];
-            calc_type da = p[Order::A];
-            p[Order::R] = (value_type)(sr + dr - ((sr * dr + base_mask) >> base_shift));
-            p[Order::G] = (value_type)(sg + dg - ((sg * dg + base_mask) >> base_shift));
-            p[Order::B] = (value_type)(sb + db - ((sb * db + base_mask) >> base_shift));
-            p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
+            if(sa)
+            {
+                calc_type dr = p[Order::R];
+                calc_type dg = p[Order::G];
+                calc_type db = p[Order::B];
+                calc_type da = p[Order::A];
+                p[Order::R] = (value_type)(sr + dr - ((sr * dr + base_mask) >> base_shift));
+                p[Order::G] = (value_type)(sg + dg - ((sg * dg + base_mask) >> base_shift));
+                p[Order::B] = (value_type)(sb + db - ((sb * db + base_mask) >> base_shift));
+                p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
+            }
         }
     };
 
@@ -801,27 +817,30 @@
                 sb = (sb * cover + 255) >> 8;
                 sa = (sa * cover + 255) >> 8;
             }
-            calc_type d1a  = base_mask - p[Order::A];
-            calc_type s1a  = base_mask - sa;
-            calc_type dr   = p[Order::R];
-            calc_type dg   = p[Order::G];
-            calc_type db   = p[Order::B];
-            calc_type da   = p[Order::A];
-            calc_type sada = sa * p[Order::A];
+            if(sa)
+            {
+                calc_type d1a  = base_mask - p[Order::A];
+                calc_type s1a  = base_mask - sa;
+                calc_type dr   = p[Order::R];
+                calc_type dg   = p[Order::G];
+                calc_type db   = p[Order::B];
+                calc_type da   = p[Order::A];
+                calc_type sada = sa * p[Order::A];
 
-            p[Order::R] = (value_type)(((2*dr < da) ? 
-                2*sr*dr + sr*d1a + dr*s1a : 
-                sada - 2*(da - dr)*(sa - sr) + sr*d1a + dr*s1a) >> base_shift);
+                p[Order::R] = (value_type)(((2*dr < da) ? 
+                    2*sr*dr + sr*d1a + dr*s1a : 
+                    sada - 2*(da - dr)*(sa - sr) + sr*d1a + dr*s1a + base_mask) >> base_shift);
 
-            p[Order::G] = (value_type)(((2*dg < da) ? 
-                2*sg*dg + sg*d1a + dg*s1a : 
-                sada - 2*(da - dg)*(sa - sg) + sg*d1a + dg*s1a) >> base_shift);
+                p[Order::G] = (value_type)(((2*dg < da) ? 
+                    2*sg*dg + sg*d1a + dg*s1a : 
+                    sada - 2*(da - dg)*(sa - sg) + sg*d1a + dg*s1a + base_mask) >> base_shift);
 
-            p[Order::B] = (value_type)(((2*db < da) ? 
-                2*sb*db + sb*d1a + db*s1a : 
-                sada - 2*(da - db)*(sa - sb) + sb*d1a + db*s1a) >> base_shift);
+                p[Order::B] = (value_type)(((2*db < da) ? 
+                    2*sb*db + sb*d1a + db*s1a : 
+                    sada - 2*(da - db)*(sa - sb) + sb*d1a + db*s1a + base_mask) >> base_shift);
 
-            p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
+                p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
+            }
         }
     };
 
@@ -855,17 +874,20 @@
                 sb = (sb * cover + 255) >> 8;
                 sa = (sa * cover + 255) >> 8;
             }
-            calc_type d1a = base_mask - p[Order::A];
-            calc_type s1a = base_mask - sa;
-            calc_type dr  = p[Order::R];
-            calc_type dg  = p[Order::G];
-            calc_type db  = p[Order::B];
-            calc_type da  = p[Order::A];
+            if(sa)
+            {
+                calc_type d1a = base_mask - p[Order::A];
+                calc_type s1a = base_mask - sa;
+                calc_type dr  = p[Order::R];
+                calc_type dg  = p[Order::G];
+                calc_type db  = p[Order::B];
+                calc_type da  = p[Order::A];
 
-            p[Order::R] = (value_type)((sd_min(sr * da, dr * sa) + sr * d1a + dr * s1a) >> base_shift);
-            p[Order::G] = (value_type)((sd_min(sg * da, dg * sa) + sg * d1a + dg * s1a) >> base_shift);
-            p[Order::B] = (value_type)((sd_min(sb * da, db * sa) + sb * d1a + db * s1a) >> base_shift);
-            p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
+                p[Order::R] = (value_type)((sd_min(sr * da, dr * sa) + sr * d1a + dr * s1a + base_mask) >> base_shift);
+                p[Order::G] = (value_type)((sd_min(sg * da, dg * sa) + sg * d1a + dg * s1a + base_mask) >> base_shift);
+                p[Order::B] = (value_type)((sd_min(sb * da, db * sa) + sb * d1a + db * s1a + base_mask) >> base_shift);
+                p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
+            }
         }
     };
 
@@ -895,17 +917,20 @@
                 sb = (sb * cover + 255) >> 8;
                 sa = (sa * cover + 255) >> 8;
             }
-            calc_type d1a = base_mask - p[Order::A];
-            calc_type s1a = base_mask - sa;
-            calc_type dr  = p[Order::R];
-            calc_type dg  = p[Order::G];
-            calc_type db  = p[Order::B];
-            calc_type da  = p[Order::A];
+            if(sa)
+            {
+                calc_type d1a = base_mask - p[Order::A];
+                calc_type s1a = base_mask - sa;
+                calc_type dr  = p[Order::R];
+                calc_type dg  = p[Order::G];
+                calc_type db  = p[Order::B];
+                calc_type da  = p[Order::A];
 
-            p[Order::R] = (value_type)((sd_max(sr * da, dr * sa) + sr * d1a + dr * s1a) >> base_shift);
-            p[Order::G] = (value_type)((sd_max(sg * da, dg * sa) + sg * d1a + dg * s1a) >> base_shift);
-            p[Order::B] = (value_type)((sd_max(sb * da, db * sa) + sb * d1a + db * s1a) >> base_shift);
-            p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
+                p[Order::R] = (value_type)((sd_max(sr * da, dr * sa) + sr * d1a + dr * s1a + base_mask) >> base_shift);
+                p[Order::G] = (value_type)((sd_max(sg * da, dg * sa) + sg * d1a + dg * s1a + base_mask) >> base_shift);
+                p[Order::B] = (value_type)((sd_max(sb * da, db * sa) + sb * d1a + db * s1a + base_mask) >> base_shift);
+                p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
+            }
         }
     };
 
@@ -940,33 +965,36 @@
                 sb = (sb * cover + 255) >> 8;
                 sa = (sa * cover + 255) >> 8;
             }
-            calc_type d1a  = base_mask - p[Order::A];
-            calc_type s1a  = base_mask - sa;
-            calc_type dr   = p[Order::R];
-            calc_type dg   = p[Order::G];
-            calc_type db   = p[Order::B];
-            calc_type da   = p[Order::A];
-            long_type drsa = dr * sa;
-            long_type dgsa = dg * sa;
-            long_type dbsa = db * sa;
-            long_type srda = sr * da;
-            long_type sgda = sg * da;
-            long_type sbda = sb * da;
-            long_type sada = sa * da;
+            if(sa)
+            {
+                calc_type d1a  = base_mask - p[Order::A];
+                calc_type s1a  = base_mask - sa;
+                calc_type dr   = p[Order::R];
+                calc_type dg   = p[Order::G];
+                calc_type db   = p[Order::B];
+                calc_type da   = p[Order::A];
+                long_type drsa = dr * sa;
+                long_type dgsa = dg * sa;
+                long_type dbsa = db * sa;
+                long_type srda = sr * da;
+                long_type sgda = sg * da;
+                long_type sbda = sb * da;
+                long_type sada = sa * da;
 
-            p[Order::R] = (value_type)((srda + drsa >= sada) ? 
-                (sada + sr * d1a + dr * s1a) >> base_shift :
-                drsa / (base_mask - (sr << base_shift) / sa) + ((sr * d1a + dr * s1a) >> base_shift));
+                p[Order::R] = (value_type)((srda + drsa >= sada) ? 
+                    (sada + sr * d1a + dr * s1a + base_mask) >> base_shift :
+                    drsa / (base_mask - (sr << base_shift) / sa) + ((sr * d1a + dr * s1a + base_mask) >> base_shift));
 
-            p[Order::G] = (value_type)((sgda + dgsa >= sada) ? 
-                (sada + sg * d1a + dg * s1a) >> base_shift :
-                dgsa / (base_mask - (sg << base_shift) / sa) + ((sg * d1a + dg * s1a) >> base_shift));
+                p[Order::G] = (value_type)((sgda + dgsa >= sada) ? 
+                    (sada + sg * d1a + dg * s1a + base_mask) >> base_shift :
+                    dgsa / (base_mask - (sg << base_shift) / sa) + ((sg * d1a + dg * s1a + base_mask) >> base_shift));
 
-            p[Order::B] = (value_type)((sbda + dbsa >= sada) ? 
-                (sada + sb * d1a + db * s1a) >> base_shift :
-                dbsa / (base_mask - (sb << base_shift) / sa) + ((sb * d1a + db * s1a) >> base_shift));
+                p[Order::B] = (value_type)((sbda + dbsa >= sada) ? 
+                    (sada + sb * d1a + db * s1a + base_mask) >> base_shift :
+                    dbsa / (base_mask - (sb << base_shift) / sa) + ((sb * d1a + db * s1a + base_mask) >> base_shift));
 
-            p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
+                p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
+            }
         }
     };
 
@@ -1001,33 +1029,36 @@
                 sb = (sb * cover + 255) >> 8;
                 sa = (sa * cover + 255) >> 8;
             }
-            calc_type d1a  = base_mask - p[Order::A];
-            calc_type s1a  = base_mask - sa;
-            calc_type dr   = p[Order::R];
-            calc_type dg   = p[Order::G];
-            calc_type db   = p[Order::B];
-            calc_type da   = p[Order::A];
-            long_type drsa = dr * sa;
-            long_type dgsa = dg * sa;
-            long_type dbsa = db * sa;
-            long_type srda = sr * da;
-            long_type sgda = sg * da;
-            long_type sbda = sb * da;
-            long_type sada = sa * da;
+            if(sa)
+            {
+                calc_type d1a  = base_mask - p[Order::A];
+                calc_type s1a  = base_mask - sa;
+                calc_type dr   = p[Order::R];
+                calc_type dg   = p[Order::G];
+                calc_type db   = p[Order::B];
+                calc_type da   = p[Order::A];
+                long_type drsa = dr * sa;
+                long_type dgsa = dg * sa;
+                long_type dbsa = db * sa;
+                long_type srda = sr * da;
+                long_type sgda = sg * da;
+                long_type sbda = sb * da;
+                long_type sada = sa * da;
 
-            p[Order::R] = (value_type)(((srda + drsa <= sada) ? 
-                sr * d1a + dr * s1a :
-                sa * (srda + drsa - sada) / sr + sr * d1a + dr * s1a) >> base_shift);
+                p[Order::R] = (value_type)(((srda + drsa <= sada) ? 
+                    sr * d1a + dr * s1a :
+                    sa * (srda + drsa - sada) / sr + sr * d1a + dr * s1a + base_mask) >> base_shift);
 
-            p[Order::G] = (value_type)(((sgda + dgsa <= sada) ? 
-                sg * d1a + dg * s1a :
-                sa * (sgda + dgsa - sada) / sg + sg * d1a + dg * s1a) >> base_shift);
+                p[Order::G] = (value_type)(((sgda + dgsa <= sada) ? 
+                    sg * d1a + dg * s1a :
+                    sa * (sgda + dgsa - sada) / sg + sg * d1a + dg * s1a + base_mask) >> base_shift);
 
-            p[Order::B] = (value_type)(((sbda + dbsa <= sada) ? 
-                sb * d1a + db * s1a :
-                sa * (sbda + dbsa - sada) / sb + sb * d1a + db * s1a) >> base_shift);
+                p[Order::B] = (value_type)(((sbda + dbsa <= sada) ? 
+                    sb * d1a + db * s1a :
+                    sa * (sbda + dbsa - sada) / sb + sb * d1a + db * s1a + base_mask) >> base_shift);
 
-            p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
+                p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
+            }
         }
     };
 
@@ -1062,27 +1093,30 @@
                 sb = (sb * cover + 255) >> 8;
                 sa = (sa * cover + 255) >> 8;
             }
-            calc_type d1a  = base_mask - p[Order::A];
-            calc_type s1a  = base_mask - sa;
-            calc_type dr   = p[Order::R];
-            calc_type dg   = p[Order::G];
-            calc_type db   = p[Order::B];
-            calc_type da   = p[Order::A];
-            calc_type sada = sa * da;
+            if(sa)
+            {
+                calc_type d1a  = base_mask - p[Order::A];
+                calc_type s1a  = base_mask - sa;
+                calc_type dr   = p[Order::R];
+                calc_type dg   = p[Order::G];
+                calc_type db   = p[Order::B];
+                calc_type da   = p[Order::A];
+                calc_type sada = sa * da;
 
-            p[Order::R] = (value_type)(((2*sr < sa) ? 
-                2*sr*dr + sr*d1a + dr*s1a : 
-                sada - 2*(da - dr)*(sa - sr) + sr*d1a + dr*s1a) >> base_shift);
+                p[Order::R] = (value_type)(((2*sr < sa) ? 
+                    2*sr*dr + sr*d1a + dr*s1a : 
+                    sada - 2*(da - dr)*(sa - sr) + sr*d1a + dr*s1a + base_mask) >> base_shift);
 
-            p[Order::G] = (value_type)(((2*sg < sa) ? 
-                2*sg*dg + sg*d1a + dg*s1a : 
-                sada - 2*(da - dg)*(sa - sg) + sg*d1a + dg*s1a) >> base_shift);
+                p[Order::G] = (value_type)(((2*sg < sa) ? 
+                    2*sg*dg + sg*d1a + dg*s1a : 
+                    sada - 2*(da - dg)*(sa - sg) + sg*d1a + dg*s1a + base_mask) >> base_shift);
 
-            p[Order::B] = (value_type)(((2*sb < sa) ? 
-                2*sb*db + sb*d1a + db*s1a : 
-                sada - 2*(da - db)*(sa - sb) + sb*d1a + db*s1a) >> base_shift);
+                p[Order::B] = (value_type)(((2*sb < sa) ? 
+                    2*sb*db + sb*d1a + db*s1a : 
+                    sada - 2*(da - db)*(sa - sb) + sb*d1a + db*s1a + base_mask) >> base_shift);
 
-            p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
+                p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
+            }
         }
     };
 
@@ -1117,31 +1151,34 @@
             double sg = double(g * cover) / (base_mask * 255);
             double sb = double(b * cover) / (base_mask * 255);
             double sa = double(a * cover) / (base_mask * 255);
-            double dr = double(p[Order::R]) / base_mask;
-            double dg = double(p[Order::G]) / base_mask;
-            double db = double(p[Order::B]) / base_mask;
-            double da = double(p[Order::A] ? p[Order::A] : 1) / base_mask;
-            if(cover < 255)
+            if(sa > 0)
             {
-                a = (a * cover + 255) >> 8;
-            }
+                double dr = double(p[Order::R]) / base_mask;
+                double dg = double(p[Order::G]) / base_mask;
+                double db = double(p[Order::B]) / base_mask;
+                double da = double(p[Order::A] ? p[Order::A] : 1) / base_mask;
+                if(cover < 255)
+                {
+                    a = (a * cover + 255) >> 8;
+                }
 
-            if(2*sr < sa)       dr = dr*(sa + (1 - dr/da)*(2*sr - sa)) + sr*(1 - da) + dr*(1 - sa);
-            else if(8*dr <= da) dr = dr*(sa + (1 - dr/da)*(2*sr - sa)*(3 - 8*dr/da)) + sr*(1 - da) + dr*(1 - sa);
-            else                dr = (dr*sa + (sqrt(dr/da)*da - dr)*(2*sr - sa)) + sr*(1 - da) + dr*(1 - sa);
+                if(2*sr < sa)       dr = dr*(sa + (1 - dr/da)*(2*sr - sa)) + sr*(1 - da) + dr*(1 - sa);
+                else if(8*dr <= da) dr = dr*(sa + (1 - dr/da)*(2*sr - sa)*(3 - 8*dr/da)) + sr*(1 - da) + dr*(1 - sa);
+                else                dr = (dr*sa + (sqrt(dr/da)*da - dr)*(2*sr - sa)) + sr*(1 - da) + dr*(1 - sa);
 
-            if(2*sg < sa)       dg = dg*(sa + (1 - dg/da)*(2*sg - sa)) + sg*(1 - da) + dg*(1 - sa);
-            else if(8*dg <= da) dg = dg*(sa + (1 - dg/da)*(2*sg - sa)*(3 - 8*dg/da)) + sg*(1 - da) + dg*(1 - sa);
-            else                dg = (dg*sa + (sqrt(dg/da)*da - dg)*(2*sg - sa)) + sg*(1 - da) + dg*(1 - sa);
+                if(2*sg < sa)       dg = dg*(sa + (1 - dg/da)*(2*sg - sa)) + sg*(1 - da) + dg*(1 - sa);
+                else if(8*dg <= da) dg = dg*(sa + (1 - dg/da)*(2*sg - sa)*(3 - 8*dg/da)) + sg*(1 - da) + dg*(1 - sa);
+                else                dg = (dg*sa + (sqrt(dg/da)*da - dg)*(2*sg - sa)) + sg*(1 - da) + dg*(1 - sa);
 
-            if(2*sb < sa)       db = db*(sa + (1 - db/da)*(2*sb - sa)) + sb*(1 - da) + db*(1 - sa);
-            else if(8*db <= da) db = db*(sa + (1 - db/da)*(2*sb - sa)*(3 - 8*db/da)) + sb*(1 - da) + db*(1 - sa);
-            else                db = (db*sa + (sqrt(db/da)*da - db)*(2*sb - sa)) + sb*(1 - da) + db*(1 - sa);
+                if(2*sb < sa)       db = db*(sa + (1 - db/da)*(2*sb - sa)) + sb*(1 - da) + db*(1 - sa);
+                else if(8*db <= da) db = db*(sa + (1 - db/da)*(2*sb - sa)*(3 - 8*db/da)) + sb*(1 - da) + db*(1 - sa);
+                else                db = (db*sa + (sqrt(db/da)*da - db)*(2*sb - sa)) + sb*(1 - da) + db*(1 - sa);
 
-            p[Order::R] = (value_type)uround(dr * base_mask);
-            p[Order::G] = (value_type)uround(dg * base_mask);
-            p[Order::B] = (value_type)uround(db * base_mask);
-            p[Order::A] = (value_type)(a + p[Order::A] - ((a * p[Order::A] + base_mask) >> base_shift));
+                p[Order::R] = (value_type)uround(dr * base_mask);
+                p[Order::G] = (value_type)uround(dg * base_mask);
+                p[Order::B] = (value_type)uround(db * base_mask);
+                p[Order::A] = (value_type)(a + p[Order::A] - ((a * p[Order::A] + base_mask) >> base_shift));
+            }
         }
     };
 
@@ -1156,6 +1193,7 @@
         enum base_scale_e
         { 
             base_shift = color_type::base_shift,
+            base_scale = color_type::base_scale,
             base_mask  = color_type::base_mask
         };
 
@@ -1172,14 +1210,17 @@
                 sb = (sb * cover + 255) >> 8;
                 sa = (sa * cover + 255) >> 8;
             }
-            calc_type dr = p[Order::R];
-            calc_type dg = p[Order::G];
-            calc_type db = p[Order::B];
-            calc_type da = p[Order::A];
-            p[Order::R] = (value_type)(sr + dr - ((2 * sd_min(sr*da, dr*sa)) >> base_shift));
-            p[Order::G] = (value_type)(sg + dg - ((2 * sd_min(sg*da, dg*sa)) >> base_shift));
-            p[Order::B] = (value_type)(sb + db - ((2 * sd_min(sb*da, db*sa)) >> base_shift));
-            p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
+            if(sa)
+            {
+                calc_type dr = p[Order::R];
+                calc_type dg = p[Order::G];
+                calc_type db = p[Order::B];
+                calc_type da = p[Order::A];
+                p[Order::R] = (value_type)(sr + dr - ((2 * sd_min(sr*da, dr*sa) + base_mask) >> base_shift));
+                p[Order::G] = (value_type)(sg + dg - ((2 * sd_min(sg*da, dg*sa) + base_mask) >> base_shift));
+                p[Order::B] = (value_type)(sb + db - ((2 * sd_min(sb*da, db*sa) + base_mask) >> base_shift));
+                p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
+            }
         }
     };
 
@@ -1210,16 +1251,19 @@
                 sb = (sb * cover + 255) >> 8;
                 sa = (sa * cover + 255) >> 8;
             }
-            calc_type d1a = base_mask - p[Order::A];
-            calc_type s1a = base_mask - sa;
-            calc_type dr = p[Order::R];
-            calc_type dg = p[Order::G];
-            calc_type db = p[Order::B];
-            calc_type da = p[Order::A];
-            p[Order::R] = (value_type)((sr*da + dr*sa - 2*sr*dr + sr*d1a + dr*s1a) >> base_shift);
-            p[Order::G] = (value_type)((sg*da + dg*sa - 2*sg*dg + sg*d1a + dg*s1a) >> base_shift);
-            p[Order::B] = (value_type)((sb*da + db*sa - 2*sb*db + sb*d1a + db*s1a) >> base_shift);
-            p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
+            if(sa)
+            {
+                calc_type d1a = base_mask - p[Order::A];
+                calc_type s1a = base_mask - sa;
+                calc_type dr = p[Order::R];
+                calc_type dg = p[Order::G];
+                calc_type db = p[Order::B];
+                calc_type da = p[Order::A];
+                p[Order::R] = (value_type)((sr*da + dr*sa - 2*sr*dr + sr*d1a + dr*s1a + base_mask) >> base_shift);
+                p[Order::G] = (value_type)((sg*da + dg*sa - 2*sg*dg + sg*d1a + dg*s1a + base_mask) >> base_shift);
+                p[Order::B] = (value_type)((sb*da + db*sa - 2*sb*db + sb*d1a + db*s1a + base_mask) >> base_shift);
+                p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
+            }
         }
     };
 
@@ -1270,16 +1314,88 @@
         }
     };
 
+    //=====================================================comp_op_rgba_invert
+    template<class ColorT, class Order> struct comp_op_rgba_invert
+    {
+        typedef ColorT color_type;
+        typedef Order order_type;
+        typedef typename color_type::value_type value_type;
+        typedef typename color_type::calc_type calc_type;
+        typedef typename color_type::long_type long_type;
+        enum base_scale_e
+        { 
+            base_shift = color_type::base_shift,
+            base_mask  = color_type::base_mask
+        };
 
+        // Dca' = (Da - Dca) * Sa + Dca.(1 - Sa)
+        // Da'  = Sa + Da - Sa.Da 
+        static AGG_INLINE void blend_pix(value_type* p, 
+                                         unsigned sr, unsigned sg, unsigned sb, 
+                                         unsigned sa, unsigned cover)
+        {
+            sa = (sa * cover + 255) >> 8;
+            if(sa)
+            {
+                calc_type da = p[Order::A];
+                calc_type dr = ((da - p[Order::R]) * sa + base_mask) >> base_shift;
+                calc_type dg = ((da - p[Order::G]) * sa + base_mask) >> base_shift;
+                calc_type db = ((da - p[Order::B]) * sa + base_mask) >> base_shift;
+                calc_type s1a = base_mask - sa;
+                p[Order::R] = (value_type)(dr + ((p[Order::R] * s1a + base_mask) >> base_shift));
+                p[Order::G] = (value_type)(dg + ((p[Order::G] * s1a + base_mask) >> base_shift));
+                p[Order::B] = (value_type)(db + ((p[Order::B] * s1a + base_mask) >> base_shift));
+                p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
+            }
+        }
+    };
 
+    //=================================================comp_op_rgba_invert_rgb
+    template<class ColorT, class Order> struct comp_op_rgba_invert_rgb
+    {
+        typedef ColorT color_type;
+        typedef Order order_type;
+        typedef typename color_type::value_type value_type;
+        typedef typename color_type::calc_type calc_type;
+        typedef typename color_type::long_type long_type;
+        enum base_scale_e
+        { 
+            base_shift = color_type::base_shift,
+            base_mask  = color_type::base_mask
+        };
 
+        // Dca' = (Da - Dca) * Sca + Dca.(1 - Sa)
+        // Da'  = Sa + Da - Sa.Da 
+        static AGG_INLINE void blend_pix(value_type* p, 
+                                         unsigned sr, unsigned sg, unsigned sb, 
+                                         unsigned sa, unsigned cover)
+        {
+            if(cover < 255)
+            {
+                sr = (sr * cover + 255) >> 8;
+                sg = (sg * cover + 255) >> 8;
+                sb = (sb * cover + 255) >> 8;
+                sa = (sa * cover + 255) >> 8;
+            }
+            if(sa)
+            {
+                calc_type da = p[Order::A];
+                calc_type dr = ((da - p[Order::R]) * sr + base_mask) >> base_shift;
+                calc_type dg = ((da - p[Order::G]) * sg + base_mask) >> base_shift;
+                calc_type db = ((da - p[Order::B]) * sb + base_mask) >> base_shift;
+                calc_type s1a = base_mask - sa;
+                p[Order::R] = (value_type)(dr + ((p[Order::R] * s1a + base_mask) >> base_shift));
+                p[Order::G] = (value_type)(dg + ((p[Order::G] * s1a + base_mask) >> base_shift));
+                p[Order::B] = (value_type)(db + ((p[Order::B] * s1a + base_mask) >> base_shift));
+                p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
+            }
+        }
+    };
 
 
 
 
 
-
-
     //======================================================comp_op_table_rgba
     template<class ColorT, class Order> struct comp_op_table_rgba
     {
@@ -1324,6 +1440,8 @@
         comp_op_rgba_difference <ColorT,Order>::blend_pix,
         comp_op_rgba_exclusion  <ColorT,Order>::blend_pix,
         comp_op_rgba_contrast   <ColorT,Order>::blend_pix,
+        comp_op_rgba_invert     <ColorT,Order>::blend_pix,
+        comp_op_rgba_invert_rgb <ColorT,Order>::blend_pix,
         0
     };
 
@@ -1357,6 +1475,8 @@
         comp_op_difference,    //----comp_op_difference
         comp_op_exclusion,     //----comp_op_exclusion
         comp_op_contrast,      //----comp_op_contrast
+        comp_op_invert,        //----comp_op_invert
+        comp_op_invert_rgb,    //----comp_op_invert_rgb
 
         end_of_comp_op_e
     };
@@ -1652,31 +1772,48 @@
 
         //--------------------------------------------------------------------
         pixfmt_alpha_blend_rgba() : m_rbuf(0) {}
-        pixfmt_alpha_blend_rgba(rbuf_type& rb) : m_rbuf(&rb) {}
+        explicit pixfmt_alpha_blend_rgba(rbuf_type& rb) : m_rbuf(&rb) {}
         void attach(rbuf_type& rb) { m_rbuf = &rb; }
 
         //--------------------------------------------------------------------
+        template<class PixFmt>
+        bool attach(PixFmt& pixf, int x1, int y1, int x2, int y2)
+        {
+            rect_i r(x1, y1, x2, y2);
+            if(r.clip(rect_i(0, 0, pixf.width()-1, pixf.height()-1)))
+            {
+                int stride = pixf.stride();
+                m_rbuf->attach(pixf.pix_ptr(r.x1, stride < 0 ? r.y2 : r.y1), 
+                               (r.x2 - r.x1) + 1,
+                               (r.y2 - r.y1) + 1,
+                               stride);
+                return true;
+            }
+            return false;
+        }
+
+        //--------------------------------------------------------------------
         AGG_INLINE unsigned width()  const { return m_rbuf->width();  }
         AGG_INLINE unsigned height() const { return m_rbuf->height(); }
+        AGG_INLINE int      stride() const { return m_rbuf->stride(); }
 
         //--------------------------------------------------------------------
-        const int8u* row_ptr(int y) const
-        {
-            return m_rbuf->row_ptr(y);
-        }
+        AGG_INLINE       int8u* row_ptr(int y)       { return m_rbuf->row_ptr(y); }
+        AGG_INLINE const int8u* row_ptr(int y) const { return m_rbuf->row_ptr(y); }
+        AGG_INLINE row_data     row(int y)     const { return m_rbuf->row(y); }
 
         //--------------------------------------------------------------------
-        const int8u* pix_ptr(int x, int y) const
+        AGG_INLINE int8u* pix_ptr(int x, int y)
         {
             return m_rbuf->row_ptr(y) + x * pix_width;
         }
 
-        //--------------------------------------------------------------------
-        row_data row(int y) const
+        AGG_INLINE const int8u* pix_ptr(int x, int y) const
         {
-            return m_rbuf->row(y);
+            return m_rbuf->row_ptr(y) + x * pix_width;
         }
 
+
         //--------------------------------------------------------------------
         AGG_INLINE static void make_pix(int8u* p, const color_type& c)
         {
@@ -1939,6 +2076,24 @@
 
 
         //--------------------------------------------------------------------
+        void copy_color_vspan(int x, int y,
+                              unsigned len, 
+                              const color_type* colors)
+        {
+            do 
+            {
+                value_type* p = (value_type*)m_rbuf->row_ptr(x, y++, 1) + (x << 2);
+                p[order_type::R] = colors->r;
+                p[order_type::G] = colors->g;
+                p[order_type::B] = colors->b;
+                p[order_type::A] = colors->a;
+                ++colors;
+            }
+            while(--len);
+        }
+
+
+        //--------------------------------------------------------------------
         void blend_color_hspan(int x, int y,
                                unsigned len, 
                                const color_type* colors,
@@ -2170,6 +2325,77 @@
             }
         }
 
+        //--------------------------------------------------------------------
+        template<class SrcPixelFormatRenderer>
+        void blend_from_color(const SrcPixelFormatRenderer& from, 
+                              const color_type& color,
+                              int xdst, int ydst,
+                              int xsrc, int ysrc,
+                              unsigned len,
+                              int8u cover)
+        {
+            typedef typename SrcPixelFormatRenderer::value_type src_value_type;
+            const src_value_type* psrc = (src_value_type*)from.row_ptr(ysrc);
+            if(psrc)
+            {
+                value_type* pdst = 
+                    (value_type*)m_rbuf->row_ptr(xdst, ydst, len) + (xdst << 2);
+                do 
+                {
+                    cob_type::copy_or_blend_pix(pdst, 
+                                                color.r, color.g, color.b, color.a,
+                                                (*psrc * cover + base_mask) >> base_shift);
+                    ++psrc;
+                    pdst += 4;
+                }
+                while(--len);
+            }
+        }
+
+        //--------------------------------------------------------------------
+        template<class SrcPixelFormatRenderer>
+        void blend_from_lut(const SrcPixelFormatRenderer& from, 
+                            const color_type* color_lut,
+                            int xdst, int ydst,
+                            int xsrc, int ysrc,
+                            unsigned len,
+                            int8u cover)
+        {
+            typedef typename SrcPixelFormatRenderer::value_type src_value_type;
+            const src_value_type* psrc = (src_value_type*)from.row_ptr(ysrc);
+            if(psrc)
+            {
+                value_type* pdst = 
+                    (value_type*)m_rbuf->row_ptr(xdst, ydst, len) + (xdst << 2);
+
+                if(cover == 255)
+                {
+                    do 
+                    {
+                        const color_type& color = color_lut[*psrc];
+                        cob_type::copy_or_blend_pix(pdst, 
+                                                    color.r, color.g, color.b, color.a);
+                        ++psrc;
+                        pdst += 4;
+                    }
+                    while(--len);
+                }
+                else
+                {
+                    do 
+                    {
+                        const color_type& color = color_lut[*psrc];
+                        cob_type::copy_or_blend_pix(pdst, 
+                                                    color.r, color.g, color.b, color.a,
+                                                    cover);
+                        ++psrc;
+                        pdst += 4;
+                    }
+                    while(--len);
+                }
+            }
+        }
+
     private:
         rbuf_type* m_rbuf;
     };
@@ -2199,39 +2425,55 @@
 
         //--------------------------------------------------------------------
         pixfmt_custom_blend_rgba() : m_rbuf(0), m_comp_op(3) {}
-        pixfmt_custom_blend_rgba(rbuf_type& rb, unsigned comp_op=3) : 
+        explicit pixfmt_custom_blend_rgba(rbuf_type& rb, unsigned comp_op=3) : 
             m_rbuf(&rb),
             m_comp_op(comp_op)
         {}
         void attach(rbuf_type& rb) { m_rbuf = &rb; }
 
         //--------------------------------------------------------------------
-        unsigned width()  const { return m_rbuf->width();  }
-        unsigned height() const { return m_rbuf->height(); }
+        template<class PixFmt>
+        bool attach(PixFmt& pixf, int x1, int y1, int x2, int y2)
+        {
+            rect_i r(x1, y1, x2, y2);
+            if(r.clip(rect_i(0, 0, pixf.width()-1, pixf.height()-1)))
+            {
+                int stride = pixf.stride();
+                m_rbuf->attach(pixf.pix_ptr(r.x1, stride < 0 ? r.y2 : r.y1), 
+                               (r.x2 - r.x1) + 1,
+                               (r.y2 - r.y1) + 1,
+                               stride);
+                return true;
+            }
+            return false;
+        }
 
         //--------------------------------------------------------------------
-        void comp_op(unsigned op) { m_comp_op = op; }
-        unsigned comp_op() const  { return m_comp_op; }
+        AGG_INLINE unsigned width()  const { return m_rbuf->width();  }
+        AGG_INLINE unsigned height() const { return m_rbuf->height(); }
+        AGG_INLINE int      stride() const { return m_rbuf->stride(); }
 
         //--------------------------------------------------------------------
-        const int8u* row_ptr(int y) const
-        {
-            return m_rbuf->row_ptr(y);
-        }
+        AGG_INLINE       int8u* row_ptr(int y)       { return m_rbuf->row_ptr(y); }
+        AGG_INLINE const int8u* row_ptr(int y) const { return m_rbuf->row_ptr(y); }
+        AGG_INLINE row_data     row(int y)     const { return m_rbuf->row(y); }
 
         //--------------------------------------------------------------------
-        const int8u* pix_ptr(int x, int y) const
+        AGG_INLINE int8u* pix_ptr(int x, int y)
         {
             return m_rbuf->row_ptr(y) + x * pix_width;
         }
 
-        //--------------------------------------------------------------------
-        row_data row(int x, int y) const
+        AGG_INLINE const int8u* pix_ptr(int x, int y) const
         {
-            return m_rbuf->row(y);
+            return m_rbuf->row_ptr(y) + x * pix_width;
         }
 
         //--------------------------------------------------------------------
+        void comp_op(unsigned op) { m_comp_op = op; }
+        unsigned comp_op() const  { return m_comp_op; }
+
+        //--------------------------------------------------------------------
         AGG_INLINE static void make_pix(int8u* p, const color_type& c)
         {
             ((value_type*)p)[order_type::R] = c.r;
@@ -2374,6 +2616,23 @@
         }
 
         //--------------------------------------------------------------------
+        void copy_color_vspan(int x, int y,
+                              unsigned len, 
+                              const color_type* colors)
+        {
+            do 
+            {
+                value_type* p = (value_type*)m_rbuf->row_ptr(x, y++, 1) + (x << 2);
+                p[order_type::R] = colors->r;
+                p[order_type::G] = colors->g;
+                p[order_type::B] = colors->b;
+                p[order_type::A] = colors->a;
+                ++colors;
+            }
+            while(--len);
+        }
+
+        //--------------------------------------------------------------------
         void blend_color_hspan(int x, int y, unsigned len, 
                                const color_type* colors, 
                                const int8u* covers,
@@ -2518,6 +2777,63 @@
             }
         }
 
+        //--------------------------------------------------------------------
+        template<class SrcPixelFormatRenderer>
+        void blend_from_color(const SrcPixelFormatRenderer& from, 
+                              const color_type& color,
+                              int xdst, int ydst,
+                              int xsrc, int ysrc,
+                              unsigned len,
+                              int8u cover)
+        {
+            typedef typename SrcPixelFormatRenderer::value_type src_value_type;
+            const src_value_type* psrc = (src_value_type*)from.row_ptr(ysrc);
+            if(psrc)
+            {
+                value_type* pdst = 
+                    (value_type*)m_rbuf->row_ptr(xdst, ydst, len) + (xdst << 2);
+                do 
+                {
+                    blender_type::blend_pix(m_comp_op,
+                                            pdst, 
+                                            color.r, color.g, color.b, color.a,
+                                            (*psrc * cover + base_mask) >> base_shift);
+                    ++psrc;
+                    pdst += 4;
+                }
+                while(--len);
+            }
+        }
+
+        //--------------------------------------------------------------------
+        template<class SrcPixelFormatRenderer>
+        void blend_from_lut(const SrcPixelFormatRenderer& from, 
+                            const color_type* color_lut,
+                            int xdst, int ydst,
+                            int xsrc, int ysrc,
+                            unsigned len,
+                            int8u cover)
+        {
+            typedef typename SrcPixelFormatRenderer::value_type src_value_type;
+            const src_value_type* psrc = (src_value_type*)from.row_ptr(ysrc);
+            if(psrc)
+            {
+                value_type* pdst = 
+                    (value_type*)m_rbuf->row_ptr(xdst, ydst, len) + (xdst << 2);
+                do 
+                {
+                    const color_type& color = color_lut[*psrc];
+                    blender_type::blend_pix(m_comp_op,
+                                            pdst, 
+                                            color.r, color.g, color.b, color.a,
+                                            cover);
+                    ++psrc;
+                    pdst += 4;
+                }
+                while(--len);
+            }
+        }
+
     private:
         rbuf_type* m_rbuf;
         unsigned m_comp_op;

Modified: trunk/agg/include/agg_rasterizer_cells_aa.h
===================================================================
--- trunk/agg/include/agg_rasterizer_cells_aa.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_rasterizer_cells_aa.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -103,21 +103,21 @@
         void allocate_block();
         
     private:
-        unsigned    m_num_blocks;
-        unsigned    m_max_blocks;
-        unsigned    m_curr_block;
-        unsigned    m_num_cells;
-        cell_type** m_cells;
-        cell_type*  m_curr_cell_ptr;
-        pod_vector<cell_type*> m_sorted_cells;
-        pod_vector<sorted_y>   m_sorted_y;
-        cell_type   m_curr_cell;
-        cell_type   m_style_cell;
-        int         m_min_x;
-        int         m_min_y;
-        int         m_max_x;
-        int         m_max_y;
-        bool        m_sorted;
+        unsigned                m_num_blocks;
+        unsigned                m_max_blocks;
+        unsigned                m_curr_block;
+        unsigned                m_num_cells;
+        cell_type**             m_cells;
+        cell_type*              m_curr_cell_ptr;
+        pod_vector<cell_type*>  m_sorted_cells;
+        pod_vector<sorted_y>    m_sorted_y;
+        cell_type               m_curr_cell;
+        cell_type               m_style_cell;
+        int                     m_min_x;
+        int                     m_min_y;
+        int                     m_max_x;
+        int                     m_max_y;
+        bool                    m_sorted;
     };
 
 
@@ -132,10 +132,10 @@
             cell_type** ptr = m_cells + m_num_blocks - 1;
             while(m_num_blocks--)
             {
-                delete [] *ptr;
+                pod_allocator<cell_type>::deallocate(*ptr, cell_block_size);
                 ptr--;
             }
-            delete [] m_cells;
+            pod_allocator<cell_type*>::deallocate(m_cells, m_max_blocks);
         }
     }
 
@@ -188,10 +188,6 @@
             }
             *m_curr_cell_ptr++ = m_curr_cell;
             ++m_num_cells;
-            //if(m_curr_cell.x < m_min_x) m_min_x = m_curr_cell.x;
-            //if(m_curr_cell.x > m_max_x) m_max_x = m_curr_cell.x;
-            //if(m_curr_cell.y < m_min_y) m_min_y = m_curr_cell.y;
-            //if(m_curr_cell.y > m_max_y) m_max_y = m_curr_cell.y;
         }
     }
 
@@ -474,16 +470,22 @@
         {
             if(m_num_blocks >= m_max_blocks)
             {
-                cell_type** new_cells = new cell_type* [m_max_blocks + cell_block_pool];
+                cell_type** new_cells = 
+                    pod_allocator<cell_type*>::allocate(m_max_blocks + 
+                                                        cell_block_pool);
+
                 if(m_cells)
                 {
                     memcpy(new_cells, m_cells, m_max_blocks * sizeof(cell_type*));
-                    delete [] m_cells;
+                    pod_allocator<cell_type*>::deallocate(m_cells, m_max_blocks);
                 }
                 m_cells = new_cells;
                 m_max_blocks += cell_block_pool;
             }
-            m_cells[m_num_blocks++] = new cell_type [unsigned(cell_block_size)];
+
+            m_cells[m_num_blocks++] = 
+                pod_allocator<cell_type>::allocate(cell_block_size);
+
         }
         m_curr_cell_ptr = m_cells[m_curr_block++];
     }
@@ -642,7 +644,6 @@
 //        cell = cell; // Breakpoint here
 //    }
 //}
-
         // Allocate the array of cell pointers
         m_sorted_cells.allocate(m_num_cells, 16);
 
@@ -721,6 +722,33 @@
         m_sorted = true;
     }
 
+
+
+    //------------------------------------------------------scanline_hit_test
+    class scanline_hit_test
+    {
+    public:
+        scanline_hit_test(int x) : m_x(x), m_hit(false) {}
+
+        void reset_spans() {}
+        void finalize(int) {}
+        void add_cell(int x, int)
+        {
+            if(m_x == x) m_hit = true;
+        }
+        void add_span(int x, int len, int)
+        {
+            if(m_x >= x && m_x < x+len) m_hit = true;
+        }
+        unsigned num_spans() const { return 1; }
+        bool hit() const { return m_hit; }
+
+    private:
+        int  m_x;
+        bool m_hit;
+    };
+
+
 }
 
 #endif

Modified: trunk/agg/include/agg_rasterizer_compound_aa.h
===================================================================
--- trunk/agg/include/agg_rasterizer_compound_aa.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_rasterizer_compound_aa.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -70,6 +70,15 @@
     };
 
 
+    //===========================================================layer_order_e
+    enum layer_order_e
+    {
+        layer_unsorted, //------layer_unsorted
+        layer_direct,   //------layer_direct
+        layer_inverse   //------layer_inverse
+    };
+
+
     //==================================================rasterizer_compound_aa
     template<class Clip=rasterizer_sl_clip_int> class rasterizer_compound_aa
     {
@@ -86,8 +95,9 @@
         };
 
     public:
-        typedef Clip                     clip_type;
-        typedef typename Clip::conv_type conv_type;
+        typedef Clip                      clip_type;
+        typedef typename Clip::conv_type  conv_type;
+        typedef typename Clip::coord_type coord_type;
 
         enum aa_scale_e
         {
@@ -103,13 +113,20 @@
             m_outline(),
             m_clipper(),
             m_filling_rule(fill_non_zero),
+            m_layer_order(layer_direct),
             m_styles(),  // Active Styles
             m_ast(),     // Active Style Table (unique values)
             m_asm(),     // Active Style Mask 
             m_cells(),
+            m_cover_buf(),
+            m_master_alpha(),
             m_min_style(0x7FFFFFFF),
             m_max_style(-0x7FFFFFFF),
-            m_scan_y(0x7FFFFFFF)
+            m_start_x(0),
+            m_start_y(0),
+            m_scan_y(0x7FFFFFFF),
+            m_sl_start(0),
+            m_sl_len(0)
         {}
 
         //--------------------------------------------------------------------
@@ -117,6 +134,8 @@
         void reset_clipping();
         void clip_box(double x1, double y1, double x2, double y2);
         void filling_rule(filling_rule_e filling_rule);
+        void layer_order(layer_order_e order);
+        void master_alpha(int style, double alpha);
 
         //--------------------------------------------------------------------
         void styles(int left, int right);
@@ -158,10 +177,18 @@
         void sort();
         bool rewind_scanlines();
         unsigned sweep_styles();
+        int      scanline_start()  const { return m_sl_start; }
+        unsigned scanline_length() const { return m_sl_len;   }
         unsigned style(unsigned style_idx) const;
 
+        cover_type* allocate_cover_buffer(unsigned len);
+
         //--------------------------------------------------------------------
-        AGG_INLINE unsigned calculate_alpha(int area) const
+        bool navigate_scanline(int y); 
+        bool hit_test(int tx, int ty);
+
+        //--------------------------------------------------------------------
+        AGG_INLINE unsigned calculate_alpha(int area, unsigned master_alpha) const
         {
             int cover = area >> (poly_subpixel_shift*2 + 1 - aa_shift);
             if(cover < 0) cover = -cover;
@@ -174,7 +201,7 @@
                 }
             }
             if(cover > aa_mask) cover = aa_mask;
-            return cover;
+            return (cover * master_alpha + aa_mask) >> aa_shift;
         }
 
         //--------------------------------------------------------------------
@@ -187,9 +214,18 @@
 
             sl.reset_spans();
 
-            if(style_idx < 0) style_idx = 0;
-            else              style_idx++;
+            unsigned master_alpha = aa_mask;
 
+            if(style_idx < 0) 
+            {
+                style_idx = 0;
+            }
+            else 
+            {
+                style_idx++;
+                master_alpha = m_master_alpha[m_ast[style_idx] + m_min_style - 1];
+            }
+
             const style_info& st = m_styles[m_ast[style_idx]];
 
             unsigned num_cells = st.num_cells;
@@ -208,14 +244,16 @@
 
                 if(area)
                 {
-                    alpha = calculate_alpha((cover << (poly_subpixel_shift + 1)) - area);
+                    alpha = calculate_alpha((cover << (poly_subpixel_shift + 1)) - area,
+                                            master_alpha);
                     sl.add_cell(x, alpha);
                     x++;
                 }
 
                 if(num_cells && cell->x > x)
                 {
-                    alpha = calculate_alpha(cover << (poly_subpixel_shift + 1));
+                    alpha = calculate_alpha(cover << (poly_subpixel_shift + 1),
+                                            master_alpha);
                     if(alpha)
                     {
                         sl.add_span(x, cell->x - x, alpha);
@@ -226,11 +264,11 @@
             if(sl.num_spans() == 0) return false;
             sl.finalize(scan_y);
             return true;
-
         }
 
     private:
         void add_style(int style_id);
+        void allocate_master_alpha();
 
         //--------------------------------------------------------------------
         // Disable copying
@@ -242,14 +280,21 @@
         rasterizer_cells_aa<cell_style_aa> m_outline;
         clip_type              m_clipper;
         filling_rule_e         m_filling_rule;
+        layer_order_e          m_layer_order;
         pod_vector<style_info> m_styles;  // Active Styles
         pod_vector<unsigned>   m_ast;     // Active Style Table (unique values)
         pod_vector<int8u>      m_asm;     // Active Style Mask 
         pod_vector<cell_info>  m_cells;
+        pod_vector<cover_type> m_cover_buf;
+        pod_bvector<unsigned>  m_master_alpha;
 
-        int      m_min_style;
-        int      m_max_style;
-        int      m_scan_y;
+        int        m_min_style;
+        int        m_max_style;
+        coord_type m_start_x;
+        coord_type m_start_y;
+        int        m_scan_y;
+        int        m_sl_start;
+        unsigned   m_sl_len;
     };
 
 
@@ -269,6 +314,8 @@
         m_min_style =  0x7FFFFFFF;
         m_max_style = -0x7FFFFFFF;
         m_scan_y    =  0x7FFFFFFF;
+        m_sl_start  =  0;
+        m_sl_len    = 0;
     }
 
     //------------------------------------------------------------------------
@@ -280,6 +327,13 @@
 
     //------------------------------------------------------------------------
     template<class Clip> 
+    void rasterizer_compound_aa<Clip>::layer_order(layer_order_e order)
+    {
+        m_layer_order = order;
+    }
+
+    //------------------------------------------------------------------------
+    template<class Clip> 
     void rasterizer_compound_aa<Clip>::clip_box(double x1, double y1, 
                                                 double x2, double y2)
     {
@@ -316,7 +370,8 @@
     void rasterizer_compound_aa<Clip>::move_to(int x, int y)
     {
         if(m_outline.sorted()) reset();
-        m_clipper.move_to(conv_type::downscale(x), conv_type::downscale(y));
+        m_clipper.move_to(m_start_x = conv_type::downscale(x), 
+                          m_start_y = conv_type::downscale(y));
     }
 
     //------------------------------------------------------------------------
@@ -333,7 +388,8 @@
     void rasterizer_compound_aa<Clip>::move_to_d(double x, double y) 
     { 
         if(m_outline.sorted()) reset();
-        m_clipper.move_to(conv_type::upscale(x), conv_type::upscale(y)); 
+        m_clipper.move_to(m_start_x = conv_type::upscale(x), 
+                          m_start_y = conv_type::upscale(y)); 
     }
 
     //------------------------------------------------------------------------
@@ -354,12 +410,15 @@
             move_to_d(x, y);
         }
         else 
+        if(is_vertex(cmd))
         {
-            if(is_vertex(cmd))
-            {
-                line_to_d(x, y);
-            }
+            line_to_d(x, y);
         }
+        else
+        if(is_close(cmd))
+        {
+            m_clipper.line_to(m_outline, m_start_x, m_start_y);
+        }
     }
 
     //------------------------------------------------------------------------
@@ -407,6 +466,7 @@
         }
         m_scan_y = m_outline.min_y();
         m_styles.allocate(m_max_style - m_min_style + 2, 128);
+        allocate_master_alpha();
         return true;
     }
 
@@ -453,83 +513,96 @@
             m_asm.allocate((num_styles + 7) >> 3, 8);
             m_asm.zero();
 
-            // Pre-add zero (for no-fill style, that is, -1).
-            // We need that to ensure that the "-1 style" would go first.
-            m_asm[0] |= 1; 
-            m_ast.add(0);
-            style = &m_styles[0];
-            style->start_cell = 0;
-            style->num_cells = 0;
-            style->last_x = -0x7FFFFFFF;
-
-            while(num_cells--)
+            if(num_cells)
             {
-                curr_cell = *cells++;
-                add_style(curr_cell->left);
-                add_style(curr_cell->right);
-            }
+                // Pre-add zero (for no-fill style, that is, -1).
+                // We need that to ensure that the "-1 style" would go first.
+                m_asm[0] |= 1; 
+                m_ast.add(0);
+                style = &m_styles[0];
+                style->start_cell = 0;
+                style->num_cells = 0;
+                style->last_x = -0x7FFFFFFF;
 
-            // Convert the Y-histogram into the array of starting indexes
-            unsigned i;
-            unsigned start_cell = 0;
-            for(i = 0; i < m_ast.size(); i++)
-            {
-                style_info& st = m_styles[m_ast[i]];
-                unsigned v = st.start_cell;
-                st.start_cell = start_cell;
-                start_cell += v;
-            }
-
-            cells = m_outline.scanline_cells(m_scan_y);
-            num_cells = m_outline.scanline_num_cells(m_scan_y);
-
-            while(num_cells--)
-            {
-                curr_cell = *cells++;
-                style_id = (curr_cell->left < 0) ? 0 : 
-                            curr_cell->left - m_min_style + 1;
-
-                style = &m_styles[style_id];
-                if(curr_cell->x == style->last_x)
+                m_sl_start = cells[0]->x;
+                m_sl_len   = cells[num_cells-1]->x - m_sl_start + 1;
+                while(num_cells--)
                 {
-                    cell = &m_cells[style->start_cell + style->num_cells - 1];
-                    cell->area  += curr_cell->area;
-                    cell->cover += curr_cell->cover;
+                    curr_cell = *cells++;
+                    add_style(curr_cell->left);
+                    add_style(curr_cell->right);
                 }
-                else
+
+                // Convert the Y-histogram into the array of starting indexes
+                unsigned i;
+                unsigned start_cell = 0;
+                for(i = 0; i < m_ast.size(); i++)
                 {
-                    cell = &m_cells[style->start_cell + style->num_cells];
-                    cell->x       = curr_cell->x;
-                    cell->area    = curr_cell->area;
-                    cell->cover   = curr_cell->cover;
-                    style->last_x = curr_cell->x;
-                    style->num_cells++;
+                    style_info& st = m_styles[m_ast[i]];
+                    unsigned v = st.start_cell;
+                    st.start_cell = start_cell;
+                    start_cell += v;
                 }
 
-                style_id = (curr_cell->right < 0) ? 0 : 
-                            curr_cell->right - m_min_style + 1;
+                cells = m_outline.scanline_cells(m_scan_y);
+                num_cells = m_outline.scanline_num_cells(m_scan_y);
 
-                style = &m_styles[style_id];
-                if(curr_cell->x == style->last_x)
+                while(num_cells--)
                 {
-                    cell = &m_cells[style->start_cell + style->num_cells - 1];
-                    cell->area  -= curr_cell->area;
-                    cell->cover -= curr_cell->cover;
+                    curr_cell = *cells++;
+                    style_id = (curr_cell->left < 0) ? 0 : 
+                                curr_cell->left - m_min_style + 1;
+
+                    style = &m_styles[style_id];
+                    if(curr_cell->x == style->last_x)
+                    {
+                        cell = &m_cells[style->start_cell + style->num_cells - 1];
+                        cell->area  += curr_cell->area;
+                        cell->cover += curr_cell->cover;
+                    }
+                    else
+                    {
+                        cell = &m_cells[style->start_cell + style->num_cells];
+                        cell->x       = curr_cell->x;
+                        cell->area    = curr_cell->area;
+                        cell->cover   = curr_cell->cover;
+                        style->last_x = curr_cell->x;
+                        style->num_cells++;
+                    }
+
+                    style_id = (curr_cell->right < 0) ? 0 : 
+                                curr_cell->right - m_min_style + 1;
+
+                    style = &m_styles[style_id];
+                    if(curr_cell->x == style->last_x)
+                    {
+                        cell = &m_cells[style->start_cell + style->num_cells - 1];
+                        cell->area  -= curr_cell->area;
+                        cell->cover -= curr_cell->cover;
+                    }
+                    else
+                    {
+                        cell = &m_cells[style->start_cell + style->num_cells];
+                        cell->x       =  curr_cell->x;
+                        cell->area    = -curr_cell->area;
+                        cell->cover   = -curr_cell->cover;
+                        style->last_x =  curr_cell->x;
+                        style->num_cells++;
+                    }
                 }
-                else
-                {
-                    cell = &m_cells[style->start_cell + style->num_cells];
-                    cell->x       =  curr_cell->x;
-                    cell->area    = -curr_cell->area;
-                    cell->cover   = -curr_cell->cover;
-                    style->last_x =  curr_cell->x;
-                    style->num_cells++;
-                }
             }
             if(m_ast.size() > 1) break;
             ++m_scan_y;
         }
         ++m_scan_y;
+
+        if(m_layer_order != layer_unsorted)
+        {
+            range_adaptor<pod_vector<unsigned> > ra(m_ast, 1, m_ast.size() - 1);
+            if(m_layer_order == layer_direct) quick_sort(ra, unsigned_greater);
+            else                              quick_sort(ra, unsigned_less);
+        }
+
         return m_ast.size() - 1;
     }
 
@@ -542,7 +615,81 @@
         return m_ast[style_idx + 1] + m_min_style - 1;
     }
 
+    //------------------------------------------------------------------------ 
+    template<class Clip> 
+    AGG_INLINE bool rasterizer_compound_aa<Clip>::navigate_scanline(int y)
+    {
+        m_outline.sort_cells();
+        if(m_outline.total_cells() == 0) 
+        {
+            return false;
+        }
+        if(m_max_style < m_min_style)
+        {
+            return false;
+        }
+        if(y < m_outline.min_y() || y > m_outline.max_y()) 
+        {
+            return false;
+        }
+        m_scan_y = y;
+        m_styles.allocate(m_max_style - m_min_style + 2, 128);
+        allocate_master_alpha();
+        return true;
+    }
+    
+    //------------------------------------------------------------------------ 
+    template<class Clip> 
+    bool rasterizer_compound_aa<Clip>::hit_test(int tx, int ty)
+    {
+        if(!navigate_scanline(ty)) 
+        {
+            return false;
+        }
 
+        unsigned num_styles = sweep_styles(); 
+        if(num_styles <= 0)
+        {
+            return false;
+        }
+
+        scanline_hit_test sl(tx);
+        sweep_scanline(sl, -1);
+        return sl.hit();
+    }
+
+    //------------------------------------------------------------------------ 
+    template<class Clip> 
+    cover_type* rasterizer_compound_aa<Clip>::allocate_cover_buffer(unsigned len)
+    {
+        m_cover_buf.allocate(len, 256);
+        return &m_cover_buf[0];
+    }
+
+    //------------------------------------------------------------------------ 
+    template<class Clip> 
+    void rasterizer_compound_aa<Clip>::allocate_master_alpha()
+    {
+        while((int)m_master_alpha.size() <= m_max_style)
+        {
+            m_master_alpha.add(aa_mask);
+        }
+    }
+
+    //------------------------------------------------------------------------ 
+    template<class Clip> 
+    void rasterizer_compound_aa<Clip>::master_alpha(int style, double alpha)
+    {
+        if(style >= 0)
+        {
+            while((int)m_master_alpha.size() <= style)
+            {
+                m_master_alpha.add(aa_mask);
+            }
+            m_master_alpha[style] = uround(alpha * aa_mask);
+        }
+    }
+
 }
 
 

Modified: trunk/agg/include/agg_rasterizer_outline.h
===================================================================
--- trunk/agg/include/agg_rasterizer_outline.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_rasterizer_outline.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -23,14 +23,15 @@
     template<class Renderer> class rasterizer_outline
     {
     public:
-        rasterizer_outline(Renderer& ren) : 
+        explicit rasterizer_outline(Renderer& ren) : 
             m_ren(&ren), 
             m_start_x(0), 
             m_start_y(0), 
             m_vertices(0)
-        {
-        }
+        {}
+        void attach(Renderer& ren) { m_ren = &ren; }
 
+
         //--------------------------------------------------------------------
         void move_to(int x, int y)
         {

Modified: trunk/agg/include/agg_rasterizer_outline_aa.h
===================================================================
--- trunk/agg/include/agg_rasterizer_outline_aa.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_rasterizer_outline_aa.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -85,21 +85,21 @@
         typedef line_aa_vertex                  vertex_type;
         typedef vertex_sequence<vertex_type, 6> vertex_storage_type;
 
-        rasterizer_outline_aa(Renderer& ren) : 
-            m_ren(ren), 
+        explicit rasterizer_outline_aa(Renderer& ren) : 
+            m_ren(&ren), 
             m_line_join(ren.accurate_join_only() ? 
                             outline_miter_accurate_join : 
                             outline_round_join),
             m_round_cap(false),
             m_start_x(0),
             m_start_y(0)
-        {
-        }
+        {}
+        void attach(Renderer& ren) { m_ren = &ren; }
 
         //------------------------------------------------------------------------
         void line_join(outline_aa_join_e join) 
         { 
-            m_line_join = m_ren.accurate_join_only() ? 
+            m_line_join = m_ren->accurate_join_only() ? 
                 outline_miter_accurate_join : 
                 join; 
         }
@@ -187,7 +187,7 @@
         {
             for(unsigned i = 0; i < num_paths; i++)
             {
-                m_ren.color(colors[i]);
+                m_ren->color(colors[i]);
                 add_path(vs, path_id[i]);
             }
         }
@@ -199,7 +199,7 @@
             unsigned i;
             for(i = 0; i < c.num_paths(); i++)
             {
-                m_ren.color(c.color(i));
+                m_ren->color(c.color(i));
                 add_path(c, i);
             }
         }
@@ -209,7 +209,7 @@
         const rasterizer_outline_aa<Renderer, Coord>& operator = 
             (const rasterizer_outline_aa<Renderer, Coord>&);
 
-        Renderer&           m_ren;
+        Renderer*           m_ren;
         vertex_storage_type m_src_vertices;
         outline_aa_join_e   m_line_join;
         bool                m_round_cap;
@@ -245,19 +245,19 @@
 
             switch(dv.flags)
             {
-            case 0: m_ren.line3(dv.curr, dv.xb1, dv.yb1, dv.xb2, dv.yb2); break;
-            case 1: m_ren.line2(dv.curr, dv.xb2, dv.yb2); break;
-            case 2: m_ren.line1(dv.curr, dv.xb1, dv.yb1); break;
-            case 3: m_ren.line0(dv.curr); break;
+            case 0: m_ren->line3(dv.curr, dv.xb1, dv.yb1, dv.xb2, dv.yb2); break;
+            case 1: m_ren->line2(dv.curr, dv.xb2, dv.yb2); break;
+            case 2: m_ren->line1(dv.curr, dv.xb1, dv.yb1); break;
+            case 3: m_ren->line0(dv.curr); break;
             }
 
             if(m_line_join == outline_round_join && (dv.flags & 2) == 0)
             {
-                m_ren.pie(dv.curr.x2, dv.curr.y2, 
-                          dv.curr.x2 + (dv.curr.y2 - dv.curr.y1),
-                          dv.curr.y2 - (dv.curr.x2 - dv.curr.x1),
-                          dv.curr.x2 + (dv.next.y2 - dv.next.y1),
-                          dv.curr.y2 - (dv.next.x2 - dv.next.x1));
+                m_ren->pie(dv.curr.x2, dv.curr.y2, 
+                           dv.curr.x2 + (dv.curr.y2 - dv.curr.y1),
+                           dv.curr.y2 - (dv.curr.x2 - dv.curr.x1),
+                           dv.curr.x2 + (dv.next.y2 - dv.next.y1),
+                           dv.curr.y2 - (dv.next.x2 - dv.next.x1));
             }
 
             dv.x1 = dv.x2;
@@ -406,16 +406,16 @@
                     line_parameters lp(x1, y1, x2, y2, lprev);
                     if(m_round_cap) 
                     {
-                        m_ren.semidot(cmp_dist_start, x1, y1, x1 + (y2 - y1), y1 - (x2 - x1));
+                        m_ren->semidot(cmp_dist_start, x1, y1, x1 + (y2 - y1), y1 - (x2 - x1));
                     }
-                    m_ren.line3(lp, 
-                                x1 + (y2 - y1), 
-                                y1 - (x2 - x1),
-                                x2 + (y2 - y1), 
-                                y2 - (x2 - x1));
+                    m_ren->line3(lp, 
+                                 x1 + (y2 - y1), 
+                                 y1 - (x2 - x1),
+                                 x2 + (y2 - y1), 
+                                 y2 - (x2 - x1));
                     if(m_round_cap) 
                     {
-                        m_ren.semidot(cmp_dist_end, x2, y2, x2 + (y2 - y1), y2 - (x2 - x1));
+                        m_ren->semidot(cmp_dist_end, x2, y2, x2 + (y2 - y1), y2 - (x2 - x1));
                     }
                 }
                 break;
@@ -440,32 +440,32 @@
 
                     if(m_round_cap) 
                     {
-                        m_ren.semidot(cmp_dist_start, x1, y1, x1 + (y2 - y1), y1 - (x2 - x1));
+                        m_ren->semidot(cmp_dist_start, x1, y1, x1 + (y2 - y1), y1 - (x2 - x1));
                     }
 
                     if(m_line_join == outline_round_join)
                     {
-                        m_ren.line3(lp1, x1 + (y2 - y1), y1 - (x2 - x1), 
-                                         x2 + (y2 - y1), y2 - (x2 - x1));
+                        m_ren->line3(lp1, x1 + (y2 - y1), y1 - (x2 - x1), 
+                                          x2 + (y2 - y1), y2 - (x2 - x1));
 
-                        m_ren.pie(x2, y2, x2 + (y2 - y1), y2 - (x2 - x1),
-                                          x2 + (y3 - y2), y2 - (x3 - x2));
+                        m_ren->pie(x2, y2, x2 + (y2 - y1), y2 - (x2 - x1),
+                                           x2 + (y3 - y2), y2 - (x3 - x2));
 
-                        m_ren.line3(lp2, x2 + (y3 - y2), y2 - (x3 - x2),
-                                         x3 + (y3 - y2), y3 - (x3 - x2));
+                        m_ren->line3(lp2, x2 + (y3 - y2), y2 - (x3 - x2),
+                                          x3 + (y3 - y2), y3 - (x3 - x2));
                     }
                     else
                     {
                         bisectrix(lp1, lp2, &dv.xb1, &dv.yb1);
-                        m_ren.line3(lp1, x1 + (y2 - y1), y1 - (x2 - x1),
-                                         dv.xb1,         dv.yb1);
+                        m_ren->line3(lp1, x1 + (y2 - y1), y1 - (x2 - x1),
+                                          dv.xb1,         dv.yb1);
 
-                        m_ren.line3(lp2, dv.xb1,         dv.yb1,
-                                         x3 + (y3 - y2), y3 - (x3 - x2));
+                        m_ren->line3(lp2, dv.xb1,         dv.yb1,
+                                          x3 + (y3 - y2), y3 - (x3 - x2));
                     }
                     if(m_round_cap) 
                     {
-                        m_ren.semidot(cmp_dist_end, x3, y3, x3 + (y3 - y2), y3 - (x3 - x2));
+                        m_ren->semidot(cmp_dist_end, x3, y3, x3 + (y3 - y2), y3 - (x3 - x2));
                     }
                 }
                 break;
@@ -521,31 +521,31 @@
 
                     if(m_round_cap) 
                     {
-                        m_ren.semidot(cmp_dist_start, x1, y1, x1 + (y2 - y1), y1 - (x2 - x1));
+                        m_ren->semidot(cmp_dist_start, x1, y1, x1 + (y2 - y1), y1 - (x2 - x1));
                     }
                     if((dv.flags & 1) == 0)
                     {
                         if(m_line_join == outline_round_join)
                         {
-                            m_ren.line3(prev, x1 + (y2 - y1), y1 - (x2 - x1),
-                                              x2 + (y2 - y1), y2 - (x2 - x1));
-                            m_ren.pie(prev.x2, prev.y2, 
-                                      x2 + (y2 - y1), y2 - (x2 - x1),
-                                      dv.curr.x1 + (dv.curr.y2 - dv.curr.y1), 
-                                      dv.curr.y1 - (dv.curr.x2 - dv.curr.x1));
+                            m_ren->line3(prev, x1 + (y2 - y1), y1 - (x2 - x1),
+                                               x2 + (y2 - y1), y2 - (x2 - x1));
+                            m_ren->pie(prev.x2, prev.y2, 
+                                       x2 + (y2 - y1), y2 - (x2 - x1),
+                                       dv.curr.x1 + (dv.curr.y2 - dv.curr.y1), 
+                                       dv.curr.y1 - (dv.curr.x2 - dv.curr.x1));
                         }
                         else
                         {
                             bisectrix(prev, dv.curr, &dv.xb1, &dv.yb1);
-                            m_ren.line3(prev, x1 + (y2 - y1), y1 - (x2 - x1),
-                                              dv.xb1,         dv.yb1);
+                            m_ren->line3(prev, x1 + (y2 - y1), y1 - (x2 - x1),
+                                               dv.xb1,         dv.yb1);
                         }
                     }
                     else
                     {
-                        m_ren.line1(prev, 
-                                    x1 + (y2 - y1), 
-                                    y1 - (x2 - x1));
+                        m_ren->line1(prev, 
+                                     x1 + (y2 - y1), 
+                                     y1 - (x2 - x1));
                     }
                     if((dv.flags & 2) == 0 && m_line_join != outline_round_join)
                     {
@@ -558,30 +558,30 @@
                     {
                         if(m_line_join == outline_round_join)
                         {
-                            m_ren.line3(dv.curr, 
-                                        dv.curr.x1 + (dv.curr.y2 - dv.curr.y1), 
-                                        dv.curr.y1 - (dv.curr.x2 - dv.curr.x1),
-                                        dv.curr.x2 + (dv.curr.y2 - dv.curr.y1), 
-                                        dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));
+                            m_ren->line3(dv.curr, 
+                                         dv.curr.x1 + (dv.curr.y2 - dv.curr.y1), 
+                                         dv.curr.y1 - (dv.curr.x2 - dv.curr.x1),
+                                         dv.curr.x2 + (dv.curr.y2 - dv.curr.y1), 
+                                         dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));
                         }
                         else
                         {
-                            m_ren.line3(dv.curr, dv.xb1, dv.yb1,
-                                        dv.curr.x2 + (dv.curr.y2 - dv.curr.y1), 
-                                        dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));
+                            m_ren->line3(dv.curr, dv.xb1, dv.yb1,
+                                         dv.curr.x2 + (dv.curr.y2 - dv.curr.y1), 
+                                         dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));
                         }
                     }
                     else
                     {
-                        m_ren.line2(dv.curr, 
-                                    dv.curr.x2 + (dv.curr.y2 - dv.curr.y1), 
-                                    dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));
+                        m_ren->line2(dv.curr, 
+                                     dv.curr.x2 + (dv.curr.y2 - dv.curr.y1), 
+                                     dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));
                     }
                     if(m_round_cap) 
                     {
-                        m_ren.semidot(cmp_dist_end, dv.curr.x2, dv.curr.y2,
-                                      dv.curr.x2 + (dv.curr.y2 - dv.curr.y1),
-                                      dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));
+                        m_ren->semidot(cmp_dist_end, dv.curr.x2, dv.curr.y2,
+                                       dv.curr.x2 + (dv.curr.y2 - dv.curr.y1),
+                                       dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));
                     }
 
                 }

Modified: trunk/agg/include/agg_rasterizer_scanline_aa.h
===================================================================
--- trunk/agg/include/agg_rasterizer_scanline_aa.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_rasterizer_scanline_aa.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -357,7 +357,7 @@
     template<class Clip> 
     void rasterizer_scanline_aa<Clip>::close_polygon()
     {
-        if(m_auto_close && m_status == status_line_to)
+        if(m_status == status_line_to)
         {
             m_clipper.line_to(m_outline, m_start_x, m_start_y);
             m_status = status_closed;
@@ -369,7 +369,7 @@
     void rasterizer_scanline_aa<Clip>::move_to(int x, int y)
     {
         if(m_outline.sorted()) reset();
-        if(m_status == status_line_to) close_polygon();
+        if(m_auto_close) close_polygon();
         m_clipper.move_to(m_start_x = conv_type::downscale(x), 
                           m_start_y = conv_type::downscale(y));
         m_status = status_move_to;
@@ -390,7 +390,7 @@
     void rasterizer_scanline_aa<Clip>::move_to_d(double x, double y) 
     { 
         if(m_outline.sorted()) reset();
-        if(m_status == status_line_to) close_polygon();
+        if(m_auto_close) close_polygon();
         m_clipper.move_to(m_start_x = conv_type::upscale(x), 
                           m_start_y = conv_type::upscale(y)); 
         m_status = status_move_to;
@@ -415,12 +415,15 @@
             move_to_d(x, y);
         }
         else 
+        if(is_vertex(cmd))
         {
-            if(is_vertex(cmd))
-            {
-                line_to_d(x, y);
-            }
+            line_to_d(x, y);
         }
+        else
+        if(is_close(cmd))
+        {
+            close_polygon();
+        }
     }
 
     //------------------------------------------------------------------------
@@ -452,6 +455,7 @@
     template<class Clip> 
     void rasterizer_scanline_aa<Clip>::sort()
     {
+        if(m_auto_close) close_polygon();
         m_outline.sort_cells();
     }
 
@@ -459,7 +463,7 @@
     template<class Clip> 
     AGG_INLINE bool rasterizer_scanline_aa<Clip>::rewind_scanlines()
     {
-        close_polygon();
+        if(m_auto_close) close_polygon();
         m_outline.sort_cells();
         if(m_outline.total_cells() == 0) 
         {
@@ -474,7 +478,7 @@
     template<class Clip> 
     AGG_INLINE bool rasterizer_scanline_aa<Clip>::navigate_scanline(int y)
     {
-        close_polygon();
+        if(m_auto_close) close_polygon();
         m_outline.sort_cells();
         if(m_outline.total_cells() == 0 || 
            y < m_outline.min_y() || 
@@ -486,31 +490,6 @@
         return true;
     }
 
-    //------------------------------------------------------scanline_hit_test
-    class scanline_hit_test
-    {
-    public:
-        scanline_hit_test(int x) : m_x(x), m_hit(false) {}
-
-        void reset_spans() {}
-        void finalize(int) {}
-        void add_cell(int x, int)
-        {
-            if(m_x == x) m_hit = true;
-        }
-        void add_span(int x, int len, int)
-        {
-            if(m_x >= x && m_x < x+len) m_hit = true;
-        }
-        unsigned num_spans() const { return 1; }
-        bool hit() const { return m_hit; }
-
-    private:
-        int  m_x;
-        bool m_hit;
-    };
-
-
     //------------------------------------------------------------------------
     template<class Clip> 
     bool rasterizer_scanline_aa<Clip>::hit_test(int tx, int ty)

Modified: trunk/agg/include/agg_renderer_base.h
===================================================================
--- trunk/agg/include/agg_renderer_base.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_renderer_base.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -36,7 +36,7 @@
 
         //--------------------------------------------------------------------
         renderer_base() : m_ren(0), m_clip_box(1, 1, 0, 0) {}
-        renderer_base(pixfmt_type& ren) :
+        explicit renderer_base(pixfmt_type& ren) :
             m_ren(&ren),
             m_clip_box(0, 0, ren.width() - 1, ren.height() - 1)
         {}
@@ -327,7 +327,31 @@
             m_ren->copy_color_hspan(x, y, len, colors);
         }
 
+
         //--------------------------------------------------------------------
+        void copy_color_vspan(int x, int y, int len, const color_type* colors)
+        {
+            if(x > xmax()) return;
+            if(x < xmin()) return;
+
+            if(y < ymin())
+            {
+                int d = ymin() - y;
+                len -= d;
+                if(len <= 0) return;
+                colors += d;
+                y = ymin();
+            }
+            if(y + len > ymax())
+            {
+                len = ymax() - y + 1;
+                if(len <= 0) return;
+            }
+            m_ren->copy_color_vspan(x, y, len, colors);
+        }
+
+
+        //--------------------------------------------------------------------
         void blend_color_hspan(int x, int y, int len, 
                                const color_type* colors, 
                                const cover_type* covers,
@@ -539,6 +563,150 @@
             }
         }
 
+        //--------------------------------------------------------------------
+        template<class SrcPixelFormatRenderer>
+        void blend_from_color(const SrcPixelFormatRenderer& src, 
+                              const color_type& color,
+                              const rect_i* rect_src_ptr = 0, 
+                              int dx = 0, 
+                              int dy = 0,
+                              cover_type cover = agg::cover_full)
+        {
+            rect_i rsrc(0, 0, src.width(), src.height());
+            if(rect_src_ptr)
+            {
+                rsrc.x1 = rect_src_ptr->x1; 
+                rsrc.y1 = rect_src_ptr->y1;
+                rsrc.x2 = rect_src_ptr->x2 + 1;
+                rsrc.y2 = rect_src_ptr->y2 + 1;
+            }
+
+            // Version with xdst, ydst (absolute positioning)
+            //rect_i rdst(xdst, ydst, xdst + rsrc.x2 - rsrc.x1, ydst + rsrc.y2 - rsrc.y1);
+
+            // Version with dx, dy (relative positioning)
+            rect_i rdst(rsrc.x1 + dx, rsrc.y1 + dy, rsrc.x2 + dx, rsrc.y2 + dy);
+            rect_i rc = clip_rect_area(rdst, rsrc, src.width(), src.height());
+
+            if(rc.x2 > 0)
+            {
+                int incy = 1;
+                if(rdst.y1 > rsrc.y1)
+                {
+                    rsrc.y1 += rc.y2 - 1;
+                    rdst.y1 += rc.y2 - 1;
+                    incy = -1;
+                }
+                while(rc.y2 > 0)
+                {
+                    typename SrcPixelFormatRenderer::row_data rw = src.row(rsrc.y1);
+                    if(rw.ptr)
+                    {
+                        int x1src = rsrc.x1;
+                        int x1dst = rdst.x1;
+                        int len   = rc.x2;
+                        if(rw.x1 > x1src)
+                        {
+                            x1dst += rw.x1 - x1src;
+                            len   -= rw.x1 - x1src;
+                            x1src  = rw.x1;
+                        }
+                        if(len > 0)
+                        {
+                            if(x1src + len-1 > rw.x2)
+                            {
+                                len -= x1src + len - rw.x2 - 1;
+                            }
+                            if(len > 0)
+                            {
+                                m_ren->blend_from_color(src,
+                                                        color,
+                                                        x1dst, rdst.y1,
+                                                        x1src, rsrc.y1,
+                                                        len,
+                                                        cover);
+                            }
+                        }
+                    }
+                    rdst.y1 += incy;
+                    rsrc.y1 += incy;
+                    --rc.y2;
+                }
+            }
+        }
+
+        //--------------------------------------------------------------------
+        template<class SrcPixelFormatRenderer>
+        void blend_from_lut(const SrcPixelFormatRenderer& src, 
+                            const color_type* color_lut,
+                            const rect_i* rect_src_ptr = 0, 
+                            int dx = 0, 
+                            int dy = 0,
+                            cover_type cover = agg::cover_full)
+        {
+            rect_i rsrc(0, 0, src.width(), src.height());
+            if(rect_src_ptr)
+            {
+                rsrc.x1 = rect_src_ptr->x1; 
+                rsrc.y1 = rect_src_ptr->y1;
+                rsrc.x2 = rect_src_ptr->x2 + 1;
+                rsrc.y2 = rect_src_ptr->y2 + 1;
+            }
+
+            // Version with xdst, ydst (absolute positioning)
+            //rect_i rdst(xdst, ydst, xdst + rsrc.x2 - rsrc.x1, ydst + rsrc.y2 - rsrc.y1);
+
+            // Version with dx, dy (relative positioning)
+            rect_i rdst(rsrc.x1 + dx, rsrc.y1 + dy, rsrc.x2 + dx, rsrc.y2 + dy);
+            rect_i rc = clip_rect_area(rdst, rsrc, src.width(), src.height());
+
+            if(rc.x2 > 0)
+            {
+                int incy = 1;
+                if(rdst.y1 > rsrc.y1)
+                {
+                    rsrc.y1 += rc.y2 - 1;
+                    rdst.y1 += rc.y2 - 1;
+                    incy = -1;
+                }
+                while(rc.y2 > 0)
+                {
+                    typename SrcPixelFormatRenderer::row_data rw = src.row(rsrc.y1);
+                    if(rw.ptr)
+                    {
+                        int x1src = rsrc.x1;
+                        int x1dst = rdst.x1;
+                        int len   = rc.x2;
+                        if(rw.x1 > x1src)
+                        {
+                            x1dst += rw.x1 - x1src;
+                            len   -= rw.x1 - x1src;
+                            x1src  = rw.x1;
+                        }
+                        if(len > 0)
+                        {
+                            if(x1src + len-1 > rw.x2)
+                            {
+                                len -= x1src + len - rw.x2 - 1;
+                            }
+                            if(len > 0)
+                            {
+                                m_ren->blend_from_lut(src,
+                                                      color_lut,
+                                                      x1dst, rdst.y1,
+                                                      x1src, rsrc.y1,
+                                                      len,
+                                                      cover);
+                            }
+                        }
+                    }
+                    rdst.y1 += incy;
+                    rsrc.y1 += incy;
+                    --rc.y2;
+                }
+            }
+        }
+
     private:
         pixfmt_type* m_ren;
         rect_i       m_clip_box;

Modified: trunk/agg/include/agg_renderer_markers.h
===================================================================
--- trunk/agg/include/agg_renderer_markers.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_renderer_markers.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -65,8 +65,7 @@
         //--------------------------------------------------------------------
         renderer_markers(base_ren_type& rbuf) :
             base_type(rbuf)
-        {
-        }
+        {}
 
         //--------------------------------------------------------------------
         bool visible(int x, int y, int r) const

Modified: trunk/agg/include/agg_renderer_mclip.h
===================================================================
--- trunk/agg/include/agg_renderer_mclip.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_renderer_mclip.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -37,11 +37,15 @@
         typedef renderer_base<pixfmt_type> base_ren_type;
 
         //--------------------------------------------------------------------
-        renderer_mclip(pixfmt_type& ren) :
-            m_ren(ren),
+        explicit renderer_mclip(pixfmt_type& pixf) :
+            m_ren(pixf),
             m_curr_cb(0),
             m_bounds(m_ren.xmin(), m_ren.ymin(), m_ren.xmax(), m_ren.ymax())
+        {}
+        void attach(pixfmt_type& pixf)
         {
+            m_ren.attach(pixf);
+            reset_clipping(true);
         }
           
         //--------------------------------------------------------------------

Modified: trunk/agg/include/agg_renderer_outline_aa.h
===================================================================
--- trunk/agg/include/agg_renderer_outline_aa.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_renderer_outline_aa.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -15,7 +15,7 @@
 #ifndef AGG_RENDERER_OUTLINE_AA_INCLUDED
 #define AGG_RENDERER_OUTLINE_AA_INCLUDED
 
-#include "agg_basics.h"
+#include "agg_array.h"
 #include "agg_math.h"
 #include "agg_line_aa_basics.h"
 #include "agg_dda_line.h"
@@ -1274,12 +1274,7 @@
         };
         
         //---------------------------------------------------------------------
-        ~line_profile_aa() { delete [] m_profile; }
-
-        //---------------------------------------------------------------------
         line_profile_aa() : 
-            m_size(0), 
-            m_profile(0), 
             m_subpixel_width(0),
             m_min_width(1.0),
             m_smoother_width(1.0)
@@ -1291,8 +1286,6 @@
         //---------------------------------------------------------------------
         template<class GammaF> 
         line_profile_aa(double w, const GammaF& gamma_function) : 
-            m_size(0), 
-            m_profile(0), 
             m_subpixel_width(0),
             m_min_width(1.0),
             m_smoother_width(1.0)
@@ -1318,7 +1311,7 @@
 
         void width(double w);
 
-        unsigned profile_size() const { return m_size; }
+        unsigned profile_size() const { return m_profile.size(); }
         int subpixel_width() const { return m_subpixel_width; }
 
         //---------------------------------------------------------------------
@@ -1339,12 +1332,11 @@
         void set(double center_width, double smoother_width);
 
         //---------------------------------------------------------------------
-        unsigned    m_size;
-        value_type* m_profile;
-        value_type  m_gamma[aa_scale];
-        int         m_subpixel_width;
-        double      m_min_width;
-        double      m_smoother_width;
+        pod_array<value_type> m_profile;
+        value_type            m_gamma[aa_scale];
+        int                   m_subpixel_width;
+        double                m_min_width;
+        double                m_smoother_width;
     };
 
 
@@ -1363,8 +1355,8 @@
             m_profile(&prof),
             m_clip_box(0,0,0,0),
             m_clipping(false)
-        {
-        }
+        {}
+        void attach(base_ren_type& ren) { m_ren = &ren; }
 
         //---------------------------------------------------------------------
         void color(const color_type& c) { m_color = c; }
@@ -1657,7 +1649,7 @@
                         }
                         else
                         {
-                            while(abs(sx - lp.x1) + abs(sy - lp.y1) > 2 * lp2.len)
+                            while(abs(sx - lp.x1) + abs(sy - lp.y1) > lp2.len)
                             {
                                 sx = (lp.x1 + sx) >> 1;
                                 sy = (lp.y1 + sy) >> 1;
@@ -1724,7 +1716,7 @@
                         }
                         else
                         {
-                            while(abs(ex - lp.x2) + abs(ey - lp.y2) > 2 * lp2.len)
+                            while(abs(ex - lp.x2) + abs(ey - lp.y2) > lp2.len)
                             {
                                 ex = (lp.x2 + ex) >> 1;
                                 ey = (lp.y2 + ey) >> 1;
@@ -1796,7 +1788,7 @@
                         }
                         else
                         {
-                            while(abs(sx - lp.x1) + abs(sy - lp.y1) > 2 * lp2.len)
+                            while(abs(sx - lp.x1) + abs(sy - lp.y1) > lp2.len)
                             {
                                 sx = (lp.x1 + sx) >> 1;
                                 sy = (lp.y1 + sy) >> 1;
@@ -1809,7 +1801,7 @@
                         }
                         else
                         {
-                            while(abs(ex - lp.x2) + abs(ey - lp.y2) > 2 * lp2.len)
+                            while(abs(ex - lp.x2) + abs(ey - lp.y2) > lp2.len)
                             {
                                 ex = (lp.x2 + ex) >> 1;
                                 ey = (lp.y2 + ey) >> 1;

Modified: trunk/agg/include/agg_renderer_outline_image.h
===================================================================
--- trunk/agg/include/agg_renderer_outline_image.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_renderer_outline_image.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -15,6 +15,7 @@
 #ifndef AGG_RENDERER_OUTLINE_IMAGE_INCLUDED
 #define AGG_RENDERER_OUTLINE_IMAGE_INCLUDED
 
+#include "agg_array.h"
 #include "agg_math.h"
 #include "agg_line_aa_basics.h"
 #include "agg_dda_line.h"
@@ -70,17 +71,11 @@
         typedef typename filter_type::color_type color_type;
 
         //--------------------------------------------------------------------
-        ~line_image_pattern()
-        {
-            delete [] m_data;
-        }
-
-        //--------------------------------------------------------------------
         line_image_pattern(const Filter& filter) :
             m_filter(&filter),
             m_dilation(filter.dilation() + 1),
             m_dilation_hr(m_dilation << line_subpixel_shift),
-            m_data(0),
+            m_data(),
             m_width(0),
             m_height(0),
             m_width_hr(0),
@@ -96,7 +91,7 @@
             m_filter(&filter),
             m_dilation(filter.dilation() + 1),
             m_dilation_hr(m_dilation << line_subpixel_shift),
-            m_data(0),
+            m_data(),
             m_width(0),
             m_height(0),
             m_width_hr(0),
@@ -117,12 +112,11 @@
             m_offset_y_hr = m_dilation_hr + m_half_height_hr - line_subpixel_scale/2;
             m_half_height_hr += line_subpixel_scale/2;
 
-            delete [] m_data;
-            m_data = new color_type [(m_width + m_dilation * 2) * (m_height + m_dilation * 2)];
+            m_data.resize((m_width + m_dilation * 2) * (m_height + m_dilation * 2));
 
-            m_buf.attach(m_data, m_width  + m_dilation * 2, 
-                                 m_height + m_dilation * 2, 
-                                 m_width  + m_dilation * 2);
+            m_buf.attach(&m_data[0], m_width  + m_dilation * 2, 
+                                     m_height + m_dilation * 2, 
+                                     m_width  + m_dilation * 2);
             unsigned x, y;
             color_type* d1;
             color_type* d2;
@@ -195,7 +189,7 @@
         const filter_type*        m_filter;
         unsigned                  m_dilation;
         int                       m_dilation_hr;
-        color_type*               m_data;
+        pod_array<color_type>     m_data;
         unsigned                  m_width;
         unsigned                  m_height;
         int                       m_width_hr;
@@ -829,8 +823,8 @@
             m_scale_x(1.0),
             m_clip_box(0,0,0,0),
             m_clipping(false)
-        {
-        }
+        {}
+        void attach(base_ren_type& ren) { m_ren = &ren; }
 
         //---------------------------------------------------------------------
         void pattern(const pattern_type& p) { m_pattern = &p; }
@@ -924,10 +918,6 @@
             
             fix_degenerate_bisectrix_start(lp, &sx, &sy);
             fix_degenerate_bisectrix_end(lp, &ex, &ey);
-//sx = lp.x1 + (lp.y2 - lp.y1);
-//sy = lp.y1 - (lp.x2 - lp.x1);
-//ex = lp.x2 + (lp.y2 - lp.y1);
-//ey = lp.y2 - (lp.x2 - lp.x1);
             line_interpolator_image<self_type> li(*this, lp, 
                                                   sx, sy, 
                                                   ex, ey, 

Modified: trunk/agg/include/agg_renderer_primitives.h
===================================================================
--- trunk/agg/include/agg_renderer_primitives.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_renderer_primitives.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -35,14 +35,14 @@
         typedef typename base_ren_type::color_type color_type;
 
         //--------------------------------------------------------------------
-        renderer_primitives(base_ren_type& ren) :
+        explicit renderer_primitives(base_ren_type& ren) :
             m_ren(&ren),
             m_fill_color(),
             m_line_color(),
             m_curr_x(0),
             m_curr_y(0)
-        {
-        }
+        {}
+        void attach(base_ren_type& ren) { m_ren = &ren; }
 
         //--------------------------------------------------------------------
         static int coord(double c) 

Modified: trunk/agg/include/agg_renderer_raster_text.h
===================================================================
--- trunk/agg/include/agg_renderer_raster_text.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_renderer_raster_text.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -34,8 +34,8 @@
         renderer_raster_htext_solid(ren_type& ren, glyph_gen_type& glyph) :
             m_ren(&ren),
             m_glyph(&glyph)
-        {
-        }
+        {}
+        void attach(ren_type& ren) { m_ren = &ren; }
 
         //--------------------------------------------------------------------
         void color(const color_type& c) { m_color = c; }

Modified: trunk/agg/include/agg_renderer_scanline.h
===================================================================
--- trunk/agg/include/agg_renderer_scanline.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_renderer_scanline.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -52,7 +52,6 @@
         }
     }
 
-
     //===============================================render_scanlines_aa_solid
     template<class Rasterizer, class Scanline, 
              class BaseRenderer, class ColorT>
@@ -103,7 +102,6 @@
         }
     }
 
-
     //==============================================renderer_scanline_aa_solid
     template<class BaseRenderer> class renderer_scanline_aa_solid
     {
@@ -113,7 +111,7 @@
 
         //--------------------------------------------------------------------
         renderer_scanline_aa_solid() : m_ren(0) {}
-        renderer_scanline_aa_solid(base_ren_type& ren) : m_ren(&ren) {}
+        explicit renderer_scanline_aa_solid(base_ren_type& ren) : m_ren(&ren) {}
         void attach(base_ren_type& ren)
         {
             m_ren = &ren;
@@ -176,8 +174,6 @@
         }
     }
 
-
-
     //=====================================================render_scanlines_aa
     template<class Rasterizer, class Scanline, class BaseRenderer, 
              class SpanAllocator, class SpanGenerator>
@@ -195,8 +191,6 @@
         }
     }
 
-
-
     //====================================================renderer_scanline_aa
     template<class BaseRenderer, class SpanAllocator, class SpanGenerator> 
     class renderer_scanline_aa
@@ -244,318 +238,6 @@
 
 
 
-
-
-
-
-
-
-
-
-
-/*
-    //===================================================renderer_scanline_bin
-    template<class BaseRenderer, class SpanGenerator> class renderer_scanline_bin
-    {
-    public:
-        typedef BaseRenderer  base_ren_type;
-        typedef SpanGenerator span_gen_type;
-
-        //--------------------------------------------------------------------
-        renderer_scanline_bin() : m_ren(0), m_span_gen(0) {}
-        renderer_scanline_bin(base_ren_type& ren, span_gen_type& span_gen) :
-            m_ren(&ren),
-            m_span_gen(&span_gen)
-        {}
-        void attach(base_ren_type& ren, span_gen_type& span_gen)
-        {
-            m_ren = &ren;
-            m_span_gen = &span_gen;
-        }
-        
-        //--------------------------------------------------------------------
-        void prepare(unsigned max_span_len) 
-        { 
-            m_span_gen->prepare(max_span_len); 
-        }
-
-        //--------------------------------------------------------------------
-        template<class Scanline> void render(const Scanline& sl)
-        {
-            int y = sl.y();
-            m_ren->first_clip_box();
-            do
-            {
-                int xmin = m_ren->xmin();
-                int xmax = m_ren->xmax();
-
-                if(y >= m_ren->ymin() && y <= m_ren->ymax())
-                {
-                    unsigned num_spans = sl.num_spans();
-                    typename Scanline::const_iterator span = sl.begin();
-                    for(;;)
-                    {
-                        int x = span->x;
-                        int len = span->len;
-
-                        if(len < 0) len = -len;
-                        if(x < xmin)
-                        {
-                            len -= xmin - x;
-                            x = xmin;
-                        }
-                        if(len > 0)
-                        {
-                            if(x + len > xmax)
-                            {
-                                len = xmax - x + 1;
-                            }
-                            if(len > 0)
-                            {
-                                m_ren->blend_color_hspan_no_clip(
-                                    x, y, len, 
-                                    m_span_gen->generate(x, y, len),
-                                    0);
-                            }
-                        }
-                        if(--num_spans == 0) break;
-                        ++span;
-                    }
-                }
-            }
-            while(m_ren->next_clip_box());
-        }
-        
-    private:
-        base_ren_type* m_ren;
-        SpanGenerator* m_span_gen;
-    };
-
-
-
-
-
-    //================================================renderer_scanline_direct
-    template<class BaseRenderer, class SpanGenerator> class renderer_scanline_direct
-    {
-    public:
-        typedef BaseRenderer  base_ren_type;
-        typedef SpanGenerator span_gen_type;
-
-        //--------------------------------------------------------------------
-        renderer_scanline_direct() : m_ren(0), m_span_gen(0) {}
-        renderer_scanline_direct(base_ren_type& ren, span_gen_type& span_gen) :
-            m_ren(&ren),
-            m_span_gen(&span_gen)
-        {}
-        void attach(base_ren_type& ren, span_gen_type& span_gen)
-        {
-            m_ren = &ren;
-            m_span_gen = &span_gen;
-        }
-
-        //--------------------------------------------------------------------
-        void prepare(unsigned max_span_len) 
-        { 
-            m_span_gen->prepare(max_span_len); 
-        }
-
-        //--------------------------------------------------------------------
-        template<class Scanline> void render(const Scanline& sl)
-        {
-            int y = sl.y();
-            m_ren->first_clip_box();
-            do
-            {
-                int xmin = m_ren->xmin();
-                int xmax = m_ren->xmax();
-
-                if(y >= m_ren->ymin() && y <= m_ren->ymax())
-                {
-                    unsigned num_spans = sl.num_spans();
-                    typename Scanline::const_iterator span = sl.begin();
-                    for(;;)
-                    {
-                        int x = span->x;
-                        int len = span->len;
-
-                        if(len < 0) len = -len;
-                        if(x < xmin)
-                        {
-                            len -= xmin - x;
-                            x = xmin;
-                        }
-                        if(len > 0)
-                        {
-                            if(x + len > xmax)
-                            {
-                                len = xmax - x + 1;
-                            }
-                            if(len > 0)
-                            {
-                                span_data span = m_ren->span(x, y, len);
-                                if(span.ptr)
-                                {
-                                    m_span_gen->generate(span.x, y, span.len, span.ptr);
-                                }
-                            }
-                        }
-                        if(--num_spans == 0) break;
-                        ++span;
-                    }
-                }
-            }
-            while(m_ren->next_clip_box());
-        }
-        
-    private:
-        base_ren_type* m_ren;
-        SpanGenerator* m_span_gen;
-    };
-
-
-
-
-
-
-    //===============================================renderer_scanline_bin_copy
-    template<class BaseRenderer, class SpanGenerator> class renderer_scanline_bin_copy
-    {
-    public:
-        typedef BaseRenderer  base_ren_type;
-        typedef SpanGenerator span_gen_type;
-
-        //--------------------------------------------------------------------
-        renderer_scanline_bin_copy() : m_ren(0), m_span_gen(0) {}
-        renderer_scanline_bin_copy(base_ren_type& ren, span_gen_type& span_gen) :
-            m_ren(&ren),
-            m_span_gen(&span_gen)
-        {}
-        void attach(base_ren_type& ren, span_gen_type& span_gen)
-        {
-            m_ren = &ren;
-            m_span_gen = &span_gen;
-        }
-        
-        //--------------------------------------------------------------------
-        void prepare(unsigned max_span_len) 
-        { 
-            m_span_gen->prepare(max_span_len); 
-        }
-
-        //--------------------------------------------------------------------
-        template<class Scanline> void render(const Scanline& sl)
-        {
-            int y = sl.y();
-            m_ren->first_clip_box();
-            do
-            {
-                int xmin = m_ren->xmin();
-                int xmax = m_ren->xmax();
-
-                if(y >= m_ren->ymin() && y <= m_ren->ymax())
-                {
-                    unsigned num_spans = sl.num_spans();
-                    typename Scanline::const_iterator span = sl.begin();
-                    for(;;)
-                    {
-                        int x = span->x;
-                        int len = span->len;
-
-                        if(len < 0) len = -len;
-                        if(x < xmin)
-                        {
-                            len -= xmin - x;
-                            x = xmin;
-                        }
-                        if(len > 0)
-                        {
-                            if(x + len > xmax)
-                            {
-                                len = xmax - x + 1;
-                            }
-                            if(len > 0)
-                            {
-                                m_ren->copy_color_hspan_no_clip(
-                                    x, y, len, 
-                                    m_span_gen->generate(x, y, len));
-                            }
-                        }
-                        if(--num_spans == 0) break;
-                        ++span;
-                    }
-                }
-            }
-            while(m_ren->next_clip_box());
-        }
-        
-    private:
-        base_ren_type* m_ren;
-        SpanGenerator* m_span_gen;
-    };
-
-
-
-    //=============================================renderer_scanline_bin_solid
-    template<class BaseRenderer> class renderer_scanline_bin_solid
-    {
-    public:
-        typedef BaseRenderer base_ren_type;
-        typedef typename base_ren_type::color_type color_type;
-
-        //--------------------------------------------------------------------
-        renderer_scanline_bin_solid() : m_ren(0) {}
-        renderer_scanline_bin_solid(base_ren_type& ren) :
-            m_ren(&ren)
-        {}
-        void attach(base_ren_type& ren)
-        {
-            m_ren = &ren;
-        }
-        
-        //--------------------------------------------------------------------
-        void color(const color_type& c) { m_color = c; }
-        const color_type& color() const { return m_color; }
-
-        //--------------------------------------------------------------------
-        void prepare(unsigned) {}
-
-        //--------------------------------------------------------------------
-        template<class Scanline> void render(const Scanline& sl)
-        {
-            unsigned num_spans = sl.num_spans();
-            typename Scanline::const_iterator span = sl.begin();
-            for(;;)
-            {
-                m_ren->blend_hline(span->x, 
-                                   sl.y(), 
-                                   span->x - 1 + ((span->len < 0) ? 
-                                                     -span->len : 
-                                                      span->len), 
-                                   m_color, 
-                                   cover_full);
-                if(--num_spans == 0) break;
-                ++span;
-            }
-        }
-        
-    private:
-        base_ren_type* m_ren;
-        color_type m_color;
-    };
-*/
-
-
-
-
-
-
-
-
-
-
-
-
     //===============================================render_scanline_bin_solid
     template<class Scanline, class BaseRenderer, class ColorT> 
     void render_scanline_bin_solid(const Scanline& sl, 
@@ -578,7 +260,6 @@
         }
     }
 
-
     //==============================================render_scanlines_bin_solid
     template<class Rasterizer, class Scanline, 
              class BaseRenderer, class ColorT>
@@ -621,7 +302,6 @@
         }
     }
 
-
     //=============================================renderer_scanline_bin_solid
     template<class BaseRenderer> class renderer_scanline_bin_solid
     {
@@ -631,7 +311,7 @@
 
         //--------------------------------------------------------------------
         renderer_scanline_bin_solid() : m_ren(0) {}
-        renderer_scanline_bin_solid(base_ren_type& ren) : m_ren(&ren) {}
+        explicit renderer_scanline_bin_solid(base_ren_type& ren) : m_ren(&ren) {}
         void attach(base_ren_type& ren)
         {
             m_ren = &ren;
@@ -662,11 +342,97 @@
 
 
 
+    //======================================================render_scanline_bin
+    template<class Scanline, class BaseRenderer, 
+             class SpanAllocator, class SpanGenerator> 
+    void render_scanline_bin(const Scanline& sl, BaseRenderer& ren, 
+                             SpanAllocator& alloc, SpanGenerator& span_gen)
+    {
+        int y = sl.y();
 
+        unsigned num_spans = sl.num_spans();
+        typename Scanline::const_iterator span = sl.begin();
+        for(;;)
+        {
+            int x = span->x;
+            int len = span->len;
+            if(len < 0) len = -len;
+            typename BaseRenderer::color_type* colors = alloc.allocate(len);
+            span_gen.generate(colors, x, y, len);
+            ren.blend_color_hspan(x, y, len, colors, 0, cover_full); 
+            if(--num_spans == 0) break;
+            ++span;
+        }
+    }
 
+    //=====================================================render_scanlines_bin
+    template<class Rasterizer, class Scanline, class BaseRenderer, 
+             class SpanAllocator, class SpanGenerator>
+    void render_scanlines_bin(Rasterizer& ras, Scanline& sl, BaseRenderer& ren, 
+                              SpanAllocator& alloc, SpanGenerator& span_gen)
+    {
+        if(ras.rewind_scanlines())
+        {
+            sl.reset(ras.min_x(), ras.max_x());
+            span_gen.prepare();
+            while(ras.sweep_scanline(sl))
+            {
+                render_scanline_bin(sl, ren, alloc, span_gen);
+            }
+        }
+    }
 
+    //====================================================renderer_scanline_bin
+    template<class BaseRenderer, class SpanAllocator, class SpanGenerator> 
+    class renderer_scanline_bin
+    {
+    public:
+        typedef BaseRenderer  base_ren_type;
+        typedef SpanAllocator alloc_type;
+        typedef SpanGenerator span_gen_type;
 
+        //--------------------------------------------------------------------
+        renderer_scanline_bin() : m_ren(0), m_alloc(0), m_span_gen(0) {}
+        renderer_scanline_bin(base_ren_type& ren, 
+                              alloc_type& alloc, 
+                              span_gen_type& span_gen) :
+            m_ren(&ren),
+            m_alloc(&alloc),
+            m_span_gen(&span_gen)
+        {}
+        void attach(base_ren_type& ren, 
+                    alloc_type& alloc, 
+                    span_gen_type& span_gen)
+        {
+            m_ren = &ren;
+            m_alloc = &alloc;
+            m_span_gen = &span_gen;
+        }
+        
+        //--------------------------------------------------------------------
+        void prepare() { m_span_gen->prepare(); }
 
+        //--------------------------------------------------------------------
+        template<class Scanline> void render(const Scanline& sl)
+        {
+            render_scanline_bin(sl, *m_ren, *m_alloc, *m_span_gen);
+        }
+
+    private:
+        base_ren_type* m_ren;
+        alloc_type*    m_alloc;
+        span_gen_type* m_span_gen;
+    };
+
+
+
+
+
+
+
+
+
+
     //========================================================render_scanlines
     template<class Rasterizer, class Scanline, class Renderer>
     void render_scanlines(Rasterizer& ras, Scanline& sl, Renderer& ren)
@@ -682,7 +448,6 @@
         }
     }
 
-
     //========================================================render_all_paths
     template<class Rasterizer, class Scanline, class Renderer, 
              class VertexSource, class ColorStorage, class PathId>
@@ -707,6 +472,7 @@
 
 
 
+
     //=============================================render_scanlines_compound
     template<class Rasterizer, 
              class ScanlineAA, 
@@ -821,7 +587,14 @@
                                         covers = span_aa->covers;
                                         do
                                         {
-                                            colors->add(c, *covers);
+                                            if(*covers == cover_full) 
+                                            {
+                                                *colors = c;
+                                            }
+                                            else
+                                            {
+                                                colors->add(c, *covers);
+                                            }
                                             ++colors;
                                             ++covers;
                                         }
@@ -847,7 +620,14 @@
                                         covers = span_aa->covers;
                                         do
                                         {
-                                            colors->add(*cspan, *covers);
+                                            if(*covers == cover_full) 
+                                            {
+                                                *colors = *cspan;
+                                            }
+                                            else
+                                            {
+                                                colors->add(*cspan, *covers);
+                                            }
                                             ++cspan;
                                             ++colors;
                                             ++covers;
@@ -875,17 +655,198 @@
                             if(--num_spans == 0) break;
                             ++span_bin;
                         }
+                    } // if(ras.sweep_scanline(sl_bin, -1))
+                } // if(num_styles == 1) ... else
+            } // while((num_styles = ras.sweep_styles()) > 0)
+        } // if(ras.rewind_scanlines())
+    }
 
+    //=======================================render_scanlines_compound_layered
+    template<class Rasterizer, 
+             class ScanlineAA, 
+             class BaseRenderer, 
+             class SpanAllocator,
+             class StyleHandler>
+    void render_scanlines_compound_layered(Rasterizer& ras, 
+                                           ScanlineAA& sl_aa,
+                                           BaseRenderer& ren,
+                                           SpanAllocator& alloc,
+                                           StyleHandler& sh)
+    {
+        if(ras.rewind_scanlines())
+        {
+            int min_x = ras.min_x();
+            int len = ras.max_x() - min_x + 2;
+            sl_aa.reset(min_x, ras.max_x());
+
+            typedef typename BaseRenderer::color_type color_type;
+            color_type* color_span   = alloc.allocate(len * 2);
+            color_type* mix_buffer   = color_span + len;
+            cover_type* cover_buffer = ras.allocate_cover_buffer(len);
+            unsigned num_spans;
+
+            unsigned num_styles;
+            unsigned style;
+            bool     solid;
+            while((num_styles = ras.sweep_styles()) > 0)
+            {
+                typename ScanlineAA::const_iterator span_aa;
+                if(num_styles == 1)
+                {
+                    // Optimization for a single style. Happens often
+                    //-------------------------
+                    if(ras.sweep_scanline(sl_aa, 0))
+                    {
+                        style = ras.style(0);
+                        if(sh.is_solid(style))
+                        {
+                            // Just solid fill
+                            //-----------------------
+                            render_scanline_aa_solid(sl_aa, ren, sh.color(style));
+                        }
+                        else
+                        {
+                            // Arbitrary span generator
+                            //-----------------------
+                            span_aa   = sl_aa.begin();
+                            num_spans = sl_aa.num_spans();
+                            for(;;)
+                            {
+                                len = span_aa->len;
+                                sh.generate_span(color_span, 
+                                                 span_aa->x, 
+                                                 sl_aa.y(), 
+                                                 len, 
+                                                 style);
+
+                                ren.blend_color_hspan(span_aa->x, 
+                                                      sl_aa.y(), 
+                                                      span_aa->len,
+                                                      color_span,
+                                                      span_aa->covers);
+                                if(--num_spans == 0) break;
+                                ++span_aa;
+                            }
+                        }
                     }
                 }
-            }
-        }
-    }
+                else
+                {
+                    int      sl_start = ras.scanline_start();
+                    unsigned sl_len   = ras.scanline_length();
 
+                    if(sl_len)
+                    {
+                        memset(mix_buffer + sl_start - min_x, 
+                               0, 
+                               sl_len * sizeof(color_type));
 
+                        memset(cover_buffer + sl_start - min_x, 
+                               0, 
+                               sl_len * sizeof(cover_type));
 
+                        int sl_y = 0x7FFFFFFF;
+                        unsigned i;
+                        for(i = 0; i < num_styles; i++)
+                        {
+                            style = ras.style(i);
+                            solid = sh.is_solid(style);
 
+                            if(ras.sweep_scanline(sl_aa, i))
+                            {
+                                unsigned    cover;
+                                color_type* colors;
+                                color_type* cspan;
+                                cover_type* src_covers;
+                                cover_type* dst_covers;
+                                span_aa   = sl_aa.begin();
+                                num_spans = sl_aa.num_spans();
+                                sl_y      = sl_aa.y();
+                                if(solid)
+                                {
+                                    // Just solid fill
+                                    //-----------------------
+                                    for(;;)
+                                    {
+                                        color_type c = sh.color(style);
+                                        len    = span_aa->len;
+                                        colors = mix_buffer + span_aa->x - min_x;
+                                        src_covers = span_aa->covers;
+                                        dst_covers = cover_buffer + span_aa->x - min_x;
+                                        do
+                                        {
+                                            cover = *src_covers;
+                                            if(*dst_covers + cover > cover_full)
+                                            {
+                                                cover = cover_full - *dst_covers;
+                                            }
+                                            if(cover)
+                                            {
+                                                colors->add(c, cover);
+                                                *dst_covers += cover;
+                                            }
+                                            ++colors;
+                                            ++src_covers;
+                                            ++dst_covers;
+                                        }
+                                        while(--len);
+                                        if(--num_spans == 0) break;
+                                        ++span_aa;
+                                    }
+                                }
+                                else
+                                {
+                                    // Arbitrary span generator
+                                    //-----------------------
+                                    for(;;)
+                                    {
+                                        len = span_aa->len;
+                                        colors = mix_buffer + span_aa->x - min_x;
+                                        cspan  = color_span;
+                                        sh.generate_span(cspan, 
+                                                         span_aa->x, 
+                                                         sl_aa.y(), 
+                                                         len, 
+                                                         style);
+                                        src_covers = span_aa->covers;
+                                        dst_covers = cover_buffer + span_aa->x - min_x;
+                                        do
+                                        {
+                                            cover = *src_covers;
+                                            if(*dst_covers + cover > cover_full)
+                                            {
+                                                cover = cover_full - *dst_covers;
+                                            }
+                                            if(cover)
+                                            {
+                                                colors->add(*cspan, cover);
+                                                *dst_covers += cover;
+                                            }
+                                            ++cspan;
+                                            ++colors;
+                                            ++src_covers;
+                                            ++dst_covers;
+                                        }
+                                        while(--len);
+                                        if(--num_spans == 0) break;
+                                        ++span_aa;
+                                    }
+                                }
+                            }
+                        }
+                        ren.blend_color_hspan(sl_start, 
+                                              sl_y, 
+                                              sl_len,
+                                              mix_buffer + sl_start - min_x,
+                                              0,
+                                              cover_full);
+                    } //if(sl_len)
+                } //if(num_styles == 1) ... else
+            } //while((num_styles = ras.sweep_styles()) > 0)
+        } //if(ras.rewind_scanlines())
+    }
 
+
 }
 
 #endif

Modified: trunk/agg/include/agg_rendering_buffer.h
===================================================================
--- trunk/agg/include/agg_rendering_buffer.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_rendering_buffer.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -20,50 +20,147 @@
 #ifndef AGG_RENDERING_BUFFER_INCLUDED
 #define AGG_RENDERING_BUFFER_INCLUDED
 
-#include "agg_basics.h"
+#include "agg_array.h"
 
 namespace agg
 {
 
-    //==========================================================row_ptr_cache
-    template<class T> class row_ptr_cache
+    //===========================================================row_accessor
+    template<class T> class row_accessor
     {
     public:
+        typedef const_row_info<T> row_data;
+
+        //-------------------------------------------------------------------
+        row_accessor() :
+            m_buf(0),
+            m_start(0),
+            m_width(0),
+            m_height(0),
+            m_stride(0)
+        {
+        }
+
         //--------------------------------------------------------------------
-        struct row_data
+        row_accessor(T* buf, unsigned width, unsigned height, int stride) :
+            m_buf(0),
+            m_start(0),
+            m_width(0),
+            m_height(0),
+            m_stride(0)
         {
-            int x1, x2;
-            const int8u* ptr;
-            row_data() {}
-            row_data(int x1_, int x2_, const int8u* ptr_) : 
-                x1(x1_), x2(x2_), ptr(ptr_) {}
-        };
+            attach(buf, width, height, stride);
+        }
 
-        //-------------------------------------------------------------------
-        ~row_ptr_cache()
+
+        //--------------------------------------------------------------------
+        void attach(T* buf, unsigned width, unsigned height, int stride)
         {
-            delete [] m_rows;
+			m_buf = m_start = buf;
+			m_width = width;
+			m_height = height;
+			m_stride = stride;
+			if(stride < 0) 
+            { 
+				m_start = m_buf - int(height - 1) * stride;
+			}
         }
 
+        //--------------------------------------------------------------------
+        AGG_INLINE       T* buf()          { return m_buf;    }
+        AGG_INLINE const T* buf()    const { return m_buf;    }
+        AGG_INLINE unsigned width()  const { return m_width;  }
+        AGG_INLINE unsigned height() const { return m_height; }
+        AGG_INLINE int      stride() const { return m_stride; }
+        AGG_INLINE unsigned stride_abs() const 
+        {
+            return (m_stride < 0) ? unsigned(-m_stride) : unsigned(m_stride); 
+        }
+
+        //--------------------------------------------------------------------
+		AGG_INLINE       T* row_ptr(int, int y, unsigned) 
+        { 
+            return m_start + y * m_stride; 
+        }
+		AGG_INLINE       T* row_ptr(int y)       { return m_start + y * m_stride; }
+		AGG_INLINE const T* row_ptr(int y) const { return m_start + y * m_stride; }
+		AGG_INLINE row_data row    (int y) const 
+        { 
+            return row_data(0, m_width-1, row_ptr(y)); 
+        }
+
+        //--------------------------------------------------------------------
+        template<class RenBuf>
+        void copy_from(const RenBuf& src)
+        {
+            unsigned h = height();
+            if(src.height() < h) h = src.height();
+        
+            unsigned l = stride_abs();
+            if(src.stride_abs() < l) l = src.stride_abs();
+        
+            l *= sizeof(T);
+
+            unsigned y;
+            unsigned w = width();
+            for (y = 0; y < h; y++)
+            {
+                memcpy(row_ptr(0, y, w), src.row_ptr(y), l);
+            }
+        }
+
+        //--------------------------------------------------------------------
+        void clear(T value)
+        {
+            unsigned y;
+            unsigned w = width();
+            unsigned stride = stride_abs();
+            for(y = 0; y < height(); y++)
+            {
+                T* p = row_ptr(0, y, w);
+                unsigned x;
+                for(x = 0; x < stride; x++)
+                {
+                    *p++ = value;
+                }
+            }
+        }
+
+    private:
+        //--------------------------------------------------------------------
+        T*            m_buf;    // Pointer to renrdering buffer
+        T*            m_start;  // Pointer to first pixel depending on stride 
+        unsigned      m_width;  // Width in pixels
+        unsigned      m_height; // Height in pixels
+        int           m_stride; // Number of bytes per row. Can be < 0
+    };
+
+
+
+
+    //==========================================================row_ptr_cache
+    template<class T> class row_ptr_cache
+    {
+    public:
+        typedef const_row_info<T> row_data;
+
         //-------------------------------------------------------------------
         row_ptr_cache() :
             m_buf(0),
-            m_rows(0),
+            m_rows(),
             m_width(0),
             m_height(0),
-            m_stride(0),
-            m_max_height(0)
+            m_stride(0)
         {
         }
 
         //--------------------------------------------------------------------
         row_ptr_cache(T* buf, unsigned width, unsigned height, int stride) :
             m_buf(0),
-            m_rows(0),
+            m_rows(),
             m_width(0),
             m_height(0),
-            m_stride(0),
-            m_max_height(0)
+            m_stride(0)
         {
             attach(buf, width, height, stride);
         }
@@ -75,20 +172,19 @@
             m_width = width;
             m_height = height;
             m_stride = stride;
-            if(height > m_max_height)
+            if(height > m_rows.size())
             {
-                delete [] m_rows;
-                m_rows = new T* [m_max_height = height];
+                m_rows.resize(height);
             }
 
             T* row_ptr = m_buf;
 
             if(stride < 0)
             {
-                row_ptr = m_buf - (height - 1) * stride;
+                row_ptr = m_buf - int(height - 1) * stride;
             }
 
-            T** rows = m_rows;
+            T** rows = &m_rows[0];
 
             while(height--)
             {
@@ -98,24 +194,30 @@
         }
 
         //--------------------------------------------------------------------
-              T* buf()          { return m_buf;    }
-        const T* buf()    const { return m_buf;    }
-        unsigned width()  const { return m_width;  }
-        unsigned height() const { return m_height; }
-        int      stride() const { return m_stride; }
-        unsigned stride_abs() const 
+        AGG_INLINE       T* buf()          { return m_buf;    }
+        AGG_INLINE const T* buf()    const { return m_buf;    }
+        AGG_INLINE unsigned width()  const { return m_width;  }
+        AGG_INLINE unsigned height() const { return m_height; }
+        AGG_INLINE int      stride() const { return m_stride; }
+        AGG_INLINE unsigned stride_abs() const 
         {
             return (m_stride < 0) ? unsigned(-m_stride) : unsigned(m_stride); 
         }
 
         //--------------------------------------------------------------------
-              T* row_ptr(int, int y, unsigned) { return m_rows[y]; }
-              T* row_ptr(int y)                { return m_rows[y]; }
-        const T* row_ptr(int y) const          { return m_rows[y]; }
-        row_data row    (int y) const { return row_data(0, m_width-1, m_rows[y]); }
+        AGG_INLINE       T* row_ptr(int, int y, unsigned) 
+        { 
+            return m_rows[y]; 
+        }
+        AGG_INLINE       T* row_ptr(int y)       { return m_rows[y]; }
+        AGG_INLINE const T* row_ptr(int y) const { return m_rows[y]; }
+        AGG_INLINE row_data row    (int y) const 
+        { 
+            return row_data(0, m_width-1, m_rows[y]); 
+        }
 
         //--------------------------------------------------------------------
-        T const* const* rows() const { return m_rows; }
+        T const* const* rows() const { return &m_rows[0]; }
 
         //--------------------------------------------------------------------
         template<class RenBuf>
@@ -154,27 +256,43 @@
             }
         }
 
-
     private:
         //--------------------------------------------------------------------
-        // Prohibit copying
-        row_ptr_cache(const row_ptr_cache<T>&);
-        const row_ptr_cache<T>& operator = (const row_ptr_cache<T>&);
-
-    private:
-        //--------------------------------------------------------------------
-        T*       m_buf;        // Pointer to renrdering buffer
-        T**      m_rows;       // Pointers to each row of the buffer
-        unsigned m_width;      // Width in pixels
-        unsigned m_height;     // Height in pixels
-        int      m_stride;     // Number of bytes per row. Can be < 0
-        unsigned m_max_height; // The maximal height (currently allocated)
+        T*            m_buf;        // Pointer to renrdering buffer
+        pod_array<T*> m_rows;       // Pointers to each row of the buffer
+        unsigned      m_width;      // Width in pixels
+        unsigned      m_height;     // Height in pixels
+        int           m_stride;     // Number of bytes per row. Can be < 0
     };
 
 
 
+
     //========================================================rendering_buffer
-    typedef row_ptr_cache<int8u> rendering_buffer;
+    // 
+    // The definition of the main type for accessing the rows in the frame 
+    // buffer. It provides functionality to navigate to the rows in a 
+    // rectangular matrix, from top to bottom or from bottom to top depending 
+    // on stride.
+    //
+    // row_accessor is cheap to create/destroy, but performs one multiplication
+    // when calling row_ptr().
+    // 
+    // row_ptr_cache creates an array of pointers to rows, so, the access 
+    // via row_ptr() may be faster. But it requires memory allocation 
+    // when creating. For example, on typical Intel Pentium hardware 
+    // row_ptr_cache speeds span_image_filter_rgb_nn up to 10%
+    //
+    // It's used only in short hand typedefs like pixfmt_rgba32 and can be 
+    // redefined in agg_config.h
+    // In real applications you can use both, depending on your needs
+    //------------------------------------------------------------------------
+#ifdef AGG_RENDERING_BUFFER
+    typedef AGG_RENDERING_BUFFER rendering_buffer;
+#else
+//  typedef row_ptr_cache<int8u> rendering_buffer;
+    typedef row_accessor<int8u> rendering_buffer;
+#endif
 
 }
 

Modified: trunk/agg/include/agg_rendering_buffer_dynarow.h
===================================================================
--- trunk/agg/include/agg_rendering_buffer_dynarow.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_rendering_buffer_dynarow.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -20,8 +20,7 @@
 #ifndef AGG_RENDERING_BUFFER_DYNAROW_INCLUDED
 #define AGG_RENDERING_BUFFER_DYNAROW_INCLUDED
 
-#include <string.h>
-#include "agg_basics.h"
+#include "agg_array.h"
 
 namespace agg
 {
@@ -36,12 +35,7 @@
     class rendering_buffer_dynarow
     {
     public:
-        //----------------------------------------------------------------------
-        struct row_data
-        {
-            int x1, x2;
-            const int8u* ptr;
-        };
+        typedef row_info<int8u> row_data;
 
         //-------------------------------------------------------------------
         ~rendering_buffer_dynarow()
@@ -51,9 +45,10 @@
 
         //-------------------------------------------------------------------
         rendering_buffer_dynarow() :
-            m_rows(0),
+            m_rows(),
             m_width(0),
-            m_height(0)
+            m_height(0),
+            m_byte_width(0)
         {
         }
 
@@ -61,12 +56,12 @@
         //--------------------------------------------------------------------
         rendering_buffer_dynarow(unsigned width, unsigned height, 
                                  unsigned byte_width) :
-            m_rows(new row_data[height]),
+            m_rows(height),
             m_width(width),
             m_height(height),
             m_byte_width(byte_width)
         {
-            memset(m_rows, 0, sizeof(row_data) * height);
+            memset(&m_rows[0], 0, sizeof(row_data) * height);
         }
 
         // Allocate and clear the buffer
@@ -74,16 +69,17 @@
         void init(unsigned width, unsigned height, unsigned byte_width)
         {
             unsigned i;
-            for(i = 0; i < m_height; ++i) delete [] (int8u*)m_rows[i].ptr;
-            delete [] m_rows;
-            m_rows = 0;
+            for(i = 0; i < m_height; ++i) 
+            {
+                pod_allocator<int8u>::deallocate((int8u*)m_rows[i].ptr, m_byte_width);
+            }
             if(width && height)
             {
                 m_width  = width;
                 m_height = height;
                 m_byte_width = byte_width;
-                m_rows = new row_data[height];
-                memset(m_rows, 0, sizeof(row_data) * height);
+                m_rows.resize(height);
+                memset(&m_rows[0], 0, sizeof(row_data) * height);
             }
         }
 
@@ -97,7 +93,7 @@
         //--------------------------------------------------------------------
         int8u* row_ptr(int x, int y, unsigned len)
         {
-            row_data* r = m_rows + y;
+            row_data* r = &m_rows[y];
             int x2 = x + len - 1;
             if(r->ptr)
             {
@@ -106,7 +102,7 @@
             }
             else
             {
-                int8u* p = new int8u [m_byte_width];
+                int8u* p = pod_allocator<int8u>::allocate(m_byte_width);
                 r->ptr = p;
                 r->x1  = x;
                 r->x2  = x2;
@@ -128,10 +124,10 @@
 
     private:
         //--------------------------------------------------------------------
-        row_data* m_rows;       // Pointers to each row of the buffer
-        unsigned  m_width;      // Width in pixels
-        unsigned  m_height;     // Height in pixels
-        unsigned  m_byte_width; // Width in bytes
+        pod_array<row_data> m_rows;       // Pointers to each row of the buffer
+        unsigned            m_width;      // Width in pixels
+        unsigned            m_height;     // Height in pixels
+        unsigned            m_byte_width; // Width in bytes
     };
 
 

Modified: trunk/agg/include/agg_scanline_bin.h
===================================================================
--- trunk/agg/include/agg_scanline_bin.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_scanline_bin.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -54,15 +54,9 @@
         typedef const span* const_iterator;
 
         //--------------------------------------------------------------------
-        ~scanline_bin()
-        {
-            delete [] m_spans;
-        }
-
         scanline_bin() :
-            m_max_len(0),
             m_last_x(0x7FFFFFF0),
-            m_spans(0),
+            m_spans(),
             m_cur_span(0)
         {
         }
@@ -71,14 +65,12 @@
         void reset(int min_x, int max_x)
         {
             unsigned max_len = max_x - min_x + 3;
-            if(max_len > m_max_len)
+            if(max_len > m_spans.size())
             {
-                delete [] m_spans;
-                m_spans   = new span [max_len];
-                m_max_len = max_len;
+                m_spans.resize(max_len);
             }
             m_last_x   = 0x7FFFFFF0;
-            m_cur_span = m_spans;
+            m_cur_span = &m_spans[0];
         }
 
         //--------------------------------------------------------------------
@@ -129,23 +121,22 @@
         void reset_spans()
         {
             m_last_x    = 0x7FFFFFF0;
-            m_cur_span  = m_spans;
+            m_cur_span  = &m_spans[0];
         }
 
         //--------------------------------------------------------------------
         int            y()         const { return m_y; }
-        unsigned       num_spans() const { return unsigned(m_cur_span - m_spans); }
-        const_iterator begin()     const { return m_spans + 1; }
+        unsigned       num_spans() const { return unsigned(m_cur_span - &m_spans[0]); }
+        const_iterator begin()     const { return &m_spans[1]; }
 
     private:
         scanline_bin(const scanline_bin&);
         const scanline_bin operator = (const scanline_bin&);
 
-        unsigned  m_max_len;
-        int       m_last_x;
-        int       m_y;
-        span*     m_spans;
-        span*     m_cur_span;
+        int             m_last_x;
+        int             m_y;
+        pod_array<span> m_spans;
+        span*           m_cur_span;
     };
 
 

Modified: trunk/agg/include/agg_scanline_p.h
===================================================================
--- trunk/agg/include/agg_scanline_p.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_scanline_p.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -57,19 +57,11 @@
         typedef span* iterator;
         typedef const span* const_iterator;
 
-        //--------------------------------------------------------------------
-        ~scanline_p8()
-        {
-            delete [] m_spans;
-            delete [] m_covers;
-        }
-
         scanline_p8() :
-            m_max_len(0),
             m_last_x(0x7FFFFFF0),
-            m_covers(0),
+            m_covers(),
             m_cover_ptr(0),
-            m_spans(0),
+            m_spans(),
             m_cur_span(0)
         {
         }
@@ -78,17 +70,14 @@
         void reset(int min_x, int max_x)
         {
             unsigned max_len = max_x - min_x + 3;
-            if(max_len > m_max_len)
+            if(max_len > m_spans.size())
             {
-                delete [] m_spans;
-                delete [] m_covers;
-                m_covers  = new cover_type [max_len];
-                m_spans   = new span [max_len];
-                m_max_len = max_len;
+                m_spans.resize(max_len);
+                m_covers.resize(max_len);
             }
             m_last_x    = 0x7FFFFFF0;
-            m_cover_ptr = m_covers;
-            m_cur_span  = m_spans;
+            m_cover_ptr = &m_covers[0];
+            m_cur_span  = &m_spans[0];
             m_cur_span->len = 0;
         }
 
@@ -160,27 +149,26 @@
         void reset_spans()
         {
             m_last_x    = 0x7FFFFFF0;
-            m_cover_ptr = m_covers;
-            m_cur_span  = m_spans;
+            m_cover_ptr = &m_covers[0];
+            m_cur_span  = &m_spans[0];
             m_cur_span->len = 0;
         }
 
         //--------------------------------------------------------------------
         int            y()         const { return m_y; }
-        unsigned       num_spans() const { return unsigned(m_cur_span - m_spans); }
-        const_iterator begin()     const { return m_spans + 1; }
+        unsigned       num_spans() const { return unsigned(m_cur_span - &m_spans[0]); }
+        const_iterator begin()     const { return &m_spans[1]; }
 
     private:
         scanline_p8(const self_type&);
         const self_type& operator = (const self_type&);
 
-        unsigned    m_max_len;
-        int         m_last_x;
-        int         m_y;
-        cover_type* m_covers;
-        cover_type* m_cover_ptr;
-        span*       m_spans;
-        span*       m_cur_span;
+        int                   m_last_x;
+        int                   m_y;
+        pod_array<cover_type> m_covers;
+        cover_type*           m_cover_ptr;
+        pod_array<span>       m_spans;
+        span*                 m_cur_span;
     };
 
 
@@ -231,15 +219,10 @@
         };
 
         //--------------------------------------------------------------------
-        ~scanline32_p8()
-        {
-            delete [] m_covers;
-        }
-
         scanline32_p8() :
             m_max_len(0),
             m_last_x(0x7FFFFFF0),
-            m_covers(0),
+            m_covers(),
             m_cover_ptr(0)
         {
         }
@@ -248,14 +231,12 @@
         void reset(int min_x, int max_x)
         {
             unsigned max_len = max_x - min_x + 3;
-            if(max_len > m_max_len)
+            if(max_len > m_covers.size())
             {
-                delete [] m_covers;
-                m_covers  = new cover_type[max_len];
-                m_max_len = max_len;
+                m_covers.resize(max_len);
             }
             m_last_x    = 0x7FFFFFF0;
-            m_cover_ptr = m_covers;
+            m_cover_ptr = &m_covers[0];
             m_spans.remove_all();
         }
 
@@ -319,7 +300,7 @@
         void reset_spans()
         {
             m_last_x    = 0x7FFFFFF0;
-            m_cover_ptr = m_covers;
+            m_cover_ptr = &m_covers[0];
             m_spans.remove_all();
         }
 
@@ -332,12 +313,12 @@
         scanline32_p8(const self_type&);
         const self_type& operator = (const self_type&);
 
-        unsigned        m_max_len;
-        int             m_last_x;
-        int             m_y;
-        cover_type*     m_covers;
-        cover_type*     m_cover_ptr;
-        span_array_type m_spans;
+        unsigned              m_max_len;
+        int                   m_last_x;
+        int                   m_y;
+        pod_array<cover_type> m_covers;
+        cover_type*           m_cover_ptr;
+        span_array_type       m_spans;
     };
 
 

Modified: trunk/agg/include/agg_scanline_storage_aa.h
===================================================================
--- trunk/agg/include/agg_scanline_storage_aa.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_scanline_storage_aa.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -83,7 +83,8 @@
             int i;
             for(i = m_extra_storage.size()-1; i >= 0; --i)
             {
-                delete [] m_extra_storage[(unsigned)i].ptr;
+                pod_allocator<T>::deallocate(m_extra_storage[i].ptr,
+                                             m_extra_storage[i].len);
             }
             m_extra_storage.remove_all();
             m_cells.remove_all();
@@ -101,7 +102,7 @@
             }
             extra_span s;
             s.len = num_cells;
-            s.ptr = new T [num_cells];
+            s.ptr = pod_allocator<T>::allocate(num_cells);
             memcpy(s.ptr, cells, sizeof(T) * num_cells);
             m_extra_storage.add(s);
             return -int(m_extra_storage.size());
@@ -142,7 +143,7 @@
                 const extra_span& src = v.m_extra_storage[i];
                 extra_span dst;
                 dst.len = src.len;
-                dst.ptr = new T [dst.len];
+                dst.ptr = pod_allocator<T>::allocate(dst.len);
                 memcpy(dst.ptr, src.ptr, dst.len * sizeof(T));
                 m_extra_storage.add(dst);
             }

Modified: trunk/agg/include/agg_scanline_u.h
===================================================================
--- trunk/agg/include/agg_scanline_u.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_scanline_u.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -125,18 +125,9 @@
         typedef const span* const_iterator;
 
         //--------------------------------------------------------------------
-        ~scanline_u8()
-        {
-            delete [] m_spans;
-            delete [] m_covers;
-        }
-
         scanline_u8() :
             m_min_x(0),
-            m_max_len(0),
             m_last_x(0x7FFFFFF0),
-            m_covers(0),
-            m_spans(0),
             m_cur_span(0)
         {}
 
@@ -144,17 +135,14 @@
         void reset(int min_x, int max_x)
         {
             unsigned max_len = max_x - min_x + 2;
-            if(max_len > m_max_len)
+            if(max_len > m_spans.size())
             {
-                delete [] m_spans;
-                delete [] m_covers;
-                m_covers  = new cover_type [max_len];
-                m_spans   = new span       [max_len];
-                m_max_len = max_len;
+                m_spans.resize(max_len);
+                m_covers.resize(max_len);
             }
-            m_last_x        = 0x7FFFFFF0;
-            m_min_x         = min_x;
-            m_cur_span      = m_spans;
+            m_last_x   = 0x7FFFFFF0;
+            m_min_x    = min_x;
+            m_cur_span = &m_spans[0];
         }
 
         //--------------------------------------------------------------------
@@ -171,7 +159,7 @@
                 m_cur_span++;
                 m_cur_span->x      = (coord_type)(x + m_min_x);
                 m_cur_span->len    = 1;
-                m_cur_span->covers = m_covers + x;
+                m_cur_span->covers = &m_covers[x];
             }
             m_last_x = x;
         }
@@ -180,7 +168,7 @@
         void add_cells(int x, unsigned len, const cover_type* covers)
         {
             x -= m_min_x;
-            memcpy(m_covers + x, covers, len * sizeof(cover_type));
+            memcpy(&m_covers[x], covers, len * sizeof(cover_type));
             if(x == m_last_x+1)
             {
                 m_cur_span->len += (coord_type)len;
@@ -190,7 +178,7 @@
                 m_cur_span++;
                 m_cur_span->x      = (coord_type)(x + m_min_x);
                 m_cur_span->len    = (coord_type)len;
-                m_cur_span->covers = m_covers + x;
+                m_cur_span->covers = &m_covers[x];
             }
             m_last_x = x + len - 1;
         }
@@ -199,7 +187,7 @@
         void add_span(int x, unsigned len, unsigned cover)
         {
             x -= m_min_x;
-            memset(m_covers + x, cover, len);
+            memset(&m_covers[x], cover, len);
             if(x == m_last_x+1)
             {
                 m_cur_span->len += (coord_type)len;
@@ -209,7 +197,7 @@
                 m_cur_span++;
                 m_cur_span->x      = (coord_type)(x + m_min_x);
                 m_cur_span->len    = (coord_type)len;
-                m_cur_span->covers = m_covers + x;
+                m_cur_span->covers = &m_covers[x];
             }
             m_last_x = x + len - 1;
         }
@@ -224,27 +212,26 @@
         void reset_spans()
         {
             m_last_x    = 0x7FFFFFF0;
-            m_cur_span  = m_spans;
+            m_cur_span  = &m_spans[0];
         }
 
         //--------------------------------------------------------------------
         int      y()           const { return m_y; }
-        unsigned num_spans()   const { return unsigned(m_cur_span - m_spans); }
-        const_iterator begin() const { return m_spans + 1; }
-        iterator       begin()       { return m_spans + 1; }
+        unsigned num_spans()   const { return unsigned(m_cur_span - &m_spans[0]); }
+        const_iterator begin() const { return &m_spans[1]; }
+        iterator       begin()       { return &m_spans[1]; }
 
     private:
         scanline_u8(const self_type&);
         const self_type& operator = (const self_type&);
 
     private:
-        int           m_min_x;
-        unsigned      m_max_len;
-        int           m_last_x;
-        int           m_y;
-        cover_type*   m_covers;
-        span*         m_spans;
-        span*         m_cur_span;
+        int                   m_min_x;
+        int                   m_last_x;
+        int                   m_y;
+        pod_array<cover_type> m_covers;
+        pod_array<span>       m_spans;
+        span*                 m_cur_span;
     };
 
 
@@ -357,27 +344,19 @@
 
 
         //--------------------------------------------------------------------
-        ~scanline32_u8()
-        {
-            delete [] m_covers;
-        }
-
         scanline32_u8() :
             m_min_x(0),
-            m_max_len(0),
             m_last_x(0x7FFFFFF0),
-            m_covers(0)
+            m_covers()
         {}
 
         //--------------------------------------------------------------------
         void reset(int min_x, int max_x)
         {
             unsigned max_len = max_x - min_x + 2;
-            if(max_len > m_max_len)
+            if(max_len > m_covers.size())
             {
-                delete [] m_covers;
-                m_covers  = new cover_type [max_len];
-                m_max_len = max_len;
+                m_covers.resize(max_len);
             }
             m_last_x = 0x7FFFFFF0;
             m_min_x  = min_x;
@@ -395,7 +374,7 @@
             }
             else
             {
-                m_spans.add(span(coord_type(x + m_min_x), 1, m_covers + x));
+                m_spans.add(span(coord_type(x + m_min_x), 1, &m_covers[x]));
             }
             m_last_x = x;
         }
@@ -404,14 +383,16 @@
         void add_cells(int x, unsigned len, const cover_type* covers)
         {
             x -= m_min_x;
-            memcpy(m_covers + x, covers, len * sizeof(cover_type));
+            memcpy(&m_covers[x], covers, len * sizeof(cover_type));
             if(x == m_last_x+1)
             {
                 m_spans.last().len += coord_type(len);
             }
             else
             {
-                m_spans.add(span(coord_type(x + m_min_x), coord_type(len), m_covers + x));
+                m_spans.add(span(coord_type(x + m_min_x), 
+                                 coord_type(len), 
+                                 &m_covers[x]));
             }
             m_last_x = x + len - 1;
         }
@@ -420,14 +401,16 @@
         void add_span(int x, unsigned len, unsigned cover)
         {
             x -= m_min_x;
-            memset(m_covers + x, cover, len);
+            memset(&m_covers[x], cover, len);
             if(x == m_last_x+1)
             {
                 m_spans.last().len += coord_type(len);
             }
             else
             {
-                m_spans.add(span(coord_type(x + m_min_x), coord_type(len), m_covers + x));
+                m_spans.add(span(coord_type(x + m_min_x), 
+                                 coord_type(len), 
+                                 &m_covers[x]));
             }
             m_last_x = x + len - 1;
         }
@@ -456,12 +439,11 @@
         const self_type& operator = (const self_type&);
 
     private:
-        int             m_min_x;
-        unsigned        m_max_len;
-        int             m_last_x;
-        int             m_y;
-        cover_type*     m_covers;
-        span_array_type m_spans;
+        int                   m_min_x;
+        int                   m_last_x;
+        int                   m_y;
+        pod_array<cover_type> m_covers;
+        span_array_type       m_spans;
     };
 
 

Modified: trunk/agg/include/agg_span_allocator.h
===================================================================
--- trunk/agg/include/agg_span_allocator.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_span_allocator.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -16,7 +16,7 @@
 #ifndef AGG_SPAN_ALLOCATOR_INCLUDED
 #define AGG_SPAN_ALLOCATOR_INCLUDED
 
-#include "agg_basics.h"
+#include "agg_array.h"
 
 namespace agg
 {
@@ -27,44 +27,24 @@
         typedef ColorT color_type;
 
         //--------------------------------------------------------------------
-        ~span_allocator()
-        {
-            delete [] m_span;
-        }
-
-        //--------------------------------------------------------------------
-        span_allocator() :
-            m_max_span_len(0),
-            m_span(0)
-        {
-        }
-
-        //--------------------------------------------------------------------
         AGG_INLINE color_type* allocate(unsigned span_len)
         {
-            if(span_len > m_max_span_len)
+            if(span_len > m_span.size())
             {
                 // To reduce the number of reallocs we align the 
                 // span_len to 256 color elements. 
                 // Well, I just like this number and it looks reasonable.
                 //-----------------------
-                delete [] m_span;
-                span_len = ((span_len + 255) >> 8) << 8;
-                m_span = new color_type[m_max_span_len = span_len];
+                m_span.resize(((span_len + 255) >> 8) << 8);
             }
-            return m_span;
+            return &m_span[0];
         }
 
-        AGG_INLINE color_type* span()               { return m_span; }
-        AGG_INLINE unsigned    max_span_len() const { return m_max_span_len; }
+        AGG_INLINE color_type* span()               { return &m_span[0]; }
+        AGG_INLINE unsigned    max_span_len() const { return m_span.size(); }
 
     private:
-        //--------------------------------------------------------------------
-        span_allocator(const span_allocator<ColorT>&);
-        const span_allocator<ColorT>& operator = (const span_allocator<ColorT>&);
-
-        unsigned    m_max_span_len;
-        color_type* m_span;
+        pod_array<color_type> m_span;
     };
 }
 

Modified: trunk/agg/include/agg_span_converter.h
===================================================================
--- trunk/agg/include/agg_span_converter.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_span_converter.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -29,6 +29,9 @@
         span_converter(SpanGenerator& span_gen, SpanConverter& span_cnv) : 
             m_span_gen(&span_gen), m_span_cnv(&span_cnv) {}
 
+        void attach_generator(SpanGenerator& span_gen) { m_span_gen = &span_gen; }
+        void attach_converter(SpanConverter& span_cnv) { m_span_cnv = &span_cnv; }
+
         //--------------------------------------------------------------------
         void prepare() 
         { 

Modified: trunk/agg/include/agg_span_gradient.h
===================================================================
--- trunk/agg/include/agg_span_gradient.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_span_gradient.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -146,6 +146,10 @@
     };
 
 
+
+
+
+
     //==========================================================gradient_circle
     class gradient_circle
     {
@@ -168,7 +172,6 @@
         }
     };
 
-
     //========================================================gradient_radial_d
     class gradient_radial_d
     {
@@ -179,25 +182,24 @@
         }
     };
 
-
     //====================================================gradient_radial_focus
     class gradient_radial_focus
     {
     public:
         //---------------------------------------------------------------------
         gradient_radial_focus() : 
-            m_radius(100 * gradient_subpixel_scale), 
-            m_focus_x(0), 
-            m_focus_y(0)
+            m_r(100 * gradient_subpixel_scale), 
+            m_fx(0), 
+            m_fy(0)
         {
             update_values();
         }
 
         //---------------------------------------------------------------------
         gradient_radial_focus(double r, double fx, double fy) : 
-            m_radius (iround(r  * gradient_subpixel_scale)), 
-            m_focus_x(iround(fx * gradient_subpixel_scale)), 
-            m_focus_y(iround(fy * gradient_subpixel_scale))
+            m_r (iround(r  * gradient_subpixel_scale)), 
+            m_fx(iround(fx * gradient_subpixel_scale)), 
+            m_fy(iround(fy * gradient_subpixel_scale))
         {
             update_values();
         }
@@ -205,111 +207,62 @@
         //---------------------------------------------------------------------
         void init(double r, double fx, double fy)
         {
-            m_radius  = iround(r  * gradient_subpixel_scale);
-            m_focus_x = iround(fx * gradient_subpixel_scale);
-            m_focus_y = iround(fy * gradient_subpixel_scale);
+            m_r  = iround(r  * gradient_subpixel_scale);
+            m_fx = iround(fx * gradient_subpixel_scale);
+            m_fy = iround(fy * gradient_subpixel_scale);
             update_values();
         }
 
         //---------------------------------------------------------------------
-        double radius()  const { return double(m_radius)  / gradient_subpixel_scale; }
-        double focus_x() const { return double(m_focus_x) / gradient_subpixel_scale; }
-        double focus_y() const { return double(m_focus_y) / gradient_subpixel_scale; }
+        double radius()  const { return double(m_r)  / gradient_subpixel_scale; }
+        double focus_x() const { return double(m_fx) / gradient_subpixel_scale; }
+        double focus_y() const { return double(m_fy) / gradient_subpixel_scale; }
 
         //---------------------------------------------------------------------
         int calculate(int x, int y, int) const
         {
-            double solution_x;
-            double solution_y;
-
-            // Special case to avoid divide by zero or very near zero
-            //---------------------------------
-            if(x == iround(m_focus_x))
-            {		   
-                solution_x = m_focus_x;
-                solution_y = 0.0;
-                solution_y += (y > m_focus_y) ? m_trivial : -m_trivial;
-            }
-            else 
-            {    
-                // Slope of the focus-current line
-                //-------------------------------
-                double slope = double(y - m_focus_y) / double(x - m_focus_x);
-
-                // y-intercept of that same line
-                //--------------------------------
-                double yint  = double(y) - (slope * x); 
-		
-                // Use the classical quadratic formula to calculate 
-                // the intersection point		  
-                //--------------------------------
-                double a = (slope * slope) + 1; 
-                double b =  2 * slope * yint;
-                double c =  yint * yint - m_radius2;
-                double det = sqrt((b * b) - (4.0 * a * c));
-		        solution_x = -b;
-		
-                // Choose the positive or negative root depending
-                // on where the X coord lies with respect to the focus.
-                solution_x += (x < m_focus_x) ? -det : det;
-		        solution_x /= 2.0 * a;
-
-                // Calculating of Y is trivial
-                solution_y  = (slope * solution_x) + yint;
-            }	                    	
-
-            // Calculate the percentage (0...1) of the current point along the 
-            // focus-circumference line and return the normalized (0...d) value
-            //-------------------------------
-            solution_x -= double(m_focus_x);
-            solution_y -= double(m_focus_y);
-            double int_to_focus = solution_x * solution_x + solution_y * solution_y;
-            double cur_to_focus = double(x - m_focus_x) * double(x - m_focus_x) +
-                                  double(y - m_focus_y) * double(y - m_focus_y);
-
-            return iround(sqrt(cur_to_focus / int_to_focus) * m_radius);
+            double dx = x - m_fx;
+            double dy = y - m_fy;
+            double d2 = dx * m_fy - dy * m_fx;
+            double d3 = m_r2 * (dx * dx + dy * dy) - d2 * d2;
+            return iround((dx * m_fx + dy * m_fy + sqrt(fabs(d3))) * m_mul);
         }
 
     private:
         //---------------------------------------------------------------------
         void update_values()
         {
-            // For use in the quadratic equation
-            //-------------------------------
-            m_radius2 = double(m_radius) * double(m_radius);
-
-            double dist = sqrt(double(m_focus_x) * double(m_focus_x) + 
-                               double(m_focus_y) * double(m_focus_y));
-
-            // Test if distance from focus to center is greater than the radius
-            // For the sake of assurance factor restrict the point to be 
-            // no further than 99% of the radius.
-            //-------------------------------
-            double r = m_radius * 0.99;
-            if(dist > r) 
-            { 
-                // clamp focus to radius
-                // x = r cos theta, y = r sin theta
-                //------------------------
-                double a = atan2(double(m_focus_y), double(m_focus_x));
-                m_focus_x = iround(r * cos(a));
-                m_focus_y = iround(r * sin(a));
+            // Calculate the invariant values. In case the focal center
+            // lies exactly on the gradient circle the divisor degenerates
+            // into zero. In this case we just move the focal center by
+            // one subpixel unit possibly in the direction to the origin (0,0)
+            // and calculate the values again.
+            //-------------------------
+            m_r2  = double(m_r)  * double(m_r);
+            m_fx2 = double(m_fx) * double(m_fx);
+            m_fy2 = double(m_fy) * double(m_fy);
+            double d = (m_r2 - (m_fx2 + m_fy2));
+            if(d == 0)
+            {
+                if(m_fx) { if(m_fx < 0) ++m_fx; else --m_fx; }
+                if(m_fy) { if(m_fy < 0) ++m_fy; else --m_fy; }
+                m_fx2 = double(m_fx) * double(m_fx);
+                m_fy2 = double(m_fy) * double(m_fy);
+                d = (m_r2 - (m_fx2 + m_fy2));
             }
-
-            // Calculate the solution to be used in the case where x == focus_x
-            //------------------------------
-            m_trivial = sqrt(m_radius2 - (m_focus_x * m_focus_x));
+            m_mul = m_r / d;
         }
 
-        int m_radius;
-        int m_focus_x;
-        int m_focus_y;
-        double m_radius2;
-        double m_trivial;
+        int    m_r;
+        int    m_fx;
+        int    m_fy;
+        double m_r2;
+        double m_fx2;
+        double m_fy2;
+        double m_mul;
     };
 
 
-
     //==============================================================gradient_x
     class gradient_x
     {
@@ -325,7 +278,6 @@
         static int calculate(int, int y, int) { return y; }
     };
 
-
     //========================================================gradient_diamond
     class gradient_diamond
     {
@@ -338,7 +290,6 @@
         }
     };
 
-
     //=============================================================gradient_xy
     class gradient_xy
     {
@@ -349,7 +300,6 @@
         }
     };
 
-
     //========================================================gradient_sqrt_xy
     class gradient_sqrt_xy
     {
@@ -360,7 +310,6 @@
         }
     };
 
-
     //==========================================================gradient_conic
     class gradient_conic
     {
@@ -371,7 +320,6 @@
         }
     };
 
-
     //=================================================gradient_repeat_adaptor
     template<class GradientF> class gradient_repeat_adaptor
     {
@@ -390,7 +338,6 @@
         const GradientF* m_gradient;
     };
 
-
     //================================================gradient_reflect_adaptor
     template<class GradientF> class gradient_reflect_adaptor
     {

Modified: trunk/agg/include/agg_span_image_filter.h
===================================================================
--- trunk/agg/include/agg_span_image_filter.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_span_image_filter.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -46,6 +46,7 @@
             m_dx_int(image_subpixel_scale / 2),
             m_dy_int(image_subpixel_scale / 2)
         {}
+        void attach(source_type& v) { m_src = &v; }
 
         //--------------------------------------------------------------------
                source_type& source()            { return *m_src; }
@@ -57,7 +58,6 @@
         double filter_dy_dbl()            const { return m_dy_dbl; }
 
         //--------------------------------------------------------------------
-        void set_source(source_type& v)          { m_src = &v; }
         void interpolator(interpolator_type& v)  { m_interpolator = &v; }
         void filter(const image_filter_lut& v)   { m_filter = &v; }
         void filter_offset(double dx, double dy)
@@ -136,33 +136,29 @@
 
             base_type::interpolator().transformer().scaling_abs(&scale_x, &scale_y);
 
-            m_rx     = image_subpixel_scale;
-            m_ry     = image_subpixel_scale;
-            m_rx_inv = image_subpixel_scale;
-            m_ry_inv = image_subpixel_scale;
-
-            scale_x *= m_blur_x;
-            scale_y *= m_blur_y;
-
             if(scale_x * scale_y > m_scale_limit)
             {
                 scale_x = scale_x * m_scale_limit / (scale_x * scale_y);
                 scale_y = scale_y * m_scale_limit / (scale_x * scale_y);
             }
 
-            if(scale_x > 1.0001)
-            {
-                if(scale_x > m_scale_limit) scale_x = m_scale_limit;
-                m_rx     = uround(    scale_x * double(image_subpixel_scale));
-                m_rx_inv = uround(1.0/scale_x * double(image_subpixel_scale));
-            }
+            if(scale_x < 1) scale_x = 1;
+            if(scale_y < 1) scale_y = 1;
 
-            if(scale_y > 1.0001)
-            {
-                if(scale_y > m_scale_limit) scale_y = m_scale_limit;
-                m_ry     = uround(    scale_y * double(image_subpixel_scale));
-                m_ry_inv = uround(1.0/scale_y * double(image_subpixel_scale));
-            }
+            if(scale_x > m_scale_limit) scale_x = m_scale_limit;
+            if(scale_y > m_scale_limit) scale_y = m_scale_limit;
+
+            scale_x *= m_blur_x;
+            scale_y *= m_blur_y;
+
+            if(scale_x < 1) scale_x = 1;
+            if(scale_y < 1) scale_y = 1;
+
+            m_rx     = uround(    scale_x * double(image_subpixel_scale));
+            m_rx_inv = uround(1.0/scale_x * double(image_subpixel_scale));
+
+            m_ry     = uround(    scale_y * double(image_subpixel_scale));
+            m_ry_inv = uround(1.0/scale_y * double(image_subpixel_scale));
         }
 
     protected:
@@ -219,6 +215,24 @@
                                 m_blur_y = uround(v * double(image_subpixel_scale)); }
 
     protected:
+        AGG_INLINE void adjust_scale(int* rx, int* ry)
+        {
+            if(*rx < image_subpixel_scale) *rx = image_subpixel_scale;
+            if(*ry < image_subpixel_scale) *ry = image_subpixel_scale;
+            if(*rx > image_subpixel_scale * m_scale_limit) 
+            {
+                *rx = image_subpixel_scale * m_scale_limit;
+            }
+            if(*ry > image_subpixel_scale * m_scale_limit) 
+            {
+                *ry = image_subpixel_scale * m_scale_limit;
+            }
+            *rx = (*rx * m_blur_x) >> image_subpixel_shift;
+            *ry = (*ry * m_blur_y) >> image_subpixel_shift;
+            if(*rx < image_subpixel_scale) *rx = image_subpixel_scale;
+            if(*ry < image_subpixel_scale) *ry = image_subpixel_scale;
+        }
+
         int m_scale_limit;
         int m_blur_x;
         int m_blur_y;

Modified: trunk/agg/include/agg_span_image_filter_gray.h
===================================================================
--- trunk/agg/include/agg_span_image_filter_gray.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_span_image_filter_gray.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -676,36 +676,11 @@
                 int ry_inv = image_subpixel_scale;
                 base_type::interpolator().coordinates(&x,  &y);
                 base_type::interpolator().local_scale(&rx, &ry);
+                base_type::adjust_scale(&rx, &ry);
 
-                rx = (rx * base_type::m_blur_x) >> image_subpixel_shift;
-                ry = (ry * base_type::m_blur_y) >> image_subpixel_shift;
+                rx_inv = image_subpixel_scale * image_subpixel_scale / rx;
+                ry_inv = image_subpixel_scale * image_subpixel_scale / ry;
 
-                if(rx < image_subpixel_scale)
-                {
-                    rx = image_subpixel_scale;
-                }
-                else
-                {
-                    if(rx > image_subpixel_scale * base_type::m_scale_limit) 
-                    {
-                        rx = image_subpixel_scale * base_type::m_scale_limit;
-                    }
-                    rx_inv = image_subpixel_scale * image_subpixel_scale / rx;
-                }
-
-                if(ry < image_subpixel_scale)
-                {
-                    ry = image_subpixel_scale;
-                }
-                else
-                {
-                    if(ry > image_subpixel_scale * base_type::m_scale_limit) 
-                    {
-                        ry = image_subpixel_scale * base_type::m_scale_limit;
-                    }
-                    ry_inv = image_subpixel_scale * image_subpixel_scale / ry;
-                }
-
                 int radius_x = (diameter * rx) >> 1;
                 int radius_y = (diameter * ry) >> 1;
                 int len_x_lr = 

Modified: trunk/agg/include/agg_span_image_filter_rgb.h
===================================================================
--- trunk/agg/include/agg_span_image_filter_rgb.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_span_image_filter_rgb.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -808,36 +808,11 @@
                 int ry_inv = image_subpixel_scale;
                 base_type::interpolator().coordinates(&x,  &y);
                 base_type::interpolator().local_scale(&rx, &ry);
+                base_type::adjust_scale(&rx, &ry);
 
-                rx = (rx * base_type::m_blur_x) >> image_subpixel_shift;
-                ry = (ry * base_type::m_blur_y) >> image_subpixel_shift;
+                rx_inv = image_subpixel_scale * image_subpixel_scale / rx;
+                ry_inv = image_subpixel_scale * image_subpixel_scale / ry;
 
-                if(rx < image_subpixel_scale)
-                {
-                    rx = image_subpixel_scale;
-                }
-                else
-                {
-                    if(rx > image_subpixel_scale * base_type::m_scale_limit) 
-                    {
-                        rx = image_subpixel_scale * base_type::m_scale_limit;
-                    }
-                    rx_inv = image_subpixel_scale * image_subpixel_scale / rx;
-                }
-
-                if(ry < image_subpixel_scale)
-                {
-                    ry = image_subpixel_scale;
-                }
-                else
-                {
-                    if(ry > image_subpixel_scale * base_type::m_scale_limit) 
-                    {
-                        ry = image_subpixel_scale * base_type::m_scale_limit;
-                    }
-                    ry_inv = image_subpixel_scale * image_subpixel_scale / ry;
-                }
-
                 int radius_x = (diameter * rx) >> 1;
                 int radius_y = (diameter * ry) >> 1;
                 int len_x_lr = 

Modified: trunk/agg/include/agg_span_image_filter_rgba.h
===================================================================
--- trunk/agg/include/agg_span_image_filter_rgba.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_span_image_filter_rgba.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -832,36 +832,11 @@
                 int ry_inv = image_subpixel_scale;
                 base_type::interpolator().coordinates(&x,  &y);
                 base_type::interpolator().local_scale(&rx, &ry);
+                base_type::adjust_scale(&rx, &ry);
 
-                rx = (rx * base_type::m_blur_x) >> image_subpixel_shift;
-                ry = (ry * base_type::m_blur_y) >> image_subpixel_shift;
+                rx_inv = image_subpixel_scale * image_subpixel_scale / rx;
+                ry_inv = image_subpixel_scale * image_subpixel_scale / ry;
 
-                if(rx < image_subpixel_scale)
-                {
-                    rx = image_subpixel_scale;
-                }
-                else
-                {
-                    if(rx > image_subpixel_scale * base_type::m_scale_limit) 
-                    {
-                        rx = image_subpixel_scale * base_type::m_scale_limit;
-                    }
-                    rx_inv = image_subpixel_scale * image_subpixel_scale / rx;
-                }
-
-                if(ry < image_subpixel_scale)
-                {
-                    ry = image_subpixel_scale;
-                }
-                else
-                {
-                    if(ry > image_subpixel_scale * base_type::m_scale_limit) 
-                    {
-                        ry = image_subpixel_scale * base_type::m_scale_limit;
-                    }
-                    ry_inv = image_subpixel_scale * image_subpixel_scale / ry;
-                }
-
                 int radius_x = (diameter * rx) >> 1;
                 int radius_y = (diameter * ry) >> 1;
                 int len_x_lr = 

Modified: trunk/agg/include/agg_span_pattern_gray.h
===================================================================
--- trunk/agg/include/agg_span_pattern_gray.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_span_pattern_gray.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -50,9 +50,9 @@
         {}
 
         //--------------------------------------------------------------------
+        void   attach(source_type& v)      { m_src = &v; }
                source_type& source()       { return *m_src; }
         const  source_type& source() const { return *m_src; }
-        void   set_source(source_type& v)  { m_src = &v; }
 
         //--------------------------------------------------------------------
         void       offset_x(unsigned v) { m_offset_x = v; }

Modified: trunk/agg/include/agg_span_pattern_rgb.h
===================================================================
--- trunk/agg/include/agg_span_pattern_rgb.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_span_pattern_rgb.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -51,9 +51,9 @@
         {}
 
         //--------------------------------------------------------------------
+        void   attach(source_type& v)      { m_src = &v; }
                source_type& source()       { return *m_src; }
         const  source_type& source() const { return *m_src; }
-        void   set_source(source_type& v)  { m_src = &v; }
 
         //--------------------------------------------------------------------
         void       offset_x(unsigned v) { m_offset_x = v; }

Modified: trunk/agg/include/agg_span_pattern_rgba.h
===================================================================
--- trunk/agg/include/agg_span_pattern_rgba.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_span_pattern_rgba.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -50,9 +50,9 @@
         {}
 
         //--------------------------------------------------------------------
+        void   attach(source_type& v)      { m_src = &v; }
                source_type& source()       { return *m_src; }
         const  source_type& source() const { return *m_src; }
-        void   set_source(source_type& v)  { m_src = &v; }
 
         //--------------------------------------------------------------------
         void       offset_x(unsigned v) { m_offset_x = v; }
@@ -75,7 +75,7 @@
                 span->g = p[order_type::G];
                 span->b = p[order_type::B];
                 span->a = p[order_type::A];
-                p = m_src->next_x();
+                p = (const value_type*)m_src->next_x();
                 ++span;
             }
             while(--len);

Modified: trunk/agg/include/agg_trans_affine.h
===================================================================
--- trunk/agg/include/agg_trans_affine.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_trans_affine.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -24,7 +24,7 @@
 
 namespace agg
 {
-    const double affine_epsilon = 1e-14; // About of precision of doubles
+    const double affine_epsilon = 1e-14; 
 
     //============================================================trans_affine
     //
@@ -84,48 +84,58 @@
     // m *= agg::trans_affine_rotation(30.0 * 3.1415926 / 180.0);  // rotate
     // m *= agg::trans_affine_translation(100.0, 100.0);           // move back to (100,100)
     //----------------------------------------------------------------------
-    class trans_affine
+    struct trans_affine
     {
-    public:
+        double sx, shy, shx, sy, tx, ty;
+
         //------------------------------------------ Construction
-        // Construct an identity matrix - it does not transform anything
+        // Identity matrix
         trans_affine() :
-            m0(1.0), m1(0.0), m2(0.0), m3(1.0), m4(0.0), m5(0.0)
+            sx(1.0), shy(0.0), shx(0.0), sy(1.0), tx(0.0), ty(0.0)
         {}
 
-        // Construct a custom matrix. Usually used in derived classes
-        trans_affine(double v0, double v1, double v2, double v3, double v4, double v5) :
-            m0(v0), m1(v1), m2(v2), m3(v3), m4(v4), m5(v5)
+        // Custom matrix. Usually used in derived classes
+        trans_affine(double v0, double v1, double v2, 
+                     double v3, double v4, double v5) :
+            sx(v0), shy(v1), shx(v2), sy(v3), tx(v4), ty(v5)
         {}
 
-        // Construct a matrix to transform a parallelogram to another one.
-        trans_affine(const double* rect, const double* parl)
-        {
-            parl_to_parl(rect, parl);
-        }
+        // Custom matrix from m[6]
+        explicit trans_affine(const double* m) :
+            sx(m[0]), shy(m[1]), shx(m[2]), sy(m[3]), tx(m[4]), ty(m[5])
+        {}
 
-        // Construct a matrix to transform a rectangle to a parallelogram.
+        // Rectangle to a parallelogram.
         trans_affine(double x1, double y1, double x2, double y2, 
                      const double* parl)
         {
             rect_to_parl(x1, y1, x2, y2, parl);
         }
 
-        // Construct a matrix to transform a parallelogram to a rectangle.
+        // Parallelogram to a rectangle.
         trans_affine(const double* parl, 
                      double x1, double y1, double x2, double y2)
         {
             parl_to_rect(parl, x1, y1, x2, y2);
         }
 
+        // Arbitrary parallelogram transformation.
+        trans_affine(const double* src, const double* dst)
+        {
+            parl_to_parl(src, dst);
+        }
 
         //---------------------------------- Parellelogram transformations
-        // Calculate a matrix to transform a parallelogram to another one.
-        // src and dst are pointers to arrays of three points 
-        // (double[6], x,y,...) that identify three corners of the 
-        // parallelograms assuming implicit fourth points.
-        // There are also transformations rectangtle to parallelogram and 
-        // parellelogram to rectangle
+        // transform a parallelogram to another one. Src and dst are 
+        // pointers to arrays of three points (double[6], x1,y1,...) that 
+        // identify three corners of the parallelograms assuming implicit 
+        // fourth point. The arguments are arrays of double[6] mapped 
+        // to x1,y1, x2,y2, x3,y3  where the coordinates are:
+        //        *-----------------*
+        //       /          (x3,y3)/
+        //      /                 /
+        //     /(x1,y1)   (x2,y2)/
+        //    *-----------------*
         const trans_affine& parl_to_parl(const double* src, 
                                          const double* dst);
 
@@ -139,9 +149,15 @@
 
 
         //------------------------------------------ Operations
-        // Reset - actually load an identity matrix
+        // Reset - load an identity matrix
         const trans_affine& reset();
 
+        // Direct transformations operations
+        const trans_affine& translate(double x, double y);
+        const trans_affine& rotate(double a);
+        const trans_affine& scale(double s);
+        const trans_affine& scale(double x, double y);
+
         // Multiply matrix to another one
         const trans_affine& multiply(const trans_affine& m);
 
@@ -169,38 +185,38 @@
         // Store matrix to an array [6] of double
         void store_to(double* m) const
         {
-            *m++ = m0; *m++ = m1; *m++ = m2; *m++ = m3; *m++ = m4; *m++ = m5;
+            *m++ = sx; *m++ = shy; *m++ = shx; *m++ = sy; *m++ = tx; *m++ = ty;
         }
 
         // Load matrix from an array [6] of double
         const trans_affine& load_from(const double* m)
         {
-            m0 = *m++; m1 = *m++; m2 = *m++; m3 = *m++; m4 = *m++;  m5 = *m++;
+            sx = *m++; shy = *m++; shx = *m++; sy = *m++; tx = *m++;  ty = *m++;
             return *this;
         }
 
         //------------------------------------------- Operators
         
-        // Multiply current matrix to another one
+        // Multiply the matrix by another one
         const trans_affine& operator *= (const trans_affine& m)
         {
             return multiply(m);
         }
 
-        // Multiply current matrix to inverse of another one
+        // Multiply the matrix by inverse of another one
         const trans_affine& operator /= (const trans_affine& m)
         {
             return multiply_inv(m);
         }
 
-        // Multiply current matrix to another one and return
+        // Multiply the matrix by another one and return
         // the result in a separete matrix.
         trans_affine operator * (const trans_affine& m)
         {
             return trans_affine(*this).multiply(m);
         }
 
-        // Multiply current matrix to inverse of another one 
+        // Multiply the matrix by inverse of another one 
         // and return the result in a separete matrix.
         trans_affine operator / (const trans_affine& m)
         {
@@ -227,89 +243,139 @@
         }
 
         //-------------------------------------------- Transformations
-        // Direct transformation x and y
+        // Direct transformation of x and y
         void transform(double* x, double* y) const;
 
-        // Direct transformation x and y, 2x2 matrix only, no translation
+        // Direct transformation of x and y, 2x2 matrix only, no translation
         void transform_2x2(double* x, double* y) const;
 
-        // Inverse transformation x and y. It works slower than the 
-        // direct transformation, so if the performance is critical 
-        // it's better to invert() the matrix and then use transform()
+        // Inverse transformation of x and y. It works slower than the 
+        // direct transformation. For massive operations it's better to 
+        // invert() the matrix and then use direct transformations. 
         void inverse_transform(double* x, double* y) const;
 
         //-------------------------------------------- Auxiliary
         // Calculate the determinant of matrix
         double determinant() const
         {
-            return 1.0 / (m0 * m3 - m1 * m2);
+            return sx * sy - shy * shx;
         }
 
+        // Calculate the reciprocal of the determinant
+        double determinant_reciprocal() const
+        {
+            return 1.0 / (sx * sy - shy * shx);
+        }
+
         // Get the average scale (by X and Y). 
         // Basically used to calculate the approximation_scale when
         // decomposinting curves into line segments.
         double scale() const;
 
+        // Check to see if the matrix is not degenerate
+        bool is_valid(double epsilon = affine_epsilon) const;
+
         // Check to see if it's an identity matrix
         bool is_identity(double epsilon = affine_epsilon) const;
 
         // Check to see if two matrices are equal
         bool is_equal(const trans_affine& m, double epsilon = affine_epsilon) const;
 
-        // Determine the major parameters. Use carefully considering degenerate matrices
+        // Determine the major parameters. Use with caution considering 
+        // possible degenerate cases.
         double rotation() const;
         void   translation(double* dx, double* dy) const;
-        void   scaling(double* sx, double* sy) const;
-        void   scaling_abs(double* sx, double* sy) const
-        {
-            *sx = sqrt(m0*m0 + m2*m2);
-            *sy = sqrt(m1*m1 + m3*m3);
-        }
-
-    private:
-        double m0;
-        double m1;
-        double m2;
-        double m3;
-        double m4;
-        double m5;
+        void   scaling(double* x, double* y) const;
+        void   scaling_abs(double* x, double* y) const;
     };
 
     //------------------------------------------------------------------------
     inline void trans_affine::transform(double* x, double* y) const
     {
-        register double tx = *x;
-        *x = tx * m0 + *y * m2 + m4;
-        *y = tx * m1 + *y * m3 + m5;
+        register double tmp = *x;
+        *x = tmp * sx  + *y * shx + tx;
+        *y = tmp * shy + *y * sy  + ty;
     }
 
     //------------------------------------------------------------------------
     inline void trans_affine::transform_2x2(double* x, double* y) const
     {
-        register double tx = *x;
-        *x = tx * m0 + *y * m2;
-        *y = tx * m1 + *y * m3;
+        register double tmp = *x;
+        *x = tmp * sx  + *y * shx;
+        *y = tmp * shy + *y * sy;
     }
 
     //------------------------------------------------------------------------
     inline void trans_affine::inverse_transform(double* x, double* y) const
     {
-        register double d = determinant();
-        register double a = (*x - m4) * d;
-        register double b = (*y - m5) * d;
-        *x = a * m3 - b * m2;
-        *y = b * m0 - a * m1;
+        register double d = determinant_reciprocal();
+        register double a = (*x - tx) * d;
+        register double b = (*y - ty) * d;
+        *x = a * sy - b * shx;
+        *y = b * sx - a * shy;
     }
 
     //------------------------------------------------------------------------
     inline double trans_affine::scale() const
     {
-        double x = 0.707106781 * m0 + 0.707106781 * m2;
-        double y = 0.707106781 * m1 + 0.707106781 * m3;
+        double x = 0.707106781 * sx  + 0.707106781 * shx;
+        double y = 0.707106781 * shy + 0.707106781 * sy;
         return sqrt(x*x + y*y);
     }
 
     //------------------------------------------------------------------------
+    inline const trans_affine& trans_affine::translate(double x, double y) 
+    { 
+        tx += x;
+        ty += y; 
+        return *this;
+    }
+
+    //------------------------------------------------------------------------
+    inline const trans_affine& trans_affine::rotate(double a) 
+    {
+        double ca = cos(a); 
+        double sa = sin(a);
+        double t0 = sx  * ca - shy * sa;
+        double t2 = shx * ca - sy * sa;
+        double t4 = tx  * ca - ty * sa;
+        shy = sx  * sa + shy * ca;
+        sy  = shx * sa + sy * ca; 
+        ty  = tx  * sa + ty * ca;
+        sx  = t0;
+        shx = t2;
+        tx  = t4;
+        return *this;
+    }
+
+    //------------------------------------------------------------------------
+    inline const trans_affine& trans_affine::scale(double x, double y) 
+    {
+        double mm0 = x; // Possible hint for the optimizer
+        double mm3 = y; 
+        sx  *= mm0;
+        shx *= mm0;
+        tx  *= mm0;
+        shy *= mm3;
+        sy  *= mm3;
+        ty  *= mm3;
+        return *this;
+    }
+
+    //------------------------------------------------------------------------
+    inline const trans_affine& trans_affine::scale(double s) 
+    {
+        double m = s; // Possible hint for the optimizer
+        sx  *= m;
+        shx *= m;
+        tx  *= m;
+        shy *= m;
+        sy  *= m;
+        ty  *= m;
+        return *this;
+    }
+
+    //------------------------------------------------------------------------
     inline const trans_affine& trans_affine::premultiply(const trans_affine& m)
     {
         trans_affine t = m;
@@ -321,8 +387,7 @@
     {
         trans_affine t = m;
         t.invert();
-        multiply(t);
-        return *this;
+        return multiply(t);
     }
 
     //------------------------------------------------------------------------
@@ -333,6 +398,16 @@
         return *this = t.multiply(*this);
     }
 
+    //------------------------------------------------------------------------
+    inline void trans_affine::scaling_abs(double* x, double* y) const
+    {
+        // Used to calculate scaling coefficients in image resampling. 
+        // When there is considerable shear this method gives us much
+        // better estimation than just sx, sy.
+        *x = sqrt(sx  * sx  + shx * shx);
+        *y = sqrt(shy * shy + sy  * sy);
+    }
+
     //====================================================trans_affine_rotation
     // Rotation matrix. sin() and cos() are calculated twice for the same angle.
     // There's no harm because the performance of sin()/cos() is very good on all
@@ -347,12 +422,12 @@
     };
 
     //====================================================trans_affine_scaling
-    // Scaling matrix. sx, sy - scale coefficients by X and Y respectively
+    // Scaling matrix. x, y - scale coefficients by X and Y respectively
     class trans_affine_scaling : public trans_affine
     {
     public:
-        trans_affine_scaling(double sx, double sy) : 
-          trans_affine(sx, 0.0, 0.0, sy, 0.0, 0.0)
+        trans_affine_scaling(double x, double y) : 
+          trans_affine(x, 0.0, 0.0, y, 0.0, 0.0)
         {}
 
         trans_affine_scaling(double s) : 
@@ -365,8 +440,8 @@
     class trans_affine_translation : public trans_affine
     {
     public:
-        trans_affine_translation(double tx, double ty) : 
-          trans_affine(1.0, 0.0, 0.0, 1.0, tx, ty)
+        trans_affine_translation(double x, double y) : 
+          trans_affine(1.0, 0.0, 0.0, 1.0, x, y)
         {}
     };
 
@@ -375,8 +450,8 @@
     class trans_affine_skewing : public trans_affine
     {
     public:
-        trans_affine_skewing(double sx, double sy) : 
-          trans_affine(1.0, tan(sy), tan(sx), 1.0, 0.0, 0.0)
+        trans_affine_skewing(double x, double y) : 
+          trans_affine(1.0, tan(y), tan(x), 1.0, 0.0, 0.0)
         {}
     };
 
@@ -402,6 +477,40 @@
     };
 
 
+    //============================================trans_affine_reflection_unit
+    // Reflection matrix. Reflect coordinates across the line through 
+    // the origin containing the unit vector (ux, uy).
+    // Contributed by John Horigan
+    class trans_affine_reflection_unit : public trans_affine
+    {
+    public:
+        trans_affine_reflection_unit(double ux, double uy) :
+          trans_affine(2.0 * ux * ux - 1.0, 
+                       2.0 * ux * uy, 
+                       2.0 * ux * uy, 
+                       2.0 * uy * uy - 1.0, 
+                       0.0, 0.0)
+        {}
+    };
+
+
+    //=================================================trans_affine_reflection
+    // Reflection matrix. Reflect coordinates across the line through 
+    // the origin at the angle a or containing the non-unit vector (x, y).
+    // Contributed by John Horigan
+    class trans_affine_reflection : public trans_affine_reflection_unit
+    {
+    public:
+        trans_affine_reflection(double a) :
+          trans_affine_reflection_unit(cos(a), sin(a))
+        {}
+
+
+        trans_affine_reflection(double x, double y) :
+          trans_affine_reflection_unit(x / sqrt(x * x + y * y), y / sqrt(x * x + y * y))
+        {}
+    };
+
 }
 
 

Modified: trunk/agg/include/agg_trans_perspective.h
===================================================================
--- trunk/agg/include/agg_trans_perspective.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_trans_perspective.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -19,125 +19,212 @@
 #ifndef AGG_TRANS_PERSPECTIVE_INCLUDED
 #define AGG_TRANS_PERSPECTIVE_INCLUDED
 
-#include "agg_basics.h"
-#include "agg_simul_eq.h"
+#include "agg_trans_affine.h"
 
 namespace agg
 {
     //=======================================================trans_perspective
-    class trans_perspective
+    struct trans_perspective
     {
-    public:
-        //--------------------------------------------------------------------
-        trans_perspective() : m_valid(false) {}
+        double sx, shy, w0, shx, sy, w1, tx, ty, w2;
 
+        //------------------------------------------------------- Construction
+        // Identity matrix
+        trans_perspective() : 
+            sx (1), shy(0), w0(0), 
+            shx(0), sy (1), w1(0), 
+            tx (0), ty (0), w2(1) {}
 
-        //--------------------------------------------------------------------
-        // Arbitrary quadrangle transformations
-        trans_perspective(const double* src, const double* dst) 
-        {
-            quad_to_quad(src, dst);
-        }
+        // Custom matrix
+        trans_perspective(double v0, double v1, double v2, 
+                          double v3, double v4, double v5,
+                          double v6, double v7, double v8) :
+           sx (v0), shy(v1), w0(v2), 
+           shx(v3), sy (v4), w1(v5), 
+           tx (v6), ty (v7), w2(v8) {}
 
+        // Custom matrix from m[9]
+        explicit trans_perspective(const double* m) :
+           sx (m[0]), shy(m[1]), w0(m[2]), 
+           shx(m[3]), sy (m[4]), w1(m[5]), 
+           tx (m[6]), ty (m[7]), w2(m[8]) {}
 
-        //--------------------------------------------------------------------
-        // Direct transformations 
+        // From affine
+        explicit trans_perspective(const trans_affine& a) : 
+           sx (a.sx ), shy(a.shy), w0(0), 
+           shx(a.shx), sy (a.sy ), w1(0), 
+           tx (a.tx ), ty (a.ty ), w2(1) {}
+
+        // Rectangle to quadrilateral
         trans_perspective(double x1, double y1, double x2, double y2, 
-                          const double* quad)
-        {
-            rect_to_quad(x1, y1, x2, y2, quad);
-        }
+                          const double* quad);
 
-
-        //--------------------------------------------------------------------
-        // Reverse transformations 
+        // Quadrilateral to rectangle
         trans_perspective(const double* quad, 
-                          double x1, double y1, double x2, double y2)
-        {
-            quad_to_rect(quad, x1, y1, x2, y2);
-        }
+                          double x1, double y1, double x2, double y2);
 
+        // Arbitrary quadrilateral transformations
+        trans_perspective(const double* src, const double* dst);
 
-        //--------------------------------------------------------------------
-        // Set the transformations using two arbitrary quadrangles.
-        void quad_to_quad(const double* src, const double* dst)
-        {
+        //-------------------------------------- Quadrilateral transformations
+        // The arguments are double[8] that are mapped to quadrilaterals:
+        // x1,y1, x2,y2, x3,y3, x4,y4
+        bool quad_to_quad(const double* qs, const double* qd);
 
-            double left[8][8];
-            double right[8][1];
+        bool rect_to_quad(double x1, double y1, 
+                          double x2, double y2,
+                          const double* q);
 
-            unsigned i;
-            for (i = 0; i < 4; i++)
-            {
-                unsigned ix = i * 2;
-                unsigned iy = ix + 1;
+        bool quad_to_rect(const double* q,
+                          double x1, double y1, 
+                          double x2, double y2);
 
-                left[ix][0]  =  1.0;
-                left[ix][1]  =  src[ix];
-                left[ix][2]  =  src[iy];
-                left[ix][3]  =  0.0;
-                left[ix][4]  =  0.0;
-                left[ix][5]  =  0.0;
-                left[ix][6]  = -src[ix] * dst[ix];
-                left[ix][7]  = -src[iy] * dst[ix];
-                right[ix][0] =  dst[ix];
+        // Map square (0,0,1,1) to the quadrilateral and vice versa
+        bool square_to_quad(const double* q);
+        bool quad_to_square(const double* q);
 
-                left[iy][0]  =  0.0;
-                left[iy][1]  =  0.0;
-                left[iy][2]  =  0.0;
-                left[iy][3]  =  1.0;
-                left[iy][4]  =  src[ix];
-                left[iy][5]  =  src[iy];
-                left[iy][6]  = -src[ix] * dst[iy];
-                left[iy][7]  = -src[iy] * dst[iy];
-                right[iy][0] =  dst[iy];
-            }
-            m_valid = simul_eq<8, 1>::solve(left, right, m_mtx);
+
+        //--------------------------------------------------------- Operations
+        // Reset - load an identity matrix
+        const trans_perspective& reset();
+
+        // Invert matrix. Returns false in degenerate case
+        bool invert();
+
+        // Direct transformations operations
+        const trans_perspective& translate(double x, double y);
+        const trans_perspective& rotate(double a);
+        const trans_perspective& scale(double s);
+        const trans_perspective& scale(double x, double y);
+
+        // Multiply the matrix by another one
+        const trans_perspective& multiply(const trans_perspective& m);
+
+        // Multiply "m" by "this" and assign the result to "this"
+        const trans_perspective& premultiply(const trans_perspective& m);
+
+        // Multiply matrix to inverse of another one
+        const trans_perspective& multiply_inv(const trans_perspective& m);
+
+        // Multiply inverse of "m" by "this" and assign the result to "this"
+        const trans_perspective& premultiply_inv(const trans_perspective& m);
+
+        // Multiply the matrix by another one
+        const trans_perspective& multiply(const trans_affine& m);
+
+        // Multiply "m" by "this" and assign the result to "this"
+        const trans_perspective& premultiply(const trans_affine& m);
+
+        // Multiply the matrix by inverse of another one
+        const trans_perspective& multiply_inv(const trans_affine& m);
+
+        // Multiply inverse of "m" by "this" and assign the result to "this"
+        const trans_perspective& premultiply_inv(const trans_affine& m);
+
+        //--------------------------------------------------------- Load/Store
+        void store_to(double* m) const;
+        const trans_perspective& load_from(const double* m);
+
+        //---------------------------------------------------------- Operators
+        // Multiply the matrix by another one
+        const trans_perspective& operator *= (const trans_perspective& m)
+        {
+            return multiply(m);
         }
+        const trans_perspective& operator *= (const trans_affine& m)
+        {
+            return multiply(m);
+        }
 
+        // Multiply the matrix by inverse of another one
+        const trans_perspective& operator /= (const trans_perspective& m)
+        {
+            return multiply_inv(m);
+        }
+        const trans_perspective& operator /= (const trans_affine& m)
+        {
+            return multiply_inv(m);
+        }
 
-        //--------------------------------------------------------------------
-        // Set the direct transformations, i.e., rectangle -> quadrangle
-        void rect_to_quad(double x1, double y1, double x2, double y2, 
-                          const double* quad)
+        // Multiply the matrix by another one and return
+        // the result in a separete matrix.
+        trans_perspective operator * (const trans_perspective& m)
         {
-            double src[8];
-            src[0] = src[6] = x1;
-            src[2] = src[4] = x2;
-            src[1] = src[3] = y1;
-            src[5] = src[7] = y2;
-            quad_to_quad(src, quad);
+            return trans_perspective(*this).multiply(m);
         }
+        trans_perspective operator * (const trans_affine& m)
+        {
+            return trans_perspective(*this).multiply(m);
+        }
 
+        // Multiply the matrix by inverse of another one 
+        // and return the result in a separete matrix.
+        trans_perspective operator / (const trans_perspective& m)
+        {
+            return trans_perspective(*this).multiply_inv(m);
+        }
+        trans_perspective operator / (const trans_affine& m)
+        {
+            return trans_perspective(*this).multiply_inv(m);
+        }
 
-        //--------------------------------------------------------------------
-        // Set the reverse transformations, i.e., quadrangle -> rectangle
-        void quad_to_rect(const double* quad, 
-                          double x1, double y1, double x2, double y2)
+        // Calculate and return the inverse matrix
+        trans_perspective operator ~ () const
         {
-            double dst[8];
-            dst[0] = dst[6] = x1;
-            dst[2] = dst[4] = x2;
-            dst[1] = dst[3] = y1;
-            dst[5] = dst[7] = y2;
-            quad_to_quad(quad, dst);
+            trans_perspective ret = *this;
+            ret.invert();
+            return ret;
         }
 
-        //--------------------------------------------------------------------
-        // Check if the equations were solved successfully
-        bool is_valid() const { return m_valid; }
+        // Equal operator with default epsilon
+        bool operator == (const trans_perspective& m) const
+        {
+            return is_equal(m, affine_epsilon);
+        }
 
-        //--------------------------------------------------------------------
-        // Transform a point (x, y)
-        void transform(double* x, double* y) const
+        // Not Equal operator with default epsilon
+        bool operator != (const trans_perspective& m) const
         {
-            double tx = *x;
-            double ty = *y;
-            double d = 1.0 / (m_mtx[6][0] * tx + m_mtx[7][0] * ty + 1.0);
-            *x = (m_mtx[0][0] + m_mtx[1][0] * tx + m_mtx[2][0] * ty) * d;
-            *y = (m_mtx[3][0] + m_mtx[4][0] * tx + m_mtx[5][0] * ty) * d;
+            return !is_equal(m, affine_epsilon);
         }
 
+        //---------------------------------------------------- Transformations
+        // Direct transformation of x and y
+        void transform(double* x, double* y) const;
+
+        // Direct transformation of x and y, affine part only
+        void transform_affine(double* x, double* y) const;
+
+        // Direct transformation of x and y, 2x2 matrix only, no translation
+        void transform_2x2(double* x, double* y) const;
+
+        // Inverse transformation of x and y. It works slow because
+        // it explicitly inverts the matrix on every call. For massive 
+        // operations it's better to invert() the matrix and then use 
+        // direct transformations. 
+        void inverse_transform(double* x, double* y) const;
+
+
+        //---------------------------------------------------------- Auxiliary
+        const trans_perspective& from_affine(const trans_affine& a);
+        double determinant() const;
+        double determinant_reciprocal() const;
+
+        bool is_valid(double epsilon = affine_epsilon) const;
+        bool is_identity(double epsilon = affine_epsilon) const;
+        bool is_equal(const trans_perspective& m, 
+                      double epsilon = affine_epsilon) const;
+
+        // Determine the major affine parameters. Use with caution 
+        // considering possible degenerate cases.
+        double scale() const;
+        double rotation() const;
+        void   translation(double* dx, double* dy) const;
+        void   scaling(double* x, double* y) const;
+        void   scaling_abs(double* x, double* y) const;
+
+
+
         //--------------------------------------------------------------------
         class iterator_x
         {
@@ -153,17 +240,16 @@
             double y;
 
             iterator_x() {}
-            iterator_x(double tx, double ty, double step, const double m[8][1]) :
-                den(m[6][0] * tx + m[7][0] * ty + 1.0),
-                den_step(m[6][0] * step),
-                nom_x(m[0][0] + m[1][0] * tx + m[2][0] * ty),
-                nom_x_step(m[1][0] * step),
-                nom_y(m[3][0] + m[4][0] * tx + m[5][0] * ty),
-                nom_y_step(m[4][0] * step),
+            iterator_x(double px, double py, double step, const trans_perspective& m) :
+                den(px * m.w0 + py * m.w1 + m.w2),
+                den_step(m.w0 * step),
+                nom_x(px * m.sx + py * m.shx + m.tx),
+                nom_x_step(step * m.sx),
+                nom_y(px * m.shy + py * m.sy + m.ty),
+                nom_y_step(step * m.shy),
                 x(nom_x / den),
                 y(nom_y / den)
-            {
-            }
+            {}
 
             void operator ++ ()
             {
@@ -179,14 +265,467 @@
         //--------------------------------------------------------------------
         iterator_x begin(double x, double y, double step) const
         {
-            return iterator_x(x, y, step, m_mtx);
+            return iterator_x(x, y, step, *this);
         }
-
-    private:
-        double m_mtx[8][1];
-        bool   m_valid;
     };
 
+
+
+
+
+
+
+
+
+   
+
+
+
+
+    //------------------------------------------------------------------------
+    inline bool trans_perspective::square_to_quad(const double* q)
+    {
+        double dx = q[0] - q[2] + q[4] - q[6];
+        double dy = q[1] - q[3] + q[5] - q[7];
+        if(dx == 0.0 && dy == 0.0)
+        {   
+            // Affine case (parallelogram)
+            //---------------
+            sx  = q[2] - q[0];
+            shy = q[3] - q[1];
+            w0  = 0.0;
+            shx = q[4] - q[2];
+            sy  = q[5] - q[3];
+            w1  = 0.0;
+            tx  = q[0];
+            ty  = q[1];
+            w2  = 1.0;
+        }
+        else
+        {
+            double dx1 = q[2] - q[4];
+            double dy1 = q[3] - q[5];
+            double dx2 = q[6] - q[4];
+            double dy2 = q[7] - q[5];
+            double den = dx1 * dy2 - dx2 * dy1;
+            if(den == 0.0)
+            {
+                // Singular case
+                //---------------
+                sx = shy = w0 = shx = sy = w1 = tx = ty = w2 = 0.0;
+                return false;
+            }
+            // General case
+            //---------------
+            double u = (dx * dy2 - dy * dx2) / den;
+            double v = (dy * dx1 - dx * dy1) / den;
+            sx  = q[2] - q[0] + u * q[2];
+            shy = q[3] - q[1] + u * q[3];
+            w0  = u;
+            shx = q[6] - q[0] + v * q[6];
+            sy  = q[7] - q[1] + v * q[7];
+            w1  = v;
+            tx  = q[0];
+            ty  = q[1];
+            w2  = 1.0;
+        }
+        return true;
+    }
+
+    //------------------------------------------------------------------------
+    inline bool trans_perspective::invert()
+    {
+        double d0 = sy  * w2 - w1  * ty;
+        double d1 = w0  * ty - shy * w2;
+        double d2 = shy * w1 - w0  * sy;
+        double d  = sx  * d0 + shx * d1 + tx * d2;
+        if(d == 0.0) 
+        {
+            sx = shy = w0 = shx = sy = w1 = tx = ty = w2 = 0.0;
+            return false;
+        }
+        d = 1.0 / d;
+        trans_perspective a = *this;
+        sx  = d * d0;
+        shy = d * d1;
+        w0  = d * d2;
+        shx = d * (a.w1 *a.tx  - a.shx*a.w2);
+        sy  = d * (a.sx *a.w2  - a.w0 *a.tx);
+        w1  = d * (a.w0 *a.shx - a.sx *a.w1);
+        tx  = d * (a.shx*a.ty  - a.sy *a.tx);
+        ty  = d * (a.shy*a.tx  - a.sx *a.ty);
+        w2  = d * (a.sx *a.sy  - a.shy*a.shx);
+        return true;
+    }
+
+    //------------------------------------------------------------------------
+    inline bool trans_perspective::quad_to_square(const double* q)
+    {
+        if(!square_to_quad(q)) return false;
+        invert();
+        return true;
+    }
+
+    //------------------------------------------------------------------------
+    inline bool trans_perspective::quad_to_quad(const double* qs, 
+                                                const double* qd)
+    {
+        trans_perspective p;
+        if(!  quad_to_square(qs)) return false;
+        if(!p.square_to_quad(qd)) return false;
+        multiply(p);
+        return true;
+    }
+
+    //------------------------------------------------------------------------
+    inline bool trans_perspective::rect_to_quad(double x1, double y1, 
+                                                double x2, double y2,
+                                                const double* q)
+    {
+        double r[8];
+        r[0] = r[6] = x1;
+        r[2] = r[4] = x2;
+        r[1] = r[3] = y1;
+        r[5] = r[7] = y2;
+        return quad_to_quad(r, q);
+    }
+
+    //------------------------------------------------------------------------
+    inline bool trans_perspective::quad_to_rect(const double* q,
+                                                double x1, double y1, 
+                                                double x2, double y2)
+    {
+        double r[8];
+        r[0] = r[6] = x1;
+        r[2] = r[4] = x2;
+        r[1] = r[3] = y1;
+        r[5] = r[7] = y2;
+        return quad_to_quad(q, r);
+    }
+
+    //------------------------------------------------------------------------
+    inline trans_perspective::trans_perspective(double x1, double y1, 
+                                                double x2, double y2, 
+                                                const double* quad)
+    {
+        rect_to_quad(x1, y1, x2, y2, quad);
+    }
+
+    //------------------------------------------------------------------------
+    inline trans_perspective::trans_perspective(const double* quad, 
+                                                double x1, double y1, 
+                                                double x2, double y2)
+    {
+        quad_to_rect(quad, x1, y1, x2, y2);
+    }
+
+    //------------------------------------------------------------------------
+    inline trans_perspective::trans_perspective(const double* src, 
+                                                const double* dst) 
+    {
+        quad_to_quad(src, dst);
+    }
+
+    //------------------------------------------------------------------------
+    inline const trans_perspective& trans_perspective::reset()
+    {
+        sx  = 1; shy = 0; w0 = 0; 
+        shx = 0; sy  = 1; w1 = 0;
+        tx  = 0; ty  = 0; w2 = 1;
+        return *this;
+    }
+
+    //------------------------------------------------------------------------
+    inline const trans_perspective& 
+    trans_perspective::multiply(const trans_perspective& a)
+    {
+        trans_perspective b = *this;
+        sx  = a.sx *b.sx  + a.shx*b.shy + a.tx*b.w0;
+        shx = a.sx *b.shx + a.shx*b.sy  + a.tx*b.w1;
+        tx  = a.sx *b.tx  + a.shx*b.ty  + a.tx*b.w2;
+        shy = a.shy*b.sx  + a.sy *b.shy + a.ty*b.w0;
+        sy  = a.shy*b.shx + a.sy *b.sy  + a.ty*b.w1;
+        ty  = a.shy*b.tx  + a.sy *b.ty  + a.ty*b.w2;
+        w0  = a.w0 *b.sx  + a.w1 *b.shy + a.w2*b.w0;
+        w1  = a.w0 *b.shx + a.w1 *b.sy  + a.w2*b.w1;
+        w2  = a.w0 *b.tx  + a.w1 *b.ty  + a.w2*b.w2;
+        return *this;
+    }
+
+    //------------------------------------------------------------------------
+    inline const trans_perspective& 
+    trans_perspective::multiply(const trans_affine& a)
+    {
+        trans_perspective b = *this;
+        sx  = a.sx *b.sx  + a.shx*b.shy + a.tx*b.w0;
+        shx = a.sx *b.shx + a.shx*b.sy  + a.tx*b.w1;
+        tx  = a.sx *b.tx  + a.shx*b.ty  + a.tx*b.w2;
+        shy = a.shy*b.sx  + a.sy *b.shy + a.ty*b.w0;
+        sy  = a.shy*b.shx + a.sy *b.sy  + a.ty*b.w1;
+        ty  = a.shy*b.tx  + a.sy *b.ty  + a.ty*b.w2;
+        return *this;
+    }
+
+    //------------------------------------------------------------------------
+    inline const trans_perspective& 
+    trans_perspective::premultiply(const trans_perspective& b)
+    {
+        trans_perspective a = *this;
+        sx  = a.sx *b.sx  + a.shx*b.shy + a.tx*b.w0;
+        shx = a.sx *b.shx + a.shx*b.sy  + a.tx*b.w1;
+        tx  = a.sx *b.tx  + a.shx*b.ty  + a.tx*b.w2;
+        shy = a.shy*b.sx  + a.sy *b.shy + a.ty*b.w0;
+        sy  = a.shy*b.shx + a.sy *b.sy  + a.ty*b.w1;
+        ty  = a.shy*b.tx  + a.sy *b.ty  + a.ty*b.w2;
+        w0  = a.w0 *b.sx  + a.w1 *b.shy + a.w2*b.w0;
+        w1  = a.w0 *b.shx + a.w1 *b.sy  + a.w2*b.w1;
+        w2  = a.w0 *b.tx  + a.w1 *b.ty  + a.w2*b.w2;
+        return *this;
+    }
+
+    //------------------------------------------------------------------------
+    inline const trans_perspective& 
+    trans_perspective::premultiply(const trans_affine& b)
+    {
+        trans_perspective a = *this;
+        sx  = a.sx *b.sx  + a.shx*b.shy;
+        shx = a.sx *b.shx + a.shx*b.sy;
+        tx  = a.sx *b.tx  + a.shx*b.ty  + a.tx;
+        shy = a.shy*b.sx  + a.sy *b.shy;
+        sy  = a.shy*b.shx + a.sy *b.sy;
+        ty  = a.shy*b.tx  + a.sy *b.ty  + a.ty;
+        w0  = a.w0 *b.sx  + a.w1 *b.shy;
+        w1  = a.w0 *b.shx + a.w1 *b.sy;
+        w2  = a.w0 *b.tx  + a.w1 *b.ty  + a.w2;
+        return *this;
+    }
+
+    //------------------------------------------------------------------------
+    const trans_perspective& 
+    trans_perspective::multiply_inv(const trans_perspective& m)
+    {
+        trans_perspective t = m;
+        t.invert();
+        return multiply(t);
+    }
+
+    //------------------------------------------------------------------------
+    const trans_perspective&
+    trans_perspective::multiply_inv(const trans_affine& m)
+    {
+        trans_affine t = m;
+        t.invert();
+        return multiply(t);
+    }
+
+    //------------------------------------------------------------------------
+    const trans_perspective&
+    trans_perspective::premultiply_inv(const trans_perspective& m)
+    {
+        trans_perspective t = m;
+        t.invert();
+        return *this = t.multiply(*this);
+    }
+
+    //------------------------------------------------------------------------
+    const trans_perspective&
+    trans_perspective::premultiply_inv(const trans_affine& m)
+    {
+        trans_perspective t(m);
+        t.invert();
+        return *this = t.multiply(*this);
+    }
+
+    //------------------------------------------------------------------------
+    inline const trans_perspective& 
+    trans_perspective::translate(double x, double y)
+    {
+        tx += x;
+        ty += y;
+        return *this;
+    }
+
+    //------------------------------------------------------------------------
+    inline const trans_perspective& trans_perspective::rotate(double a)
+    {
+        multiply(trans_affine_rotation(a));
+        return *this;
+    }
+
+    //------------------------------------------------------------------------
+    inline const trans_perspective& trans_perspective::scale(double s)
+    {
+        multiply(trans_affine_scaling(s));
+        return *this;
+    }
+
+    //------------------------------------------------------------------------
+    inline const trans_perspective& trans_perspective::scale(double x, double y)
+    {
+        multiply(trans_affine_scaling(x, y));
+        return *this;
+    }
+
+    //------------------------------------------------------------------------
+    inline void trans_perspective::transform(double* px, double* py) const
+    {
+        double x = *px;
+        double y = *py;
+        double m = 1.0 / (x*w0 + y*w1 + w2);
+        *px = m * (x*sx  + y*shx + tx);
+        *py = m * (x*shy + y*sy  + ty);
+    }
+
+    //------------------------------------------------------------------------
+    inline void trans_perspective::transform_affine(double* x, double* y) const
+    {
+        double tmp = *x;
+        *x = tmp * sx  + *y * shx + tx;
+        *y = tmp * shy + *y * sy  + ty;
+    }
+
+    //------------------------------------------------------------------------
+    inline void trans_perspective::transform_2x2(double* x, double* y) const
+    {
+        double tmp = *x;
+        *x = tmp * sx  + *y * shx;
+        *y = tmp * shy + *y * sy;
+    }
+
+    //------------------------------------------------------------------------
+    inline void trans_perspective::inverse_transform(double* x, double* y) const
+    {
+        trans_perspective t(*this);
+        if(t.invert()) t.transform(x, y);
+    }
+
+    //------------------------------------------------------------------------
+    inline void trans_perspective::store_to(double* m) const
+    {
+        *m++ = sx;  *m++ = shy; *m++ = w0; 
+        *m++ = shx; *m++ = sy;  *m++ = w1;
+        *m++ = tx;  *m++ = ty;  *m++ = w2;
+    }
+
+    //------------------------------------------------------------------------
+    inline const trans_perspective& trans_perspective::load_from(const double* m)
+    {
+        sx  = *m++; shy = *m++; w0 = *m++; 
+        shx = *m++; sy  = *m++; w1 = *m++;
+        tx  = *m++; ty  = *m++; w2 = *m++;
+        return *this;
+    }
+
+    //------------------------------------------------------------------------
+    inline const trans_perspective& 
+    trans_perspective::from_affine(const trans_affine& a)
+    {
+        sx  = a.sx;  shy = a.shy; w0 = 0; 
+        shx = a.shx; sy  = a.sy;  w1 = 0;
+        tx  = a.tx;  ty  = a.ty;  w2 = 1;
+        return *this;
+    }
+
+    //------------------------------------------------------------------------
+    inline double trans_perspective::determinant() const
+    {
+        return sx  * (sy  * w2 - ty  * w1) +
+               shx * (ty  * w0 - shy * w2) +
+               tx  * (shy * w1 - sy  * w0);
+    }
+  
+    //------------------------------------------------------------------------
+    inline double trans_perspective::determinant_reciprocal() const
+    {
+        return 1.0 / determinant();
+    }
+
+    //------------------------------------------------------------------------
+    inline bool trans_perspective::is_valid(double epsilon) const
+    {
+        return fabs(sx) > epsilon && fabs(sy) > epsilon && fabs(w2) > epsilon;
+    }
+
+    //------------------------------------------------------------------------
+    inline bool trans_perspective::is_identity(double epsilon) const
+    {
+        return is_equal_eps(sx,  1.0, epsilon) &&
+               is_equal_eps(shy, 0.0, epsilon) &&
+               is_equal_eps(w0,  0.0, epsilon) &&
+               is_equal_eps(shx, 0.0, epsilon) && 
+               is_equal_eps(sy,  1.0, epsilon) &&
+               is_equal_eps(w1,  0.0, epsilon) &&
+               is_equal_eps(tx,  0.0, epsilon) &&
+               is_equal_eps(ty,  0.0, epsilon) &&
+               is_equal_eps(w2,  1.0, epsilon);
+    }
+
+    //------------------------------------------------------------------------
+    inline bool trans_perspective::is_equal(const trans_perspective& m, 
+                                            double epsilon) const
+    {
+        return is_equal_eps(sx,  m.sx,  epsilon) &&
+               is_equal_eps(shy, m.shy, epsilon) &&
+               is_equal_eps(w0,  m.w0,  epsilon) &&
+               is_equal_eps(shx, m.shx, epsilon) && 
+               is_equal_eps(sy,  m.sy,  epsilon) &&
+               is_equal_eps(w1,  m.w1,  epsilon) &&
+               is_equal_eps(tx,  m.tx,  epsilon) &&
+               is_equal_eps(ty,  m.ty,  epsilon) &&
+               is_equal_eps(w2,  m.w2,  epsilon);
+    }
+
+    //------------------------------------------------------------------------
+    inline double trans_perspective::scale() const
+    {
+        double x = 0.707106781 * sx  + 0.707106781 * shx;
+        double y = 0.707106781 * shy + 0.707106781 * sy;
+        return sqrt(x*x + y*y);
+    }
+
+    //------------------------------------------------------------------------
+    inline double trans_perspective::rotation() const
+    {
+        double x1 = 0.0;
+        double y1 = 0.0;
+        double x2 = 1.0;
+        double y2 = 0.0;
+        transform(&x1, &y1);
+        transform(&x2, &y2);
+        return atan2(y2-y1, x2-x1);
+    }
+
+    //------------------------------------------------------------------------
+    void trans_perspective::translation(double* dx, double* dy) const
+    {
+        *dx = tx;
+        *dy = ty;
+    }
+
+    //------------------------------------------------------------------------
+    void trans_perspective::scaling(double* x, double* y) const
+    {
+        double x1 = 0.0;
+        double y1 = 0.0;
+        double x2 = 1.0;
+        double y2 = 1.0;
+        trans_perspective t(*this);
+        t *= trans_affine_rotation(-rotation());
+        t.transform(&x1, &y1);
+        t.transform(&x2, &y2);
+        *x = x2 - x1;
+        *y = y2 - y1;
+    }
+
+    //------------------------------------------------------------------------
+    void trans_perspective::scaling_abs(double* x, double* y) const
+    {
+        *x = sqrt(sx  * sx  + shx * shx);
+        *y = sqrt(shy * shy + sy  * sy);
+    }
+
+
 }
 
 #endif
+

Modified: trunk/agg/include/agg_trans_warp_magnifier.h
===================================================================
--- trunk/agg/include/agg_trans_warp_magnifier.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_trans_warp_magnifier.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -33,6 +33,11 @@
         void magnification(double m)    { m_magn = m;         }
         void radius(double r)           { m_radius = r;       }
 
+        double xc()            const { return m_xc; }
+        double yc()            const { return m_yc; }
+        double magnification() const { return m_magn;   }
+        double radius()        const { return m_radius; }
+
         void transform(double* x, double* y) const;
         void inverse_transform(double* x, double* y) const;
 

Modified: trunk/agg/include/agg_vcgen_contour.h
===================================================================
--- trunk/agg/include/agg_vcgen_contour.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_vcgen_contour.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -43,23 +43,28 @@
 
         vcgen_contour();
 
-        void line_join(line_join_e lj) { m_line_join = lj; }
-        void inner_join(inner_join_e ij) { m_inner_join = ij; }
-        void width(double w) { m_width = w * 0.5; }
-        void miter_limit(double ml) { m_miter_limit = ml; }
-        void miter_limit_theta(double t);
-        void inner_miter_limit(double ml) { m_inner_miter_limit = ml; }
-        void approximation_scale(double as) { m_approx_scale = as; }
-        void auto_detect_orientation(bool v) { m_auto_detect = v; }
+        void line_cap(line_cap_e lc)     { m_stroker.line_cap(lc); }
+        void line_join(line_join_e lj)   { m_stroker.line_join(lj); }
+        void inner_join(inner_join_e ij) { m_stroker.inner_join(ij); }
 
-        line_join_e line_join() const { return m_line_join; }
-        inner_join_e inner_join() const { return m_inner_join; }
-        double width() const { return m_width * 2.0; }
-        double miter_limit() const { return m_miter_limit; }
-        double inner_miter_limit() const { return m_inner_miter_limit; }
-        double approximation_scale() const { return m_approx_scale; }
-        bool   auto_detect_orientation() const { return m_auto_detect; }
+        line_cap_e   line_cap()   const { return m_stroker.line_cap(); }
+        line_join_e  line_join()  const { return m_stroker.line_join(); }
+        inner_join_e inner_join() const { return m_stroker.inner_join(); }
 
+        void width(double w) { m_stroker.width(m_width = w); }
+        void miter_limit(double ml) { m_stroker.miter_limit(ml); }
+        void miter_limit_theta(double t) { m_stroker.miter_limit_theta(t); }
+        void inner_miter_limit(double ml) { m_stroker.inner_miter_limit(ml); }
+        void approximation_scale(double as) { m_stroker.approximation_scale(as); }
+
+        double width() const { return m_width; }
+        double miter_limit() const { return m_stroker.miter_limit(); }
+        double inner_miter_limit() const { return m_stroker.inner_miter_limit(); }
+        double approximation_scale() const { return m_stroker.approximation_scale(); }
+
+        void auto_detect_orientation(bool v) { m_auto_detect = v; }
+        bool auto_detect_orientation() const { return m_auto_detect; }
+
         // Generator interface
         void remove_all();
         void add_vertex(double x, double y, unsigned cmd);
@@ -72,22 +77,16 @@
         vcgen_contour(const vcgen_contour&);
         const vcgen_contour& operator = (const vcgen_contour&);
 
-        vertex_storage m_src_vertices;
-        coord_storage  m_out_vertices;
-        double         m_width;
-        line_join_e    m_line_join;
-        inner_join_e   m_inner_join;
-        double         m_approx_scale;
-        double         m_abs_width;
-        double         m_signed_width;
-        double         m_miter_limit;
-        double         m_inner_miter_limit;
-        status_e       m_status;
-        unsigned       m_src_vertex;
-        unsigned       m_out_vertex;
-        unsigned       m_closed;
-        unsigned       m_orientation;
-        bool           m_auto_detect;
+        math_stroke<coord_storage> m_stroker;
+        double                     m_width;
+        vertex_storage             m_src_vertices;
+        coord_storage              m_out_vertices;
+        status_e                   m_status;
+        unsigned                   m_src_vertex;
+        unsigned                   m_out_vertex;
+        unsigned                   m_closed;
+        unsigned                   m_orientation;
+        bool                       m_auto_detect;
     };
 
 }

Modified: trunk/agg/include/agg_vcgen_stroke.h
===================================================================
--- trunk/agg/include/agg_vcgen_stroke.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_vcgen_stroke.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -51,24 +51,24 @@
 
         vcgen_stroke();
 
-        void line_cap(line_cap_e lc)     { m_line_cap = lc; }
-        void line_join(line_join_e lj)   { m_line_join = lj; }
-        void inner_join(inner_join_e ij) { m_inner_join = ij; }
+        void line_cap(line_cap_e lc)     { m_stroker.line_cap(lc); }
+        void line_join(line_join_e lj)   { m_stroker.line_join(lj); }
+        void inner_join(inner_join_e ij) { m_stroker.inner_join(ij); }
 
-        line_cap_e   line_cap()   const { return m_line_cap; }
-        line_join_e  line_join()  const { return m_line_join; }
-        inner_join_e inner_join() const { return m_inner_join; }
+        line_cap_e   line_cap()   const { return m_stroker.line_cap(); }
+        line_join_e  line_join()  const { return m_stroker.line_join(); }
+        inner_join_e inner_join() const { return m_stroker.inner_join(); }
 
-        void width(double w) { m_width = w * 0.5; }
-        void miter_limit(double ml) { m_miter_limit = ml; }
-        void miter_limit_theta(double t);
-        void inner_miter_limit(double ml) { m_inner_miter_limit = ml; }
-        void approximation_scale(double as) { m_approx_scale = as; }
+        void width(double w) { m_stroker.width(w); }
+        void miter_limit(double ml) { m_stroker.miter_limit(ml); }
+        void miter_limit_theta(double t) { m_stroker.miter_limit_theta(t); }
+        void inner_miter_limit(double ml) { m_stroker.inner_miter_limit(ml); }
+        void approximation_scale(double as) { m_stroker.approximation_scale(as); }
 
-        double width() const { return m_width * 2.0; }
-        double miter_limit() const { return m_miter_limit; }
-        double inner_miter_limit() const { return m_inner_miter_limit; }
-        double approximation_scale() const { return m_approx_scale; }
+        double width() const { return m_stroker.width(); }
+        double miter_limit() const { return m_stroker.miter_limit(); }
+        double inner_miter_limit() const { return m_stroker.inner_miter_limit(); }
+        double approximation_scale() const { return m_stroker.approximation_scale(); }
 
         void shorten(double s) { m_shorten = s; }
         double shorten() const { return m_shorten; }
@@ -85,21 +85,15 @@
         vcgen_stroke(const vcgen_stroke&);
         const vcgen_stroke& operator = (const vcgen_stroke&);
 
-        vertex_storage m_src_vertices;
-        coord_storage  m_out_vertices;
-        double         m_width;
-        double         m_miter_limit;
-        double         m_inner_miter_limit;
-        double         m_approx_scale;
-        double         m_shorten;
-        line_cap_e     m_line_cap;
-        line_join_e    m_line_join;
-        inner_join_e   m_inner_join;
-        unsigned       m_closed;
-        status_e       m_status;
-        status_e       m_prev_status;
-        unsigned       m_src_vertex;
-        unsigned       m_out_vertex;
+        math_stroke<coord_storage> m_stroker;
+        vertex_storage             m_src_vertices;
+        coord_storage              m_out_vertices;
+        double                     m_shorten;
+        unsigned                   m_closed;
+        status_e                   m_status;
+        status_e                   m_prev_status;
+        unsigned                   m_src_vertex;
+        unsigned                   m_out_vertex;
     };
 
 

Modified: trunk/agg/include/agg_vertex_sequence.h
===================================================================
--- trunk/agg/include/agg_vertex_sequence.h	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/include/agg_vertex_sequence.h	2006-11-09 23:44:34 UTC (rev 367)
@@ -30,7 +30,7 @@
     // Modified agg::pod_bvector. The data is interpreted as a sequence 
     // of vertices. It means that the type T must expose:
     //
-    // bool operator() (const T& val)
+    // bool T::operator() (const T& val)
     // 
     // that is called every time new vertex is being added. The main purpose
     // of this operator is the possibility to calculate some values during 

Modified: trunk/agg/src/agg_bspline.cpp
===================================================================
--- trunk/agg/src/agg_bspline.cpp	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/src/agg_bspline.cpp	2006-11-09 23:44:34 UTC (rev 367)
@@ -17,26 +17,16 @@
 //
 //----------------------------------------------------------------------------
 
-
 #include "agg_bspline.h"
 
 namespace agg
 {
-
     //------------------------------------------------------------------------
-    bspline::~bspline()
-    {
-        delete [] m_am;
-    }
-
-
-    //------------------------------------------------------------------------
     bspline::bspline() :
         m_max(0),
         m_num(0),
         m_x(0),
         m_y(0),
-        m_am(0),
         m_last_idx(-1)
     {
     }
@@ -47,7 +37,6 @@
         m_num(0),
         m_x(0),
         m_y(0),
-        m_am(0),
         m_last_idx(-1)
     {
         init(num);
@@ -59,7 +48,6 @@
         m_num(0),
         m_x(0),
         m_y(0),
-        m_am(0),
         m_last_idx(-1)
     {
         init(num, x, y);
@@ -71,11 +59,10 @@
     {
         if(max > 2 && max > m_max)
         {
-            delete [] m_am;
-            m_am = new double[max * 3];
+            m_am.resize(max * 3);
             m_max = max;
-            m_x = m_am + m_max;
-            m_y = m_am + m_max * 2;
+            m_x   = &m_am[m_max];
+            m_y   = &m_am[m_max * 2];
         }
         m_num = 0;
         m_last_idx = -1;
@@ -103,7 +90,6 @@
             double* temp; 
             double* r; 
             double* s;
-            double* al; 
             double h, p, d, f, e;
     
             for(k = 0; k < m_num; k++) 
@@ -113,8 +99,8 @@
 
             n1 = 3 * m_num;
 
-            al = new double[n1];
-            temp = al;
+            pod_array<double> al(n1);
+            temp = &al[0];
 
             for(k = 0; k < n1; k++) 
             {
@@ -155,7 +141,6 @@
                 al[k]   = al[k] * al[k + 1] + s[k];
                 m_am[k] = al[k];
             }
-            delete [] al;
         }
         m_last_idx = -1;
     }

Modified: trunk/agg/src/agg_curves.cpp
===================================================================
--- trunk/agg/src/agg_curves.cpp	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/src/agg_curves.cpp	2006-11-09 23:44:34 UTC (rev 367)
@@ -82,9 +82,6 @@
         m_step = m_num_steps;
     }
 
-
-
-
     //------------------------------------------------------------------------
     void curve3_inc::rewind(unsigned)
     {
@@ -100,9 +97,6 @@
         m_dfy  = m_saved_dfy;
     }
 
-
-
-
     //------------------------------------------------------------------------
     unsigned curve3_inc::vertex(double* x, double* y)
     {
@@ -131,7 +125,6 @@
         return path_cmd_line_to;
     }
 
-
     //------------------------------------------------------------------------
     void curve3_div::init(double x1, double y1, 
                           double x2, double y2, 
@@ -140,12 +133,10 @@
         m_points.remove_all();
         m_distance_tolerance_square = 0.5 / m_approximation_scale;
         m_distance_tolerance_square *= m_distance_tolerance_square;
-        m_distance_tolerance_manhattan = 4.0 / m_approximation_scale;
         bezier(x1, y1, x2, y2, x3, y3);
         m_count = 0;
     }
 
-
     //------------------------------------------------------------------------
     void curve3_div::recursive_bezier(double x1, double y1, 
                                       double x2, double y2, 
@@ -169,10 +160,11 @@
         double dx = x3-x1;
         double dy = y3-y1;
         double d = fabs(((x2 - x3) * dy - (y2 - y3) * dx));
+        double da;
 
         if(d > curve_collinearity_epsilon)
         { 
-            // Regular care
+            // Regular case
             //-----------------
             if(d * d <= m_distance_tolerance_square * (dx*dx + dy*dy))
             {
@@ -187,7 +179,7 @@
 
                 // Angle & Cusp Condition
                 //----------------------
-                double da = fabs(atan2(y3 - y2, x3 - x2) - atan2(y2 - y1, x2 - x1));
+                da = fabs(atan2(y3 - y2, x3 - x2) - atan2(y2 - y1, x2 - x1));
                 if(da >= pi) da = 2*pi - da;
 
                 if(da < m_angle_tolerance)
@@ -201,12 +193,31 @@
         }
         else
         {
-            if(fabs(x1 + x3 - x2 - x2) +
-               fabs(y1 + y3 - y2 - y2) <= m_distance_tolerance_manhattan)
+            // Collinear case
+            //------------------
+            da = dx*dx + dy*dy;
+            if(da == 0)
             {
-                m_points.add(point_d(x123, y123));
+                d = calc_sq_distance(x1, y1, x2, y2);
+            }
+            else
+            {
+                d = ((x2 - x1)*dx + (y2 - y1)*dy) / da;
+                if(d > 0 && d < 1)
+                {
+                    // Simple collinear case, 1---2---3
+                    // We can leave just two endpoints
+                    return;
+                }
+                     if(d <= 0) d = calc_sq_distance(x2, y2, x1, y1);
+                else if(d >= 1) d = calc_sq_distance(x2, y2, x3, y3);
+                else            d = calc_sq_distance(x2, y2, x1 + d*dx, y1 + d*dy);
+            }
+            if(d < m_distance_tolerance_square)
+            {
+                m_points.add(point_d(x2, y2));
                 return;
-            }    
+            }
         }
 
         // Continue subdivision
@@ -307,9 +318,6 @@
         m_step = m_num_steps;
     }
 
-
-
-
     //------------------------------------------------------------------------
     void curve4_inc::rewind(unsigned)
     {
@@ -327,10 +335,6 @@
         m_ddfy = m_saved_ddfy;
     }
 
-
-
-
-
     //------------------------------------------------------------------------
     unsigned curve4_inc::vertex(double* x, double* y)
     {
@@ -376,12 +380,10 @@
         m_points.remove_all();
         m_distance_tolerance_square = 0.5 / m_approximation_scale;
         m_distance_tolerance_square *= m_distance_tolerance_square;
-        m_distance_tolerance_manhattan = 4.0 / m_approximation_scale;
         bezier(x1, y1, x2, y2, x3, y3, x4, y4);
         m_count = 0;
     }
 
-
     //------------------------------------------------------------------------
     void curve4_div::recursive_bezier(double x1, double y1, 
                                       double x2, double y2, 
@@ -409,6 +411,7 @@
         double x1234 = (x123 + x234) / 2;
         double y1234 = (y123 + y234) / 2;
 
+
         // Try to approximate the full cubic curve by a single straight line
         //------------------
         double dx = x4-x1;
@@ -416,7 +419,7 @@
 
         double d2 = fabs(((x2 - x4) * dy - (y2 - y4) * dx));
         double d3 = fabs(((x3 - x4) * dy - (y3 - y4) * dx));
-        double da1, da2;
+        double da1, da2, k;
 
         switch((int(d2 > curve_collinearity_epsilon) << 1) +
                 int(d3 > curve_collinearity_epsilon))
@@ -424,18 +427,55 @@
         case 0:
             // All collinear OR p1==p4
             //----------------------
-            if(fabs(x1 + x3 - x2 - x2) +
-               fabs(y1 + y3 - y2 - y2) +
-               fabs(x2 + x4 - x3 - x3) +
-               fabs(y2 + y4 - y3 - y3) <= m_distance_tolerance_manhattan)
+            k = dx*dx + dy*dy;
+            if(k == 0)
             {
-                m_points.add(point_d(x1234, y1234));
-                return;
-            }    
+                d2 = calc_sq_distance(x1, y1, x2, y2);
+                d3 = calc_sq_distance(x4, y4, x3, y3);
+            }
+            else
+            {
+                k   = 1 / k;
+                da1 = x2 - x1;
+                da2 = y2 - y1;
+                d2  = k * (da1*dx + da2*dy);
+                da1 = x3 - x1;
+                da2 = y3 - y1;
+                d3  = k * (da1*dx + da2*dy);
+                if(d2 > 0 && d2 < 1 && d3 > 0 && d3 < 1)
+                {
+                    // Simple collinear case, 1---2---3---4
+                    // We can leave just two endpoints
+                    return;
+                }
+                     if(d2 <= 0) d2 = calc_sq_distance(x2, y2, x1, y1);
+                else if(d2 >= 1) d2 = calc_sq_distance(x2, y2, x4, y4);
+                else             d2 = calc_sq_distance(x2, y2, x1 + d2*dx, y1 + d2*dy);
+
+                     if(d3 <= 0) d3 = calc_sq_distance(x3, y3, x1, y1);
+                else if(d3 >= 1) d3 = calc_sq_distance(x3, y3, x4, y4);
+                else             d3 = calc_sq_distance(x3, y3, x1 + d3*dx, y1 + d3*dy);
+            }
+            if(d2 > d3)
+            {
+                if(d2 < m_distance_tolerance_square)
+                {
+                    m_points.add(point_d(x2, y2));
+                    return;
+                }
+            }
+            else
+            {
+                if(d3 < m_distance_tolerance_square)
+                {
+                    m_points.add(point_d(x3, y3));
+                    return;
+                }
+            }
             break;
 
         case 1:
-            // p1,p2,p4 are collinear, p3 is considerable
+            // p1,p2,p4 are collinear, p3 is significant
             //----------------------
             if(d3 * d3 <= m_distance_tolerance_square * (dx*dx + dy*dy))
             {
@@ -469,7 +509,7 @@
             break;
 
         case 2:
-            // p1,p3,p4 are collinear, p2 is considerable
+            // p1,p3,p4 are collinear, p2 is significant
             //----------------------
             if(d2 * d2 <= m_distance_tolerance_square * (dx*dx + dy*dy))
             {
@@ -503,7 +543,7 @@
             break;
 
         case 3: 
-            // Regular care
+            // Regular case
             //-----------------
             if((d2 + d3)*(d2 + d3) <= m_distance_tolerance_square * (dx*dx + dy*dy))
             {
@@ -518,9 +558,9 @@
 
                 // Angle & Cusp Condition
                 //----------------------
-                double a23 = atan2(y3 - y2, x3 - x2);
-                da1 = fabs(a23 - atan2(y2 - y1, x2 - x1));
-                da2 = fabs(atan2(y4 - y3, x4 - x3) - a23);
+                k   = atan2(y3 - y2, x3 - x2);
+                da1 = fabs(k - atan2(y2 - y1, x2 - x1));
+                da2 = fabs(atan2(y4 - y3, x4 - x3) - k);
                 if(da1 >= pi) da1 = 2*pi - da1;
                 if(da2 >= pi) da2 = 2*pi - da2;
 

Modified: trunk/agg/src/agg_gsv_text.cpp
===================================================================
--- trunk/agg/src/agg_gsv_text.cpp	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/src/agg_gsv_text.cpp	2006-11-09 23:44:34 UTC (rev 367)
@@ -19,8 +19,10 @@
 #include <string.h>
 #include <stdio.h>
 #include "agg_gsv_text.h"
+#include "agg_bounding_rect.h"
 
 
+
 namespace agg
 {
     int8u gsv_default_font[] = 
@@ -480,17 +482,7 @@
         0xf6,0xfa,0x04,0x06,0x08,0xfa
     };
 
-
-
     //-------------------------------------------------------------------------
-    gsv_text::~gsv_text()
-    {
-        if(m_loaded_font) delete [] m_loaded_font;
-        if(m_text_buf)    delete [] m_text_buf;
-    }
-
-
-    //-------------------------------------------------------------------------
     gsv_text::gsv_text() :
       m_x(0.0),
       m_y(0.0),
@@ -500,11 +492,10 @@
       m_space(0.0),
       m_line_space(0.0),
       m_text(m_chr),
-      m_text_buf(0),
-      m_buf_size(0), 
+      m_text_buf(),
       m_cur_chr(m_chr),
       m_font(gsv_default_font),
-      m_loaded_font(0),
+      m_loaded_font(),
       m_status(initial),
       m_big_endian(false),
       m_flip(false)
@@ -515,13 +506,11 @@
         if(*(char*)&t == 0) m_big_endian = true;
     }
 
-
-
     //-------------------------------------------------------------------------
     void gsv_text::font(const void* font)
     {
         m_font = font;
-        if(m_font == 0) m_font = m_loaded_font;
+        if(m_font == 0) m_font = &m_loaded_font[0];
     }
 
     //-------------------------------------------------------------------------
@@ -551,13 +540,10 @@
         //if(m_flip) m_y += m_height;
     }
 
-
     //-------------------------------------------------------------------------
     void gsv_text::load_font(const char* file)
     {
-        if(m_loaded_font) delete [] m_loaded_font;
-        m_loaded_font = 0;
-
+        m_loaded_font.resize(0);
         FILE* fd = fopen(file, "rb");
         if(fd)
         {
@@ -568,15 +554,14 @@
             fseek(fd, 0l, SEEK_SET);
             if(len > 0)
             {
-                m_loaded_font = new char [len];
-                fread(m_loaded_font, 1, len, fd);
-                m_font = m_loaded_font;
+                m_loaded_font.resize(len);
+                fread(&m_loaded_font[0], 1, len, fd);
+                m_font = &m_loaded_font[0];
             }
             fclose(fd);
         }
     }
 
-
     //-------------------------------------------------------------------------
     void gsv_text::text(const char* text)
     {
@@ -587,17 +572,14 @@
             return;
         }
         unsigned new_size = strlen(text) + 1;
-        if(new_size > m_buf_size)
+        if(new_size > m_text_buf.size())
         {
-            if(m_text_buf) delete [] m_text_buf;
-            m_text_buf = new char [m_buf_size = new_size];
+            m_text_buf.resize(new_size);
         }
-        memcpy(m_text_buf, text, new_size);
-        m_text = m_text_buf;
+        memcpy(&m_text_buf[0], text, new_size);
+        m_text = &m_text_buf[0];
     }
 
-
-
     //-------------------------------------------------------------------------
     void gsv_text::rewind(unsigned)
     {
@@ -614,7 +596,6 @@
         m_cur_chr = m_text;
     }
 
-
     //-------------------------------------------------------------------------
     unsigned gsv_text::vertex(double* x, double* y)
     {
@@ -622,7 +603,6 @@
         int8 yc, yf;
         int dx, dy;
         bool quit = false;
-
         
         while(!quit)
         {
@@ -683,6 +663,13 @@
         return path_cmd_stop;
     }
 
+    //-------------------------------------------------------------------------
+    double gsv_text::text_width()
+    {
+        double x1, y1, x2, y2;
+        bounding_rect_single(*this, 0, &x1, &y1, &x2, &y2);
+        return x2 - x1;
+    }
 
 
 }

Modified: trunk/agg/src/agg_image_filters.cpp
===================================================================
--- trunk/agg/src/agg_image_filters.cpp	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/src/agg_image_filters.cpp	2006-11-09 23:44:34 UTC (rev 367)
@@ -23,32 +23,16 @@
 
 namespace agg
 {
-
     //--------------------------------------------------------------------
-    image_filter_lut::~image_filter_lut()
-    {
-        delete [] m_weight_array;
-    }
-
-
-    //--------------------------------------------------------------------
-    image_filter_lut::image_filter_lut() :
-        m_weight_array(0),
-        m_max_size(0)
-    {}
-
-    //--------------------------------------------------------------------
     void image_filter_lut::realloc_lut(double radius)
     {
         m_radius = radius;
         m_diameter = uceil(radius) * 2;
         m_start = -int(m_diameter / 2 - 1);
         unsigned size = m_diameter << image_subpixel_shift;
-        if(size > m_max_size)
+        if(size > m_weight_array.size())
         {
-            delete [] m_weight_array;
-            m_weight_array = new int16 [size];
-            m_max_size = size;
+            m_weight_array.resize(size);
         }
     }
 

Modified: trunk/agg/src/agg_line_aa_basics.cpp
===================================================================
--- trunk/agg/src/agg_line_aa_basics.cpp	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/src/agg_line_aa_basics.cpp	2006-11-09 23:44:34 UTC (rev 367)
@@ -41,9 +41,9 @@
     //         (7)111 | 101(5) 
     //   [2]          |          [3]
     //               <3> 
-    //                                                  0,1,2,3,4,5,6,7 
-    int8u line_parameters::s_orthogonal_quadrant[8] = { 0,0,1,1,3,3,2,2 };
-    int8u line_parameters::s_diagonal_quadrant[8]   = { 0,1,2,1,0,3,2,3 };
+    //                                                        0,1,2,3,4,5,6,7 
+    const int8u line_parameters::s_orthogonal_quadrant[8] = { 0,0,1,1,3,3,2,2 };
+    const int8u line_parameters::s_diagonal_quadrant[8]   = { 0,1,2,1,0,3,2,3 };
 
 
 

Modified: trunk/agg/src/agg_line_profile_aa.cpp
===================================================================
--- trunk/agg/src/agg_line_profile_aa.cpp	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/src/agg_line_profile_aa.cpp	2006-11-09 23:44:34 UTC (rev 367)
@@ -44,12 +44,11 @@
     {
         m_subpixel_width = uround(w * subpixel_scale);
         unsigned size = m_subpixel_width + subpixel_scale * 6;
-        if(size > m_size)
+        if(size > m_profile.size())
         {
-            delete [] m_profile;
-            m_profile = new value_type[m_size = size];
+            m_profile.resize(size);
         }
-        return m_profile;
+        return &m_profile[0];
     }
 
 

Modified: trunk/agg/src/agg_sqrt_tables.cpp
===================================================================
--- trunk/agg/src/agg_sqrt_tables.cpp	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/src/agg_sqrt_tables.cpp	2006-11-09 23:44:34 UTC (rev 367)
@@ -21,7 +21,7 @@
 
 namespace agg
 {
-    int16u g_sqrt_table[1024] = 
+    int16u g_sqrt_table[1024] =                       //----------g_sqrt_table
     {
         0,
         2048,2896,3547,4096,4579,5017,5418,5793,6144,6476,6792,7094,7384,7663,7932,8192,8444,
@@ -100,7 +100,7 @@
     };
 
 
-    int8 g_elder_bit_table[256] = 
+    int8 g_elder_bit_table[256] =          //---------g_elder_bit_table
     {
         0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
         5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,

Modified: trunk/agg/src/agg_trans_affine.cpp
===================================================================
--- trunk/agg/src/agg_trans_affine.cpp	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/src/agg_trans_affine.cpp	2006-11-09 23:44:34 UTC (rev 367)
@@ -27,12 +27,12 @@
     const trans_affine& trans_affine::parl_to_parl(const double* src, 
                                                    const double* dst)
     {
-        m0 = src[2] - src[0];
-        m1 = src[3] - src[1];
-        m2 = src[4] - src[0];
-        m3 = src[5] - src[1];
-        m4 = src[0];
-        m5 = src[1];
+        sx  = src[2] - src[0];
+        shy = src[3] - src[1];
+        shx = src[4] - src[0];
+        sy  = src[5] - src[1];
+        tx  = src[0];
+        ty  = src[1];
         invert();
         multiply(trans_affine(dst[2] - dst[0], dst[3] - dst[1], 
                               dst[4] - dst[0], dst[5] - dst[1],
@@ -69,15 +69,15 @@
     //------------------------------------------------------------------------
     const trans_affine& trans_affine::multiply(const trans_affine& m)
     {
-        double t0 = m0 * m.m0 + m1 * m.m2;
-        double t2 = m2 * m.m0 + m3 * m.m2;
-        double t4 = m4 * m.m0 + m5 * m.m2 + m.m4;
-        m1 = m0 * m.m1 + m1 * m.m3;
-        m3 = m2 * m.m1 + m3 * m.m3;
-        m5 = m4 * m.m1 + m5 * m.m3 + m.m5;
-        m0 = t0;
-        m2 = t2;
-        m4 = t4;
+        double t0 = sx  * m.sx + shy * m.shx;
+        double t2 = shx * m.sx + sy  * m.shx;
+        double t4 = tx  * m.sx + ty  * m.shx + m.tx;
+        shy = sx  * m.shy + shy * m.sy;
+        sy  = shx * m.shy + sy  * m.sy;
+        ty  = tx  * m.shy + ty  * m.sy + m.ty;
+        sx  = t0;
+        shx = t2;
+        tx  = t4;
         return *this;
     }
 
@@ -85,18 +85,18 @@
     //------------------------------------------------------------------------
     const trans_affine& trans_affine::invert()
     {
-        double d  = determinant();
+        double d  = determinant_reciprocal();
 
-        double t0 =  m3 * d;
-               m3 =  m0 * d;
-               m1 = -m1 * d;
-               m2 = -m2 * d;
+        double t0  =  sy  * d;
+               sy  =  sx  * d;
+               shy = -shy * d;
+               shx = -shx * d;
 
-        double t4 = -m4 * t0 - m5 * m2;
-               m5 = -m4 * m1 - m5 * m3;
+        double t4 = -tx * t0  - ty * shx;
+               ty = -tx * shy - ty * sy;
 
-        m0 = t0;
-        m4 = t4;
+        sx = t0;
+        tx = t4;
         return *this;
     }
 
@@ -104,55 +104,55 @@
    //------------------------------------------------------------------------
     const trans_affine& trans_affine::flip_x()
     {
-        m0 = -m0;
-        m1 = -m1;
-        m4 = -m4;
+        sx  = -sx;
+        shy = -shy;
+        tx  = -tx;
         return *this;
     }
 
     //------------------------------------------------------------------------
     const trans_affine& trans_affine::flip_y()
     {
-        m2 = -m2;
-        m3 = -m3;
-        m5 = -m5;
+        shx = -shx;
+        sy  = -sy;
+        ty  = -ty;
         return *this;
     }
 
     //------------------------------------------------------------------------
     const trans_affine& trans_affine::reset()
     {
-        m0 = m3 = 1.0; 
-        m1 = m2 = m4 = m5 = 0.0;
+        sx  = sy  = 1.0; 
+        shy = shx = tx = ty = 0.0;
         return *this;
     }
 
     //------------------------------------------------------------------------
-    inline bool is_equal_eps(double v1, double v2, double epsilon)
+    bool trans_affine::is_identity(double epsilon) const
     {
-        return fabs(v1 - v2) < epsilon;
+        return is_equal_eps(sx,  1.0, epsilon) &&
+               is_equal_eps(shy, 0.0, epsilon) &&
+               is_equal_eps(shx, 0.0, epsilon) && 
+               is_equal_eps(sy,  1.0, epsilon) &&
+               is_equal_eps(tx,  0.0, epsilon) &&
+               is_equal_eps(ty,  0.0, epsilon);
     }
 
     //------------------------------------------------------------------------
-    bool trans_affine::is_identity(double epsilon) const
+    bool trans_affine::is_valid(double epsilon) const
     {
-        return is_equal_eps(m0, 1.0, epsilon) &&
-               is_equal_eps(m1, 0.0, epsilon) &&
-               is_equal_eps(m2, 0.0, epsilon) && 
-               is_equal_eps(m3, 1.0, epsilon) &&
-               is_equal_eps(m4, 0.0, epsilon) &&
-               is_equal_eps(m5, 0.0, epsilon);
+        return fabs(sx) > epsilon && fabs(sy) > epsilon;
     }
 
     //------------------------------------------------------------------------
     bool trans_affine::is_equal(const trans_affine& m, double epsilon) const
     {
-        return is_equal_eps(m0, m.m0, epsilon) &&
-               is_equal_eps(m1, m.m1, epsilon) &&
-               is_equal_eps(m2, m.m2, epsilon) && 
-               is_equal_eps(m3, m.m3, epsilon) &&
-               is_equal_eps(m4, m.m4, epsilon) &&
-               is_equal_eps(m5, m.m5, epsilon);
+        return is_equal_eps(sx,  m.sx,  epsilon) &&
+               is_equal_eps(shy, m.shy, epsilon) &&
+               is_equal_eps(shx, m.shx, epsilon) && 
+               is_equal_eps(sy,  m.sy,  epsilon) &&
+               is_equal_eps(tx,  m.tx,  epsilon) &&
+               is_equal_eps(ty,  m.ty,  epsilon);
     }
 
     //------------------------------------------------------------------------
@@ -170,13 +170,12 @@
     //------------------------------------------------------------------------
     void trans_affine::translation(double* dx, double* dy) const
     {
-        trans_affine t(*this);
-        t *= trans_affine_rotation(-rotation());
-        t.transform(dx, dy);
+        *dx = tx;
+        *dy = ty;
     }
 
     //------------------------------------------------------------------------
-    void trans_affine::scaling(double* sx, double* sy) const
+    void trans_affine::scaling(double* x, double* y) const
     {
         double x1 = 0.0;
         double y1 = 0.0;
@@ -186,8 +185,8 @@
         t *= trans_affine_rotation(-rotation());
         t.transform(&x1, &y1);
         t.transform(&x2, &y2);
-        *sx = x2 - x1;
-        *sy = y2 - y1;
+        *x = x2 - x1;
+        *y = y2 - y1;
     }
 
 

Modified: trunk/agg/src/agg_trans_warp_magnifier.cpp
===================================================================
--- trunk/agg/src/agg_trans_warp_magnifier.cpp	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/src/agg_trans_warp_magnifier.cpp	2006-11-09 23:44:34 UTC (rev 367)
@@ -40,10 +40,30 @@
     //------------------------------------------------------------------------
     void trans_warp_magnifier::inverse_transform(double* x, double* y) const
     {
-        trans_warp_magnifier t(*this);
-        t.magnification(1.0 / m_magn);
-        t.radius(m_radius * m_magn);
-        t.transform(x, y);
+        // New version by Andrew Skalkin
+        //-----------------
+        double dx = *x - m_xc;
+        double dy = *y - m_yc;
+        double r = sqrt(dx * dx + dy * dy);
+
+        if(r < m_radius * m_magn) 
+        {
+            *x = m_xc + dx / m_magn;
+            *y = m_yc + dy / m_magn;
+        }
+        else
+        {
+            double rnew = r - m_radius * (m_magn - 1.0);
+            *x = m_xc + rnew * dx / r; 
+            *y = m_yc + rnew * dy / r;
+        }
+
+        // Old version
+        //-----------------
+        //trans_warp_magnifier t(*this);
+        //t.magnification(1.0 / m_magn);
+        //t.radius(m_radius * m_magn);
+        //t.transform(x, y);
     }
 
 

Modified: trunk/agg/src/agg_vcgen_contour.cpp
===================================================================
--- trunk/agg/src/agg_vcgen_contour.cpp	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/src/agg_vcgen_contour.cpp	2006-11-09 23:44:34 UTC (rev 367)
@@ -25,16 +25,10 @@
 
     //------------------------------------------------------------------------
     vcgen_contour::vcgen_contour() :
+        m_stroker(),
+        m_width(1),
         m_src_vertices(),
         m_out_vertices(),
-        m_width(1.0),
-        m_line_join(bevel_join),
-        m_inner_join(inner_miter),
-        m_approx_scale(1.0),
-        m_abs_width(1.0),
-        m_signed_width(1.0),
-        m_miter_limit(4.0),
-        m_inner_miter_limit(1.0 + 1.0/64.0),
         m_status(initial),
         m_src_vertex(0),
         m_closed(0),
@@ -43,27 +37,16 @@
     {
     }
 
-
     //------------------------------------------------------------------------
     void vcgen_contour::remove_all()
     {
         m_src_vertices.remove_all();
         m_closed = 0;
         m_orientation = 0;
-        m_abs_width = fabs(m_width);
-        m_signed_width = m_width;
         m_status = initial;
     }
 
-
     //------------------------------------------------------------------------
-    void vcgen_contour::miter_limit_theta(double t)
-    { 
-        m_miter_limit = 1.0 / sin(t * 0.5) ;
-    }
-
-
-    //------------------------------------------------------------------------
     void vcgen_contour::add_vertex(double x, double y, unsigned cmd)
     {
         m_status = initial;
@@ -91,14 +74,12 @@
         }
     }
 
-
     //------------------------------------------------------------------------
     void vcgen_contour::rewind(unsigned)
     {
         if(m_status == initial)
         {
             m_src_vertices.close(true);
-            m_signed_width = m_width;
             if(m_auto_detect)
             {
                 if(!is_oriented(m_orientation))
@@ -110,14 +91,13 @@
             }
             if(is_oriented(m_orientation))
             {
-                m_signed_width = is_ccw(m_orientation) ? m_width : -m_width;
+                m_stroker.width(is_ccw(m_orientation) ? m_width : -m_width);
             }
         }
         m_status = ready;
         m_src_vertex = 0;
     }
 
-
     //------------------------------------------------------------------------
     unsigned vcgen_contour::vertex(double* x, double* y)
     {
@@ -146,18 +126,12 @@
                     m_status = end_poly;
                     break;
                 }
-                stroke_calc_join(m_out_vertices, 
-                                 m_src_vertices.prev(m_src_vertex), 
-                                 m_src_vertices.curr(m_src_vertex), 
-                                 m_src_vertices.next(m_src_vertex), 
-                                 m_src_vertices.prev(m_src_vertex).dist,
-                                 m_src_vertices.curr(m_src_vertex).dist,
-                                 m_signed_width, 
-                                 m_line_join,
-                                 m_inner_join,
-                                 m_miter_limit,
-                                 m_inner_miter_limit,
-                                 m_approx_scale);
+                m_stroker.calc_join(m_out_vertices, 
+                                    m_src_vertices.prev(m_src_vertex), 
+                                    m_src_vertices.curr(m_src_vertex), 
+                                    m_src_vertices.next(m_src_vertex), 
+                                    m_src_vertices.prev(m_src_vertex).dist,
+                                    m_src_vertices.curr(m_src_vertex).dist);
                 ++m_src_vertex;
                 m_status = out_vertices;
                 m_out_vertex = 0;

Modified: trunk/agg/src/agg_vcgen_stroke.cpp
===================================================================
--- trunk/agg/src/agg_vcgen_stroke.cpp	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/agg/src/agg_vcgen_stroke.cpp	2006-11-09 23:44:34 UTC (rev 367)
@@ -25,16 +25,10 @@
 
     //------------------------------------------------------------------------
     vcgen_stroke::vcgen_stroke() :
+        m_stroker(),
         m_src_vertices(),
         m_out_vertices(),
-        m_width(0.5),
-        m_miter_limit(4.0),
-        m_inner_miter_limit(1.01),
-        m_approx_scale(1.0),
         m_shorten(0.0),
-        m_line_cap(butt_cap),
-        m_line_join(miter_join),
-        m_inner_join(inner_miter),
         m_closed(0),
         m_status(initial),
         m_src_vertex(0),
@@ -42,15 +36,7 @@
     {
     }
 
-
     //------------------------------------------------------------------------
-    void vcgen_stroke::miter_limit_theta(double t)
-    { 
-        m_miter_limit = 1.0 / sin(t * 0.5) ;
-    }
-
-
-    //------------------------------------------------------------------------
     void vcgen_stroke::remove_all()
     {
         m_src_vertices.remove_all();
@@ -80,23 +66,7 @@
         }
     }
 
-
     //------------------------------------------------------------------------
-    static inline void calc_butt_cap(double* cap,
-                                     const vertex_dist& v0, 
-                                     const vertex_dist& v1, 
-                                     double len,
-                                     double width)
-    {
-        double dx = (v1.y - v0.y) * width / len;
-        double dy = (v1.x - v0.x) * width / len;
-        cap[0] = v0.x - dx; 
-        cap[1] = v0.y + dy;
-        cap[2] = v0.x + dx;
-        cap[3] = v0.y - dy;
-    }
-
-    //------------------------------------------------------------------------
     void vcgen_stroke::rewind(unsigned)
     {
         if(m_status == initial)
@@ -135,13 +105,10 @@
                 break;
 
             case cap1:
-                stroke_calc_cap(m_out_vertices,
-                                m_src_vertices[0], 
-                                m_src_vertices[1], 
-                                m_src_vertices[0].dist,
-                                m_line_cap,
-                                m_width,
-                                m_approx_scale);
+                m_stroker.calc_cap(m_out_vertices,
+                                   m_src_vertices[0], 
+                                   m_src_vertices[1], 
+                                   m_src_vertices[0].dist);
                 m_src_vertex = 1;
                 m_prev_status = outline1;
                 m_status = out_vertices;
@@ -149,13 +116,10 @@
                 break;
 
             case cap2:
-                stroke_calc_cap(m_out_vertices,
-                                m_src_vertices[m_src_vertices.size() - 1], 
-                                m_src_vertices[m_src_vertices.size() - 2], 
-                                m_src_vertices[m_src_vertices.size() - 2].dist,
-                                m_line_cap,
-                                m_width,
-                                m_approx_scale);
+                m_stroker.calc_cap(m_out_vertices,
+                                   m_src_vertices[m_src_vertices.size() - 1], 
+                                   m_src_vertices[m_src_vertices.size() - 2], 
+                                   m_src_vertices[m_src_vertices.size() - 2].dist);
                 m_prev_status = outline2;
                 m_status = out_vertices;
                 m_out_vertex = 0;
@@ -179,18 +143,12 @@
                         break;
                     }
                 }
-                stroke_calc_join(m_out_vertices, 
-                                 m_src_vertices.prev(m_src_vertex), 
-                                 m_src_vertices.curr(m_src_vertex), 
-                                 m_src_vertices.next(m_src_vertex), 
-                                 m_src_vertices.prev(m_src_vertex).dist,
-                                 m_src_vertices.curr(m_src_vertex).dist,
-                                 m_width, 
-                                 m_line_join,
-                                 m_inner_join,
-                                 m_miter_limit,
-                                 m_inner_miter_limit,
-                                 m_approx_scale);
+                m_stroker.calc_join(m_out_vertices, 
+                                    m_src_vertices.prev(m_src_vertex), 
+                                    m_src_vertices.curr(m_src_vertex), 
+                                    m_src_vertices.next(m_src_vertex), 
+                                    m_src_vertices.prev(m_src_vertex).dist,
+                                    m_src_vertices.curr(m_src_vertex).dist);
                 ++m_src_vertex;
                 m_prev_status = m_status;
                 m_status = out_vertices;
@@ -210,18 +168,12 @@
                 }
 
                 --m_src_vertex;
-                stroke_calc_join(m_out_vertices,
-                                 m_src_vertices.next(m_src_vertex), 
-                                 m_src_vertices.curr(m_src_vertex), 
-                                 m_src_vertices.prev(m_src_vertex), 
-                                 m_src_vertices.curr(m_src_vertex).dist, 
-                                 m_src_vertices.prev(m_src_vertex).dist,
-                                 m_width, 
-                                 m_line_join,
-                                 m_inner_join,
-                                 m_miter_limit,
-                                 m_inner_miter_limit,
-                                 m_approx_scale);
+                m_stroker.calc_join(m_out_vertices,
+                                    m_src_vertices.next(m_src_vertex), 
+                                    m_src_vertices.curr(m_src_vertex), 
+                                    m_src_vertices.prev(m_src_vertex), 
+                                    m_src_vertices.curr(m_src_vertex).dist, 
+                                    m_src_vertices.prev(m_src_vertex).dist);
 
                 m_prev_status = m_status;
                 m_status = out_vertices;

Modified: trunk/demo/python/rundemo.py
===================================================================
--- trunk/demo/python/rundemo.py	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/demo/python/rundemo.py	2006-11-09 23:44:34 UTC (rev 367)
@@ -290,7 +290,6 @@
 popplaces_text_symbolizer.halo_fill = Color('white')
 popplaces_text_symbolizer.halo_radius = 1
 popplaces_rule.symbols.append(popplaces_text_symbolizer)
-popplaces_rule.symbols.append(PointSymbolizer("/home/artem/dot.png","png",10,10))
 
 popplaces_style.rules.append(popplaces_rule)
 

Modified: trunk/src/agg_renderer.cpp
===================================================================
--- trunk/src/agg_renderer.cpp	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/src/agg_renderer.cpp	2006-11-09 23:44:34 UTC (rev 367)
@@ -146,7 +146,7 @@
             unsigned width = pixmap_.width();
             unsigned height = pixmap_.height();
             path_type path(t_,*geom,prj_trans);
-            agg::row_ptr_cache<agg::int8u> buf(pixmap_.raw_data(),width,height,width * 4);
+            agg::row_accessor<agg::int8u> buf(pixmap_.raw_data(),width,height,width * 4);
             agg::pixfmt_rgba32 pixf(buf);
             ren_base renb(pixf);	    
 		
@@ -179,13 +179,13 @@
         if (geom && geom->num_points() > 1)
         {
             path_type path(t_,*geom,prj_trans);
-            agg::row_ptr_cache<agg::int8u> buf(pixmap_.raw_data(),
+            agg::row_accessor<agg::int8u> buf(pixmap_.raw_data(),
                                                pixmap_.width(),
                                                pixmap_.height(),
                                                pixmap_.width()*4);
             agg::pixfmt_rgba32 pixf(buf);
             ren_base renb(pixf);	    
-		
+            
             mapnik::stroke const&  stroke_ = sym.get_stroke();
 		
             Color const& col = stroke_.get_color();
@@ -241,7 +241,7 @@
                 prof.width(stroke_.get_width());
                 renderer_oaa ren_oaa(renb, prof);
                 rasterizer_outline_aa ras_oaa(ren_oaa);
-		    
+                
                 ren_oaa.color(agg::rgba8(r, g, b, int(255*stroke_.get_opacity())));
                 ren_oaa.clip_box(0,0,pixmap_.width(),pixmap_.height());
                 ras_oaa.add_path(path);		
@@ -389,7 +389,7 @@
             unsigned height = pixmap_.height();
             ImageData32 const& pat = sym.get_pattern();
             path_type path(t_,*geom,prj_trans);
-            agg::row_ptr_cache<agg::int8u> buf(pixmap_.raw_data(), width, height,width*4);
+            agg::row_accessor<agg::int8u> buf(pixmap_.raw_data(), width, height,width*4);
             agg::pixfmt_rgba32 pixf(buf);
             renderer_base ren_base(pixf);  
             agg::pattern_filter_bilinear_rgba8 filter; 
@@ -429,13 +429,13 @@
             unsigned height = pixmap_.height();
             path_type path(t_,*geom,prj_trans);
 	    
-            agg::row_ptr_cache<agg::int8u> buf(pixmap_.raw_data(),width,height,width * 4);
+            agg::row_accessor<agg::int8u> buf(pixmap_.raw_data(),width,height,width * 4);
             agg::pixfmt_rgba32 pixf(buf);
             ren_base renb(pixf);
 	
             unsigned w=pattern.width();
             unsigned h=pattern.height();
-            agg::row_ptr_cache<agg::int8u> pattern_rbuf((agg::int8u*)pattern.getBytes(),w,h,w*4);  
+            agg::row_accessor<agg::int8u> pattern_rbuf((agg::int8u*)pattern.getBytes(),w,h,w*4);  
 	    
             double x0,y0;
             path.vertex(&x0,&y0);
@@ -443,12 +443,13 @@
 	
             unsigned offset_x = unsigned(width - x0);
             unsigned offset_y = unsigned(height - y0);
-	
+            
             agg::span_allocator<agg::rgba8> sa;
-            img_source_type img_src(pattern_rbuf);
+            agg::pixfmt_rgba32 pixf_pattern(pattern_rbuf);
+            img_source_type img_src(pixf_pattern);
             span_gen_type sg(img_src, offset_x, offset_y);
             renderer_type rp(renb,sa, sg);
-	
+            
             agg::rasterizer_scanline_aa<> ras;
             agg::scanline_u8 sl;
             ras.clip_box(0,0,width,height);

Modified: trunk/src/load_map.cpp
===================================================================
--- trunk/src/load_map.cpp	2006-11-08 20:58:40 UTC (rev 366)
+++ trunk/src/load_map.cpp	2006-11-09 23:44:34 UTC (rev 367)
@@ -126,16 +126,23 @@
                             
                             if ( sym.first == "PointSymbolizer")
                             {
-                                std::string file =  
-                                    sym.second.get<std::string>("<xmlattr>.file"); 
-                                std::string type =  
-                                    sym.second.get<std::string>("<xmlattr>.type");
-                                unsigned width =  
-                                    sym.second.get<unsigned>("<xmlattr>.width");
-                                unsigned height =  
-                                    sym.second.get<unsigned>("<xmlattr>.height");
+                                boost::optional<std::string> file =  
+                                    sym.second.get_optional<std::string>("<xmlattr>.file"); 
+                                boost::optional<std::string> type =  
+                                    sym.second.get_optional<std::string>("<xmlattr>.type");
+                                boost::optional<unsigned> width =  
+                                    sym.second.get_optional<unsigned>("<xmlattr>.width");
+                                boost::optional<unsigned> height =  
+                                    sym.second.get_optional<unsigned>("<xmlattr>.height");
                                 
-                                rule.append(point_symbolizer(file,type,width,height));
+                                if (file && type && width && height)
+                                {
+                                    rule.append(point_symbolizer(*file,*type,*width,*height));
+                                }
+                                else
+                                {
+                                    rule.append(point_symbolizer());
+                                }
                             } 
                             else if ( sym.first == "LinePatternSymbolizer")
                             {



From pavlenko at mail.berlios.de  Fri Nov 10 00:48:12 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Fri, 10 Nov 2006 00:48:12 +0100
Subject: [Mapnik-svn] r368 - trunk/agg/include
Message-ID: <200611092348.kA9NmCGN008055@sheep.berlios.de>

Author: pavlenko
Date: 2006-11-10 00:48:09 +0100 (Fri, 10 Nov 2006)
New Revision: 368

Added:
   trunk/agg/include/agg_blur.h
   trunk/agg/include/agg_gradient_lut.h
   trunk/agg/include/agg_pixfmt_transposer.h
Log:
added missing agg headers

Added: trunk/agg/include/agg_blur.h
===================================================================
--- trunk/agg/include/agg_blur.h	2006-11-09 23:44:34 UTC (rev 367)
+++ trunk/agg/include/agg_blur.h	2006-11-09 23:48:09 UTC (rev 368)
@@ -0,0 +1,1294 @@
+//----------------------------------------------------------------------------
+// Anti-Grain Geometry - Version 2.4
+// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
+//
+// Permission to copy, use, modify, sell and distribute this software 
+// is granted provided this copyright notice appears in all copies. 
+// This software is provided "as is" without express or implied
+// warranty, and with no claim as to its suitability for any purpose.
+//
+//----------------------------------------------------------------------------
+// Contact: mcseem at antigrain.com
+//          mcseemagg at yahoo.com
+//          http://www.antigrain.com
+//----------------------------------------------------------------------------
+//
+// The Stack Blur Algorithm was invented by Mario Klingemann, 
+// mario at quasimondo.com and described here:
+// http://incubator.quasimondo.com/processing/fast_blur_deluxe.php
+// (search phrase "Stackblur: Fast But Goodlooking"). 
+// The major improvement is that there's no more division table
+// that was very expensive to create for large blur radii. Insted, 
+// for 8-bit per channel and radius not exceeding 254 the division is 
+// replaced by multiplication and shift. 
+//
+//----------------------------------------------------------------------------
+
+#ifndef AGG_BLUR_INCLUDED
+#define AGG_BLUR_INCLUDED
+
+#include "agg_array.h"
+#include "agg_pixfmt_transposer.h"
+
+namespace agg
+{
+
+    template<class T> struct stack_blur_tables
+    {
+        static int16u const g_stack_blur8_mul[255];
+        static int8u  const g_stack_blur8_shr[255];
+    };
+
+    //------------------------------------------------------------------------
+    template<class T> 
+    int16u const stack_blur_tables<T>::g_stack_blur8_mul[255] = 
+    {
+        512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,
+        454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,
+        482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,
+        437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,
+        497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,
+        320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,
+        446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,
+        329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,
+        505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,
+        399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,
+        324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,
+        268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,
+        451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,
+        385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,
+        332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,
+        289,287,285,282,280,278,275,273,271,269,267,265,263,261,259
+    };
+
+    //------------------------------------------------------------------------
+    template<class T> 
+    int8u const stack_blur_tables<T>::g_stack_blur8_shr[255] = 
+    {
+          9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 
+         17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 
+         19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,
+         20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,
+         21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
+         21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 
+         22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
+         22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 
+         23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
+         23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
+         23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
+         23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 
+         24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+         24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+         24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+         24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24
+    };
+
+
+
+    //==============================================================stack_blur
+    template<class ColorT, class CalculatorT> class stack_blur
+    {
+    public:
+        typedef ColorT      color_type;
+        typedef CalculatorT calculator_type;
+
+        //--------------------------------------------------------------------
+        template<class Img> void blur_x(Img& img, unsigned radius)
+        {
+            if(radius < 1) return;
+
+            unsigned x, y, xp, i;
+            unsigned stack_ptr;
+            unsigned stack_start;
+
+            color_type      pix;
+            color_type*     stack_pix;
+            calculator_type sum;
+            calculator_type sum_in;
+            calculator_type sum_out;
+
+            unsigned w   = img.width();
+            unsigned h   = img.height();
+            unsigned wm  = w - 1;
+            unsigned div = radius * 2 + 1;
+
+            unsigned div_sum = (radius + 1) * (radius + 1);
+            unsigned mul_sum = 0;
+            unsigned shr_sum = 0;
+            unsigned max_val = color_type::base_mask;
+
+            if(max_val <= 255 && radius < 255)
+            {
+                mul_sum = stack_blur_tables<int>::g_stack_blur8_mul[radius];
+                shr_sum = stack_blur_tables<int>::g_stack_blur8_shr[radius];
+            }
+
+            m_buf.allocate(w, 128);
+            m_stack.allocate(div, 32);
+
+            for(y = 0; y < h; y++)
+            {
+                sum.clear();
+                sum_in.clear();
+                sum_out.clear();
+
+                pix = img.pixel(0, y);
+                for(i = 0; i <= radius; i++)
+                {
+                    m_stack[i] = pix;
+                    sum.add(pix, i + 1);
+                    sum_out.add(pix);
+                }
+                for(i = 1; i <= radius; i++)
+                {
+                    pix = img.pixel((i > wm) ? wm : i, y);
+                    m_stack[i + radius] = pix;
+                    sum.add(pix, radius + 1 - i);
+                    sum_in.add(pix);
+                }
+
+                stack_ptr = radius;
+                for(x = 0; x < w; x++)
+                {
+                    if(mul_sum) sum.calc_pix(m_buf[x], mul_sum, shr_sum);
+                    else        sum.calc_pix(m_buf[x], div_sum);
+
+                    sum.sub(sum_out);
+           
+                    stack_start = stack_ptr + div - radius;
+                    if(stack_start >= div) stack_start -= div;
+                    stack_pix = &m_stack[stack_start];
+
+                    sum_out.sub(*stack_pix);
+
+                    xp = x + radius + 1;
+                    if(xp > wm) xp = wm;
+                    pix = img.pixel(xp, y);
+            
+                    *stack_pix = pix;
+            
+                    sum_in.add(pix);
+                    sum.add(sum_in);
+            
+                    ++stack_ptr;
+                    if(stack_ptr >= div) stack_ptr = 0;
+                    stack_pix = &m_stack[stack_ptr];
+
+                    sum_out.add(*stack_pix);
+                    sum_in.sub(*stack_pix);
+                }
+                img.copy_color_hspan(0, y, w, &m_buf[0]);
+            }
+        }
+
+        //--------------------------------------------------------------------
+        template<class Img> void blur_y(Img& img, unsigned radius)
+        {
+            pixfmt_transposer<Img> img2(img);
+            blur_x(img2, radius);
+        }
+
+        //--------------------------------------------------------------------
+        template<class Img> void blur(Img& img, unsigned radius)
+        {
+            blur_x(img, radius);
+            pixfmt_transposer<Img> img2(img);
+            blur_x(img2, radius);
+        }
+
+    private:
+        pod_vector<color_type> m_buf;
+        pod_vector<color_type> m_stack;
+    };
+
+    //====================================================stack_blur_calc_rgba
+    template<class T=unsigned> struct stack_blur_calc_rgba
+    {
+        typedef T value_type;
+        value_type r,g,b,a;
+
+        AGG_INLINE void clear() 
+        { 
+            r = g = b = a = 0; 
+        }
+
+        template<class ArgT> AGG_INLINE void add(const ArgT& v)
+        {
+            r += v.r;
+            g += v.g;
+            b += v.b;
+            a += v.a;
+        }
+
+        template<class ArgT> AGG_INLINE void add(const ArgT& v, unsigned k)
+        {
+            r += v.r * k;
+            g += v.g * k;
+            b += v.b * k;
+            a += v.a * k;
+        }
+
+        template<class ArgT> AGG_INLINE void sub(const ArgT& v)
+        {
+            r -= v.r;
+            g -= v.g;
+            b -= v.b;
+            a -= v.a;
+        }
+
+        template<class ArgT> AGG_INLINE void calc_pix(ArgT& v, unsigned div)
+        {
+            typedef typename ArgT::value_type value_type;
+            v.r = value_type(r / div);
+            v.g = value_type(g / div);
+            v.b = value_type(b / div);
+            v.a = value_type(a / div);
+        }
+
+        template<class ArgT> 
+        AGG_INLINE void calc_pix(ArgT& v, unsigned mul, unsigned shr)
+        {
+            typedef typename ArgT::value_type value_type;
+            v.r = value_type((r * mul) >> shr);
+            v.g = value_type((g * mul) >> shr);
+            v.b = value_type((b * mul) >> shr);
+            v.a = value_type((a * mul) >> shr);
+        }
+    };
+
+
+    //=====================================================stack_blur_calc_rgb
+    template<class T=unsigned> struct stack_blur_calc_rgb
+    {
+        typedef T value_type;
+        value_type r,g,b;
+
+        AGG_INLINE void clear() 
+        { 
+            r = g = b = 0; 
+        }
+
+        template<class ArgT> AGG_INLINE void add(const ArgT& v)
+        {
+            r += v.r;
+            g += v.g;
+            b += v.b;
+        }
+
+        template<class ArgT> AGG_INLINE void add(const ArgT& v, unsigned k)
+        {
+            r += v.r * k;
+            g += v.g * k;
+            b += v.b * k;
+        }
+
+        template<class ArgT> AGG_INLINE void sub(const ArgT& v)
+        {
+            r -= v.r;
+            g -= v.g;
+            b -= v.b;
+        }
+
+        template<class ArgT> AGG_INLINE void calc_pix(ArgT& v, unsigned div)
+        {
+            typedef typename ArgT::value_type value_type;
+            v.r = value_type(r / div);
+            v.g = value_type(g / div);
+            v.b = value_type(b / div);
+        }
+
+        template<class ArgT> 
+        AGG_INLINE void calc_pix(ArgT& v, unsigned mul, unsigned shr)
+        {
+            typedef typename ArgT::value_type value_type;
+            v.r = value_type((r * mul) >> shr);
+            v.g = value_type((g * mul) >> shr);
+            v.b = value_type((b * mul) >> shr);
+        }
+    };
+
+
+    //====================================================stack_blur_calc_gray
+    template<class T=unsigned> struct stack_blur_calc_gray
+    {
+        typedef T value_type;
+        value_type v;
+
+        AGG_INLINE void clear() 
+        { 
+            v = 0; 
+        }
+
+        template<class ArgT> AGG_INLINE void add(const ArgT& a)
+        {
+            v += a.v;
+        }
+
+        template<class ArgT> AGG_INLINE void add(const ArgT& a, unsigned k)
+        {
+            v += a.v * k;
+        }
+
+        template<class ArgT> AGG_INLINE void sub(const ArgT& a)
+        {
+            v -= a.v;
+        }
+
+        template<class ArgT> AGG_INLINE void calc_pix(ArgT& a, unsigned div)
+        {
+            typedef typename ArgT::value_type value_type;
+            a.v = value_type(v / div);
+        }
+
+        template<class ArgT> 
+        AGG_INLINE void calc_pix(ArgT& a, unsigned mul, unsigned shr)
+        {
+            typedef typename ArgT::value_type value_type;
+            a.v = value_type((v * mul) >> shr);
+        }
+    };
+
+
+
+    //========================================================stack_blur_gray8
+    template<class Img> 
+    void stack_blur_gray8(Img& img, unsigned rx, unsigned ry)
+    {
+        unsigned x, y, xp, yp, i;
+        unsigned stack_ptr;
+        unsigned stack_start;
+
+        const int8u* src_pix_ptr;
+              int8u* dst_pix_ptr;
+        unsigned pix;
+        unsigned stack_pix;
+        unsigned sum;
+        unsigned sum_in;
+        unsigned sum_out;
+
+        unsigned w   = img.width();
+        unsigned h   = img.height();
+        unsigned wm  = w - 1;
+        unsigned hm  = h - 1;
+
+        unsigned div;
+        unsigned mul_sum;
+        unsigned shr_sum;
+
+        pod_vector<int8u> stack;
+
+        if(rx > 0)
+        {
+            if(rx > 254) rx = 254;
+            div = rx * 2 + 1;
+            mul_sum = stack_blur_tables<int>::g_stack_blur8_mul[rx];
+            shr_sum = stack_blur_tables<int>::g_stack_blur8_shr[rx];
+            stack.allocate(div);
+
+            for(y = 0; y < h; y++)
+            {
+                sum = sum_in = sum_out = 0;
+
+                src_pix_ptr = img.pix_ptr(0, y);
+                pix = *src_pix_ptr;
+                for(i = 0; i <= rx; i++)
+                {
+                    stack[i] = pix;
+                    sum     += pix * (i + 1);
+                    sum_out += pix;
+                }
+                for(i = 1; i <= rx; i++)
+                {
+                    if(i <= wm) src_pix_ptr += Img::pix_step; 
+                    pix = *src_pix_ptr; 
+                    stack[i + rx] = pix;
+                    sum    += pix * (rx + 1 - i);
+                    sum_in += pix;
+                }
+
+                stack_ptr = rx;
+                xp = rx;
+                if(xp > wm) xp = wm;
+                src_pix_ptr = img.pix_ptr(xp, y);
+                dst_pix_ptr = img.pix_ptr(0, y);
+                for(x = 0; x < w; x++)
+                {
+                    *dst_pix_ptr = (sum * mul_sum) >> shr_sum;
+                    dst_pix_ptr += Img::pix_step;
+
+                    sum -= sum_out;
+       
+                    stack_start = stack_ptr + div - rx;
+                    if(stack_start >= div) stack_start -= div;
+                    sum_out -= stack[stack_start];
+
+                    if(xp < wm) 
+                    {
+                        src_pix_ptr += Img::pix_step;
+                        pix = *src_pix_ptr;
+                        ++xp;
+                    }
+        
+                    stack[stack_start] = pix;
+        
+                    sum_in += pix;
+                    sum    += sum_in;
+        
+                    ++stack_ptr;
+                    if(stack_ptr >= div) stack_ptr = 0;
+                    stack_pix = stack[stack_ptr];
+
+                    sum_out += stack_pix;
+                    sum_in  -= stack_pix;
+                }
+            }
+        }
+
+        if(ry > 0)
+        {
+            if(ry > 254) ry = 254;
+            div = ry * 2 + 1;
+            mul_sum = stack_blur_tables<int>::g_stack_blur8_mul[ry];
+            shr_sum = stack_blur_tables<int>::g_stack_blur8_shr[ry];
+            stack.allocate(div);
+
+            int stride = img.stride();
+            for(x = 0; x < w; x++)
+            {
+                sum = sum_in = sum_out = 0;
+
+                src_pix_ptr = img.pix_ptr(x, 0);
+                pix = *src_pix_ptr;
+                for(i = 0; i <= ry; i++)
+                {
+                    stack[i] = pix;
+                    sum     += pix * (i + 1);
+                    sum_out += pix;
+                }
+                for(i = 1; i <= ry; i++)
+                {
+                    if(i <= hm) src_pix_ptr += stride; 
+                    pix = *src_pix_ptr; 
+                    stack[i + ry] = pix;
+                    sum    += pix * (ry + 1 - i);
+                    sum_in += pix;
+                }
+
+                stack_ptr = ry;
+                yp = ry;
+                if(yp > hm) yp = hm;
+                src_pix_ptr = img.pix_ptr(x, yp);
+                dst_pix_ptr = img.pix_ptr(x, 0);
+                for(y = 0; y < h; y++)
+                {
+                    *dst_pix_ptr = (sum * mul_sum) >> shr_sum;
+                    dst_pix_ptr += stride;
+
+                    sum -= sum_out;
+       
+                    stack_start = stack_ptr + div - ry;
+                    if(stack_start >= div) stack_start -= div;
+                    sum_out -= stack[stack_start];
+
+                    if(yp < hm) 
+                    {
+                        src_pix_ptr += stride;
+                        pix = *src_pix_ptr;
+                        ++yp;
+                    }
+        
+                    stack[stack_start] = pix;
+        
+                    sum_in += pix;
+                    sum    += sum_in;
+        
+                    ++stack_ptr;
+                    if(stack_ptr >= div) stack_ptr = 0;
+                    stack_pix = stack[stack_ptr];
+
+                    sum_out += stack_pix;
+                    sum_in  -= stack_pix;
+                }
+            }
+        }
+    }
+
+
+
+    //========================================================stack_blur_rgb24
+    template<class Img> 
+    void stack_blur_rgb24(Img& img, unsigned rx, unsigned ry)
+    {
+        typedef typename Img::color_type color_type;
+        typedef typename Img::order_type order_type;
+        enum order_e 
+        { 
+            R = order_type::R, 
+            G = order_type::G, 
+            B = order_type::B 
+        };
+
+        unsigned x, y, xp, yp, i;
+        unsigned stack_ptr;
+        unsigned stack_start;
+
+        const int8u* src_pix_ptr;
+              int8u* dst_pix_ptr;
+        color_type*  stack_pix_ptr;
+
+        unsigned sum_r;
+        unsigned sum_g;
+        unsigned sum_b;
+        unsigned sum_in_r;
+        unsigned sum_in_g;
+        unsigned sum_in_b;
+        unsigned sum_out_r;
+        unsigned sum_out_g;
+        unsigned sum_out_b;
+
+        unsigned w   = img.width();
+        unsigned h   = img.height();
+        unsigned wm  = w - 1;
+        unsigned hm  = h - 1;
+
+        unsigned div;
+        unsigned mul_sum;
+        unsigned shr_sum;
+
+        pod_vector<color_type> stack;
+
+        if(rx > 0)
+        {
+            if(rx > 254) rx = 254;
+            div = rx * 2 + 1;
+            mul_sum = stack_blur_tables<int>::g_stack_blur8_mul[rx];
+            shr_sum = stack_blur_tables<int>::g_stack_blur8_shr[rx];
+            stack.allocate(div);
+
+            for(y = 0; y < h; y++)
+            {
+                sum_r = 
+                sum_g = 
+                sum_b = 
+                sum_in_r = 
+                sum_in_g = 
+                sum_in_b = 
+                sum_out_r = 
+                sum_out_g = 
+                sum_out_b = 0;
+
+                src_pix_ptr = img.pix_ptr(0, y);
+                for(i = 0; i <= rx; i++)
+                {
+                    stack_pix_ptr    = &stack[i];
+                    stack_pix_ptr->r = src_pix_ptr[R];
+                    stack_pix_ptr->g = src_pix_ptr[G];
+                    stack_pix_ptr->b = src_pix_ptr[B];
+                    sum_r           += src_pix_ptr[R] * (i + 1);
+                    sum_g           += src_pix_ptr[G] * (i + 1);
+                    sum_b           += src_pix_ptr[B] * (i + 1);
+                    sum_out_r       += src_pix_ptr[R];
+                    sum_out_g       += src_pix_ptr[G];
+                    sum_out_b       += src_pix_ptr[B];
+                }
+                for(i = 1; i <= rx; i++)
+                {
+                    if(i <= wm) src_pix_ptr += Img::pix_width; 
+                    stack_pix_ptr = &stack[i + rx];
+                    stack_pix_ptr->r = src_pix_ptr[R];
+                    stack_pix_ptr->g = src_pix_ptr[G];
+                    stack_pix_ptr->b = src_pix_ptr[B];
+                    sum_r           += src_pix_ptr[R] * (rx + 1 - i);
+                    sum_g           += src_pix_ptr[G] * (rx + 1 - i);
+                    sum_b           += src_pix_ptr[B] * (rx + 1 - i);
+                    sum_in_r        += src_pix_ptr[R];
+                    sum_in_g        += src_pix_ptr[G];
+                    sum_in_b        += src_pix_ptr[B];
+                }
+
+                stack_ptr = rx;
+                xp = rx;
+                if(xp > wm) xp = wm;
+                src_pix_ptr = img.pix_ptr(xp, y);
+                dst_pix_ptr = img.pix_ptr(0, y);
+                for(x = 0; x < w; x++)
+                {
+                    dst_pix_ptr[R] = (sum_r * mul_sum) >> shr_sum;
+                    dst_pix_ptr[G] = (sum_g * mul_sum) >> shr_sum;
+                    dst_pix_ptr[B] = (sum_b * mul_sum) >> shr_sum;
+                    dst_pix_ptr   += Img::pix_width;
+
+                    sum_r -= sum_out_r;
+                    sum_g -= sum_out_g;
+                    sum_b -= sum_out_b;
+       
+                    stack_start = stack_ptr + div - rx;
+                    if(stack_start >= div) stack_start -= div;
+                    stack_pix_ptr = &stack[stack_start];
+
+                    sum_out_r -= stack_pix_ptr->r;
+                    sum_out_g -= stack_pix_ptr->g;
+                    sum_out_b -= stack_pix_ptr->b;
+
+                    if(xp < wm) 
+                    {
+                        src_pix_ptr += Img::pix_width;
+                        ++xp;
+                    }
+        
+                    stack_pix_ptr->r = src_pix_ptr[R];
+                    stack_pix_ptr->g = src_pix_ptr[G];
+                    stack_pix_ptr->b = src_pix_ptr[B];
+        
+                    sum_in_r += src_pix_ptr[R];
+                    sum_in_g += src_pix_ptr[G];
+                    sum_in_b += src_pix_ptr[B];
+                    sum_r    += sum_in_r;
+                    sum_g    += sum_in_g;
+                    sum_b    += sum_in_b;
+        
+                    ++stack_ptr;
+                    if(stack_ptr >= div) stack_ptr = 0;
+                    stack_pix_ptr = &stack[stack_ptr];
+
+                    sum_out_r += stack_pix_ptr->r;
+                    sum_out_g += stack_pix_ptr->g;
+                    sum_out_b += stack_pix_ptr->b;
+                    sum_in_r  -= stack_pix_ptr->r;
+                    sum_in_g  -= stack_pix_ptr->g;
+                    sum_in_b  -= stack_pix_ptr->b;
+                }
+            }
+        }
+
+        if(ry > 0)
+        {
+            if(ry > 254) ry = 254;
+            div = ry * 2 + 1;
+            mul_sum = stack_blur_tables<int>::g_stack_blur8_mul[ry];
+            shr_sum = stack_blur_tables<int>::g_stack_blur8_shr[ry];
+            stack.allocate(div);
+
+            int stride = img.stride();
+            for(x = 0; x < w; x++)
+            {
+                sum_r = 
+                sum_g = 
+                sum_b = 
+                sum_in_r = 
+                sum_in_g = 
+                sum_in_b = 
+                sum_out_r = 
+                sum_out_g = 
+                sum_out_b = 0;
+
+                src_pix_ptr = img.pix_ptr(x, 0);
+                for(i = 0; i <= ry; i++)
+                {
+                    stack_pix_ptr    = &stack[i];
+                    stack_pix_ptr->r = src_pix_ptr[R];
+                    stack_pix_ptr->g = src_pix_ptr[G];
+                    stack_pix_ptr->b = src_pix_ptr[B];
+                    sum_r           += src_pix_ptr[R] * (i + 1);
+                    sum_g           += src_pix_ptr[G] * (i + 1);
+                    sum_b           += src_pix_ptr[B] * (i + 1);
+                    sum_out_r       += src_pix_ptr[R];
+                    sum_out_g       += src_pix_ptr[G];
+                    sum_out_b       += src_pix_ptr[B];
+                }
+                for(i = 1; i <= ry; i++)
+                {
+                    if(i <= hm) src_pix_ptr += stride; 
+                    stack_pix_ptr = &stack[i + ry];
+                    stack_pix_ptr->r = src_pix_ptr[R];
+                    stack_pix_ptr->g = src_pix_ptr[G];
+                    stack_pix_ptr->b = src_pix_ptr[B];
+                    sum_r           += src_pix_ptr[R] * (ry + 1 - i);
+                    sum_g           += src_pix_ptr[G] * (ry + 1 - i);
+                    sum_b           += src_pix_ptr[B] * (ry + 1 - i);
+                    sum_in_r        += src_pix_ptr[R];
+                    sum_in_g        += src_pix_ptr[G];
+                    sum_in_b        += src_pix_ptr[B];
+                }
+
+                stack_ptr = ry;
+                yp = ry;
+                if(yp > hm) yp = hm;
+                src_pix_ptr = img.pix_ptr(x, yp);
+                dst_pix_ptr = img.pix_ptr(x, 0);
+                for(y = 0; y < h; y++)
+                {
+                    dst_pix_ptr[R] = (sum_r * mul_sum) >> shr_sum;
+                    dst_pix_ptr[G] = (sum_g * mul_sum) >> shr_sum;
+                    dst_pix_ptr[B] = (sum_b * mul_sum) >> shr_sum;
+                    dst_pix_ptr += stride;
+
+                    sum_r -= sum_out_r;
+                    sum_g -= sum_out_g;
+                    sum_b -= sum_out_b;
+       
+                    stack_start = stack_ptr + div - ry;
+                    if(stack_start >= div) stack_start -= div;
+
+                    stack_pix_ptr = &stack[stack_start];
+                    sum_out_r -= stack_pix_ptr->r;
+                    sum_out_g -= stack_pix_ptr->g;
+                    sum_out_b -= stack_pix_ptr->b;
+
+                    if(yp < hm) 
+                    {
+                        src_pix_ptr += stride;
+                        ++yp;
+                    }
+        
+                    stack_pix_ptr->r = src_pix_ptr[R];
+                    stack_pix_ptr->g = src_pix_ptr[G];
+                    stack_pix_ptr->b = src_pix_ptr[B];
+        
+                    sum_in_r += src_pix_ptr[R];
+                    sum_in_g += src_pix_ptr[G];
+                    sum_in_b += src_pix_ptr[B];
+                    sum_r    += sum_in_r;
+                    sum_g    += sum_in_g;
+                    sum_b    += sum_in_b;
+        
+                    ++stack_ptr;
+                    if(stack_ptr >= div) stack_ptr = 0;
+                    stack_pix_ptr = &stack[stack_ptr];
+
+                    sum_out_r += stack_pix_ptr->r;
+                    sum_out_g += stack_pix_ptr->g;
+                    sum_out_b += stack_pix_ptr->b;
+                    sum_in_r  -= stack_pix_ptr->r;
+                    sum_in_g  -= stack_pix_ptr->g;
+                    sum_in_b  -= stack_pix_ptr->b;
+                }
+            }
+        }
+    }
+
+
+
+    //=======================================================stack_blur_rgba32
+    template<class Img> 
+    void stack_blur_rgba32(Img& img, unsigned rx, unsigned ry)
+    {
+        typedef typename Img::color_type color_type;
+        typedef typename Img::order_type order_type;
+        enum order_e 
+        { 
+            R = order_type::R, 
+            G = order_type::G, 
+            B = order_type::B,
+            A = order_type::A 
+        };
+
+        unsigned x, y, xp, yp, i;
+        unsigned stack_ptr;
+        unsigned stack_start;
+
+        const int8u* src_pix_ptr;
+              int8u* dst_pix_ptr;
+        color_type*  stack_pix_ptr;
+
+        unsigned sum_r;
+        unsigned sum_g;
+        unsigned sum_b;
+        unsigned sum_a;
+        unsigned sum_in_r;
+        unsigned sum_in_g;
+        unsigned sum_in_b;
+        unsigned sum_in_a;
+        unsigned sum_out_r;
+        unsigned sum_out_g;
+        unsigned sum_out_b;
+        unsigned sum_out_a;
+
+        unsigned w   = img.width();
+        unsigned h   = img.height();
+        unsigned wm  = w - 1;
+        unsigned hm  = h - 1;
+
+        unsigned div;
+        unsigned mul_sum;
+        unsigned shr_sum;
+
+        pod_vector<color_type> stack;
+
+        if(rx > 0)
+        {
+            if(rx > 254) rx = 254;
+            div = rx * 2 + 1;
+            mul_sum = stack_blur_tables<int>::g_stack_blur8_mul[rx];
+            shr_sum = stack_blur_tables<int>::g_stack_blur8_shr[rx];
+            stack.allocate(div);
+
+            for(y = 0; y < h; y++)
+            {
+                sum_r = 
+                sum_g = 
+                sum_b = 
+                sum_a = 
+                sum_in_r = 
+                sum_in_g = 
+                sum_in_b = 
+                sum_in_a = 
+                sum_out_r = 
+                sum_out_g = 
+                sum_out_b = 
+                sum_out_a = 0;
+
+                src_pix_ptr = img.pix_ptr(0, y);
+                for(i = 0; i <= rx; i++)
+                {
+                    stack_pix_ptr    = &stack[i];
+                    stack_pix_ptr->r = src_pix_ptr[R];
+                    stack_pix_ptr->g = src_pix_ptr[G];
+                    stack_pix_ptr->b = src_pix_ptr[B];
+                    stack_pix_ptr->a = src_pix_ptr[A];
+                    sum_r           += src_pix_ptr[R] * (i + 1);
+                    sum_g           += src_pix_ptr[G] * (i + 1);
+                    sum_b           += src_pix_ptr[B] * (i + 1);
+                    sum_a           += src_pix_ptr[A] * (i + 1);
+                    sum_out_r       += src_pix_ptr[R];
+                    sum_out_g       += src_pix_ptr[G];
+                    sum_out_b       += src_pix_ptr[B];
+                    sum_out_a       += src_pix_ptr[A];
+                }
+                for(i = 1; i <= rx; i++)
+                {
+                    if(i <= wm) src_pix_ptr += Img::pix_width; 
+                    stack_pix_ptr = &stack[i + rx];
+                    stack_pix_ptr->r = src_pix_ptr[R];
+                    stack_pix_ptr->g = src_pix_ptr[G];
+                    stack_pix_ptr->b = src_pix_ptr[B];
+                    stack_pix_ptr->a = src_pix_ptr[A];
+                    sum_r           += src_pix_ptr[R] * (rx + 1 - i);
+                    sum_g           += src_pix_ptr[G] * (rx + 1 - i);
+                    sum_b           += src_pix_ptr[B] * (rx + 1 - i);
+                    sum_a           += src_pix_ptr[A] * (rx + 1 - i);
+                    sum_in_r        += src_pix_ptr[R];
+                    sum_in_g        += src_pix_ptr[G];
+                    sum_in_b        += src_pix_ptr[B];
+                    sum_in_a        += src_pix_ptr[A];
+                }
+
+                stack_ptr = rx;
+                xp = rx;
+                if(xp > wm) xp = wm;
+                src_pix_ptr = img.pix_ptr(xp, y);
+                dst_pix_ptr = img.pix_ptr(0, y);
+                for(x = 0; x < w; x++)
+                {
+                    dst_pix_ptr[R] = (sum_r * mul_sum) >> shr_sum;
+                    dst_pix_ptr[G] = (sum_g * mul_sum) >> shr_sum;
+                    dst_pix_ptr[B] = (sum_b * mul_sum) >> shr_sum;
+                    dst_pix_ptr[A] = (sum_a * mul_sum) >> shr_sum;
+                    dst_pix_ptr += Img::pix_width;
+
+                    sum_r -= sum_out_r;
+                    sum_g -= sum_out_g;
+                    sum_b -= sum_out_b;
+                    sum_a -= sum_out_a;
+       
+                    stack_start = stack_ptr + div - rx;
+                    if(stack_start >= div) stack_start -= div;
+                    stack_pix_ptr = &stack[stack_start];
+
+                    sum_out_r -= stack_pix_ptr->r;
+                    sum_out_g -= stack_pix_ptr->g;
+                    sum_out_b -= stack_pix_ptr->b;
+                    sum_out_a -= stack_pix_ptr->a;
+
+                    if(xp < wm) 
+                    {
+                        src_pix_ptr += Img::pix_width;
+                        ++xp;
+                    }
+        
+                    stack_pix_ptr->r = src_pix_ptr[R];
+                    stack_pix_ptr->g = src_pix_ptr[G];
+                    stack_pix_ptr->b = src_pix_ptr[B];
+                    stack_pix_ptr->a = src_pix_ptr[A];
+        
+                    sum_in_r += src_pix_ptr[R];
+                    sum_in_g += src_pix_ptr[G];
+                    sum_in_b += src_pix_ptr[B];
+                    sum_in_a += src_pix_ptr[A];
+                    sum_r    += sum_in_r;
+                    sum_g    += sum_in_g;
+                    sum_b    += sum_in_b;
+                    sum_a    += sum_in_a;
+        
+                    ++stack_ptr;
+                    if(stack_ptr >= div) stack_ptr = 0;
+                    stack_pix_ptr = &stack[stack_ptr];
+
+                    sum_out_r += stack_pix_ptr->r;
+                    sum_out_g += stack_pix_ptr->g;
+                    sum_out_b += stack_pix_ptr->b;
+                    sum_out_a += stack_pix_ptr->a;
+                    sum_in_r  -= stack_pix_ptr->r;
+                    sum_in_g  -= stack_pix_ptr->g;
+                    sum_in_b  -= stack_pix_ptr->b;
+                    sum_in_a  -= stack_pix_ptr->a;
+                }
+            }
+        }
+
+        if(ry > 0)
+        {
+            if(ry > 254) ry = 254;
+            div = ry * 2 + 1;
+            mul_sum = stack_blur_tables<int>::g_stack_blur8_mul[ry];
+            shr_sum = stack_blur_tables<int>::g_stack_blur8_shr[ry];
+            stack.allocate(div);
+
+            int stride = img.stride();
+            for(x = 0; x < w; x++)
+            {
+                sum_r = 
+                sum_g = 
+                sum_b = 
+                sum_a = 
+                sum_in_r = 
+                sum_in_g = 
+                sum_in_b = 
+                sum_in_a = 
+                sum_out_r = 
+                sum_out_g = 
+                sum_out_b = 
+                sum_out_a = 0;
+
+                src_pix_ptr = img.pix_ptr(x, 0);
+                for(i = 0; i <= ry; i++)
+                {
+                    stack_pix_ptr    = &stack[i];
+                    stack_pix_ptr->r = src_pix_ptr[R];
+                    stack_pix_ptr->g = src_pix_ptr[G];
+                    stack_pix_ptr->b = src_pix_ptr[B];
+                    stack_pix_ptr->a = src_pix_ptr[A];
+                    sum_r           += src_pix_ptr[R] * (i + 1);
+                    sum_g           += src_pix_ptr[G] * (i + 1);
+                    sum_b           += src_pix_ptr[B] * (i + 1);
+                    sum_a           += src_pix_ptr[A] * (i + 1);
+                    sum_out_r       += src_pix_ptr[R];
+                    sum_out_g       += src_pix_ptr[G];
+                    sum_out_b       += src_pix_ptr[B];
+                    sum_out_a       += src_pix_ptr[A];
+                }
+                for(i = 1; i <= ry; i++)
+                {
+                    if(i <= hm) src_pix_ptr += stride; 
+                    stack_pix_ptr = &stack[i + ry];
+                    stack_pix_ptr->r = src_pix_ptr[R];
+                    stack_pix_ptr->g = src_pix_ptr[G];
+                    stack_pix_ptr->b = src_pix_ptr[B];
+                    stack_pix_ptr->a = src_pix_ptr[A];
+                    sum_r           += src_pix_ptr[R] * (ry + 1 - i);
+                    sum_g           += src_pix_ptr[G] * (ry + 1 - i);
+                    sum_b           += src_pix_ptr[B] * (ry + 1 - i);
+                    sum_a           += src_pix_ptr[A] * (ry + 1 - i);
+                    sum_in_r        += src_pix_ptr[R];
+                    sum_in_g        += src_pix_ptr[G];
+                    sum_in_b        += src_pix_ptr[B];
+                    sum_in_a        += src_pix_ptr[A];
+                }
+
+                stack_ptr = ry;
+                yp = ry;
+                if(yp > hm) yp = hm;
+                src_pix_ptr = img.pix_ptr(x, yp);
+                dst_pix_ptr = img.pix_ptr(x, 0);
+                for(y = 0; y < h; y++)
+                {
+                    dst_pix_ptr[R] = (sum_r * mul_sum) >> shr_sum;
+                    dst_pix_ptr[G] = (sum_g * mul_sum) >> shr_sum;
+                    dst_pix_ptr[B] = (sum_b * mul_sum) >> shr_sum;
+                    dst_pix_ptr[A] = (sum_a * mul_sum) >> shr_sum;
+                    dst_pix_ptr += stride;
+
+                    sum_r -= sum_out_r;
+                    sum_g -= sum_out_g;
+                    sum_b -= sum_out_b;
+                    sum_a -= sum_out_a;
+       
+                    stack_start = stack_ptr + div - ry;
+                    if(stack_start >= div) stack_start -= div;
+
+                    stack_pix_ptr = &stack[stack_start];
+                    sum_out_r -= stack_pix_ptr->r;
+                    sum_out_g -= stack_pix_ptr->g;
+                    sum_out_b -= stack_pix_ptr->b;
+                    sum_out_a -= stack_pix_ptr->a;
+
+                    if(yp < hm) 
+                    {
+                        src_pix_ptr += stride;
+                        ++yp;
+                    }
+        
+                    stack_pix_ptr->r = src_pix_ptr[R];
+                    stack_pix_ptr->g = src_pix_ptr[G];
+                    stack_pix_ptr->b = src_pix_ptr[B];
+                    stack_pix_ptr->a = src_pix_ptr[A];
+        
+                    sum_in_r += src_pix_ptr[R];
+                    sum_in_g += src_pix_ptr[G];
+                    sum_in_b += src_pix_ptr[B];
+                    sum_in_a += src_pix_ptr[A];
+                    sum_r    += sum_in_r;
+                    sum_g    += sum_in_g;
+                    sum_b    += sum_in_b;
+                    sum_a    += sum_in_a;
+        
+                    ++stack_ptr;
+                    if(stack_ptr >= div) stack_ptr = 0;
+                    stack_pix_ptr = &stack[stack_ptr];
+
+                    sum_out_r += stack_pix_ptr->r;
+                    sum_out_g += stack_pix_ptr->g;
+                    sum_out_b += stack_pix_ptr->b;
+                    sum_out_a += stack_pix_ptr->a;
+                    sum_in_r  -= stack_pix_ptr->r;
+                    sum_in_g  -= stack_pix_ptr->g;
+                    sum_in_b  -= stack_pix_ptr->b;
+                    sum_in_a  -= stack_pix_ptr->a;
+                }
+            }
+        }
+    }
+
+
+
+    //===========================================================recursive_blur
+    template<class ColorT, class CalculatorT> class recursive_blur
+    {
+    public:
+        typedef ColorT color_type;
+        typedef CalculatorT calculator_type;
+        typedef typename color_type::value_type value_type;
+        typedef typename calculator_type::value_type calc_type;
+
+        //--------------------------------------------------------------------
+        template<class Img> void blur_x(Img& img, double radius)
+        {
+            if(radius < 0.62) return;
+            if(img.width() < 3) return;
+
+            calc_type s = calc_type(radius * 0.5);
+            calc_type q = calc_type((s < 2.5) ?
+                                    3.97156 - 4.14554 * sqrt(1 - 0.26891 * s) :
+                                    0.98711 * s - 0.96330);
+
+            calc_type q2 = calc_type(q * q);
+            calc_type q3 = calc_type(q2 * q);
+
+            calc_type b0 = calc_type(1.0 / (1.578250 + 
+                                            2.444130 * q + 
+                                            1.428100 * q2 + 
+                                            0.422205 * q3));
+
+            calc_type b1 = calc_type( 2.44413 * q + 
+                                      2.85619 * q2 + 
+                                      1.26661 * q3);
+
+            calc_type b2 = calc_type(-1.42810 * q2 + 
+                                     -1.26661 * q3);
+
+            calc_type b3 = calc_type(0.422205 * q3);
+
+            calc_type b  = calc_type(1 - (b1 + b2 + b3) * b0);
+
+            b1 *= b0;
+            b2 *= b0;
+            b3 *= b0;
+
+            int w = img.width();
+            int h = img.height();
+            int wm = w-1;
+            int x, y;
+
+            m_sum1.allocate(w);
+            m_sum2.allocate(w);
+            m_buf.allocate(w);
+
+            for(y = 0; y < h; y++)
+            {
+                calculator_type c;
+                c.from_pix(img.pixel(0, y));
+                m_sum1[0].calc(b, b1, b2, b3, c, c, c, c);
+                c.from_pix(img.pixel(1, y));
+                m_sum1[1].calc(b, b1, b2, b3, c, m_sum1[0], m_sum1[0], m_sum1[0]);
+                c.from_pix(img.pixel(2, y));
+                m_sum1[2].calc(b, b1, b2, b3, c, m_sum1[1], m_sum1[0], m_sum1[0]);
+
+                for(x = 3; x < w; ++x)
+                {
+                    c.from_pix(img.pixel(x, y));
+                    m_sum1[x].calc(b, b1, b2, b3, c, m_sum1[x-1], m_sum1[x-2], m_sum1[x-3]);
+                }
+    
+                m_sum2[wm  ].calc(b, b1, b2, b3, m_sum1[wm  ], m_sum1[wm  ], m_sum1[wm], m_sum1[wm]);
+                m_sum2[wm-1].calc(b, b1, b2, b3, m_sum1[wm-1], m_sum2[wm  ], m_sum2[wm], m_sum2[wm]);
+                m_sum2[wm-2].calc(b, b1, b2, b3, m_sum1[wm-2], m_sum2[wm-1], m_sum2[wm], m_sum2[wm]);
+                m_sum2[wm  ].to_pix(m_buf[wm  ]);
+                m_sum2[wm-1].to_pix(m_buf[wm-1]);
+                m_sum2[wm-2].to_pix(m_buf[wm-2]);
+
+                for(x = wm-3; x >= 0; --x)
+                {
+                    m_sum2[x].calc(b, b1, b2, b3, m_sum1[x], m_sum2[x+1], m_sum2[x+2], m_sum2[x+3]);
+                    m_sum2[x].to_pix(m_buf[x]);
+                }
+                img.copy_color_hspan(0, y, w, &m_buf[0]);
+            }
+        }
+
+        //--------------------------------------------------------------------
+        template<class Img> void blur_y(Img& img, double radius)
+        {
+            pixfmt_transposer<Img> img2(img);
+            blur_x(img2, radius);
+        }
+
+        //--------------------------------------------------------------------
+        template<class Img> void blur(Img& img, double radius)
+        {
+            blur_x(img, radius);
+            pixfmt_transposer<Img> img2(img);
+            blur_x(img2, radius);
+        }
+
+    private:
+        agg::pod_vector<calculator_type> m_sum1;
+        agg::pod_vector<calculator_type> m_sum2;
+        agg::pod_vector<color_type>      m_buf;
+    };
+
+
+    //=================================================recursive_blur_calc_rgba
+    template<class T=double> struct recursive_blur_calc_rgba
+    {
+        typedef T value_type;
+        typedef recursive_blur_calc_rgba<T> self_type;
+
+        value_type r,g,b,a;
+
+        template<class ColorT> 
+        AGG_INLINE void from_pix(const ColorT& c)
+        {
+            r = c.r;
+            g = c.g;
+            b = c.b;
+            a = c.a;
+        }
+
+        AGG_INLINE void calc(value_type b1, 
+                             value_type b2, 
+                             value_type b3, 
+                             value_type b4,
+                             const self_type& c1, 
+                             const self_type& c2, 
+                             const self_type& c3, 
+                             const self_type& c4)
+        {
+            r = b1*c1.r + b2*c2.r + b3*c3.r + b4*c4.r;
+            g = b1*c1.g + b2*c2.g + b3*c3.g + b4*c4.g;
+            b = b1*c1.b + b2*c2.b + b3*c3.b + b4*c4.b;
+            a = b1*c1.a + b2*c2.a + b3*c3.a + b4*c4.a;
+        }
+
+        template<class ColorT> 
+        AGG_INLINE void to_pix(ColorT& c) const
+        {
+            typedef typename ColorT::value_type cv_type;
+            c.r = (cv_type)uround(r);
+            c.g = (cv_type)uround(g);
+            c.b = (cv_type)uround(b);
+            c.a = (cv_type)uround(a);
+        }
+    };
+
+
+    //=================================================recursive_blur_calc_rgb
+    template<class T=double> struct recursive_blur_calc_rgb
+    {
+        typedef T value_type;
+        typedef recursive_blur_calc_rgb<T> self_type;
+
+        value_type r,g,b;
+
+        template<class ColorT> 
+        AGG_INLINE void from_pix(const ColorT& c)
+        {
+            r = c.r;
+            g = c.g;
+            b = c.b;
+        }
+
+        AGG_INLINE void calc(value_type b1, 
+                             value_type b2, 
+                             value_type b3, 
+                             value_type b4,
+                             const self_type& c1, 
+                             const self_type& c2, 
+                             const self_type& c3, 
+                             const self_type& c4)
+        {
+            r = b1*c1.r + b2*c2.r + b3*c3.r + b4*c4.r;
+            g = b1*c1.g + b2*c2.g + b3*c3.g + b4*c4.g;
+            b = b1*c1.b + b2*c2.b + b3*c3.b + b4*c4.b;
+        }
+
+        template<class ColorT> 
+        AGG_INLINE void to_pix(ColorT& c) const
+        {
+            typedef typename ColorT::value_type cv_type;
+            c.r = (cv_type)uround(r);
+            c.g = (cv_type)uround(g);
+            c.b = (cv_type)uround(b);
+        }
+    };
+
+
+    //================================================recursive_blur_calc_gray
+    template<class T=double> struct recursive_blur_calc_gray
+    {
+        typedef T value_type;
+        typedef recursive_blur_calc_gray<T> self_type;
+
+        value_type v;
+
+        template<class ColorT> 
+        AGG_INLINE void from_pix(const ColorT& c)
+        {
+            v = c.v;
+        }
+
+        AGG_INLINE void calc(value_type b1, 
+                             value_type b2, 
+                             value_type b3, 
+                             value_type b4,
+                             const self_type& c1, 
+                             const self_type& c2, 
+                             const self_type& c3, 
+                             const self_type& c4)
+        {
+            v = b1*c1.v + b2*c2.v + b3*c3.v + b4*c4.v;
+        }
+
+        template<class ColorT> 
+        AGG_INLINE void to_pix(ColorT& c) const
+        {
+            typedef typename ColorT::value_type cv_type;
+            c.v = (cv_type)uround(v);
+        }
+    };
+
+}
+
+
+
+
+#endif

Added: trunk/agg/include/agg_gradient_lut.h
===================================================================
--- trunk/agg/include/agg_gradient_lut.h	2006-11-09 23:44:34 UTC (rev 367)
+++ trunk/agg/include/agg_gradient_lut.h	2006-11-09 23:48:09 UTC (rev 368)
@@ -0,0 +1,244 @@
+//----------------------------------------------------------------------------
+// Anti-Grain Geometry - Version 2.4
+// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
+//
+// Permission to copy, use, modify, sell and distribute this software 
+// is granted provided this copyright notice appears in all copies. 
+// This software is provided "as is" without express or implied
+// warranty, and with no claim as to its suitability for any purpose.
+//
+//----------------------------------------------------------------------------
+// Contact: mcseem at antigrain.com
+//          mcseemagg at yahoo.com
+//          http://www.antigrain.com
+//----------------------------------------------------------------------------
+
+#ifndef AGG_GRADIENT_LUT_INCLUDED
+#define AGG_GRADIENT_LUT_INCLUDED
+
+#include "agg_array.h"
+#include "agg_dda_line.h"
+#include "agg_color_rgba.h"
+#include "agg_color_gray.h"
+
+namespace agg
+{
+
+    //======================================================color_interpolator
+    template<class ColorT> struct color_interpolator
+    {
+    public:
+        typedef ColorT color_type;
+
+        color_interpolator(const color_type& c1, 
+                           const color_type& c2, 
+                           unsigned len) :
+            m_c1(c1),
+            m_c2(c2),
+            m_len(len),
+            m_count(0)
+        {}
+
+        void operator ++ ()
+        {
+            ++m_count;
+        }
+
+        color_type color() const
+        {
+            return m_c1.gradient(m_c2, double(m_count) / m_len);
+        }
+
+    private:
+        color_type m_c1;
+        color_type m_c2;
+        unsigned   m_len;
+        unsigned   m_count;
+    };
+
+    //========================================================================
+    // Fast specialization for rgba8
+    template<> struct color_interpolator<rgba8>
+    {
+    public:
+        typedef rgba8 color_type;
+
+        color_interpolator(const color_type& c1, 
+                           const color_type& c2, 
+                           unsigned len) :
+            r(c1.r, c2.r, len),
+            g(c1.g, c2.g, len),
+            b(c1.b, c2.b, len),
+            a(c1.a, c2.a, len)
+        {}
+
+        void operator ++ ()
+        {
+            ++r; ++g; ++b; ++a;
+        }
+
+        color_type color() const
+        {
+            return color_type(r.y(), g.y(), b.y(), a.y());
+        }
+
+    private:
+        agg::dda_line_interpolator<14> r, g, b, a;
+    };
+
+    //========================================================================
+    // Fast specialization for gray8
+    template<> struct color_interpolator<gray8>
+    {
+    public:
+        typedef gray8 color_type;
+
+        color_interpolator(const color_type& c1, 
+                           const color_type& c2, 
+                           unsigned len) :
+            v(c1.v, c2.v, len),
+            a(c1.a, c2.a, len)
+        {}
+
+        void operator ++ ()
+        {
+            ++v; ++a;
+        }
+
+        color_type color() const
+        {
+            return color_type(v.y(), a.y());
+        }
+
+    private:
+        agg::dda_line_interpolator<14> v,a;
+    };
+
+    //============================================================gradient_lut
+    template<class ColorInterpolator, 
+             unsigned ColorLutSize=256> class gradient_lut
+    {
+    public:
+        typedef ColorInterpolator interpolator_type;
+        typedef typename interpolator_type::color_type color_type;
+        enum { color_lut_size = ColorLutSize };
+
+        //--------------------------------------------------------------------
+        gradient_lut() : m_color_lut(color_lut_size) {}
+
+        // Build Gradient Lut
+        // First, call remove_all(), then add_color() at least twice, 
+        // then build_lut(). Argument "offset" in add_color must be 
+        // in range [0...1] and defines a color stop as it is described 
+        // in SVG specification, section Gradients and Patterns. 
+        // The simplest linear gradient is:
+        //    gradient_lut.add_color(0.0, start_color);
+        //    gradient_lut.add_color(1.0, end_color);
+        //--------------------------------------------------------------------
+        void remove_all();
+        void add_color(double offset, const color_type& color);
+        void build_lut();
+
+        // Size-index Interface. This class can be used directly as the 
+        // ColorF in span_gradient. All it needs is two access methods 
+        // size() and operator [].
+        //--------------------------------------------------------------------
+        static unsigned size() 
+        { 
+            return color_lut_size; 
+        }
+        const color_type& operator [] (unsigned i) const 
+        { 
+            return m_color_lut[i]; 
+        }
+
+    private:
+        //--------------------------------------------------------------------
+        struct color_point
+        {
+            double     offset;
+            color_type color;
+
+            color_point() {}
+            color_point(double off, const color_type& c) : 
+                offset(off), color(c)
+            {
+                if(offset < 0.0) offset = 0.0;
+                if(offset > 1.0) offset = 1.0;
+            }
+        };
+        typedef agg::pod_bvector<color_point, 4> color_profile_type;
+        typedef agg::pod_array<color_type>       color_lut_type;
+
+        static bool offset_less(const color_point& a, const color_point& b)
+        {
+            return a.offset < b.offset;
+        }
+        static bool offset_equal(const color_point& a, const color_point& b)
+        {
+            return a.offset == b.offset;
+        }
+
+        //--------------------------------------------------------------------
+        color_profile_type  m_color_profile;
+        color_lut_type      m_color_lut;
+    };
+
+
+
+    //------------------------------------------------------------------------
+    template<class T, unsigned S>
+    void gradient_lut<T,S>::remove_all()
+    { 
+        m_color_profile.remove_all(); 
+    }
+
+    //------------------------------------------------------------------------
+    template<class T, unsigned S>
+    void gradient_lut<T,S>::add_color(double offset, const color_type& color)
+    {
+        m_color_profile.add(color_point(offset, color));
+    }
+
+    //------------------------------------------------------------------------
+    template<class T, unsigned S>
+    void gradient_lut<T,S>::build_lut()
+    {
+        quick_sort(m_color_profile, offset_less);
+        m_color_profile.cut_at(remove_duplicates(m_color_profile, offset_equal));
+        if(m_color_profile.size() >= 2)
+        {
+            unsigned i;
+            unsigned start = uround(m_color_profile[0].offset * color_lut_size);
+            unsigned end;
+            color_type c = m_color_profile[0].color;
+            for(i = 0; i < start; i++) 
+            {
+                m_color_lut[i] = c;
+            }
+            for(i = 1; i < m_color_profile.size(); i++)
+            {
+                end  = uround(m_color_profile[i].offset * color_lut_size);
+                interpolator_type ci(m_color_profile[i-1].color, 
+                                     m_color_profile[i  ].color, 
+                                     end - start + 1);
+                while(start < end)
+                {
+                    m_color_lut[start] = ci.color();
+                    ++ci;
+                    ++start;
+                }
+            }
+            c = m_color_profile.last().color;
+            for(; end < m_color_lut.size(); end++)
+            {
+                m_color_lut[end] = c;
+            }
+        }
+    }
+}
+
+
+
+
+#endif

Added: trunk/agg/include/agg_pixfmt_transposer.h
===================================================================
--- trunk/agg/include/agg_pixfmt_transposer.h	2006-11-09 23:44:34 UTC (rev 367)
+++ trunk/agg/include/agg_pixfmt_transposer.h	2006-11-09 23:48:09 UTC (rev 368)
@@ -0,0 +1,157 @@
+//----------------------------------------------------------------------------
+// Anti-Grain Geometry - Version 2.4
+// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
+//
+// Permission to copy, use, modify, sell and distribute this software 
+// is granted provided this copyright notice appears in all copies. 
+// This software is provided "as is" without express or implied
+// warranty, and with no claim as to its suitability for any purpose.
+//
+//----------------------------------------------------------------------------
+// Contact: mcseem at antigrain.com
+//          mcseemagg at yahoo.com
+//          http://www.antigrain.com
+//----------------------------------------------------------------------------
+
+#ifndef AGG_PIXFMT_TRANSPOSER_INCLUDED
+#define AGG_PIXFMT_TRANSPOSER_INCLUDED
+
+#include "agg_basics.h"
+
+namespace agg
+{
+    //=======================================================pixfmt_transposer
+    template<class PixFmt> class pixfmt_transposer
+    {
+    public:
+        typedef PixFmt pixfmt_type;
+        typedef typename pixfmt_type::color_type color_type;
+        typedef typename pixfmt_type::row_data row_data;
+        typedef typename color_type::value_type value_type;
+        typedef typename color_type::calc_type calc_type;
+
+        //--------------------------------------------------------------------
+        pixfmt_transposer() : m_pixf(0) {}
+        explicit pixfmt_transposer(pixfmt_type& pixf) : m_pixf(&pixf) {}
+        void attach(pixfmt_type& pixf) { m_pixf = &pixf; }
+
+        //--------------------------------------------------------------------
+        AGG_INLINE unsigned width()  const { return m_pixf->height();  }
+        AGG_INLINE unsigned height() const { return m_pixf->width(); }
+
+        //--------------------------------------------------------------------
+        AGG_INLINE color_type pixel(int x, int y) const
+        {
+            return m_pixf->pixel(y, x);
+        }
+
+        //--------------------------------------------------------------------
+        AGG_INLINE void copy_pixel(int x, int y, const color_type& c)
+        {
+            m_pixf->copy_pixel(y, x, c);
+        }
+
+        //--------------------------------------------------------------------
+        AGG_INLINE void blend_pixel(int x, int y, 
+                                    const color_type& c, 
+                                    int8u cover)
+        {
+            m_pixf->blend_pixel(y, x, c, cover);
+        }
+
+        //--------------------------------------------------------------------
+        AGG_INLINE void copy_hline(int x, int y, 
+                                   unsigned len, 
+                                   const color_type& c)
+        {
+            m_pixf->copy_vline(y, x, len, c);
+        }
+
+        //--------------------------------------------------------------------
+        AGG_INLINE void copy_vline(int x, int y,
+                                   unsigned len, 
+                                   const color_type& c)
+        {
+            m_pixf->copy_hline(y, x, len, c);
+        }
+
+        //--------------------------------------------------------------------
+        AGG_INLINE void blend_hline(int x, int y,
+                                    unsigned len, 
+                                    const color_type& c,
+                                    int8u cover)
+        {
+            m_pixf->blend_vline(y, x, len, c, cover);
+        }
+
+        //--------------------------------------------------------------------
+        AGG_INLINE void blend_vline(int x, int y,
+                                    unsigned len, 
+                                    const color_type& c,
+                                    int8u cover)
+        {
+            m_pixf->blend_hline(y, x, len, c, cover);
+        }
+
+        //--------------------------------------------------------------------
+        AGG_INLINE void blend_solid_hspan(int x, int y,
+                                          unsigned len, 
+                                          const color_type& c,
+                                          const int8u* covers)
+        {
+            m_pixf->blend_solid_vspan(y, x, len, c, covers);
+        }
+
+        //--------------------------------------------------------------------
+        AGG_INLINE void blend_solid_vspan(int x, int y,
+                                          unsigned len, 
+                                          const color_type& c,
+                                          const int8u* covers)
+        {
+            m_pixf->blend_solid_hspan(y, x, len, c, covers);
+        }
+
+        //--------------------------------------------------------------------
+        AGG_INLINE void copy_color_hspan(int x, int y,
+                                         unsigned len, 
+                                         const color_type* colors)
+        {
+            m_pixf->copy_color_vspan(y, x, len, colors);
+        }
+
+        //--------------------------------------------------------------------
+        AGG_INLINE void copy_color_vspan(int x, int y,
+                                         unsigned len, 
+                                         const color_type* colors)
+        {
+            m_pixf->copy_color_hspan(y, x, len, colors);
+        }
+
+        //--------------------------------------------------------------------
+        AGG_INLINE void blend_color_hspan(int x, int y,
+                                          unsigned len, 
+                                          const color_type* colors,
+                                          const int8u* covers,
+                                          int8u cover)
+        {
+            m_pixf->blend_color_vspan(y, x, len, colors, covers, cover);
+        }
+
+        //--------------------------------------------------------------------
+        AGG_INLINE void blend_color_vspan(int x, int y,
+                               unsigned len, 
+                               const color_type* colors,
+                               const int8u* covers,
+                               int8u cover)
+        {
+            m_pixf->blend_color_hspan(y, x, len, colors, covers, cover);
+        }
+
+    private:
+        pixfmt_type* m_pixf;
+    };
+}
+
+#endif
+
+



From pavlenko at mail.berlios.de  Mon Nov 13 11:13:17 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Mon, 13 Nov 2006 11:13:17 +0100
Subject: [Mapnik-svn] r369 - trunk/include/mapnik
Message-ID: <200611131013.kADADHoT029666@sheep.berlios.de>

Author: pavlenko
Date: 2006-11-13 11:13:14 +0100 (Mon, 13 Nov 2006)
New Revision: 369

Modified:
   trunk/include/mapnik/config.hpp
   trunk/include/mapnik/proj_transform.hpp
   trunk/include/mapnik/projection.hpp
   trunk/include/mapnik/scale_denominator.hpp
Log:
export symbols for win32 dlls



Modified: trunk/include/mapnik/config.hpp
===================================================================
--- trunk/include/mapnik/config.hpp	2006-11-09 23:48:09 UTC (rev 368)
+++ trunk/include/mapnik/config.hpp	2006-11-13 10:13:14 UTC (rev 369)
@@ -23,7 +23,7 @@
 #ifndef CONFIG_HPP
 #define CONFIG_HPP
 
-// Window DLL support
+// Windows DLL support
 
 #ifdef _WINDOWS
 # define MAPNIK_DECL __declspec (dllexport)

Modified: trunk/include/mapnik/proj_transform.hpp
===================================================================
--- trunk/include/mapnik/proj_transform.hpp	2006-11-09 23:48:09 UTC (rev 368)
+++ trunk/include/mapnik/proj_transform.hpp	2006-11-13 10:13:14 UTC (rev 369)
@@ -32,7 +32,7 @@
 
 namespace mapnik {
     
-    class proj_transform : private boost::noncopyable
+    class MAPNIK_DECL proj_transform : private boost::noncopyable
     {
     public:
         proj_transform(projection const& source, 

Modified: trunk/include/mapnik/projection.hpp
===================================================================
--- trunk/include/mapnik/projection.hpp	2006-11-09 23:48:09 UTC (rev 368)
+++ trunk/include/mapnik/projection.hpp	2006-11-13 10:13:14 UTC (rev 369)
@@ -43,7 +43,7 @@
             : std::runtime_error("failed to initialize projection with:" + params) {}
     };
     
-    class projection
+    class MAPNIK_DECL projection
     {
         friend class proj_transform;
     public:

Modified: trunk/include/mapnik/scale_denominator.hpp
===================================================================
--- trunk/include/mapnik/scale_denominator.hpp	2006-11-09 23:48:09 UTC (rev 368)
+++ trunk/include/mapnik/scale_denominator.hpp	2006-11-13 10:13:14 UTC (rev 369)
@@ -21,10 +21,11 @@
  *****************************************************************************/
 
 //$Id$
+#include <mapnik/config.hpp>
 
 namespace mapnik {
  
     class Map;
     class projection;
-    double scale_denominator(Map const& map,projection const& prj); 
+    MAPNIK_DECL double scale_denominator(Map const& map,projection const& prj); 
 }



From pavlenko at mail.berlios.de  Wed Nov 15 22:22:56 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Wed, 15 Nov 2006 22:22:56 +0100
Subject: [Mapnik-svn] r370 - trunk/demo/c++
Message-ID: <200611152122.kAFLMune014705@sheep.berlios.de>

Author: pavlenko
Date: 2006-11-15 22:22:54 +0100 (Wed, 15 Nov 2006)
New Revision: 370

Modified:
   trunk/demo/c++/rundemo.cpp
Log:
updated to latest mapnik

Modified: trunk/demo/c++/rundemo.cpp
===================================================================
--- trunk/demo/c++/rundemo.cpp	2006-11-13 10:13:14 UTC (rev 369)
+++ trunk/demo/c++/rundemo.cpp	2006-11-15 21:22:54 UTC (rev 370)
@@ -150,7 +150,7 @@
     
     feature_type_style popplaces_style;
     rule_type popplaces_rule;
-    text_symbolizer popplaces_text_symbolizer("GEONAME",10,Color(0,0,0));
+    text_symbolizer popplaces_text_symbolizer("GEONAME","Bitstream Vera Sans Roman",10,Color(0,0,0));
     popplaces_text_symbolizer.set_halo_fill(Color(255,255,200));
     popplaces_text_symbolizer.set_halo_radius(1);
     popplaces_rule.append(popplaces_text_symbolizer);



From pavlenko at mail.berlios.de  Fri Nov 17 03:01:24 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Fri, 17 Nov 2006 03:01:24 +0100
Subject: [Mapnik-svn] r371 - in trunk: include/mapnik src
Message-ID: <200611170201.kAH21O7n015749@sheep.berlios.de>

Author: pavlenko
Date: 2006-11-17 03:01:21 +0100 (Fri, 17 Nov 2006)
New Revision: 371

Modified:
   trunk/include/mapnik/feature_style_processor.hpp
   trunk/include/mapnik/scale_denominator.hpp
   trunk/src/layer.cpp
   trunk/src/scale_denominator.cpp
Log:
fixed scale_denomitator
 


Modified: trunk/include/mapnik/feature_style_processor.hpp
===================================================================
--- trunk/include/mapnik/feature_style_processor.hpp	2006-11-15 21:22:54 UTC (rev 370)
+++ trunk/include/mapnik/feature_style_processor.hpp	2006-11-17 02:01:21 UTC (rev 371)
@@ -76,7 +76,7 @@
             try
             {
                 projection proj(m_.srs()); // map projection
-                double scale_denom = scale_denominator(m_,proj);
+                double scale_denom = scale_denominator(m_,proj.is_geographic());
                 std::clog << "scale denominator = " << scale_denom << "\n";
                 
                 std::vector<Layer>::const_iterator itr = m_.layers().begin();

Modified: trunk/include/mapnik/scale_denominator.hpp
===================================================================
--- trunk/include/mapnik/scale_denominator.hpp	2006-11-15 21:22:54 UTC (rev 370)
+++ trunk/include/mapnik/scale_denominator.hpp	2006-11-17 02:01:21 UTC (rev 371)
@@ -26,6 +26,5 @@
 namespace mapnik {
  
     class Map;
-    class projection;
-    MAPNIK_DECL double scale_denominator(Map const& map,projection const& prj); 
+    MAPNIK_DECL double scale_denominator(Map const& map, bool geographic);
 }

Modified: trunk/src/layer.cpp
===================================================================
--- trunk/src/layer.cpp	2006-11-15 21:22:54 UTC (rev 370)
+++ trunk/src/layer.cpp	2006-11-17 02:01:21 UTC (rev 371)
@@ -173,7 +173,7 @@
 
     bool Layer::isVisible(double scale) const
     {
-        return isActive() && scale >= minZoom_ && scale < maxZoom_;
+        return isActive() && scale >= minZoom_ - 1e-6 && scale < maxZoom_ + 1e-6;
     }
 
     void Layer::setSelectable(bool selectable)

Modified: trunk/src/scale_denominator.cpp
===================================================================
--- trunk/src/scale_denominator.cpp	2006-11-15 21:22:54 UTC (rev 370)
+++ trunk/src/scale_denominator.cpp	2006-11-17 02:01:21 UTC (rev 371)
@@ -23,32 +23,17 @@
 //$Id$
 #include <cmath>
 #include <mapnik/map.hpp>
-#include <mapnik/projection.hpp>
-#include <mapnik/distance.hpp>
 #include <mapnik/scale_denominator.hpp>
 
 namespace mapnik {
  
-    static const double dpi = 90.0; // display resolution
+    static const double pi = 3.14159265359; 
+    static const double meters_per_degree = 6378137 * 2 * pi/ 360;
     
-    double scale_denominator(Map const& map,projection const& prj)
+    double scale_denominator(Map const& map, bool geographic)
     {
-        double map_width = map.getWidth();
-        double map_height = map.getHeight();
-        Envelope<double> const& extent = map.getCurrentExtent();
-        double x0 = extent.minx();
-        double y0 = extent.miny();
-        double x1 = extent.maxx();
-        double y1 = extent.maxy();
-        
-        if (!prj.is_geographic())
-        {
-            prj.inverse(x0,y0);
-            prj.inverse(x1,y1); 
-        }
-        great_circle_distance distance;
-        double d1 = distance(coord2d(x0,y0),coord2d(x1, y1));
-        double d0 = sqrt(map_width * map_width + map_height * map_height) / dpi * 0.0254;
-        return d1 / d0;
+        double denom = map.scale() / 0.00028;
+        if (geographic) denom *= meters_per_degree;
+        return denom; 
     }
 }



From pavlenko at mail.berlios.de  Fri Nov 17 03:02:31 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Fri, 17 Nov 2006 03:02:31 +0100
Subject: [Mapnik-svn] r372 - trunk/include/mapnik
Message-ID: <200611170202.kAH22VFq015835@sheep.berlios.de>

Author: pavlenko
Date: 2006-11-17 03:02:29 +0100 (Fri, 17 Nov 2006)
New Revision: 372

Modified:
   trunk/include/mapnik/rule.hpp
Log:
fixed scale_denominator
 


Modified: trunk/include/mapnik/rule.hpp
===================================================================
--- trunk/include/mapnik/rule.hpp	2006-11-17 02:01:21 UTC (rev 371)
+++ trunk/include/mapnik/rule.hpp	2006-11-17 02:02:29 UTC (rev 372)
@@ -262,7 +262,7 @@
         
         bool active(double scale) const
         {
-            return ( scale > min_scale_ && scale < max_scale_ );
+            return ( scale >= min_scale_ - 1e-6 && scale < max_scale_ + 1e-6);
         }
 
         void accept(filter_visitor<FeatureT>& v) const



From vspader10east at mail.berlios.de  Fri Nov 17 15:07:42 2006
From: vspader10east at mail.berlios.de (vspader10east at BerliOS)
Date: Fri, 17 Nov 2006 15:07:42 +0100
Subject: [Mapnik-svn] r373 - in trunk: bindings/python include/mapnik src
Message-ID: <200611171407.kAHE7gS0015486@sheep.berlios.de>

Author: vspader10east
Date: 2006-11-17 15:07:41 +0100 (Fri, 17 Nov 2006)
New Revision: 373

Modified:
   trunk/bindings/python/mapnik_shield_symbolizer.cpp
   trunk/bindings/python/mapnik_text_symbolizer.cpp
   trunk/include/mapnik/placement_finder.hpp
   trunk/include/mapnik/shield_symbolizer.hpp
   trunk/include/mapnik/text_symbolizer.hpp
   trunk/src/agg_renderer.cpp
   trunk/src/placement_finder.cpp
   trunk/src/shield_symbolizer.cpp
   trunk/src/text_symbolizer.cpp
Log:
Added avoid_edges property to shield and text symbolizers.
If this is enabled, no shield/text symbolizers will be cut off
at the edges of the image.



Modified: trunk/bindings/python/mapnik_shield_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_shield_symbolizer.cpp	2006-11-17 02:02:29 UTC (rev 372)
+++ trunk/bindings/python/mapnik_shield_symbolizer.cpp	2006-11-17 14:07:41 UTC (rev 373)
@@ -34,6 +34,9 @@
                              init<>("Default Shield Symbolizer - 4x4 black square"))
         .def (init< std::string const&, std::string const&, unsigned, mapnik::Color const&,
               std::string const&, std::string const&,unsigned,unsigned>("TODO"))
+        .add_property("avoid_edges",
+                      &shield_symbolizer::get_avoid_edges,
+                      &shield_symbolizer::set_avoid_edges)
         ;
     
 }

Modified: trunk/bindings/python/mapnik_text_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_text_symbolizer.cpp	2006-11-17 02:02:29 UTC (rev 372)
+++ trunk/bindings/python/mapnik_text_symbolizer.cpp	2006-11-17 14:07:41 UTC (rev 373)
@@ -58,6 +58,9 @@
         .add_property("max_char_angle_delta",
                       &text_symbolizer::get_max_char_angle_delta,
                       &text_symbolizer::set_max_char_angle_delta)
+        .add_property("avoid_edges",
+                      &text_symbolizer::get_avoid_edges,
+                      &text_symbolizer::set_avoid_edges)
         .def("set_label_placement",&text_symbolizer::set_label_placement,
              "Set the placement of the label")
 	;

Modified: trunk/include/mapnik/placement_finder.hpp
===================================================================
--- trunk/include/mapnik/placement_finder.hpp	2006-11-17 02:02:29 UTC (rev 372)
+++ trunk/include/mapnik/placement_finder.hpp	2006-11-17 14:07:41 UTC (rev 373)
@@ -91,6 +91,8 @@
     int label_spacing; // distance between repeated labels on a single geometry
 
     double max_char_angle_delta;
+    
+    bool avoid_edges;
   };
 
 
@@ -98,7 +100,8 @@
   class placement_finder : boost::noncopyable
   {
   public:
-    placement_finder(Envelope<double> e);
+    //E is the dimensions of the map, buffer is the buffer used for collission detection.
+    placement_finder(Envelope<double> e, unsigned buffer);
   
     bool find_placements(placement *p);
     
@@ -111,8 +114,8 @@
 
     void update_detector(placement *p);
   
+    Envelope<double> dimensions_;
     label_collision_detector3 detector_;
-
   };
   
 }

Modified: trunk/include/mapnik/shield_symbolizer.hpp
===================================================================
--- trunk/include/mapnik/shield_symbolizer.hpp	2006-11-17 02:02:29 UTC (rev 372)
+++ trunk/include/mapnik/shield_symbolizer.hpp	2006-11-17 14:07:41 UTC (rev 373)
@@ -53,6 +53,8 @@
         void set_allow_overlap(bool overlap);
         bool get_allow_overlap() const;
         
+        void set_avoid_edges(bool avoid);
+        bool get_avoid_edges() const;
     private:
         std::string name_;
         std::string face_name_;
@@ -60,6 +62,7 @@
         Color fill_;
         boost::shared_ptr<ImageData32> symbol_;
         bool overlap_;
+        bool avoid_edges_;
     };
 }
 

Modified: trunk/include/mapnik/text_symbolizer.hpp
===================================================================
--- trunk/include/mapnik/text_symbolizer.hpp	2006-11-17 02:02:29 UTC (rev 372)
+++ trunk/include/mapnik/text_symbolizer.hpp	2006-11-17 14:07:41 UTC (rev 373)
@@ -64,6 +64,9 @@
         position const& get_anchor() const;	
         void set_displacement(double x, double y);
         position const& get_displacement() const;
+
+        void set_avoid_edges(bool avoid);
+        bool get_avoid_edges() const;
     private:
         std::string name_;
         std::string face_name_;
@@ -78,6 +81,7 @@
         label_placement_e label_p_;
         position anchor_;
         position displacement_;
+        bool avoid_edges_;
     };
 }
 

Modified: trunk/src/agg_renderer.cpp
===================================================================
--- trunk/src/agg_renderer.cpp	2006-11-17 02:02:29 UTC (rev 372)
+++ trunk/src/agg_renderer.cpp	2006-11-17 14:07:41 UTC (rev 373)
@@ -95,7 +95,7 @@
         : feature_style_processor<agg_renderer>(m),
           pixmap_(pixmap),
           t_(m.getWidth(),m.getHeight(),m.getCurrentExtent()),
-          finder_(Envelope<double>(-64 ,-64, m.getWidth() + 64 ,m.getHeight() + 64)),
+          finder_(Envelope<double>(0 ,0, m.getWidth(), m.getHeight()), 64),
           point_detector_(Envelope<double>(-64 ,-64, m.getWidth() + 64 ,m.getHeight() + 64))
     {
         Color const& bg=m.getBackground();
@@ -345,7 +345,8 @@
                     ren.get_string_info(text, &info);
                  
                     placement text_placement(&info, &t_, &prj_trans, geom, std::pair<double, double>(w, h) );
-                    
+                    text_placement.avoid_edges = sym.get_avoid_edges();
+                  
                     bool found = finder_.find_placements(&text_placement);
                     if (!found) {
                       return;
@@ -509,6 +510,7 @@
                     text_placement.wrap_width = sym.get_wrap_width();
                     text_placement.label_spacing = sym.get_label_spacing();
                     text_placement.max_char_angle_delta = sym.get_max_char_angle_delta();
+                    text_placement.avoid_edges = sym.get_avoid_edges();
                   
                     bool found = finder_.find_placements(&text_placement);
                     if (!found) {

Modified: trunk/src/placement_finder.cpp
===================================================================
--- trunk/src/placement_finder.cpp	2006-11-17 02:02:29 UTC (rev 372)
+++ trunk/src/placement_finder.cpp	2006-11-17 14:07:41 UTC (rev 373)
@@ -40,14 +40,15 @@
 
 namespace mapnik
 {
+    //For shields
     placement::placement(string_info *info_, CoordTransform *ctrans_, const proj_transform *proj_trans_, geometry_ptr geom_, std::pair<double, double> dimensions_)
-        : info(info_), ctrans(ctrans_), proj_trans(proj_trans_), geom(geom_), label_placement(point_placement), dimensions(dimensions_), has_dimensions(true), shape_path(*ctrans_, *geom_, *proj_trans_), total_distance_(-1.0), wrap_width(0), text_ratio(0), label_spacing(0), max_char_angle_delta(0.0)
+        : info(info_), ctrans(ctrans_), proj_trans(proj_trans_), geom(geom_), label_placement(point_placement), dimensions(dimensions_), has_dimensions(true), shape_path(*ctrans_, *geom_, *proj_trans_), total_distance_(-1.0), wrap_width(0), text_ratio(0), label_spacing(0), max_char_angle_delta(0.0), avoid_edges(false)
     {
     }
 
     //For text
     placement::placement(string_info *info_, CoordTransform *ctrans_, const proj_transform *proj_trans_, geometry_ptr geom_, label_placement_e placement_)
-        : info(info_), ctrans(ctrans_), proj_trans(proj_trans_), geom(geom_), label_placement(placement_), has_dimensions(false), shape_path(*ctrans_, *geom_, *proj_trans_), total_distance_(-1.0), wrap_width(0), text_ratio(0), label_spacing(0), max_char_angle_delta(0.0)
+        : info(info_), ctrans(ctrans_), proj_trans(proj_trans_), geom(geom_), label_placement(placement_), has_dimensions(false), shape_path(*ctrans_, *geom_, *proj_trans_), total_distance_(-1.0), wrap_width(0), text_ratio(0), label_spacing(0), max_char_angle_delta(0.0), avoid_edges(false)
     {
     }
   
@@ -136,8 +137,8 @@
   
   
   
-    placement_finder::placement_finder(Envelope<double> e)
-      : detector_(e)
+    placement_finder::placement_finder(Envelope<double> e, unsigned buffer)
+      : dimensions_(e), detector_(Envelope<double>(e.minx() - buffer, e.miny() - buffer, e.maxx() + buffer, e.maxy() + buffer))
     {
     }
 
@@ -476,6 +477,11 @@
             {
                 return false;
             }
+            
+            if (p->avoid_edges && !dimensions_.contains(e))
+            {
+                return false;
+            }
         
             p->envelopes.push(e);
 
@@ -635,6 +641,11 @@
                 {
                     return false;
                 }
+
+                if (p->avoid_edges && !dimensions_.contains(e))
+                {
+                    return false;
+                }
                 
                 p->envelopes.push(e);
             }

Modified: trunk/src/shield_symbolizer.cpp
===================================================================
--- trunk/src/shield_symbolizer.cpp	2006-11-17 02:02:29 UTC (rev 372)
+++ trunk/src/shield_symbolizer.cpp	2006-11-17 14:07:41 UTC (rev 373)
@@ -50,7 +50,7 @@
                           std::string const& file,
                           std::string const& type,
                           unsigned width,unsigned height)
-        : name_(name), face_name_(face_name), size_(size), fill_(fill), symbol_(new ImageData32(width,height))
+        : name_(name), face_name_(face_name), size_(size), fill_(fill), symbol_(new ImageData32(width,height)), avoid_edges_(false)
     {
         try 
         {
@@ -72,7 +72,8 @@
           size_(rhs.size_),
           fill_(rhs.fill_),
           symbol_(rhs.symbol_),
-          overlap_(rhs.overlap_)
+          overlap_(rhs.overlap_),
+          avoid_edges_(rhs.avoid_edges_)
     {}
     
     void shield_symbolizer::set_data( boost::shared_ptr<ImageData32> symbol)
@@ -114,5 +115,15 @@
     {
         return fill_;
     }
+    
+    bool shield_symbolizer::get_avoid_edges() const
+    {
+        return avoid_edges_;
+    }
+    
+    void shield_symbolizer::set_avoid_edges(bool avoid)
+    {
+        avoid_edges_ = avoid;
+    }
 }
 

Modified: trunk/src/text_symbolizer.cpp
===================================================================
--- trunk/src/text_symbolizer.cpp	2006-11-17 02:02:29 UTC (rev 372)
+++ trunk/src/text_symbolizer.cpp	2006-11-17 14:07:41 UTC (rev 373)
@@ -42,7 +42,8 @@
 	  halo_radius_(0),
 	  label_p_(point_placement),
 	  anchor_(0.0,0.5),
-	  displacement_(0.0,0.0)  {}
+	  displacement_(0.0,0.0),
+    avoid_edges_(false) {}
            
     text_symbolizer::text_symbolizer(text_symbolizer const& rhs)
         : name_(rhs.name_),
@@ -57,7 +58,8 @@
           halo_radius_(rhs.halo_radius_),
           label_p_(rhs.label_p_),
           anchor_(rhs.anchor_),
-          displacement_(rhs.displacement_) {}
+          displacement_(rhs.displacement_),
+          avoid_edges_(rhs.avoid_edges_) {}
 
     text_symbolizer& text_symbolizer::operator=(text_symbolizer const& other)
     {
@@ -76,6 +78,8 @@
         label_p_ = other.label_p_;
         anchor_ = other.anchor_;
         displacement_ = other.displacement_; 
+        avoid_edges_ = other.avoid_edges_;
+        
         return *this;
     } 
 
@@ -187,4 +191,14 @@
     {
         return displacement_;
     }
+    
+    bool text_symbolizer::get_avoid_edges() const
+    {
+        return avoid_edges_;
+    }
+    
+    void text_symbolizer::set_avoid_edges(bool avoid)
+    {
+        avoid_edges_ = avoid;
+    }
 }



From pavlenko at mail.berlios.de  Fri Nov 17 22:10:34 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Fri, 17 Nov 2006 22:10:34 +0100
Subject: [Mapnik-svn] r374 - trunk/plugins/input/postgis
Message-ID: <200611172110.kAHLAYhu001487@sheep.berlios.de>

Author: pavlenko
Date: 2006-11-17 22:10:28 +0100 (Fri, 17 Nov 2006)
New Revision: 374

Modified:
   trunk/plugins/input/postgis/connection.hpp
   trunk/plugins/input/postgis/connection_manager.hpp
   trunk/plugins/input/postgis/postgis.cpp
Log:
added port parameter support

Modified: trunk/plugins/input/postgis/connection.hpp
===================================================================
--- trunk/plugins/input/postgis/connection.hpp	2006-11-17 14:07:41 UTC (rev 373)
+++ trunk/plugins/input/postgis/connection.hpp	2006-11-17 21:10:28 UTC (rev 374)
@@ -27,7 +27,7 @@
 
 extern "C" 
 {
-   #include "libpq-fe.h"
+#include "libpq-fe.h"
 }
 
 #include "resultset.hpp"
@@ -41,50 +41,58 @@
 private:
     PGconn *conn_;
 public:
-    Connection(const std::string& uri,const std::string& dbname, 
-	       const std::string& username,const std::string& password)
+    Connection(std::string const& uri, 
+               std::string const& port,
+               std::string const& dbname, 
+               std::string const& username,
+               std::string const& password)
     {
-	std::string connStr="host="+uri+" dbname="+dbname+" user="+username+" password="+password;
-	conn_=PQconnectdb(connStr.c_str());
-	if (PQstatus(conn_) == CONNECTION_BAD)
-	{
-	    std::clog << "connection to "<< connStr << " failed\n"
-		      << PQerrorMessage(conn_)<< std::endl;
-	}
-	else
-	{
-	    std::clog <<"connected ok "<<std::endl;
-	}
+        std::string connStr="host="+uri;
+        if (port.length()) connStr+=" port="+port;
+        connStr+=" dbname="+dbname;
+        connStr+=" user="+username;
+        connStr+=" password="+password;
+        
+        conn_=PQconnectdb(connStr.c_str());
+        if (PQstatus(conn_) == CONNECTION_BAD)
+        {
+            std::clog << "connection to "<< connStr << " failed\n"
+                      << PQerrorMessage(conn_)<< std::endl;
+        }
+        else
+        {
+            std::clog <<"connected ok "<<std::endl;
+        }
     }
     bool execute(const std::string& sql) const
     {
-	PGresult *result=PQexec(conn_,sql.c_str());
-	bool ok=(result && PQresultStatus(result)==PGRES_COMMAND_OK);
-	PQclear(result);
-	return ok;
+        PGresult *result=PQexec(conn_,sql.c_str());
+        bool ok=(result && PQresultStatus(result)==PGRES_COMMAND_OK);
+        PQclear(result);
+        return ok;
     }
     boost::shared_ptr<ResultSet> executeQuery(const std::string& sql,int type=0) const
     {
-	PGresult *result=0;
-	if (type==1)
-	{
-	    result=PQexecParams(conn_,sql.c_str(),0,0,0,0,0,1);
-	    return boost::shared_ptr<ResultSet>(new ResultSet(result));
-	}
-	result=PQexec(conn_,sql.c_str());
-	return boost::shared_ptr<ResultSet>(new ResultSet(result));
+        PGresult *result=0;
+        if (type==1)
+        {
+            result=PQexecParams(conn_,sql.c_str(),0,0,0,0,0,1);
+            return boost::shared_ptr<ResultSet>(new ResultSet(result));
+        }
+        result=PQexec(conn_,sql.c_str());
+        return boost::shared_ptr<ResultSet>(new ResultSet(result));
     }
     bool isOK() const
     {
-	return (PQstatus(conn_)!=CONNECTION_BAD);
+        return (PQstatus(conn_)!=CONNECTION_BAD);
     }
     void close()
     {
-	PQfinish(conn_);
+        PQfinish(conn_);
     }
     ~Connection()
     {
-	PQfinish(conn_);
+        PQfinish(conn_);
     }
 };
 

Modified: trunk/plugins/input/postgis/connection_manager.hpp
===================================================================
--- trunk/plugins/input/postgis/connection_manager.hpp	2006-11-17 14:07:41 UTC (rev 373)
+++ trunk/plugins/input/postgis/connection_manager.hpp	2006-11-17 21:10:28 UTC (rev 374)
@@ -39,24 +39,29 @@
 class ConnectionCreator
 {
     string url_;
+    string port_;
     string dbname_;
     string user_;
     string pass_;
 public:
-    ConnectionCreator(const string& url,const string& dbname,
-		      const string& user,const string& pass)
-	: url_(url),
-	  dbname_(dbname),
-	  user_(user),
-	  pass_(pass) {}
+    ConnectionCreator(string const& url,
+                      string const& port,
+                      string const& dbname,
+                      string const& user,
+                      string const& pass)
+        : url_(url),
+          port_(port),
+          dbname_(dbname),
+          user_(user),
+          pass_(pass) {}
     
     T* operator()() const
     {
-	return new T(url_,dbname_,user_,pass_);
+        return new T(url_,port_,dbname_,user_,pass_);
     }
     std::string id() const 
     {
-	return url_+":"+dbname_+":"+user_+":"+pass_;
+        return url_ + ":" + dbname_;
     }
 };
 
@@ -73,39 +78,40 @@
 	
     bool registerPool(const ConnectionCreator<Connection>& creator,int initialSize,int maxSize) 
     {	    
-	mutex::scoped_lock lock(mutex_);
-	if (pools_.find(creator.id())==pools_.end())
-	{
-	    return pools_.insert(std::make_pair(creator.id(),
-						boost::shared_ptr<PoolType>(new PoolType(creator,initialSize,maxSize)))).second;
-	}
+        mutex::scoped_lock lock(mutex_);
+        if (pools_.find(creator.id())==pools_.end())
+        {
+            return pools_.insert(std::make_pair(creator.id(),
+                                                boost::shared_ptr<PoolType>(new PoolType(creator,initialSize,maxSize)))).second;
+        }
 
-	return false;
+        return false;
 	   	     
     }
+    
     const boost::shared_ptr<PoolType>& getPool(const std::string& key) 
     {
-	mutex::scoped_lock lock(mutex_);
-	ContType::const_iterator itr=pools_.find(key);
-	if (itr!=pools_.end())
-	{
-	    return itr->second;
-	}
-	static const boost::shared_ptr<PoolType> emptyPool;
-	return emptyPool;
+        mutex::scoped_lock lock(mutex_);
+        ContType::const_iterator itr=pools_.find(key);
+        if (itr!=pools_.end())
+        {
+            return itr->second;
+        }
+        static const boost::shared_ptr<PoolType> emptyPool;
+        return emptyPool;
     }
 	
     const HolderType& get(const std::string& key)
     {
-	mutex::scoped_lock lock(mutex_);
-	ContType::const_iterator itr=pools_.find(key);
-	if (itr!=pools_.end()) 
-	{
-	    boost::shared_ptr<PoolType> pool=itr->second;
-	    return pool->borrowObject();
-	}
-	static const HolderType EmptyConn;
-	return EmptyConn;
+        mutex::scoped_lock lock(mutex_);
+        ContType::const_iterator itr=pools_.find(key);
+        if (itr!=pools_.end()) 
+        {
+            boost::shared_ptr<PoolType> pool=itr->second;
+            return pool->borrowObject();
+        }
+        static const HolderType EmptyConn;
+        return EmptyConn;
     }
         
 private:

Modified: trunk/plugins/input/postgis/postgis.cpp
===================================================================
--- trunk/plugins/input/postgis/postgis.cpp	2006-11-17 14:07:41 UTC (rev 373)
+++ trunk/plugins/input/postgis/postgis.cpp	2006-11-17 21:10:28 UTC (rev 374)
@@ -43,20 +43,20 @@
 using boost::bad_lexical_cast;
 using boost::shared_ptr;
 
-postgis_datasource::postgis_datasource(const parameters& params)
+postgis_datasource::postgis_datasource(parameters const& params)
     : datasource (params),
       table_(params.get("table")),
       type_(datasource::Vector), 
-      desc_(params.get("name")),
+      desc_(params.get("type")),
       creator_(params.get("host"),
+               params.get("port"),
                params.get("dbname"),
                params.get("user"),
-               params.get("password"))
-      
+               params.get("password"))    
 {     
     ConnectionManager *mgr=ConnectionManager::instance();   
     mgr->registerPool(creator_,10,20);
-
+    
     shared_ptr<Pool<Connection,ConnectionCreator> > pool=mgr->getPool(creator_.id());
     if (pool)
     {
@@ -64,9 +64,7 @@
         if (conn && conn->isOK())
         {
             PoolGuard<shared_ptr<Connection>,shared_ptr<Pool<Connection,ConnectionCreator> > > guard(conn,pool);
-
             std::string table_name=table_from_sql(table_);
-	    
             std::ostringstream s;
             s << "select f_geometry_column,srid,type from ";
             s << GEOMETRY_COLUMNS <<" where f_table_name='" << table_name<<"'";



From pavlenko at mail.berlios.de  Sat Nov 18 17:47:31 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Sat, 18 Nov 2006 17:47:31 +0100
Subject: [Mapnik-svn] r375 - trunk/src
Message-ID: <200611181647.kAIGlVpL029667@sheep.berlios.de>

Author: pavlenko
Date: 2006-11-18 17:47:29 +0100 (Sat, 18 Nov 2006)
New Revision: 375

Modified:
   trunk/src/agg_renderer.cpp
Log:
commented out usage of rasterizer_outline_aa for strokes <= 1.0



Modified: trunk/src/agg_renderer.cpp
===================================================================
--- trunk/src/agg_renderer.cpp	2006-11-17 21:10:28 UTC (rev 374)
+++ trunk/src/agg_renderer.cpp	2006-11-18 16:47:29 UTC (rev 375)
@@ -235,18 +235,19 @@
                 ren.color(agg::rgba8(r, g, b, int(255*stroke_.get_opacity())));
                 agg::render_scanlines(ras, sl, ren);
             }
-            else if (stroke_.get_width() <= 1.0)
-            {
-                agg::line_profile_aa prof;
-                prof.width(stroke_.get_width());
-                renderer_oaa ren_oaa(renb, prof);
-                rasterizer_outline_aa ras_oaa(ren_oaa);
+            
+            //else if (stroke_.get_width() <= 1.0)
+            //{
+            //   agg::line_profile_aa prof;
+            //   prof.width(stroke_.get_width());
+            //   renderer_oaa ren_oaa(renb, prof);
+            //   rasterizer_outline_aa ras_oaa(ren_oaa);
                 
-                ren_oaa.color(agg::rgba8(r, g, b, int(255*stroke_.get_opacity())));
-                ren_oaa.clip_box(0,0,pixmap_.width(),pixmap_.height());
-                ras_oaa.add_path(path);		
-		    
-            }
+            //    ren_oaa.color(agg::rgba8(r, g, b, int(255*stroke_.get_opacity())));
+            //    ren_oaa.clip_box(0,0,pixmap_.width(),pixmap_.height());
+            //    ras_oaa.add_path(path);		
+		 
+            //    }
             else 
             {
                 renderer ren(renb);	



From pavlenko at mail.berlios.de  Sun Nov 19 18:13:43 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Sun, 19 Nov 2006 18:13:43 +0100
Subject: [Mapnik-svn] r376 - in trunk: . include/mapnik
	plugins/input/postgis plugins/input/raster
	plugins/input/shape src utils/shapeindex
Message-ID: <200611191713.kAJHDhsf006225@sheep.berlios.de>

Author: pavlenko
Date: 2006-11-19 18:13:33 +0100 (Sun, 19 Nov 2006)
New Revision: 376

Modified:
   trunk/SConstruct
   trunk/include/mapnik/feature_style_processor.hpp
   trunk/include/mapnik/font_engine_freetype.hpp
   trunk/include/mapnik/pool.hpp
   trunk/include/mapnik/utils.hpp
   trunk/plugins/input/postgis/connection.hpp
   trunk/plugins/input/postgis/postgis.cpp
   trunk/plugins/input/postgis/postgisfs.cpp
   trunk/plugins/input/raster/raster_featureset.cpp
   trunk/plugins/input/shape/shape.cpp
   trunk/plugins/input/shape/shape_featureset.cpp
   trunk/plugins/input/shape/shape_index_featureset.cpp
   trunk/src/agg_renderer.cpp
   trunk/src/datasource_cache.cpp
   trunk/src/load_map.cpp
   trunk/src/map.cpp
   trunk/src/memory.cpp
   trunk/src/png_reader.cpp
   trunk/src/polygon_pattern_symbolizer.cpp
   trunk/src/shield_symbolizer.cpp
   trunk/utils/shapeindex/shapeindex.cpp
Log:
disable clog printing in release mode. Pass -DMAPNIK_DEBUG to enable.




Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2006-11-18 16:47:29 UTC (rev 375)
+++ trunk/SConstruct	2006-11-19 17:13:33 UTC (rev 376)
@@ -145,7 +145,7 @@
 # Setup the c++ args for our own codebase
 
 if env['DEBUG']:
-    env.Append(CXXFLAGS = '-ansi -Wall -ftemplate-depth-100 -O0 -fno-inline -g -pthread -DDEBUG -DBOOST_PROPERTY_TREE_XML_PARSER_TINYXML -DTIXML_USE_STL')
+    env.Append(CXXFLAGS = '-ansi -Wall -ftemplate-depth-100 -O0 -fno-inline -g -pthread -DDEBUG -DMAPNIK_DEBUG -DBOOST_PROPERTY_TREE_XML_PARSER_TINYXML -DTIXML_USE_STL')
 else:
     env.Append(CXXFLAGS = '-ansi -Wall -ftemplate-depth-100 -O3 -finline-functions -Wno-inline -pthread -DNDEBUG -DBOOST_PROPERTY_TREE_XML_PARSER_TINYXML -DTIXML_USE_STL')
 

Modified: trunk/include/mapnik/feature_style_processor.hpp
===================================================================
--- trunk/include/mapnik/feature_style_processor.hpp	2006-11-18 16:47:29 UTC (rev 375)
+++ trunk/include/mapnik/feature_style_processor.hpp	2006-11-19 17:13:33 UTC (rev 376)
@@ -77,8 +77,9 @@
             {
                 projection proj(m_.srs()); // map projection
                 double scale_denom = scale_denominator(m_,proj.is_geographic());
+#ifdef MAPNIK_DEBUG
                 std::clog << "scale denominator = " << scale_denom << "\n";
-                
+#endif
                 std::vector<Layer>::const_iterator itr = m_.layers().begin();
                 std::vector<Layer>::const_iterator end = m_.layers().end();
             
@@ -120,8 +121,9 @@
                 prj_trans.forward(x0,y0,z0);
                 prj_trans.forward(x1,y1,z1);
                 Envelope<double> bbox(x0,y0,x1,y1);
+#ifdef MAPNIK_DEBUG
                 std::clog << bbox << "\n";
-                
+#endif                
                 std::vector<std::string> const& style_names = lay.styles();
                 std::vector<std::string>::const_iterator stylesIter = style_names.begin();
                 std::vector<std::string>::const_iterator stylesEnd = style_names.end();

Modified: trunk/include/mapnik/font_engine_freetype.hpp
===================================================================
--- trunk/include/mapnik/font_engine_freetype.hpp	2006-11-18 16:47:29 UTC (rev 375)
+++ trunk/include/mapnik/font_engine_freetype.hpp	2006-11-19 17:13:33 UTC (rev 376)
@@ -95,7 +95,9 @@
 	
     	~font_face()
     	{
+#ifdef MAPNIK_DEBUG
     	    std::clog << "clean up face:" << family_name()<<":" << style_name() << std::endl;
+#endif
     	    FT_Done_Face(face_);
     	}
 	

Modified: trunk/include/mapnik/pool.hpp
===================================================================
--- trunk/include/mapnik/pool.hpp	2006-11-18 16:47:29 UTC (rev 375)
+++ trunk/include/mapnik/pool.hpp	2006-11-19 17:13:33 UTC (rev 376)
@@ -91,8 +91,10 @@
             mutex::scoped_lock lock(mutex_);
             typename ContType::iterator itr=unusedPool_.begin();
             if (itr!=unusedPool_.end())
-            {  
+            { 
+#ifdef MAPNIK_DEBUG
                 std::clog<<"borrow "<<(*itr).get()<<"\n";
+#endif
                 usedPool_.push_back(*itr);
                 itr=unusedPool_.erase(itr);
                 return usedPool_[usedPool_.size()-1];
@@ -109,7 +111,9 @@
             {
                 if (obj.get()==(*itr).get()) 
                 {
+#ifdef MAPNIK_DEBUG
                     std::clog<<"return "<<(*itr).get()<<"\n";
+#endif
                     unusedPool_.push_back(*itr);
                     usedPool_.erase(itr);
                     return;

Modified: trunk/include/mapnik/utils.hpp
===================================================================
--- trunk/include/mapnik/utils.hpp	2006-11-18 16:47:29 UTC (rev 375)
+++ trunk/include/mapnik/utils.hpp	2006-11-19 17:13:33 UTC (rev 376)
@@ -163,30 +163,6 @@
             }
         }
     };
-
-
-    struct timer
-    {
-        //struct timeval tv_;
-        timer()
-        {
-            //gettimeofday (&tv_,0);
-        }
-        void start()
-        {
-            //gettimeofday (&tv_,0);
-        }
-        void stop()
-        {
-            //timeval tv;
-            //gettimeofday (&tv,0);
-            //std::ostringstream s;
-            //long sec=1000*(tv.tv_sec-tv_.tv_sec);
-            //long total_ms=sec+static_cast<long>(0.001*(tv.tv_usec-tv_.tv_usec));
-            //s << "elapsed time is "<<total_ms<<" ms";
-            //std::clog<<s.str()<<std::endl;
-        }
-    };
     
     //converters
     class BadConversion : public std::runtime_error

Modified: trunk/plugins/input/postgis/connection.hpp
===================================================================
--- trunk/plugins/input/postgis/connection.hpp	2006-11-18 16:47:29 UTC (rev 375)
+++ trunk/plugins/input/postgis/connection.hpp	2006-11-19 17:13:33 UTC (rev 376)
@@ -59,10 +59,6 @@
             std::clog << "connection to "<< connStr << " failed\n"
                       << PQerrorMessage(conn_)<< std::endl;
         }
-        else
-        {
-            std::clog <<"connected ok "<<std::endl;
-        }
     }
     bool execute(const std::string& sql) const
     {

Modified: trunk/plugins/input/postgis/postgis.cpp
===================================================================
--- trunk/plugins/input/postgis/postgis.cpp	2006-11-18 16:47:29 UTC (rev 375)
+++ trunk/plugins/input/postgis/postgis.cpp	2006-11-19 17:13:33 UTC (rev 376)
@@ -36,7 +36,6 @@
 const std::string postgis_datasource::SPATIAL_REF_SYS="spatial_ref_system";
 
 using std::clog;
-using std::clog;
 using std::endl;
 
 using boost::lexical_cast;
@@ -219,7 +218,7 @@
             s << std::setprecision(16);
             s << box.minx() << " " << box.miny() << ",";
             s << box.maxx() << " " << box.maxy() << ")'::box3d,"<<srid_<<")";
-            clog << s.str() << endl;
+            
             shared_ptr<ResultSet> rs=conn->executeQuery(s.str(),1);
             fs=new postgis_featureset(rs,props.size());
         }

Modified: trunk/plugins/input/postgis/postgisfs.cpp
===================================================================
--- trunk/plugins/input/postgis/postgisfs.cpp	2006-11-18 16:47:29 UTC (rev 375)
+++ trunk/plugins/input/postgis/postgisfs.cpp	2006-11-19 17:13:33 UTC (rev 376)
@@ -97,8 +97,6 @@
     else
     {
         rs_->close();
-        std::clog << "totalGeomSize="<<totalGeomSize_<<" bytes"<<std::endl;
-        std::clog << "count="<<count_<<std::endl;
         return feature_ptr();
     }
 }

Modified: trunk/plugins/input/raster/raster_featureset.cpp
===================================================================
--- trunk/plugins/input/raster/raster_featureset.cpp	2006-11-18 16:47:29 UTC (rev 375)
+++ trunk/plugins/input/raster/raster_featureset.cpp	2006-11-19 17:13:33 UTC (rev 376)
@@ -45,10 +45,8 @@
     {
         feature_ptr feature(new Feature(+id_));
         try
-        {
-            std::clog<<"raster_featureset "<<curIter_->format()<<" "<<curIter_->file()<<std::endl;
+        {         
             std::auto_ptr<ImageReader> reader(get_image_reader(curIter_->format(),curIter_->file()));
-            std::clog<<reader.get()<<std::endl;
             if (reader.get())
             {
                 int image_width=reader->width();

Modified: trunk/plugins/input/shape/shape.cpp
===================================================================
--- trunk/plugins/input/shape/shape.cpp	2006-11-18 16:47:29 UTC (rev 375)
+++ trunk/plugins/input/shape/shape.cpp	2006-11-19 17:13:33 UTC (rev 376)
@@ -72,10 +72,10 @@
                     break;
                 }
             default:
-                //
+#ifdef MAPNIK_DEBUG                
                 std::clog << "unknown type "<<fd.type_<<"\n";
+#endif 
                 break;
-
             }
         }
     }
@@ -123,9 +123,12 @@
         file.close();
     }
 
+#ifdef MAPNIK_DEBUG
     std::clog << extent_ << std::endl;
     std::clog << "file_length=" << file_length_ << std::endl;
     std::clog << "shape_type=" << shape_type << std::endl;
+#endif
+
 }
 
 int shape_datasource::type() const

Modified: trunk/plugins/input/shape/shape_featureset.cpp
===================================================================
--- trunk/plugins/input/shape/shape_featureset.cpp	2006-11-18 16:47:29 UTC (rev 375)
+++ trunk/plugins/input/shape/shape_featureset.cpp	2006-11-19 17:13:33 UTC (rev 376)
@@ -25,9 +25,9 @@
 
 template <typename filterT>
 shape_featureset<filterT>::shape_featureset(const filterT& filter, 
-					    const std::string& shape_file,
-					    const std::set<std::string>& attribute_names,
-					    long file_length )
+                                            const std::string& shape_file,
+                                            const std::set<std::string>& attribute_names,
+                                            long file_length )
     : filter_(filter),
       shape_type_(shape_io::shape_null),
       shape_(shape_file),
@@ -40,15 +40,15 @@
     typename std::set<std::string>::const_iterator pos=attribute_names.begin();
     while (pos!=attribute_names.end())
     {
-	for (int i=0;i<shape_.dbf().num_fields();++i)
-	{
-	    if (shape_.dbf().descriptor(i).name_ == *pos)
-	    {
-		attr_ids_.push_back(i);
-		break;
-	    }
-	}
-	++pos;
+        for (int i=0;i<shape_.dbf().num_fields();++i)
+        {
+            if (shape_.dbf().descriptor(i).name_ == *pos)
+            {
+                attr_ids_.push_back(i);
+                break;
+            }
+        }
+        ++pos;
     }
 }
 
@@ -61,126 +61,128 @@
     if (pos < std::streampos(file_length_ * 2))
     {
         shape_.move_to(pos);
-	int type=shape_.type();
-	feature_ptr feature(new Feature(shape_.id_));
-	if (type == shape_io::shape_point)
-	{
-	    double x=shape_.shp().read_double();
-	    double y=shape_.shp().read_double();
-	    geometry_ptr point(new point_impl(-1));
-	    point->move_to(x,y);
-	    feature->set_geometry(point);
-	    ++count_;
-	}
-	else if (type == shape_io::shape_pointm)
-	{
-	    double x=shape_.shp().read_double();
-	    double y=shape_.shp().read_double();
-	    shape_.shp().read_double();//m
-	    geometry_ptr point(new point_impl(-1));
-	    point->move_to(x,y);
-	    feature->set_geometry(point);
-	    ++count_;
-	}
-	else if (type == shape_io::shape_pointz)
-	{
-	    double x=shape_.shp().read_double();
-	    double y=shape_.shp().read_double();
-	    shape_.shp().read_double();//z
-	    shape_.shp().read_double();//m
-	    geometry_ptr point(new point_impl(-1));
-	    point->move_to(x,y);
-	    feature->set_geometry(point);
-	    ++count_;
-	}
-	else
-	{
-	    while (!filter_.pass(shape_.current_extent()))
-	    {	
-		unsigned reclen=shape_.reclength_;
-		if (!shape_.shp().is_eof())
-		{
-		    long pos = shape_.shp().pos();
-		    shape_.move_to(pos + 2 * reclen - 36);
-		}
-		else
-		{
-		    return feature_ptr();
+        int type=shape_.type();
+        feature_ptr feature(new Feature(shape_.id_));
+        if (type == shape_io::shape_point)
+        {
+            double x=shape_.shp().read_double();
+            double y=shape_.shp().read_double();
+            geometry_ptr point(new point_impl(-1));
+            point->move_to(x,y);
+            feature->set_geometry(point);
+            ++count_;
+        }
+        else if (type == shape_io::shape_pointm)
+        {
+            double x=shape_.shp().read_double();
+            double y=shape_.shp().read_double();
+            shape_.shp().read_double();//m
+            geometry_ptr point(new point_impl(-1));
+            point->move_to(x,y);
+            feature->set_geometry(point);
+            ++count_;
+        }
+        else if (type == shape_io::shape_pointz)
+        {
+            double x=shape_.shp().read_double();
+            double y=shape_.shp().read_double();
+            shape_.shp().read_double();//z
+            shape_.shp().read_double();//m
+            geometry_ptr point(new point_impl(-1));
+            point->move_to(x,y);
+            feature->set_geometry(point);
+            ++count_;
+        }
+        else
+        {
+            while (!filter_.pass(shape_.current_extent()))
+            {	
+                unsigned reclen=shape_.reclength_;
+                if (!shape_.shp().is_eof())
+                {
+                    long pos = shape_.shp().pos();
+                    shape_.move_to(pos + 2 * reclen - 36);
+                }
+                else
+                {
+                    return feature_ptr();
 
-		}
-	    }
+                }
+            }
 	    
-	    switch (type)
+            switch (type)
             {
 	  
-	    case shape_io::shape_polyline:
-		{
-		    geometry_ptr line = shape_.read_polyline();
-		    feature->set_geometry(line);
-		    ++count_;
-		    break;
-		}
-	    case shape_io::shape_polylinem:
-		{
-		    geometry_ptr line = shape_.read_polylinem();
-		    feature->set_geometry(line);
-		    ++count_;
-		    break;
-		}
-	    case shape_io::shape_polylinez:
-		{
-		    geometry_ptr line = shape_.read_polylinez();
-		    feature->set_geometry(line);
-		    ++count_;
-		    break;
-		}
-	    case shape_io::shape_polygon:
-		{		 
-		    geometry_ptr poly = shape_.read_polygon();
-		    feature->set_geometry(poly);
-		    ++count_;
-		    break;
-		}
-	    case shape_io::shape_polygonm:
-		{		 
-		    geometry_ptr poly = shape_.read_polygonm();
-		    feature->set_geometry(poly);
-		    ++count_;
-		    break;
-		}
-	    case shape_io::shape_polygonz:
-		{
-		    geometry_ptr poly = shape_.read_polygonz();
-		    feature->set_geometry(poly);
-		    ++count_;
-		    break;
-		}
+            case shape_io::shape_polyline:
+                {
+                    geometry_ptr line = shape_.read_polyline();
+                    feature->set_geometry(line);
+                    ++count_;
+                    break;
+                }
+            case shape_io::shape_polylinem:
+                {
+                    geometry_ptr line = shape_.read_polylinem();
+                    feature->set_geometry(line);
+                    ++count_;
+                    break;
+                }
+            case shape_io::shape_polylinez:
+                {
+                    geometry_ptr line = shape_.read_polylinez();
+                    feature->set_geometry(line);
+                    ++count_;
+                    break;
+                }
+            case shape_io::shape_polygon:
+                {		 
+                    geometry_ptr poly = shape_.read_polygon();
+                    feature->set_geometry(poly);
+                    ++count_;
+                    break;
+                }
+            case shape_io::shape_polygonm:
+                {		 
+                    geometry_ptr poly = shape_.read_polygonm();
+                    feature->set_geometry(poly);
+                    ++count_;
+                    break;
+                }
+            case shape_io::shape_polygonz:
+                {
+                    geometry_ptr poly = shape_.read_polygonz();
+                    feature->set_geometry(poly);
+                    ++count_;
+                    break;
+                }
 
             }
-	}
-	if (attr_ids_.size())
-	{
-	    shape_.dbf().move_to(shape_.id_);
-	    typename std::vector<int>::const_iterator pos=attr_ids_.begin();
-	    while (pos!=attr_ids_.end())
-	    {
-		try 
-		{
-		    shape_.dbf().add_attribute(*pos,*feature);//TODO optimize!!!
-		}
-		catch (...)
-		{
-		    std::clog << "error processing attributes " << std::endl;
-		}
-		++pos;
-	    }
-	}
-	return feature;
+        }
+        if (attr_ids_.size())
+        {
+            shape_.dbf().move_to(shape_.id_);
+            typename std::vector<int>::const_iterator pos=attr_ids_.begin();
+            while (pos!=attr_ids_.end())
+            {
+                try 
+                {
+                    shape_.dbf().add_attribute(*pos,*feature);//TODO optimize!!!
+                }
+                catch (...)
+                {
+                    std::clog << "error processing attributes " << std::endl;
+                }
+                ++pos;
+            }
+        }
+        return feature;
     }
     else
     {
-	std::clog<<" total shapes read="<<count_<<"\n";
-	return feature_ptr();
+#ifdef MAPNIK_DEBUG
+        std::clog<<" total shapes read="<<count_<<"\n";
+#endif
+        return feature_ptr();
     }
 }
 

Modified: trunk/plugins/input/shape/shape_index_featureset.cpp
===================================================================
--- trunk/plugins/input/shape/shape_index_featureset.cpp	2006-11-18 16:47:29 UTC (rev 375)
+++ trunk/plugins/input/shape/shape_index_featureset.cpp	2006-11-19 17:13:33 UTC (rev 376)
@@ -27,8 +27,8 @@
 
 template <typename filterT>
 shape_index_featureset<filterT>::shape_index_featureset(const filterT& filter,
-							const std::string& shape_file,
-							const std::set<std::string>& attribute_names)
+                                                        const std::string& shape_file,
+                                                        const std::set<std::string>& attribute_names)
     : filter_(filter),
       shape_type_(0),
       shape_(shape_file),
@@ -43,22 +43,26 @@
         shp_index<filterT>::query(filter,file,ids_);
         file.close();
     }
+
+#ifdef MAPNIK_DEBUG
     std::clog<< "query size=" << ids_.size() << "\n";
+#endif
+
     itr_ = ids_.begin();
 
     // deal with attributes
     std::set<std::string>::const_iterator pos=attribute_names.begin();
     while (pos!=attribute_names.end())
     {
-	for (int i=0;i<shape_.dbf().num_fields();++i)
-	{
-	    if (shape_.dbf().descriptor(i).name_ == *pos)
-	    {
-		attr_ids_.push_back(i);
-		break;
-	    }
-	}
-	++pos;
+        for (int i=0;i<shape_.dbf().num_fields();++i)
+        {
+            if (shape_.dbf().descriptor(i).name_ == *pos)
+            {
+                attr_ids_.push_back(i);
+                break;
+            }
+        }
+        ++pos;
     }
 }
 
@@ -69,119 +73,122 @@
     if (itr_!=ids_.end())
     {
         int pos=*itr_++;
-	shape_.move_to(pos);
+        shape_.move_to(pos);
         int type=shape_.type();
-	feature_ptr feature(feature_factory::create(shape_.id_));
+        feature_ptr feature(feature_factory::create(shape_.id_));
         
         if (type==shape_io::shape_point)
         {
             double x=shape_.shp().read_double();
-	    double y=shape_.shp().read_double();	    
-	    geometry_ptr point(new point_impl(-1));
-	    point->move_to(x,y);
-	    feature->set_geometry(point);
-	    ++count_;
+            double y=shape_.shp().read_double();	    
+            geometry_ptr point(new point_impl(-1));
+            point->move_to(x,y);
+            feature->set_geometry(point);
+            ++count_;
         }
-	else if (type == shape_io::shape_pointm)
-	{
-	    double x=shape_.shp().read_double();
-	    double y=shape_.shp().read_double();
-	    shape_.shp().read_double();// m
-	    geometry_ptr point(new point_impl(-1));
-	    point->move_to(x,y);
-	    feature->set_geometry(point);
-	    ++count_;
-	}
-	else if (type == shape_io::shape_pointz)
-	{
-	    double x=shape_.shp().read_double();
-	    double y=shape_.shp().read_double();
-	    shape_.shp().read_double();// z
-	    shape_.shp().read_double();// m
-	    geometry_ptr point(new point_impl(-1));
-	    point->move_to(x,y);
-	    feature->set_geometry(point);
-	    ++count_;
-	}	
+        else if (type == shape_io::shape_pointm)
+        {
+            double x=shape_.shp().read_double();
+            double y=shape_.shp().read_double();
+            shape_.shp().read_double();// m
+            geometry_ptr point(new point_impl(-1));
+            point->move_to(x,y);
+            feature->set_geometry(point);
+            ++count_;
+        }
+        else if (type == shape_io::shape_pointz)
+        {
+            double x=shape_.shp().read_double();
+            double y=shape_.shp().read_double();
+            shape_.shp().read_double();// z
+            shape_.shp().read_double();// m
+            geometry_ptr point(new point_impl(-1));
+            point->move_to(x,y);
+            feature->set_geometry(point);
+            ++count_;
+        }	
         else
         {
             while(!filter_.pass(shape_.current_extent()) && 
 	    		  itr_!=ids_.end())
-	    {
+            {
                 pos=*itr_++;
                 shape_.move_to(pos);
-	    }
+            }
 	    
             switch (type)
             {
 	        case shape_io::shape_polyline:
-		{
-		    geometry_ptr line = shape_.read_polyline();
-		    feature->set_geometry(line);
-		    ++count_;
-		    break;
-		}
-		case shape_io::shape_polylinem:
-		{
-		    geometry_ptr line = shape_.read_polylinem();
-		    feature->set_geometry(line);
-		    ++count_;
-		    break;
-		}
-		case shape_io::shape_polylinez:
-		{
-		    geometry_ptr line = shape_.read_polylinez();
-		    feature->set_geometry(line);
-		    ++count_;
-		    break;
-		}
+                {
+                    geometry_ptr line = shape_.read_polyline();
+                    feature->set_geometry(line);
+                    ++count_;
+                    break;
+                }
+            case shape_io::shape_polylinem:
+                {
+                    geometry_ptr line = shape_.read_polylinem();
+                    feature->set_geometry(line);
+                    ++count_;
+                    break;
+                }
+            case shape_io::shape_polylinez:
+                {
+                    geometry_ptr line = shape_.read_polylinez();
+                    feature->set_geometry(line);
+                    ++count_;
+                    break;
+                }
 	        case shape_io::shape_polygon:
-		{
+                {
 		 
-		    geometry_ptr poly = shape_.read_polygon();
-		    feature->set_geometry(poly);
-		    ++count_;
-		    break;
-		}
+                    geometry_ptr poly = shape_.read_polygon();
+                    feature->set_geometry(poly);
+                    ++count_;
+                    break;
+                }
 	        case shape_io::shape_polygonm:
-		{ 
-		    geometry_ptr poly = shape_.read_polygonm();
-		    feature->set_geometry(poly);
-		    ++count_;
-		    break;
-		}
+                { 
+                    geometry_ptr poly = shape_.read_polygonm();
+                    feature->set_geometry(poly);
+                    ++count_;
+                    break;
+                }
 	        case shape_io::shape_polygonz:
-		{
-		    geometry_ptr poly = shape_.read_polygonz();
-		    feature->set_geometry(poly);
-		    ++count_;
-		    break;
-		}
+                {
+                    geometry_ptr poly = shape_.read_polygonz();
+                    feature->set_geometry(poly);
+                    ++count_;
+                    break;
+                }
             }
         }
-	if (attr_ids_.size())
-	{
-	    shape_.dbf().move_to(shape_.id_);
-	    std::vector<int>::const_iterator pos=attr_ids_.begin();
-	    while (pos!=attr_ids_.end())
-	    {
-		try 
-		{
-		    shape_.dbf().add_attribute(*pos,*feature);
-		}
-		catch (...)
-		{
-		    std::clog<<"exception caught\n";
-		}
-		++pos;
-	    }
-	}
-	return feature;
+        if (attr_ids_.size())
+        {
+            shape_.dbf().move_to(shape_.id_);
+            std::vector<int>::const_iterator pos=attr_ids_.begin();
+            while (pos!=attr_ids_.end())
+            {
+                try 
+                {
+                    shape_.dbf().add_attribute(*pos,*feature);
+                }
+                catch (...)
+                {
+                    std::clog<<"exception caught\n";
+                }
+                ++pos;
+            }
+        }
+        return feature;
     }
     else
     {
-	std::clog<<count_<<" features\n";
-	return feature_ptr();
+
+#ifdef MAPNIK_DEBUG
+        std::clog<<count_<<" features\n";
+#endif
+        return feature_ptr();
     }
 }
 

Modified: trunk/src/agg_renderer.cpp
===================================================================
--- trunk/src/agg_renderer.cpp	2006-11-18 16:47:29 UTC (rev 375)
+++ trunk/src/agg_renderer.cpp	2006-11-19 17:13:33 UTC (rev 376)
@@ -100,33 +100,43 @@
     {
         Color const& bg=m.getBackground();
         pixmap_.setBackground(bg);
+#ifdef MAPNIK_DEBUG
         std::clog << "scale=" << m.scale() << "\n";
+#endif
     }
     
     template <typename T>
     void agg_renderer<T>::start_map_processing(Map const& map)
     {
+#ifdef MAPNIK_DEBUG
         std::clog << "start map processing bbox=" 
                   << map.getCurrentExtent() << "\n";
+#endif
     }
 
     template <typename T>
     void agg_renderer<T>::end_map_processing(Map const& )
     {
+#ifdef MAPNIK_DEBUG
         std::clog << "end map processing" << std::endl;
+#endif
     }
     
     template <typename T>
     void agg_renderer<T>::start_layer_processing(Layer const& lay)
     {
+#ifdef MAPNIK_DEBUG
         std::clog << "start layer processing : " << lay.name()  << std::endl;
         std::clog << "datasource = " << lay.datasource().get() << std::endl;
+#endif 
     }
     
     template <typename T>
     void agg_renderer<T>::end_layer_processing(Layer const&)
     {
+#ifdef MAPNIK_DEBUG
         std::clog << "end layer processing" << std::endl;
+#endif
     }
     
     template <typename T>	

Modified: trunk/src/datasource_cache.cpp
===================================================================
--- trunk/src/datasource_cache.cpp	2006-11-18 16:47:29 UTC (rev 375)
+++ trunk/src/datasource_cache.cpp	2006-11-19 17:13:33 UTC (rev 376)
@@ -75,15 +75,17 @@
                     std::clog << "Cannot load library: " << "  "<< lt_dlerror() << std::endl;
                 }
             }
+#ifdef MAPNIK_DEBUG
             std::clog<<"datasource="<<ds<<" type="<<type<<std::endl;
+#endif
         }
         catch (datasource_exception& ex)
         {
-            std::clog<<ex.what()<<std::endl;
+            std::clog << ex.what() << "\n";
         }
         catch (...)
         {
-            std::clog<<" exception caught\n";
+            std::clog << " exception caught\n";
         }
         return ds;
     }
@@ -112,14 +114,16 @@
                         datasource_name* ds_name = 
                             (datasource_name*) lt_dlsym(module, "datasource_name");
                         if (ds_name && insert(ds_name(),module))
-                        {                           
+                        {            
+#ifdef MAPNIK_DEBUG
                             std::clog<<"registered datasource : "<<ds_name()<<std::endl;
+#endif 
                             registered_=true;
                         }
                     }
                     else
                     {
-                        std::clog<<lt_dlerror()<<std::endl;
+                        std::clog << lt_dlerror() << "\n";
                     }
                 }
             }   

Modified: trunk/src/load_map.cpp
===================================================================
--- trunk/src/load_map.cpp	2006-11-18 16:47:29 UTC (rev 375)
+++ trunk/src/load_map.cpp	2006-11-19 17:13:33 UTC (rev 376)
@@ -446,7 +446,6 @@
                             {
                                 std::string name = param_tag.second.get<std::string>("<xmlattr>.name");
                                 std::string value = param_tag.second.data();
-                                std::clog << "name = " << name << " value = " << value << "\n";
                                 params[name] = value; 
                             }
                         }

Modified: trunk/src/map.cpp
===================================================================
--- trunk/src/map.cpp	2006-11-18 16:47:29 UTC (rev 375)
+++ trunk/src/map.cpp	2006-11-19 17:13:33 UTC (rev 376)
@@ -222,9 +222,10 @@
                 prj_trans.backward(x1,y1,z1);
                 
                 Envelope<double> layerExt2(x0,y0,x1,y1);
+#ifdef MAPNIK_DEBUG
                 std::clog << " layer1 - > " << layerExt << "\n";
                 std::clog << " layer2 - > " << layerExt2 << "\n";
-                
+#endif                
                 if (first)
                 {
                     ext = layerExt2;

Modified: trunk/src/memory.cpp
===================================================================
--- trunk/src/memory.cpp	2006-11-18 16:47:29 UTC (rev 375)
+++ trunk/src/memory.cpp	2006-11-19 17:13:33 UTC (rev 376)
@@ -46,9 +46,9 @@
         ::operator delete(p);
     }
 
-    void Object::operator delete(void* p, MemoryManager* manager)
+    void Object::operator delete(void* , MemoryManager* )
     {
-        std::clog <<"operator delete with Manager "<<std::hex<<p<<" "<<manager<<std::endl;
+        //std::clog <<"operator delete with Manager "<<std::hex<<p<<" "<<manager<<std::endl;
     }
 
     inline size_t MemoryUtils::alignPointerSize(size_t ptrSize)

Modified: trunk/src/png_reader.cpp
===================================================================
--- trunk/src/png_reader.cpp	2006-11-18 16:47:29 UTC (rev 375)
+++ trunk/src/png_reader.cpp	2006-11-19 17:13:33 UTC (rev 376)
@@ -74,7 +74,7 @@
         } 
         catch (const ImageReaderException& e) 
         {
-            std::clog<<e.what()<<std::endl;
+            std::clog << e.what() << '\n';
             throw;
         }
     }
@@ -134,8 +134,9 @@
 
         width_=width;
         height_=height;
-
+#ifdef MAPNIK_DEBUG
         std::clog<<"bit_depth="<<bit_depth_<<" color_type="<<color_type_<<std::endl;
+#endif
         png_destroy_read_struct(&png_ptr,&info_ptr,0);	
         fclose(fp);
     }

Modified: trunk/src/polygon_pattern_symbolizer.cpp
===================================================================
--- trunk/src/polygon_pattern_symbolizer.cpp	2006-11-18 16:47:29 UTC (rev 375)
+++ trunk/src/polygon_pattern_symbolizer.cpp	2006-11-19 17:13:33 UTC (rev 376)
@@ -41,7 +41,7 @@
         } 
         catch (...) 
         {
-            std::clog<<"exception caught..."<<std::endl;
+            std::clog << "exception caught...\n";
         }
     }
     polygon_pattern_symbolizer::polygon_pattern_symbolizer(polygon_pattern_symbolizer const& rhs)

Modified: trunk/src/shield_symbolizer.cpp
===================================================================
--- trunk/src/shield_symbolizer.cpp	2006-11-18 16:47:29 UTC (rev 375)
+++ trunk/src/shield_symbolizer.cpp	2006-11-19 17:13:33 UTC (rev 376)
@@ -62,7 +62,7 @@
         } 
         catch (...) 
         {
-            std::clog<<"exception caught..." << std::endl;
+            std::clog << "exception caught..." << std::endl;
         }
     }
     

Modified: trunk/utils/shapeindex/shapeindex.cpp
===================================================================
--- trunk/utils/shapeindex/shapeindex.cpp	2006-11-18 16:47:29 UTC (rev 375)
+++ trunk/utils/shapeindex/shapeindex.cpp	2006-11-19 17:13:33 UTC (rev 376)
@@ -71,7 +71,7 @@
 	
         if (vm.count("version"))
         {
-            clog<<"version 0.2.0a" <<endl;
+            clog<<"version 0.3.0" <<endl;
             return 1;
         }
 



From pavlenko at mail.berlios.de  Wed Nov 22 23:01:42 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Wed, 22 Nov 2006 23:01:42 +0100
Subject: [Mapnik-svn] r377 - in trunk: include/mapnik src
Message-ID: <200611222201.kAMM1gB2001717@sheep.berlios.de>

Author: pavlenko
Date: 2006-11-22 23:01:37 +0100 (Wed, 22 Nov 2006)
New Revision: 377

Added:
   trunk/include/mapnik/unicode.hpp
Modified:
   trunk/include/mapnik/font_engine_freetype.hpp
   trunk/src/agg_renderer.cpp
Log:
added basic support for unicode string



Modified: trunk/include/mapnik/font_engine_freetype.hpp
===================================================================
--- trunk/include/mapnik/font_engine_freetype.hpp	2006-11-19 17:13:33 UTC (rev 376)
+++ trunk/include/mapnik/font_engine_freetype.hpp	2006-11-22 22:01:37 UTC (rev 377)
@@ -153,56 +153,6 @@
         faces faces_;
     };
         
-    inline std::wstring to_unicode(std::string const& text)
-    {
-        std::wstring out;
-        unsigned long code = 0;
-        int expect = 0;
-        std::string::const_iterator itr=text.begin();
-	
-        while ( itr != text.end())
-        {
-            unsigned p = (*itr++) & 0xff;
-            if ( p >= 0xc0)
-            {
-                if ( p < 0xe0)      // U+0080 - U+07ff
-                {
-                    expect = 1;
-                    code = p & 0x1f;
-                }
-                else if ( p < 0xf0)  // U+0800 - U+ffff
-                {
-                    expect = 2;
-                    code = p & 0x0f;
-                }
-                else if ( p  < 0xf8) // U+1000 - U+10ffff
-                {
-                    expect = 3;
-                    code = p & 0x07;
-                }
-                continue;
-            }
-            else if (p >= 0x80)
-            {
-                --expect;
-                if (expect >= 0)
-                {
-                    code <<= 6;
-                    code += p & 0x3f;
-                }
-                if (expect > 0)
-                    continue;
-                expect = 0;
-            }
-            else 
-            {
-                code = p;            // U+0000 - U+007f (ascii)
-            }
-            out.push_back(wchar_t(code));
-        }
-        return out;
-    }
-    
     template <typename T>
     struct text_renderer : private boost::noncopyable
     {
@@ -282,7 +232,7 @@
 		
                 FT_Set_Transform (face,&matrix,&pen);
 		
-                FT_UInt glyph_index = FT_Get_Char_Index( face, unsigned(c) & 0xff );
+                FT_UInt glyph_index = FT_Get_Char_Index( face, unsigned(c));
 		
                 error = FT_Load_Glyph (face,glyph_index, FT_LOAD_NO_HINTING); 
                 if ( error )
@@ -339,7 +289,7 @@
                     
             FT_Set_Transform (face,&matrix,&pen);
             
-            FT_UInt glyph_index = FT_Get_Char_Index( face, c & 0xff );
+            FT_UInt glyph_index = FT_Get_Char_Index( face, c);
             
             error = FT_Load_Glyph (face,glyph_index,FT_LOAD_NO_HINTING); 
             if ( error )
@@ -354,12 +304,12 @@
             return dimension_t(slot->advance.x >> 6, glyph_bbox.yMax - glyph_bbox.yMin);
         }
         
-        void get_string_info(std::string const& text, string_info *info)
+        void get_string_info(std::wstring const& text, string_info *info)
         {
             unsigned width = 0;
             unsigned height = 0;
           
-            for (std::string::const_iterator i=text.begin();i!=text.end();++i)
+            for (std::wstring::const_iterator i=text.begin();i!=text.end();++i)
             {
                 dimension_t char_dim = character_dimensions(*i);
               

Added: trunk/include/mapnik/unicode.hpp
===================================================================
--- trunk/include/mapnik/unicode.hpp	2006-11-19 17:13:33 UTC (rev 376)
+++ trunk/include/mapnik/unicode.hpp	2006-11-22 22:01:37 UTC (rev 377)
@@ -0,0 +1,82 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+#ifndef UNICODE_HPP
+#define UNICODE_HPP
+
+#include <string>
+
+namespace mapnik {
+    
+    inline std::wstring to_unicode(std::string const& text)
+    {
+        std::wstring out;
+        unsigned long code = 0;
+        int expect = 0;
+        std::string::const_iterator itr=text.begin();
+        
+        while ( itr != text.end())
+        {
+            unsigned p = (*itr++) & 0xff;
+            if ( p >= 0xc0)
+            {
+                if ( p < 0xe0)      // U+0080 - U+07ff
+                {
+                    expect = 1;
+                    code = p & 0x1f;
+                }
+                else if ( p < 0xf0)  // U+0800 - U+ffff
+                {
+                    expect = 2;
+                    code = p & 0x0f;
+                }
+                else if ( p  < 0xf8) // U+1000 - U+10ffff
+                {
+                    expect = 3;
+                    code = p & 0x07;
+                }
+                continue;
+            }
+            else if (p >= 0x80)
+            {
+                --expect;
+                if (expect >= 0)
+                {
+                    code <<= 6;
+                    code += p & 0x3f;
+                }
+                if (expect > 0)
+                    continue;
+                expect = 0;
+            }
+            else 
+            {
+                code = p;            // U+0000 - U+007f (ascii)
+            }
+            out.push_back(wchar_t(code));
+        }
+        return out;
+    }
+}
+
+#endif // UNICODE_HPP

Modified: trunk/src/agg_renderer.cpp
===================================================================
--- trunk/src/agg_renderer.cpp	2006-11-19 17:13:33 UTC (rev 376)
+++ trunk/src/agg_renderer.cpp	2006-11-22 22:01:37 UTC (rev 377)
@@ -59,7 +59,7 @@
 // mapnik
 #include <mapnik/image_util.hpp>
 #include <mapnik/agg_renderer.hpp>
-
+#include <mapnik/unicode.hpp>
 #include <mapnik/placement_finder.hpp>
 
 namespace mapnik 
@@ -336,7 +336,7 @@
         geometry_ptr const& geom=feature.get_geometry();
         if (geom)
         {
-            std::string text = feature[sym.get_name()].to_string();
+            std::wstring text = to_unicode(feature[sym.get_name()].to_string());
             boost::trim(text);
             boost::shared_ptr<ImageData32> const& data = sym.get_data();
             
@@ -354,7 +354,7 @@
 
                     string_info info;
                     ren.get_string_info(text, &info);
-                 
+                    
                     placement text_placement(&info, &t_, &prj_trans, geom, std::pair<double, double>(w, h) );
                     text_placement.avoid_edges = sym.get_avoid_edges();
                   
@@ -497,7 +497,7 @@
        
         if (geom)
         {
-            std::string text = feature[sym.get_name()].to_string();
+            std::wstring text = to_unicode(feature[sym.get_name()].to_string());
             boost::trim(text);
             if (text.length() > 0)
             {



From vspader10east at mail.berlios.de  Wed Nov 22 23:09:11 2006
From: vspader10east at mail.berlios.de (vspader10east at BerliOS)
Date: Wed, 22 Nov 2006 23:09:11 +0100
Subject: [Mapnik-svn] r378 - trunk/src
Message-ID: <200611222209.kAMM9B8M002576@sheep.berlios.de>

Author: vspader10east
Date: 2006-11-22 23:09:11 +0100 (Wed, 22 Nov 2006)
New Revision: 378

Modified:
   trunk/src/placement_finder.cpp
Log:
Fixed up text placement.
Removed the patch for better cornering from r365,
since it wasn't working properly.


Modified: trunk/src/placement_finder.cpp
===================================================================
--- trunk/src/placement_finder.cpp	2006-11-22 22:01:37 UTC (rev 377)
+++ trunk/src/placement_finder.cpp	2006-11-22 22:09:11 UTC (rev 378)
@@ -184,27 +184,27 @@
 
         double ideal_spacing = distance/num_labels;
         std::vector<double> ideal_label_distances;
-        for (double label_pos = ideal_spacing/2; label_pos < distance; label_pos += ideal_spacing)
+        for (double label_pos = string_width/2.0; label_pos < distance - string_width/2.0; label_pos += ideal_spacing)
             ideal_label_distances.push_back(label_pos);
 
-        double delta = distance/100.0;
+        double delta = ideal_spacing/100.0;
         bool FoundPlacement = false;
         for (std::vector<double>::const_iterator itr = ideal_label_distances.begin(); itr < ideal_label_distances.end(); ++itr)
         {
             //std::clog << "Trying to find txt placement at distance: " << *itr << std::endl;
-            for (double i = 0; i < ideal_spacing; i += delta)
+            for (double i = 0; i < ideal_spacing/2.0; i += delta)
             {
                 p->clear_envelopes();
         
                 // check position +- delta for valid placement
-                if ( build_path_follow(p, *itr - string_width/2 + i)) {
+                if ( build_path_follow(p, *itr + i) ) {
                     update_detector(p);
                     FoundPlacement = true;
                     break;
                 }
 
                 p->clear_envelopes();
-                if (build_path_follow(p, *itr - string_width/2 - i) ) {
+                if ( build_path_follow(p, *itr - i) ) {
                     update_detector(p);
                     FoundPlacement = true;
                     break;
@@ -323,7 +323,7 @@
                 break;
             }
         }
-    
+        
         // now find the placement of each character starting from our initial segment
         // determined above
         double last_angle = angle; 
@@ -346,21 +346,21 @@
                 while (distance <= ci.width) 
                 {
                     double dx, dy;
-    
+                    
                     cur_node++;
-                
+                    
                     if (cur_node >= p->geom->num_points()) {
-                        break;
+                        return false;
                     }
                     
                     old_x = new_x;
                     old_y = new_y;
-
+                    
                     p->shape_path.vertex(&new_x,&new_y);
-    
+                    
                     dx = new_x - old_x;
                     dy = new_y - old_y;
-    
+                    
                     angle = atan2(-dy, dx );
                     distance += sqrt(dx*dx+dy*dy);
                 }
@@ -372,12 +372,13 @@
                     angle_delta -= M_PI;
                 while (angle_delta < -M_PI)
                     angle_delta += M_PI;
-                if (p->max_char_angle_delta > 0 && fabs(angle_delta) > p->max_char_angle_delta)
+                if (p->max_char_angle_delta > 0 && fabs(angle_delta) > p->max_char_angle_delta*(M_PI/180))
+                {
                     return false;
-
+                }
             }
-
-
+            
+            
             Envelope<double> e;
             if (p->has_dimensions)
             {
@@ -387,81 +388,15 @@
 
             double render_angle = angle;
 
-            if (fabs(angle_delta) > 0.05 && i > 0)
-            {
-                // paramatise the new line segment
-                double last_dist_from_line = string_height;
-                double line_origin_x = sqrt(pow(old_x-x,2)+pow(old_y-y,2));
-                double line_origin_y = 0;
-                double closest_lp_x = cos(fabs(angle_delta));
-                double closest_lp_y = sin(fabs(angle_delta));
+            x = new_x - (distance)*cos(angle);
+            y = new_y + (distance)*sin(angle);
+            //Center the text on the line.
+            x -= (((double)string_height/2.0) - 1.0)*cos(render_angle+M_PI/2);
+            y += (((double)string_height/2.0) - 1.0)*sin(render_angle+M_PI/2);
+            distance -= ci.width;
+            next_char_x = ci.width*cos(render_angle);
+            next_char_y = ci.width*sin(render_angle);
 
-                // iterate over placement points to find the angle to actually render the letter at
-                for (double pax = 0; pax < string_height/2 && pax < line_origin_x; pax += 0.1)
-                {
-                    // calculate dependant parameters
-                    double letter_angle = asin(pax/(string_height/2));
-                    double pbx = pax+ci.width*cos(letter_angle);
-                    double pby = ci.width*sin(letter_angle);
-
-                    // find closest point on the new segment
-                    double closest_param = ((pbx - line_origin_x)*closest_lp_x + (pby - line_origin_y)*closest_lp_y)/(closest_lp_x*closest_lp_x + closest_lp_y*closest_lp_y);
-                    double closest_point_x = line_origin_x + closest_param*closest_lp_x;
-                    double closest_point_y = line_origin_y + closest_param*closest_lp_y;
-
-                    // calculate the error between this and the letter
-                    double dist_from_line = sqrt(pow(pbx - closest_point_x,2) + pow(pby - closest_point_y,2));
-
-                    // if  our error is getting worse then stop
-                    if (dist_from_line > last_dist_from_line)
-                    {
-                        double pcx, pcy;
-                        double extra_space = (ci.height/2)*sin(fabs(angle_delta)-letter_angle);
-                        double extra_space_x = extra_space * cos(fabs(angle_delta));
-                        double extra_space_y = extra_space * sin(fabs(angle_delta));
-                        // remove extra distance used in corner
-                        distance -= line_origin_x + closest_param + extra_space;
-
-                        // transform local calculation space to a global position for placement
-                        if (angle_delta < 0)
-                        {
-                            // left turn
-                            render_angle = letter_angle + last_angle;
-                            pcx = 2*pax;
-                            pcy = 0;//-(ci.height/2)*cos(letter_angle);
-                        }
-                        else
-                        {   // right turn
-                            render_angle = -letter_angle + last_angle;
-                            pcx = 0;
-                            pcy = 0;//-(ci.height/2)*cos(letter_angle);
-                        }
-                        double rdx = pcx * cos(-last_angle) - pcy*sin(-last_angle);
-                        double rdy = pcy*cos(-last_angle) + pcx * sin(-last_angle);
-                        x += rdx;
-                        y += rdy;
-                        next_char_x = (ci.width+extra_space_x)*cos(render_angle) - extra_space_y*sin(render_angle);
-                        next_char_y = (ci.width+extra_space_x)*sin(render_angle) + extra_space_y*cos(render_angle);
-
-                        //distance -= 5;
-                        break;
-
-                    }
-                    last_dist_from_line = dist_from_line;
-                }
-            }
-            else
-            {
-                x = new_x - (distance)*cos(angle);
-                y = new_y + (distance)*sin(angle);
-                //Center the text on the line.
-                x -= (((double)string_height/2.0) - 1.0)*cos(render_angle+M_PI/2);
-                y += (((double)string_height/2.0) - 1.0)*sin(render_angle+M_PI/2);
-                distance -= ci.width;
-                next_char_x = ci.width*cos(render_angle);
-                next_char_y = ci.width*sin(render_angle);
-            }
-
             double render_x = x;
             double render_y = y;
 



From pavlenko at mail.berlios.de  Sat Nov 25 12:03:11 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Sat, 25 Nov 2006 12:03:11 +0100
Subject: [Mapnik-svn] r379 - in trunk: bindings/python include/mapnik
	plugins/input/postgis plugins/input/raster plugins/input/shape src
Message-ID: <200611251103.kAPB3BKK020734@sheep.berlios.de>

Author: pavlenko
Date: 2006-11-25 12:02:59 +0100 (Sat, 25 Nov 2006)
New Revision: 379

Added:
   trunk/bindings/python/mapnik_image_view.cpp
   trunk/include/mapnik/image_view.hpp
Modified:
   trunk/bindings/python/mapnik_datasource.cpp
   trunk/bindings/python/mapnik_image.cpp
   trunk/bindings/python/mapnik_map.cpp
   trunk/bindings/python/mapnik_python.cpp
   trunk/include/mapnik/datasource.hpp
   trunk/include/mapnik/geom_util.hpp
   trunk/include/mapnik/geometry.hpp
   trunk/include/mapnik/graphics.hpp
   trunk/include/mapnik/image_data.hpp
   trunk/include/mapnik/image_util.hpp
   trunk/include/mapnik/layer.hpp
   trunk/include/mapnik/map.hpp
   trunk/plugins/input/postgis/postgis.cpp
   trunk/plugins/input/postgis/postgis.hpp
   trunk/plugins/input/raster/raster_datasource.cpp
   trunk/plugins/input/raster/raster_datasource.hpp
   trunk/plugins/input/shape/shape.cpp
   trunk/plugins/input/shape/shape.hpp
   trunk/plugins/input/shape/shape_featureset.cpp
   trunk/plugins/input/shape/shape_index_featureset.cpp
   trunk/src/agg_renderer.cpp
   trunk/src/datasource_cache.cpp
   trunk/src/graphics.cpp
   trunk/src/image_util.cpp
   trunk/src/layer.cpp
   trunk/src/map.cpp
Log:
1. hit_test implementation for geometry objects:
        
    bool hit_test(double x, double y, double tol);
       
2. added image_view(unsigned x, unsigned y, unsigned width, unsigned height)
   allowing to select region from image data e.g (in Python):

    im = Image(2048,2048)
    view = im.view(0,0,256,256)
    save_to_file(filename,type, view)
    
3. changed envelope method to return vy value in datasource classes

4. features_at_point impl for shape and postgis plug-ins

  


Modified: trunk/bindings/python/mapnik_datasource.cpp
===================================================================
--- trunk/bindings/python/mapnik_datasource.cpp	2006-11-22 22:09:11 UTC (rev 378)
+++ trunk/bindings/python/mapnik_datasource.cpp	2006-11-25 11:02:59 UTC (rev 379)
@@ -75,8 +75,8 @@
     
     class_<datasource,boost::shared_ptr<datasource>,
         boost::noncopyable>("Datasource",no_init)
-        .def("envelope",&datasource::envelope,
-             return_value_policy<copy_const_reference>())
+        .def("envelope",&datasource::envelope)
+        .def("descriptor",&datasource::get_descriptor) //todo
         .def("features",&datasource::features)
         .def("params",&datasource::params,return_value_policy<copy_const_reference>(), 
              "The configuration parameters of the data source. "  

Modified: trunk/bindings/python/mapnik_image.cpp
===================================================================
--- trunk/bindings/python/mapnik_image.cpp	2006-11-22 22:09:11 UTC (rev 378)
+++ trunk/bindings/python/mapnik_image.cpp	2006-11-25 11:02:59 UTC (rev 379)
@@ -39,8 +39,9 @@
 {
     using namespace boost::python;
     class_<Image32>("Image","This class represents a 32 bit image.",init<int,int>())
-	.def("width",&Image32::width)
-	.def("height",&Image32::height)
+        .def("width",&Image32::width)
+        .def("height",&Image32::height)
+        .def("view",&Image32::get_view)
         .add_property("background",make_function
                       (&Image32::getBackground,return_value_policy<copy_const_reference>()),
                        &Image32::setBackground, "The background color of the image.")

Added: trunk/bindings/python/mapnik_image_view.cpp
===================================================================
--- trunk/bindings/python/mapnik_image_view.cpp	2006-11-22 22:09:11 UTC (rev 378)
+++ trunk/bindings/python/mapnik_image_view.cpp	2006-11-25 11:02:59 UTC (rev 379)
@@ -0,0 +1,45 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko, Jean-Francois Doyon
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id$
+
+#include <boost/python.hpp>
+
+//#include <boost/python/module.hpp>
+//#include <boost/python/def.hpp>
+//#include <mapnik/graphics.hpp>
+#include <mapnik/image_util.hpp>
+#include <mapnik/image_view.hpp>
+
+using mapnik::ImageData32;
+using mapnik::image_view;
+using mapnik::save_to_file;
+
+void export_image_view()
+{
+    using namespace boost::python;
+    class_<image_view<ImageData32> >("ImageView","A view into an image.",no_init)
+        .def("width",&image_view<ImageData32>::width)
+        .def("height",&image_view<ImageData32>::height)
+        ;
+    
+    def("save_to_file",save_to_file<image_view<ImageData32> >);
+}

Modified: trunk/bindings/python/mapnik_map.cpp
===================================================================
--- trunk/bindings/python/mapnik_map.cpp	2006-11-22 22:09:11 UTC (rev 378)
+++ trunk/bindings/python/mapnik_map.cpp	2006-11-25 11:02:59 UTC (rev 379)
@@ -78,6 +78,9 @@
     }
 };
 
+std::vector<Layer>& (Map::*layers_nonconst)() =  &Map::layers;
+std::vector<Layer> const& (Map::*layers_const)() const =  &Map::layers;
+
 void export_map() 
 {
     using namespace boost::python;
@@ -108,7 +111,7 @@
         .def("append_style",&Map::insert_style)
         .def("remove_style",&Map::remove_style)
         .add_property("layers",make_function
-                      (&Map::layers,return_value_policy<reference_existing_object>()), 
+                      (layers_nonconst,return_value_policy<reference_existing_object>()), 
                       "Get the list of layers in this map.")
         .def("find_style",&Map::find_style,return_value_policy<copy_const_reference>())
         .def_pickle(map_pickle_suite())

Modified: trunk/bindings/python/mapnik_python.cpp
===================================================================
--- trunk/bindings/python/mapnik_python.cpp	2006-11-22 22:09:11 UTC (rev 378)
+++ trunk/bindings/python/mapnik_python.cpp	2006-11-25 11:02:59 UTC (rev 379)
@@ -32,6 +32,7 @@
 void export_envelope();
 void export_query();
 void export_image();
+void export_image_view();
 void export_map();
 void export_python();
 void export_filter();
@@ -96,6 +97,7 @@
     export_color(); 
     export_envelope();   
     export_image();
+    export_image_view();
     export_filter();
     export_rule();
     export_style();    

Modified: trunk/include/mapnik/datasource.hpp
===================================================================
--- trunk/include/mapnik/datasource.hpp	2006-11-22 22:09:11 UTC (rev 378)
+++ trunk/include/mapnik/datasource.hpp	2006-11-25 11:02:59 UTC (rev 379)
@@ -46,9 +46,9 @@
         virtual feature_ptr next()=0;
         virtual ~Featureset() {};
     };
-
-    typedef boost::shared_ptr<Featureset> featureset_ptr;
     
+    typedef MAPNIK_DECL boost::shared_ptr<Featureset> featureset_ptr;
+    
     class MAPNIK_DECL datasource_exception : public std::exception
     {
     private:
@@ -84,8 +84,8 @@
         virtual int type() const=0;
         virtual featureset_ptr features(const query& q) const=0;
         virtual featureset_ptr features_at_point(coord2d const& pt) const=0;
-        virtual Envelope<double> const& envelope() const=0;
-        virtual layer_descriptor const& get_descriptor() const=0;
+        virtual Envelope<double> envelope() const=0;
+        virtual layer_descriptor get_descriptor() const=0;
         virtual ~datasource() {};
     };
     
@@ -103,7 +103,7 @@
         }
     };
 
-    typedef boost::shared_ptr<datasource> datasource_p;
+    typedef boost::shared_ptr<datasource> datasource_ptr;
     
     
     #define DATASOURCE_PLUGIN(classname)                              \

Modified: trunk/include/mapnik/geom_util.hpp
===================================================================
--- trunk/include/mapnik/geom_util.hpp	2006-11-22 22:09:11 UTC (rev 378)
+++ trunk/include/mapnik/geom_util.hpp	2006-11-25 11:02:59 UTC (rev 379)
@@ -34,7 +34,6 @@
 
 namespace mapnik
 {
-
     template <typename T>
     bool clip_test(T p,T q,double& tmin,double& tmax)
     {
@@ -117,14 +116,6 @@
     	return inside;
     }
 
-#define TOL 0.00001
-
-    /*
-      (Ay-Cy)(Bx-Ax)-(Ax-Cx)(By-Ay)
-      s = -----------------------------
-      L^2
-    */
-
     inline bool point_in_circle(double x,double y,double cx,double cy,double r)
     {
         double dx = x - cx;
@@ -133,40 +124,75 @@
         return (d2 <= r * r);
     }
     
-    inline bool point_on_segment(double x,double y,double x0,double y0,double x1,double y1)
-    {	
+    template <typename T>
+    inline T sqr(T x)
+    {
+        return x * x;
+    }
+
+    inline double distance2(double x0,double y0,double x1,double y1)
+    {
         double dx = x1 - x0;
         double dy = y1 - y0;
-        if ( fabs(dx) > TOL  ||  fabs(dy) > TOL )
-        {
-            double s = (y0 - y) * dx - (x0 - x) * dy;
-            return ( fabs (s) < TOL ) ;
-        } 
-        return false;
+        return sqr(dx) + sqr(dy);
     }
-
-    inline bool point_on_segment2(double x,double y,double x0,double y0,double x1,double y1)
-    {	 
-        double d  = sqrt ((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0));
-        double d0 = sqrt ((x0 - x) * (x0 - x) + (y0 - y) * (y0 - y));
-        double d1 = sqrt ((x1 - x) * (x1 - x) + (y1 - y) * (y1 - y));
-        double d2 = d0 + d1;
-        return ( d2 - d < 0.01);
+    
+    inline double distance(double x0,double y0, double x1,double y1)
+    {
+        return sqrt(distance2(x0,y0,x1,y1));
     }
     
-#undef TOL
-    template <typename Iter> 
-    inline bool point_on_path(double x,double y,Iter start,Iter end)
+    inline double point_to_segment_distance(double x, double y, 
+                                            double ax, double ay, 
+                                            double bx, double by)
     {
-        return false;
+        double len2 = distance2(ax,ay,bx,by);
+        
+        if (len2 < 1e-7) 
+        {
+            return distance(x,y,ax,ay);
+        }
+        
+        double r = ((x - ax)*(bx - ax) + (y - ay)*(by -ay))/len2;
+        if ( r < 0 )
+        {
+            return distance(x,y,ax,ay);
+        }
+        else if (r > 1)
+        {
+            return distance(x,y,bx,by);
+        }
+        double s = ((ay - y)*(bx - ax) - (ax - x)*(by - ay))/len2;
+        return fabs(s) * sqrt(len2);
     }
-    
+        
     template <typename Iter> 
-    inline bool point_on_points (double x,double y,Iter start,Iter end) 
+    inline bool point_on_path(double x,double y,Iter start,Iter end, double tol)
     {
-        return false; 
+        double x0=boost::get<0>(*start);
+        double y0=boost::get<1>(*start);
+        double x1,y1;
+        while (++start!=end) 
+        {
+            if ( boost::get<2>(*start) == SEG_MOVETO)
+            {
+                x0 = boost::get<0>(*start);
+                y0 = boost::get<1>(*start);
+                continue;
+            }		
+            x1=boost::get<0>(*start);
+            y1=boost::get<1>(*start);
+            
+            double distance = point_to_segment_distance(x,y,x0,y0,x1,y1);
+            if (distance < tol)
+                return true;
+            x0=x1;
+            y0=y1;
+        }
+    	return false;
     }
-
+    
+    // filters
     struct filter_in_box
     {
         Envelope<double> box_;
@@ -191,4 +217,4 @@
     };
 }
 
-#endif                                            //GEOM_UTIL_HPP
+#endif //GEOM_UTIL_HPP

Modified: trunk/include/mapnik/geometry.hpp
===================================================================
--- trunk/include/mapnik/geometry.hpp	2006-11-22 22:09:11 UTC (rev 378)
+++ trunk/include/mapnik/geometry.hpp	2006-11-25 11:02:59 UTC (rev 379)
@@ -76,9 +76,9 @@
             }
             return result;
         }
-
+        
         virtual int type() const=0;
-        virtual bool hit_test(value_type x,value_type y) const=0;	
+        virtual bool hit_test(value_type x,value_type y, double tol) const=0;	
         virtual void label_position(double *x, double *y) const=0;
         virtual void move_to(value_type x,value_type y)=0;
         virtual void line_to(value_type x,value_type y)=0;
@@ -134,10 +134,11 @@
 	
         void rewind(unsigned ) {}
 	
-        bool hit_test(value_type x,value_type y) const
+        bool hit_test(value_type x,value_type y, double tol) const
         {
-            return false;
+            return point_in_circle(pt_.x,pt_.y, x,y,tol);
         }
+        
         void set_capacity(size_t) {}
         virtual ~point() {}
     };
@@ -227,7 +228,7 @@
             itr_=0;
         }
 	
-        bool hit_test(value_type x,value_type y) const
+        bool hit_test(value_type x,value_type y, double) const
         {	    
             return point_inside_path(x,y,cont_.begin(),cont_.end());
         } 
@@ -239,7 +240,7 @@
         virtual ~polygon() {}
     };
     
-    template <typename T, template <typename> class Container=vertex_vector>
+    template <typename T, template <typename> class Container=vertex_vector2>
     class line_string : public geometry<T>
     {
         typedef geometry<T> geometry_base;
@@ -337,9 +338,9 @@
             itr_=0;
         }
 	
-        bool hit_test(value_type x,value_type y) const
+        bool hit_test(value_type x,value_type y, double tol) const
         {	    
-            return false;
+            return point_on_path(x,y,cont_.begin(),cont_.end(),tol);
         } 
 	
         void set_capacity(size_t size) 

Modified: trunk/include/mapnik/graphics.hpp
===================================================================
--- trunk/include/mapnik/graphics.hpp	2006-11-22 22:09:11 UTC (rev 378)
+++ trunk/include/mapnik/graphics.hpp	2006-11-25 11:02:59 UTC (rev 379)
@@ -33,6 +33,7 @@
 #include <mapnik/gamma.hpp>
 #include <mapnik/image_data.hpp>
 #include <mapnik/envelope.hpp>
+#include <mapnik/image_view.hpp>
 
 namespace mapnik
 {
@@ -45,9 +46,9 @@
         ImageData32 data_;
     public:
         Image32(int width,int height);
-        Image32(const Image32& rhs);
+        Image32(Image32 const& rhs);
         ~Image32();
-        void setBackground(const Color& background);
+        void setBackground(Color const& background);
         const Color& getBackground() const;     
         const ImageData32& data() const;
         
@@ -65,10 +66,16 @@
         {
             return data_.getBytes();
         }
-	
+        
+        inline image_view<ImageData32> get_view(unsigned x,unsigned y, unsigned w,unsigned h)
+        {
+            return image_view<ImageData32>(x,y,w,h,data_);
+        }
+        
         void saveToFile(const std::string& file,const std::string& format="auto"); 
+
     private:
-
+        
         inline bool checkBounds(unsigned x, unsigned y) const
         {
             return (x < width_ && y < height_);

Modified: trunk/include/mapnik/image_data.hpp
===================================================================
--- trunk/include/mapnik/image_data.hpp	2006-11-22 22:09:11 UTC (rev 378)
+++ trunk/include/mapnik/image_data.hpp	2006-11-25 11:02:59 UTC (rev 379)
@@ -31,12 +31,9 @@
 {
     template <class T> class ImageData
     {
-    private:
-        const unsigned width_;
-        const unsigned height_;
-        T *pData_;
-        ImageData& operator=(const ImageData&);
     public:
+        typedef T pixel_type;
+        
         ImageData(unsigned width,unsigned height)
             : width_(width),
               height_(height),
@@ -119,6 +116,12 @@
         {
             ::operator delete(pData_),pData_=0;
         }
+        
+    private:
+        const unsigned width_;
+        const unsigned height_;
+        T *pData_;
+        ImageData& operator=(const ImageData&);
 	
     };
 

Modified: trunk/include/mapnik/image_util.hpp
===================================================================
--- trunk/include/mapnik/image_util.hpp	2006-11-22 22:09:11 UTC (rev 378)
+++ trunk/include/mapnik/image_util.hpp	2006-11-25 11:02:59 UTC (rev 379)
@@ -31,23 +31,23 @@
 #include <mapnik/config.hpp>
 #include <mapnik/graphics.hpp>
 
-namespace mapnik
-{
-    class MAPNIK_DECL ImageUtils
-    {
-    public:
-        static void save_to_file(const std::string& filename,
-                                 const std::string& type,
-                                 const Image32& image);
-    private:
-        static void save_as_png(const std::string& filename,
-                                const Image32& image);
-        static void save_as_jpeg(const std::string& filename,
-                                 int quality, 
-                                 const Image32& image);
-    };
+namespace mapnik {
     
     template <typename T>
+    void save_to_file(std::string const& filename,
+                      std::string const& type,
+                      T const& image);
+    
+    template <typename T>
+    void save_as_png(std::string const& filename,
+                     Image32 const& image);
+    template <typename T>
+    void save_as_jpeg(std::string const& filename,
+                      int quality, 
+                      T const& image);
+    
+    
+    template <typename T>
     double distance(T x0,T y0,T x1,T y1)
     {
         double dx = x1-x0;

Added: trunk/include/mapnik/image_view.hpp
===================================================================
--- trunk/include/mapnik/image_view.hpp	2006-11-22 22:09:11 UTC (rev 378)
+++ trunk/include/mapnik/image_view.hpp	2006-11-25 11:02:59 UTC (rev 379)
@@ -0,0 +1,102 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef IMAGE_VIEW_HPP
+#define IMAGE_VIEW_HPP
+
+
+namespace mapnik {
+    
+    template <typename T> 
+    class image_view  
+    {
+        typedef typename T::pixel_type pixel_type;
+    public:
+        image_view(unsigned x, unsigned y, unsigned width, unsigned height, T const& data)
+            : x_(x),
+              y_(y),
+              width_(width),
+              height_(height),
+              data_(data) 
+        {
+            if (x_ >= data_.width()) x_=data_.width()-1;
+            if (y_ >= data_.height()) x_=data_.height()-1;
+            if (x_ + width_ > data_.width()) width_= data_.width() - x_;
+            if (y_ + height_ > data_.height()) height_= data_.height() - y_;
+        }
+        
+        ~image_view() {}
+        
+        image_view(image_view<T> const& rhs)
+            : x_(rhs.x_),
+              y_(rhs.y_),
+              width_(rhs.width_),
+              height_(rhs.height_),
+              data_(rhs.data_) {}
+        
+        image_view<T> & operator=(image_view<T> const& rhs)
+        {
+            if (&rhs==this) return *this;
+            x_ = rhs.x_;
+            y_ = rhs.y_;
+            width_ = rhs.width_;
+            height_ = rhs.height_;
+            data_ = rhs.data_;
+        }
+        
+        inline unsigned x() const
+        {
+            return x_;
+        }
+
+        inline unsigned y() const
+        {
+            return y_;
+        }
+        
+        inline unsigned width() const
+        {
+            return width_;
+        }
+        inline unsigned height() const
+        {
+            return height_;
+        }
+        
+        inline const pixel_type* getRow(unsigned row) const
+        {
+            return data_.getRow(row + y_) + x_;
+        }
+        
+    private:
+        unsigned x_;
+        unsigned y_;
+        unsigned width_;
+        unsigned height_;
+        T const& data_;
+    };
+}
+
+#endif // IMAGE_VIEW_HPP
+

Modified: trunk/include/mapnik/layer.hpp
===================================================================
--- trunk/include/mapnik/layer.hpp	2006-11-22 22:09:11 UTC (rev 378)
+++ trunk/include/mapnik/layer.hpp	2006-11-25 11:02:59 UTC (rev 379)
@@ -46,7 +46,7 @@
         bool selectable_;
         std::vector<std::string>  styles_;
         std::string selection_style_;
-        datasource_p ds_;
+        datasource_ptr ds_;
         
         mutable std::vector<boost::shared_ptr<Feature> > selection_;
         
@@ -79,8 +79,8 @@
         void add_to_selection(boost::shared_ptr<Feature>& feature) const;
         std::vector<boost::shared_ptr<Feature> >& selection() const;
         void clear_selection() const;
-        void set_datasource(datasource_p const& ds);
-        datasource_p datasource() const;
+        void set_datasource(datasource_ptr const& ds);
+        datasource_ptr datasource() const;
         Envelope<double> envelope() const;
         ~Layer();
     private:

Modified: trunk/include/mapnik/map.hpp
===================================================================
--- trunk/include/mapnik/map.hpp	2006-11-22 22:09:11 UTC (rev 378)
+++ trunk/include/mapnik/map.hpp	2006-11-25 11:02:59 UTC (rev 379)
@@ -60,6 +60,7 @@
         Layer& getLayer(size_t index);
         void removeLayer(size_t index);
         std::vector<Layer> const& layers() const;
+        std::vector<Layer> & layers();
         void remove_all();        
         unsigned getWidth() const;
         unsigned getHeight() const;
@@ -77,6 +78,7 @@
         void pan_and_zoom(int x,int y,double zoom);
         const Envelope<double>& getCurrentExtent() const;
         double scale() const;
+        CoordTransform view_transform() const;
         ~Map();
     private:
         void fixAspectRatio();

Modified: trunk/plugins/input/postgis/postgis.cpp
===================================================================
--- trunk/plugins/input/postgis/postgis.cpp	2006-11-22 22:09:11 UTC (rev 378)
+++ trunk/plugins/input/postgis/postgis.cpp	2006-11-25 11:02:59 UTC (rev 379)
@@ -171,7 +171,7 @@
     return type_;
 }
 
-layer_descriptor const& postgis_datasource::get_descriptor() const
+layer_descriptor postgis_datasource::get_descriptor() const
 {
     return desc_;
 }
@@ -231,7 +231,7 @@
     return featureset_ptr();
 }
 
-const Envelope<double>& postgis_datasource::envelope() const
+Envelope<double> postgis_datasource::envelope() const
 {
     return extent_;
 }

Modified: trunk/plugins/input/postgis/postgis.hpp
===================================================================
--- trunk/plugins/input/postgis/postgis.hpp	2006-11-22 22:09:11 UTC (rev 378)
+++ trunk/plugins/input/postgis/postgis.hpp	2006-11-25 11:02:59 UTC (rev 379)
@@ -57,8 +57,8 @@
     int type() const;
     featureset_ptr features(const query& q) const;
     featureset_ptr features_at_point(coord2d const& pt) const;
-    mapnik::Envelope<double> const& envelope() const;
-    layer_descriptor const& get_descriptor() const;
+    mapnik::Envelope<double> envelope() const;
+    layer_descriptor get_descriptor() const;
     postgis_datasource(const parameters &params);
     ~postgis_datasource();
 private:

Modified: trunk/plugins/input/raster/raster_datasource.cpp
===================================================================
--- trunk/plugins/input/raster/raster_datasource.cpp	2006-11-22 22:09:11 UTC (rev 378)
+++ trunk/plugins/input/raster/raster_datasource.cpp	2006-11-25 11:02:59 UTC (rev 379)
@@ -74,12 +74,12 @@
     return name_;
 }
 
-const mapnik::Envelope<double>& raster_datasource::envelope() const
+mapnik::Envelope<double> raster_datasource::envelope() const
 {
     return extent_;
 }
 
-layer_descriptor const& raster_datasource::get_descriptor() const
+layer_descriptor raster_datasource::get_descriptor() const
 {
     return desc_;
 }

Modified: trunk/plugins/input/raster/raster_datasource.hpp
===================================================================
--- trunk/plugins/input/raster/raster_datasource.hpp	2006-11-22 22:09:11 UTC (rev 378)
+++ trunk/plugins/input/raster/raster_datasource.hpp	2006-11-25 11:02:59 UTC (rev 379)
@@ -45,8 +45,8 @@
     static std::string name();
     featureset_ptr features(const query& q) const;
     featureset_ptr features_at_point(coord2d const& pt) const;
-    mapnik::Envelope<double> const& envelope() const;
-    layer_descriptor const& get_descriptor() const;
+    mapnik::Envelope<double> envelope() const;
+    layer_descriptor get_descriptor() const;
 private:
     //no copying
     raster_datasource(const raster_datasource&);

Modified: trunk/plugins/input/shape/shape.cpp
===================================================================
--- trunk/plugins/input/shape/shape.cpp	2006-11-22 22:09:11 UTC (rev 378)
+++ trunk/plugins/input/shape/shape.cpp	2006-11-25 11:02:59 UTC (rev 379)
@@ -136,7 +136,7 @@
     return type_;
 }
 
-layer_descriptor const& shape_datasource::get_descriptor() const
+layer_descriptor shape_datasource::get_descriptor() const
 {
     return desc_;
 }
@@ -154,16 +154,41 @@
         return featureset_ptr
             (new shape_index_featureset<filter_in_box>(filter,shape_name_,q.property_names()));
     }
-    return featureset_ptr
-        (new shape_featureset<filter_in_box>(filter,shape_name_,q.property_names(),file_length_));
+    else
+    {
+        return featureset_ptr
+            (new shape_featureset<filter_in_box>(filter,shape_name_,q.property_names(),file_length_));
+    }
 }
 
 featureset_ptr shape_datasource::features_at_point(coord2d const& pt) const
 {
-    return featureset_ptr();
+    filter_at_point filter(pt);
+    // collect all attribute names
+    std::vector<attribute_descriptor> const& desc_vector = desc_.get_descriptors();
+    std::vector<attribute_descriptor>::const_iterator itr = desc_vector.begin();
+    std::vector<attribute_descriptor>::const_iterator end = desc_vector.end();
+    std::set<std::string> names;
+    
+    while (itr != end)
+    {    
+        names.insert(itr->get_name());
+        ++itr;
+    }
+    
+    if (indexed_)
+    {
+        return featureset_ptr
+            (new shape_index_featureset<filter_at_point>(filter,shape_name_,names));
+    }
+    else
+    {
+        return featureset_ptr
+            (new shape_featureset<filter_at_point>(filter,shape_name_,names,file_length_));
+    }
 }
 
-const Envelope<double>& shape_datasource::envelope() const
+Envelope<double> shape_datasource::envelope() const
 {
     return extent_;
 }

Modified: trunk/plugins/input/shape/shape.hpp
===================================================================
--- trunk/plugins/input/shape/shape.hpp	2006-11-22 22:09:11 UTC (rev 378)
+++ trunk/plugins/input/shape/shape.hpp	2006-11-25 11:02:59 UTC (rev 379)
@@ -37,13 +37,13 @@
 public:
     shape_datasource(const parameters &params);
     virtual ~shape_datasource();
- 
+    
     int type() const;
     static std::string name();
     featureset_ptr features(const query& q) const;
     featureset_ptr features_at_point(coord2d const& pt) const;
-    const Envelope<double>& envelope() const;
-    layer_descriptor const& get_descriptor() const;   
+    Envelope<double> envelope() const;
+    layer_descriptor get_descriptor() const;   
 private:
     shape_datasource(const shape_datasource&);
     shape_datasource& operator=(const shape_datasource&);
@@ -52,7 +52,7 @@
     std::string shape_name_;
     int type_;
     long file_length_;
-    mapnik::Envelope<double> extent_;
+    Envelope<double> extent_;
     bool indexed_;
     layer_descriptor desc_;
     static std::string name_;

Modified: trunk/plugins/input/shape/shape_featureset.cpp
===================================================================
--- trunk/plugins/input/shape/shape_featureset.cpp	2006-11-22 22:09:11 UTC (rev 378)
+++ trunk/plugins/input/shape/shape_featureset.cpp	2006-11-25 11:02:59 UTC (rev 379)
@@ -191,3 +191,5 @@
 shape_featureset<filterT>::~shape_featureset() {}
 
 template class shape_featureset<filter_in_box>;
+template class shape_featureset<filter_at_point>;
+

Modified: trunk/plugins/input/shape/shape_index_featureset.cpp
===================================================================
--- trunk/plugins/input/shape/shape_index_featureset.cpp	2006-11-22 22:09:11 UTC (rev 378)
+++ trunk/plugins/input/shape/shape_index_featureset.cpp	2006-11-25 11:02:59 UTC (rev 379)
@@ -197,4 +197,5 @@
 shape_index_featureset<filterT>::~shape_index_featureset() {}
 
 template class shape_index_featureset<filter_in_box>;
+template class shape_index_featureset<filter_at_point>;
 

Modified: trunk/src/agg_renderer.cpp
===================================================================
--- trunk/src/agg_renderer.cpp	2006-11-22 22:09:11 UTC (rev 378)
+++ trunk/src/agg_renderer.cpp	2006-11-25 11:02:59 UTC (rev 379)
@@ -419,7 +419,7 @@
                                   Feature const& feature,
                                   proj_transform const& prj_trans)
     {
-        typedef  coord_transform2<CoordTransform,geometry_type> path_type;
+        typedef coord_transform2<CoordTransform,geometry_type> path_type;
         typedef agg::renderer_base<agg::pixfmt_rgba32> ren_base; 
         typedef agg::wrap_mode_repeat wrap_x_type;
         typedef agg::wrap_mode_repeat wrap_y_type;

Modified: trunk/src/datasource_cache.cpp
===================================================================
--- trunk/src/datasource_cache.cpp	2006-11-22 22:09:11 UTC (rev 378)
+++ trunk/src/datasource_cache.cpp	2006-11-25 11:02:59 UTC (rev 379)
@@ -48,9 +48,9 @@
     std::map<string,boost::shared_ptr<PluginInfo> > datasource_cache::plugins_;
     bool datasource_cache::registered_=false;
         
-    datasource_p datasource_cache::create(const parameters& params)
+    datasource_ptr datasource_cache::create(const parameters& params)
     {
-        datasource_p ds;
+        datasource_ptr ds;
         try
         {
             const std::string type=params.get("type");	    
@@ -67,7 +67,7 @@
                     }
                     else
                     {
-                        ds=datasource_p(create_datasource(params),datasource_deleter());
+                        ds=datasource_ptr(create_datasource(params),datasource_deleter());
                     }
                 }
                 else

Modified: trunk/src/graphics.cpp
===================================================================
--- trunk/src/graphics.cpp	2006-11-22 22:09:11 UTC (rev 378)
+++ trunk/src/graphics.cpp	2006-11-25 11:02:59 UTC (rev 379)
@@ -63,6 +63,6 @@
     void Image32::saveToFile(const std::string& file,const std::string& format) 
     {
 	    //TODO: image writer factory
-	    ImageUtils::save_to_file(file,format,*this);
+	    save_to_file(file,format,data_);
     }
 }

Modified: trunk/src/image_util.cpp
===================================================================
--- trunk/src/image_util.cpp	2006-11-22 22:09:11 UTC (rev 378)
+++ trunk/src/image_util.cpp	2006-11-25 11:02:59 UTC (rev 379)
@@ -28,6 +28,7 @@
 #include <mapnik/graphics.hpp>
 #include <mapnik/memory.hpp>
 #include <mapnik/image_util.hpp>
+#include <mapnik/image_view.hpp>
 // jpeg png
 extern "C"
 {
@@ -37,9 +38,7 @@
 
 namespace mapnik
 {
-
     //use memory manager for mem allocation in libpng
-
     png_voidp malloc_fn(png_structp png_ptr,png_size_t size)
     {
         return Object::operator new(size);
@@ -48,10 +47,11 @@
     {
         Object::operator delete(ptr);
     }
-    //
-    void ImageUtils::save_to_file(const std::string& filename,
-                                  const std::string& type,
-                                  const Image32& image)
+    
+    template <typename T>
+    void save_to_file(std::string const& filename,
+                      std::string const& type,
+                      T const& image)
     {
         //all that should go into image_writer factory
         if (type=="png")
@@ -63,8 +63,9 @@
             save_as_jpeg(filename,85,image);
         }
     }
-
-    void ImageUtils::save_as_png(const std::string& filename,const Image32& image)
+    
+    template <typename T>
+    void save_as_png(std::string const& filename, T const& image)
     {
         FILE *fp=fopen(filename.c_str(), "wb");
         if (!fp) return;
@@ -105,20 +106,18 @@
                      PNG_COLOR_TYPE_RGB_ALPHA,PNG_INTERLACE_NONE,
                      PNG_COMPRESSION_TYPE_DEFAULT,PNG_FILTER_TYPE_DEFAULT);
         png_write_info(png_ptr, info_ptr);
-
-        const ImageData32& imageData=image.data();
-
         for (unsigned i=0;i<image.height();i++)
         {
-            png_write_row(png_ptr,(png_bytep)imageData.getRow(i));
+            png_write_row(png_ptr,(png_bytep)image.getRow(i));
         }
 
         png_write_end(png_ptr, info_ptr);
         png_destroy_write_struct(&png_ptr, &info_ptr);
         fclose(fp);
     }
-
-    void ImageUtils::save_as_jpeg(const std::string& filename,int quality, const Image32& image)
+    
+    template <typename T>
+    void save_as_jpeg(std::string const& filename,int quality, T const& image)
     {
         FILE *fp=fopen(filename.c_str(), "wb");
         if (!fp) return;
@@ -140,10 +139,10 @@
         jpeg_start_compress(&cinfo, 1);
         JSAMPROW row_pointer[1];
         JSAMPLE* row=new JSAMPLE[width*3];
-        const ImageData32& imageData=image.data();
+        
         while (cinfo.next_scanline < cinfo.image_height) 
         {
-            const unsigned* imageRow=imageData.getRow(cinfo.next_scanline);
+            const unsigned* imageRow=image.getRow(cinfo.next_scanline);
             int index=0;
             for (int i=0;i<width;++i)
             {
@@ -158,5 +157,14 @@
         jpeg_finish_compress(&cinfo);
         fclose(fp);
         jpeg_destroy_compress(&cinfo);
-    }
+    }  
+    
+    template void save_to_file<ImageData32>(std::string const&,
+                                            std::string const& , 
+                                            ImageData32 const&);
+
+    template void save_to_file<image_view<ImageData32> > (std::string const&,
+                                                          std::string const& , 
+                                                          image_view<ImageData32> const&);
+    
 }

Modified: trunk/src/layer.cpp
===================================================================
--- trunk/src/layer.cpp	2006-11-22 22:09:11 UTC (rev 378)
+++ trunk/src/layer.cpp	2006-11-25 11:02:59 UTC (rev 379)
@@ -186,12 +186,12 @@
         return selectable_;
     }
 
-    datasource_p Layer::datasource() const
+    datasource_ptr Layer::datasource() const
     {
         return ds_;
     }
     
-    void Layer::set_datasource(datasource_p const& ds)
+    void Layer::set_datasource(datasource_ptr const& ds)
     {
         ds_ = ds;
     }

Modified: trunk/src/map.cpp
===================================================================
--- trunk/src/map.cpp	2006-11-22 22:09:11 UTC (rev 378)
+++ trunk/src/map.cpp	2006-11-25 11:02:59 UTC (rev 379)
@@ -124,7 +124,12 @@
     {
         return layers_;
     }
-    
+
+    std::vector<Layer> & Map::layers()
+    {
+        return layers_;
+    }
+
     unsigned Map::getWidth() const
     {
         return width_;
@@ -295,6 +300,11 @@
             return currentExtent_.width()/width_;
         return currentExtent_.width();
     }
+
+    CoordTransform Map::view_transform() const
+    {
+        return CoordTransform(width_,height_,currentExtent_);
+    }
     
     Map::~Map() {}
 }



From pavlenko at mail.berlios.de  Sat Nov 25 12:06:58 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Sat, 25 Nov 2006 12:06:58 +0100
Subject: [Mapnik-svn] r380 - trunk/demo/python
Message-ID: <200611251106.kAPB6wXR020980@sheep.berlios.de>

Author: pavlenko
Date: 2006-11-25 12:06:56 +0100 (Sat, 25 Nov 2006)
New Revision: 380

Modified:
   trunk/demo/python/rundemo.py
Log:
added ellipsoid parameters to proj4 init string. 


Modified: trunk/demo/python/rundemo.py
===================================================================
--- trunk/demo/python/rundemo.py	2006-11-25 11:02:59 UTC (rev 379)
+++ trunk/demo/python/rundemo.py	2006-11-25 11:06:56 UTC (rev 380)
@@ -30,7 +30,7 @@
 # Instanciate a map, giving it a width and height. Remember: the word "map" is
 # reserved in Python! :)
 
-m = Map(800,600,"+proj=latlong")
+m = Map(800,600,"+proj=latlong +ellps=WGS84")
 
 # Set its background colour. More on colours later ...
 



From pavlenko at mail.berlios.de  Mon Nov 27 22:13:20 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Mon, 27 Nov 2006 22:13:20 +0100
Subject: [Mapnik-svn] r381 - in trunk: include/mapnik plugins/input/postgis
Message-ID: <200611272113.kARLDKC7008148@sheep.berlios.de>

Author: pavlenko
Date: 2006-11-27 22:13:15 +0100 (Mon, 27 Nov 2006)
New Revision: 381

Modified:
   trunk/include/mapnik/pool.hpp
   trunk/include/mapnik/utils.hpp
   trunk/plugins/input/postgis/connection.hpp
   trunk/plugins/input/postgis/connection_manager.hpp
   trunk/plugins/input/postgis/postgis.cpp
Log:
1. register singleton destruction with std::atexit
2. allow connection pool to grow (up to max)
 


Modified: trunk/include/mapnik/pool.hpp
===================================================================
--- trunk/include/mapnik/pool.hpp	2006-11-25 11:06:56 UTC (rev 380)
+++ trunk/include/mapnik/pool.hpp	2006-11-27 21:13:15 UTC (rev 381)
@@ -68,25 +68,25 @@
         typedef std::deque<HolderType> ContType;	
 	
         Creator<T> creator_;
-        const int initialSize_; 
-        const int maxSize_;
+        const unsigned initialSize_; 
+        const unsigned maxSize_;
         ContType usedPool_;
         ContType unusedPool_;
         boost::mutex mutex_;
     public:
 
-        Pool(const Creator<T>& creator,int initialSize=5,int maxSize=20)
+        Pool(const Creator<T>& creator,unsigned initialSize=1, unsigned maxSize=10)
             :creator_(creator),
              initialSize_(initialSize),
              maxSize_(maxSize)
         {
-            for (int i=0;i<initialSize_;++i) 
+            for (unsigned i=0; i < initialSize_; ++i) 
             {
                 unusedPool_.push_back(HolderType(creator_()));
             }
         }
 
-        const HolderType& borrowObject()
+        HolderType borrowObject()
         {	    
             mutex::scoped_lock lock(mutex_);
             typename ContType::iterator itr=unusedPool_.begin();
@@ -99,11 +99,20 @@
                 itr=unusedPool_.erase(itr);
                 return usedPool_[usedPool_.size()-1];
             }
-            static const HolderType defaultObj;
-            return defaultObj;
+            else if (unusedPool_.size() < maxSize_)
+            {
+                HolderType conn(creator_());
+                usedPool_.push_back(conn);
+#ifdef MAPNIK_DEBUG
+                std::clog << "create << " << conn.get() << "\n";
+#endif
+                return conn;
+            }
+            
+            return HolderType();
         } 
 
-        void returnObject(const HolderType& obj)
+        void returnObject(HolderType obj)
         {
             mutex::scoped_lock lock(mutex_);
             typename ContType::iterator itr=usedPool_.begin();

Modified: trunk/include/mapnik/utils.hpp
===================================================================
--- trunk/include/mapnik/utils.hpp	2006-11-25 11:06:56 UTC (rev 380)
+++ trunk/include/mapnik/utils.hpp	2006-11-27 21:13:15 UTC (rev 381)
@@ -22,6 +22,7 @@
 #define UTILS_HPP
 // stl
 #include <stdexcept>
+#include <cstdlib>
 #include <limits>
 #include <ctime>
 #include <sstream>
@@ -66,18 +67,21 @@
             int Test::* pMember_;
             int (Test::*pMemberFn_)(int);
         };
+
     public:
+        
         static T* create()
         {
             static MaxAlign staticMemory;
             return new(&staticMemory) T;
         }
+        
         static void destroy(volatile T* obj)
         {
             obj->~T();
         }
     };
-
+    
     template <typename T,
               template <typename T> class CreatePolicy=CreateStatic> class singleton
               {
@@ -90,14 +94,20 @@
                   {
                       throw std::runtime_error("dead reference!");
                   }
-              protected:
-                  static mutex mutex_;
-                  singleton() {}
-                  virtual ~singleton()
+                  
+                  static void DestroySingleton()
                   {
                       CreatePolicy<T>::destroy(pInstance_);
+                      pInstance_ = 0;
                       destroyed_=true;
+#ifdef MAPNIK_DEBUG
+                      std::clog << " destroyed singleton \n";
+#endif
                   }
+                  
+              protected:
+                  static mutex mutex_;
+                  singleton() {}
               public:
                   static  T* instance()
                   {
@@ -113,6 +123,8 @@
                               else
                               {
                                   pInstance_=CreatePolicy<T>::create();
+                                  // register destruction
+                                  std::atexit(&DestroySingleton);
                               }
                           }
                       }
@@ -126,72 +138,7 @@
               template <typename T> class CreatePolicy> T* singleton<T,CreatePolicy>::pInstance_=0;
     template <typename T,
               template <typename T> class CreatePolicy> bool singleton<T,CreatePolicy>::destroyed_=false;
-
-    template <class T> class Handle
-    {
-        T* ptr_;
-        int* pCount_;
-    public:
-        T* operator->() {return ptr_;}
-        const T* operator->() const {return ptr_;}
-        Handle(T* ptr)
-            :ptr_(ptr),pCount_(new int(1)) {}
-        Handle(const Handle& rhs)
-            :ptr_(rhs.ptr_),pCount_(rhs.pCount_)
-        {
-            (*pCount_)++;
-        }
-        Handle& operator=(const Handle& rhs)
-        {
-            if (ptr_==rhs.ptr_) return *this;
-            if (--(*pCount_)==0)
-            {
-                delete ptr_;
-                delete pCount_;
-            }
-            ptr_=rhs.ptr_;
-            pCount_=rhs.pCount_;
-            (*pCount_)++;
-            return *this;
-        }
-        ~Handle()
-        {
-            if (--(*pCount_)==0)
-            {
-                delete ptr_;
-                delete pCount_;
-            }
-        }
-    };
-    
-    //converters
-    class BadConversion : public std::runtime_error
-    {
-    public:
-        BadConversion(const std::string& s)
-            :std::runtime_error(s)
-        {}
-    };
-    
-    template <typename T>
-    inline std::string toString(const T& x)
-    {
-        std::ostringstream o;
-        if (!(o << x))
-            throw BadConversion(std::string("toString(")
-                                + typeid(x).name() + ")");
-        return o.str();
-    }
-    
-    template<typename T>
-    inline void fromString(const std::string& s, T& x,
-                           bool failIfLeftoverChars = true)
-    {
-        std::istringstream i(s);
-        char c;
-        if (!(i >> x) || (failIfLeftoverChars && i.get(c)))
-            throw BadConversion("fromString("+s+")");
-    }
+   
 }
 
 

Modified: trunk/plugins/input/postgis/connection.hpp
===================================================================
--- trunk/plugins/input/postgis/connection.hpp	2006-11-25 11:06:56 UTC (rev 380)
+++ trunk/plugins/input/postgis/connection.hpp	2006-11-27 21:13:15 UTC (rev 381)
@@ -89,6 +89,9 @@
     ~Connection()
     {
         PQfinish(conn_);
+#ifdef MAPNIK_DEBUG
+        std::clog << "close connection " << conn_ << "\n";
+#endif 
     }
 };
 

Modified: trunk/plugins/input/postgis/connection_manager.hpp
===================================================================
--- trunk/plugins/input/postgis/connection_manager.hpp	2006-11-25 11:06:56 UTC (rev 380)
+++ trunk/plugins/input/postgis/connection_manager.hpp	2006-11-27 21:13:15 UTC (rev 381)
@@ -76,7 +76,7 @@
 
 public:
 	
-    bool registerPool(const ConnectionCreator<Connection>& creator,int initialSize,int maxSize) 
+    bool registerPool(const ConnectionCreator<Connection>& creator,unsigned initialSize,unsigned maxSize) 
     {	    
         mutex::scoped_lock lock(mutex_);
         if (pools_.find(creator.id())==pools_.end())
@@ -89,7 +89,7 @@
 	   	     
     }
     
-    const boost::shared_ptr<PoolType>& getPool(const std::string& key) 
+    boost::shared_ptr<PoolType> getPool(std::string const& key) 
     {
         mutex::scoped_lock lock(mutex_);
         ContType::const_iterator itr=pools_.find(key);
@@ -101,7 +101,7 @@
         return emptyPool;
     }
 	
-    const HolderType& get(const std::string& key)
+    HolderType get(std::string const& key)
     {
         mutex::scoped_lock lock(mutex_);
         ContType::const_iterator itr=pools_.find(key);
@@ -110,10 +110,9 @@
             boost::shared_ptr<PoolType> pool=itr->second;
             return pool->borrowObject();
         }
-        static const HolderType EmptyConn;
-        return EmptyConn;
+        return HolderType();
     }
-        
+    
 private:
     ConnectionManager() {}
     ConnectionManager(const ConnectionManager&);

Modified: trunk/plugins/input/postgis/postgis.cpp
===================================================================
--- trunk/plugins/input/postgis/postgis.cpp	2006-11-25 11:06:56 UTC (rev 380)
+++ trunk/plugins/input/postgis/postgis.cpp	2006-11-27 21:13:15 UTC (rev 381)
@@ -54,7 +54,7 @@
                params.get("password"))    
 {     
     ConnectionManager *mgr=ConnectionManager::instance();   
-    mgr->registerPool(creator_,10,20);
+    mgr->registerPool(creator_,5,10);
     
     shared_ptr<Pool<Connection,ConnectionCreator> > pool=mgr->getPool(creator_.id());
     if (pool)



From pavlenko at mail.berlios.de  Tue Nov 28 01:13:33 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Tue, 28 Nov 2006 01:13:33 +0100
Subject: [Mapnik-svn] r382 - trunk/src
Message-ID: <200611280013.kAS0DXmF002664@sheep.berlios.de>

Author: pavlenko
Date: 2006-11-28 01:13:31 +0100 (Tue, 28 Nov 2006)
New Revision: 382

Modified:
   trunk/src/image_util.cpp
Log:
use libpng native alloc/dealloc 
(/valgrind-new-delete2.patch from Jon Burgess)




Modified: trunk/src/image_util.cpp
===================================================================
--- trunk/src/image_util.cpp	2006-11-27 21:13:15 UTC (rev 381)
+++ trunk/src/image_util.cpp	2006-11-28 00:13:31 UTC (rev 382)
@@ -37,17 +37,7 @@
 }
 
 namespace mapnik
-{
-    //use memory manager for mem allocation in libpng
-    png_voidp malloc_fn(png_structp png_ptr,png_size_t size)
-    {
-        return Object::operator new(size);
-    }
-    void free_fn(png_structp png_ptr, png_voidp ptr)
-    {
-        Object::operator delete(ptr);
-    }
-    
+{ 
     template <typename T>
     void save_to_file(std::string const& filename,
                       std::string const& type,
@@ -69,12 +59,11 @@
     {
         FILE *fp=fopen(filename.c_str(), "wb");
         if (!fp) return;
-        png_voidp mem_ptr=0;
+        png_voidp error_ptr=0;
         png_structp png_ptr=png_create_write_struct(PNG_LIBPNG_VER_STRING,
-                                                    (png_voidp)mem_ptr,0, 0);
-	
+                                                    error_ptr,0, 0);
+
         if (!png_ptr) return;
-        png_set_mem_fn(png_ptr,mem_ptr,malloc_fn,free_fn);
 
         // switch on optimization only if supported
 #if defined(PNG_LIBPNG_VER) && (PNG_LIBPNG_VER >= 10200) && defined(PNG_ASSEMBLER_CODE_SUPPORTED)



From pavlenko at mail.berlios.de  Tue Nov 28 01:16:15 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Tue, 28 Nov 2006 01:16:15 +0100
Subject: [Mapnik-svn] r383 - trunk/plugins/input/postgis
Message-ID: <200611280016.kAS0GFiC010336@sheep.berlios.de>

Author: pavlenko
Date: 2006-11-28 01:16:13 +0100 (Tue, 28 Nov 2006)
New Revision: 383

Modified:
   trunk/plugins/input/postgis/postgis.cpp
Log:
added initial_size ans max_size parameters for setting up db connection pool
(default to 1 and 10 respectively)



Modified: trunk/plugins/input/postgis/postgis.cpp
===================================================================
--- trunk/plugins/input/postgis/postgis.cpp	2006-11-28 00:13:31 UTC (rev 382)
+++ trunk/plugins/input/postgis/postgis.cpp	2006-11-28 00:16:13 UTC (rev 383)
@@ -27,6 +27,7 @@
 #include <set>
 #include <sstream>
 #include <iomanip>
+#include <boost/lexical_cast.hpp>
 #include "connection_manager.hpp"
 #include "postgis.hpp"
 
@@ -52,9 +53,31 @@
                params.get("dbname"),
                params.get("user"),
                params.get("password"))    
-{     
+{   
+
+    unsigned initial_size;
+    unsigned max_size;
+    
+    try 
+    {
+        initial_size = boost::lexical_cast<unsigned>(params.get("initial_size")); 
+    }
+    catch (bad_lexical_cast& )
+    {
+        initial_size = 1;
+    }
+    
+    try 
+    {
+        max_size = boost::lexical_cast<unsigned>(params.get("initial_size")); 
+    }
+    catch (bad_lexical_cast&)
+    {
+        max_size = 10;
+    }
+    
     ConnectionManager *mgr=ConnectionManager::instance();   
-    mgr->registerPool(creator_,5,10);
+    mgr->registerPool(creator_, initial_size, max_size);
     
     shared_ptr<Pool<Connection,ConnectionCreator> > pool=mgr->getPool(creator_.id());
     if (pool)



From pavlenko at mail.berlios.de  Tue Nov 28 01:16:54 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Tue, 28 Nov 2006 01:16:54 +0100
Subject: [Mapnik-svn] r384 - trunk/include/mapnik
Message-ID: <200611280016.kAS0Gsva010447@sheep.berlios.de>

Author: pavlenko
Date: 2006-11-28 01:16:53 +0100 (Tue, 28 Nov 2006)
New Revision: 384

Modified:
   trunk/include/mapnik/pool.hpp
Log:
don't keep bad connections around



Modified: trunk/include/mapnik/pool.hpp
===================================================================
--- trunk/include/mapnik/pool.hpp	2006-11-28 00:16:13 UTC (rev 383)
+++ trunk/include/mapnik/pool.hpp	2006-11-28 00:16:53 UTC (rev 384)
@@ -82,7 +82,9 @@
         {
             for (unsigned i=0; i < initialSize_; ++i) 
             {
-                unusedPool_.push_back(HolderType(creator_()));
+                HolderType conn(creator_());
+                if (conn->isOK())
+                    unusedPool_.push_back(conn);
             }
         }
 
@@ -102,13 +104,15 @@
             else if (unusedPool_.size() < maxSize_)
             {
                 HolderType conn(creator_());
-                usedPool_.push_back(conn);
+                if (conn->isOK())
+                {
+                    usedPool_.push_back(conn);
 #ifdef MAPNIK_DEBUG
                 std::clog << "create << " << conn.get() << "\n";
 #endif
                 return conn;
+                }
             }
-            
             return HolderType();
         } 
 



From pavlenko at mail.berlios.de  Tue Nov 28 11:38:57 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Tue, 28 Nov 2006 11:38:57 +0100
Subject: [Mapnik-svn] r385 - trunk/src
Message-ID: <200611281038.kASAcvwo006972@sheep.berlios.de>

Author: pavlenko
Date: 2006-11-28 11:38:56 +0100 (Tue, 28 Nov 2006)
New Revision: 385

Modified:
   trunk/src/placement_finder.cpp
Log:
define M_PI if undef



Modified: trunk/src/placement_finder.cpp
===================================================================
--- trunk/src/placement_finder.cpp	2006-11-28 00:16:53 UTC (rev 384)
+++ trunk/src/placement_finder.cpp	2006-11-28 10:38:56 UTC (rev 385)
@@ -38,6 +38,10 @@
 #include <mapnik/placement_finder.hpp>
 #include <mapnik/text_path.hpp>
 
+#ifndef M_PI
+#define M_PI 3.14159265358979323846
+#endif
+
 namespace mapnik
 {
     //For shields



From pavlenko at mail.berlios.de  Tue Nov 28 23:24:27 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Tue, 28 Nov 2006 23:24:27 +0100
Subject: [Mapnik-svn] r386 - trunk/src
Message-ID: <200611282224.kASMORcX009319@sheep.berlios.de>

Author: pavlenko
Date: 2006-11-28 23:24:24 +0100 (Tue, 28 Nov 2006)
New Revision: 386

Modified:
   trunk/src/placement_finder.cpp
Log:
use 2*M_PI for max_char_angle_delta normalizing.



Modified: trunk/src/placement_finder.cpp
===================================================================
--- trunk/src/placement_finder.cpp	2006-11-28 10:38:56 UTC (rev 385)
+++ trunk/src/placement_finder.cpp	2006-11-28 22:24:24 UTC (rev 386)
@@ -373,9 +373,9 @@
                 angle_delta = last_angle - angle;
                 // normalise between -180 and 180
                 while (angle_delta > M_PI)
-                    angle_delta -= M_PI;
+                    angle_delta -= 2*M_PI;
                 while (angle_delta < -M_PI)
-                    angle_delta += M_PI;
+                    angle_delta += 2*M_PI;
                 if (p->max_char_angle_delta > 0 && fabs(angle_delta) > p->max_char_angle_delta*(M_PI/180))
                 {
                     return false;



From pavlenko at mail.berlios.de  Tue Nov 28 23:25:33 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Tue, 28 Nov 2006 23:25:33 +0100
Subject: [Mapnik-svn] r387 - trunk/plugins/input/shape
Message-ID: <200611282225.kASMPXPQ009459@sheep.berlios.de>

Author: pavlenko
Date: 2006-11-28 23:25:31 +0100 (Tue, 28 Nov 2006)
New Revision: 387

Modified:
   trunk/plugins/input/shape/dbffile.cpp
Log:
do not assert on empty dbf files
 


Modified: trunk/plugins/input/shape/dbffile.cpp
===================================================================
--- trunk/plugins/input/shape/dbffile.cpp	2006-11-28 22:24:24 UTC (rev 386)
+++ trunk/plugins/input/shape/dbffile.cpp	2006-11-28 22:25:31 UTC (rev 387)
@@ -178,7 +178,7 @@
     {
         skip(3);
         num_records_=read_int();
-        assert(num_records_>0);
+        assert(num_records_>=0);
         num_fields_=read_short();
         assert(num_fields_>0);
         num_fields_=(num_fields_-33)/32;



From pavlenko at mail.berlios.de  Wed Nov 29 01:14:28 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Wed, 29 Nov 2006 01:14:28 +0100
Subject: [Mapnik-svn] r388 - trunk/include/mapnik
Message-ID: <200611290014.kAT0ESLC017094@sheep.berlios.de>

Author: pavlenko
Date: 2006-11-29 01:14:25 +0100 (Wed, 29 Nov 2006)
New Revision: 388

Modified:
   trunk/include/mapnik/regex_filter.hpp
   trunk/include/mapnik/text_symbolizer.hpp
   trunk/include/mapnik/utils.hpp
Log:
opps, fixed license note



Modified: trunk/include/mapnik/regex_filter.hpp
===================================================================
--- trunk/include/mapnik/regex_filter.hpp	2006-11-28 22:25:31 UTC (rev 387)
+++ trunk/include/mapnik/regex_filter.hpp	2006-11-29 00:14:25 UTC (rev 388)
@@ -1,21 +1,26 @@
-/* This file is part of Mapnik (c++ mapping toolkit)
- * Copyright (C) 2005 Artem Pavlenko
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
  *
- * Mapnik is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or any later version.
+ * Copyright (C) 2006 Artem Pavlenko
  *
- * This program is distributed in the hope that it will be useful,
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- */
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
 
+
 //$Id$
 
 #ifndef REGEX_FILTER_HPP

Modified: trunk/include/mapnik/text_symbolizer.hpp
===================================================================
--- trunk/include/mapnik/text_symbolizer.hpp	2006-11-28 22:25:31 UTC (rev 387)
+++ trunk/include/mapnik/text_symbolizer.hpp	2006-11-29 00:14:25 UTC (rev 388)
@@ -1,20 +1,24 @@
-/* This file is part of Mapnik (c++ mapping toolkit)
- * Copyright (C) 2005 Artem Pavlenko
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
  *
- * Mapnik is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or any later version.
+ * Copyright (C) 2006 Artem Pavlenko
  *
- * This program is distributed in the hope that it will be useful,
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- */
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
 
 //$Id$
 

Modified: trunk/include/mapnik/utils.hpp
===================================================================
--- trunk/include/mapnik/utils.hpp	2006-11-28 22:25:31 UTC (rev 387)
+++ trunk/include/mapnik/utils.hpp	2006-11-29 00:14:25 UTC (rev 388)
@@ -1,20 +1,24 @@
-/* This file is part of Mapnik (c++ mapping toolkit)
- * Copyright (C) 2005 Artem Pavlenko
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
  *
- * Mapnik is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or any later version.
+ * Copyright (C) 2006 Artem Pavlenko
  *
- * This program is distributed in the hope that it will be useful,
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- */
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
 
 //$Id: utils.hpp 39 2005-04-10 20:39:53Z pavlenko $
 



From pavlenko at mail.berlios.de  Wed Nov 29 11:44:45 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Wed, 29 Nov 2006 11:44:45 +0100
Subject: [Mapnik-svn] r389 - in trunk: include/mapnik src
Message-ID: <200611291044.kATAijcv031304@sheep.berlios.de>

Author: pavlenko
Date: 2006-11-29 11:44:42 +0100 (Wed, 29 Nov 2006)
New Revision: 389

Modified:
   trunk/include/mapnik/placement_finder.hpp
   trunk/include/mapnik/text_symbolizer.hpp
   trunk/src/agg_renderer.cpp
   trunk/src/placement_finder.cpp
   trunk/src/text_symbolizer.cpp
Log:
Label position tolerance and text spacing patch from David Leaver. Thanks!



Modified: trunk/include/mapnik/placement_finder.hpp
===================================================================
--- trunk/include/mapnik/placement_finder.hpp	2006-11-29 00:14:25 UTC (rev 388)
+++ trunk/include/mapnik/placement_finder.hpp	2006-11-29 10:44:42 UTC (rev 389)
@@ -89,6 +89,8 @@
     int text_ratio;
 
     int label_spacing; // distance between repeated labels on a single geometry
+    unsigned label_position_tolerance; //distance the label can be moved on the line to fit, if 0 the default is used
+	bool force_odd_labels; //Always try render an odd amount of labels
 
     double max_char_angle_delta;
     

Modified: trunk/include/mapnik/text_symbolizer.hpp
===================================================================
--- trunk/include/mapnik/text_symbolizer.hpp	2006-11-29 00:14:25 UTC (rev 388)
+++ trunk/include/mapnik/text_symbolizer.hpp	2006-11-29 10:44:42 UTC (rev 389)
@@ -53,6 +53,10 @@
         void set_wrap_width(unsigned ratio);
         unsigned get_label_spacing() const; // spacing between repeated labels on lines
         void set_label_spacing(unsigned spacing);
+        unsigned get_label_position_tolerance() const; //distance the label can be moved on the line to fit, if 0 the default is used
+        void set_label_position_tolerance(unsigned tolerance);
+		bool get_force_odd_labels() const; // try render an odd amount of labels
+		void set_force_odd_labels(bool force);
         double get_max_char_angle_delta() const; // maximum change in angle between adjacent characters
         void set_max_char_angle_delta(double angle);
         unsigned get_text_size() const;
@@ -78,6 +82,8 @@
         unsigned text_ratio_;
         unsigned wrap_width_;
         unsigned label_spacing_;
+        unsigned label_position_tolerance_;
+        bool force_odd_labels_;
         double max_char_angle_delta_;
         Color fill_;
         Color halo_fill_;

Modified: trunk/src/agg_renderer.cpp
===================================================================
--- trunk/src/agg_renderer.cpp	2006-11-29 00:14:25 UTC (rev 388)
+++ trunk/src/agg_renderer.cpp	2006-11-29 10:44:42 UTC (rev 389)
@@ -256,7 +256,6 @@
             //    ren_oaa.color(agg::rgba8(r, g, b, int(255*stroke_.get_opacity())));
             //    ren_oaa.clip_box(0,0,pixmap_.width(),pixmap_.height());
             //    ras_oaa.add_path(path);		
-		 
             //    }
             else 
             {
@@ -520,6 +519,8 @@
                     text_placement.text_ratio = sym.get_text_ratio();
                     text_placement.wrap_width = sym.get_wrap_width();
                     text_placement.label_spacing = sym.get_label_spacing();
+                    text_placement.label_position_tolerance = sym.get_label_position_tolerance();
+                    text_placement.force_odd_labels = sym.get_force_odd_labels();
                     text_placement.max_char_angle_delta = sym.get_max_char_angle_delta();
                     text_placement.avoid_edges = sym.get_avoid_edges();
                   

Modified: trunk/src/placement_finder.cpp
===================================================================
--- trunk/src/placement_finder.cpp	2006-11-29 00:14:25 UTC (rev 388)
+++ trunk/src/placement_finder.cpp	2006-11-29 10:44:42 UTC (rev 389)
@@ -46,13 +46,13 @@
 {
     //For shields
     placement::placement(string_info *info_, CoordTransform *ctrans_, const proj_transform *proj_trans_, geometry_ptr geom_, std::pair<double, double> dimensions_)
-        : info(info_), ctrans(ctrans_), proj_trans(proj_trans_), geom(geom_), label_placement(point_placement), dimensions(dimensions_), has_dimensions(true), shape_path(*ctrans_, *geom_, *proj_trans_), total_distance_(-1.0), wrap_width(0), text_ratio(0), label_spacing(0), max_char_angle_delta(0.0), avoid_edges(false)
+        : info(info_), ctrans(ctrans_), proj_trans(proj_trans_), geom(geom_), label_placement(point_placement), dimensions(dimensions_), has_dimensions(true), shape_path(*ctrans_, *geom_, *proj_trans_), total_distance_(-1.0), wrap_width(0), text_ratio(0), label_spacing(0), label_position_tolerance(0), force_odd_labels(false), max_char_angle_delta(0.0), avoid_edges(false)
     {
     }
 
     //For text
     placement::placement(string_info *info_, CoordTransform *ctrans_, const proj_transform *proj_trans_, geometry_ptr geom_, label_placement_e placement_)
-        : info(info_), ctrans(ctrans_), proj_trans(proj_trans_), geom(geom_), label_placement(placement_), has_dimensions(false), shape_path(*ctrans_, *geom_, *proj_trans_), total_distance_(-1.0), wrap_width(0), text_ratio(0), label_spacing(0), max_char_angle_delta(0.0), avoid_edges(false)
+        : info(info_), ctrans(ctrans_), proj_trans(proj_trans_), geom(geom_), label_placement(placement_), has_dimensions(false), shape_path(*ctrans_, *geom_, *proj_trans_), total_distance_(-1.0), wrap_width(0), text_ratio(0), label_spacing(0), label_position_tolerance(0), force_odd_labels(false), max_char_angle_delta(0.0), avoid_edges(false)
     {
     }
   
@@ -183,20 +183,55 @@
         int num_labels = 0;
         if (p->label_spacing)
             num_labels = static_cast<int> (floor(distance / (p->label_spacing + string_width)));
-        if (num_labels == 0)
+		if (p->force_odd_labels && num_labels%2 == 0)
+			num_labels--;
+        if (num_labels <= 0)
             num_labels = 1;
 
         double ideal_spacing = distance/num_labels;
         std::vector<double> ideal_label_distances;
-        for (double label_pos = string_width/2.0; label_pos < distance - string_width/2.0; label_pos += ideal_spacing)
-            ideal_label_distances.push_back(label_pos);
+		
+		double middle = (distance / 2.0) - (string_width/2.0); //try draw text centered
+		
+		if (num_labels % 2) //odd amount of labels
+		{
+			for (int a = 0; a < (num_labels+1)/2; a++)
+			{
+				ideal_label_distances.push_back(middle - (a*ideal_spacing));
+	
+				if (a != 0)
+					ideal_label_distances.push_back(middle + (a*ideal_spacing));
+			}
+		}
+		else //even amount of labels
+		{
+			for (int a = 0; a < num_labels/2; a++)
+			{
+				ideal_label_distances.push_back(middle - (ideal_spacing/2.0) - (a*ideal_spacing));
+				ideal_label_distances.push_back(middle + (ideal_spacing/2.0) + (a*ideal_spacing));
+			}
+		}
 
-        double delta = ideal_spacing/100.0;
+        double delta;
+		double tolerance;
+
+		if (p->label_position_tolerance > 0)
+		{
+			tolerance = p->label_position_tolerance;
+			delta = std::max ( 1.0, p->label_position_tolerance/100.0);
+		}
+		else
+		{
+			tolerance = ideal_spacing/2.0;
+			delta = ideal_spacing/100.0;
+		}
+
+
         bool FoundPlacement = false;
         for (std::vector<double>::const_iterator itr = ideal_label_distances.begin(); itr < ideal_label_distances.end(); ++itr)
         {
             //std::clog << "Trying to find txt placement at distance: " << *itr << std::endl;
-            for (double i = 0; i < ideal_spacing/2.0; i += delta)
+            for (double i = 0; i < tolerance; i += delta)
             {
                 p->clear_envelopes();
         
@@ -431,8 +466,8 @@
                 render_y -= ci.width*sin(render_angle) + (string_height-2)*cos(render_angle);
                 render_angle += M_PI;
             }
-
         
+        
             p->current_placement.path.add_node(c, render_x - p->current_placement.starting_x, -render_y + p->current_placement.starting_y, render_angle);
             x += next_char_x;
             y -= next_char_y;

Modified: trunk/src/text_symbolizer.cpp
===================================================================
--- trunk/src/text_symbolizer.cpp	2006-11-29 00:14:25 UTC (rev 388)
+++ trunk/src/text_symbolizer.cpp	2006-11-29 10:44:42 UTC (rev 389)
@@ -36,6 +36,8 @@
           text_ratio_(0),
           wrap_width_(0),
           label_spacing_(0),
+          label_position_tolerance_(0),
+          force_odd_labels_(false),
           max_char_angle_delta_(0),
 	  fill_(fill),
 	  halo_fill_(Color(255,255,255)),
@@ -52,6 +54,8 @@
           text_ratio_(rhs.text_ratio_),
           wrap_width_(rhs.wrap_width_),
           label_spacing_(rhs.label_spacing_),
+          label_position_tolerance_(rhs.label_position_tolerance_),
+          force_odd_labels_(rhs.force_odd_labels_),
           max_char_angle_delta_(rhs.max_char_angle_delta_),
           fill_(rhs.fill_),
           halo_fill_(rhs.halo_fill_),
@@ -71,6 +75,8 @@
         text_ratio_ = other.text_ratio_;
         wrap_width_ = other.wrap_width_;
         label_spacing_ = other.label_spacing_;
+        label_position_tolerance_ = other.label_position_tolerance_;
+        force_odd_labels_ = other.force_odd_labels_;
         max_char_angle_delta_ = other.max_char_angle_delta_;
         fill_ = other.fill_;
         halo_fill_ = other.halo_fill_;
@@ -123,6 +129,26 @@
         label_spacing_ = spacing;
     }
 
+    unsigned  text_symbolizer::get_label_position_tolerance() const
+    {
+        return label_position_tolerance_;
+    }
+
+    void  text_symbolizer::set_label_position_tolerance(unsigned tolerance)
+    {
+        label_position_tolerance_ = tolerance;
+    }
+
+    bool  text_symbolizer::get_force_odd_labels() const
+    {
+        return force_odd_labels_;
+    }
+
+    void  text_symbolizer::set_force_odd_labels(bool force) 
+    {
+        force_odd_labels_ = force;
+    }
+
     double text_symbolizer::get_max_char_angle_delta() const
     {
         return max_char_angle_delta_;



From pavlenko at mail.berlios.de  Wed Nov 29 13:12:26 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Wed, 29 Nov 2006 13:12:26 +0100
Subject: [Mapnik-svn] r390 - in trunk/plugins/input: postgis shape
Message-ID: <200611291212.kATCCQAE016042@sheep.berlios.de>

Author: pavlenko
Date: 2006-11-29 13:12:23 +0100 (Wed, 29 Nov 2006)
New Revision: 390

Modified:
   trunk/plugins/input/postgis/postgis.cpp
   trunk/plugins/input/postgis/postgis.hpp
   trunk/plugins/input/postgis/postgisfs.cpp
   trunk/plugins/input/shape/shape.cpp
   trunk/plugins/input/shape/shape.hpp
Log:
don't calculate extent by default



Modified: trunk/plugins/input/postgis/postgis.cpp
===================================================================
--- trunk/plugins/input/postgis/postgis.cpp	2006-11-29 10:44:42 UTC (rev 389)
+++ trunk/plugins/input/postgis/postgis.cpp	2006-11-29 12:12:23 UTC (rev 390)
@@ -46,7 +46,8 @@
 postgis_datasource::postgis_datasource(parameters const& params)
     : datasource (params),
       table_(params.get("table")),
-      type_(datasource::Vector), 
+      type_(datasource::Vector),
+      extent_initialized_(false),
       desc_(params.get("type")),
       creator_(params.get("host"),
                params.get("port"),
@@ -60,7 +61,7 @@
     
     try 
     {
-        initial_size = boost::lexical_cast<unsigned>(params.get("initial_size")); 
+        initial_size = boost::lexical_cast<unsigned>(params_.get("initial_size")); 
     }
     catch (bad_lexical_cast& )
     {
@@ -69,7 +70,7 @@
     
     try 
     {
-        max_size = boost::lexical_cast<unsigned>(params.get("initial_size")); 
+        max_size = boost::lexical_cast<unsigned>(params_.get("initial_size")); 
     }
     catch (bad_lexical_cast&)
     {
@@ -82,7 +83,7 @@
     shared_ptr<Pool<Connection,ConnectionCreator> > pool=mgr->getPool(creator_.id());
     if (pool)
     {
-        const shared_ptr<Connection>& conn = pool->borrowObject();
+        shared_ptr<Connection> conn = pool->borrowObject();
         if (conn && conn->isOK())
         {
             PoolGuard<shared_ptr<Connection>,shared_ptr<Pool<Connection,ConnectionCreator> > > guard(conn,pool);
@@ -108,40 +109,7 @@
                 std::string postgisType=rs->getValue("type");
             }
             rs->close();
-            s.str("");
             
-            if (params.get("estimate_extent") == "true")
-            {
-                s << "select xmin(ext),ymin(ext),xmax(ext),ymax(ext)"
-                  << " from (select estimated_extent('" 
-                  << table_name <<"','" 
-                  << geometryColumn_ << "') as ext) as tmp";
-            }
-            else 
-            {
-                s << "select xmin(ext),ymin(ext),xmax(ext),ymax(ext)"
-                  << " from (select extent(" <<geometryColumn_<< ") as ext from " 
-                  << table_name << ") as tmp";
-            }
-            
-            rs=conn->executeQuery(s.str());
-            if (rs->next())
-            {
-                try 
-                {
-                    double lox=lexical_cast<double>(rs->getValue(0));
-                    double loy=lexical_cast<double>(rs->getValue(1));
-                    double hix=lexical_cast<double>(rs->getValue(2));
-                    double hiy=lexical_cast<double>(rs->getValue(3));		    
-                    extent_.init(lox,loy,hix,hiy);
-                }
-                catch (bad_lexical_cast &ex)
-                {
-                    clog << ex.what() << endl;
-                }
-            }
-            rs->close();
-            
             // collect attribute desc
             s.str("");
             s << "select * from "<<table_<<" limit 1";
@@ -182,7 +150,7 @@
     }
 }
 
-std::string postgis_datasource::name_="postgis";
+std::string const postgis_datasource::name_="postgis";
 
 std::string postgis_datasource::name()
 {
@@ -216,13 +184,12 @@
 
 featureset_ptr postgis_datasource::features(const query& q) const
 {
-    Featureset *fs=0;
     Envelope<double> const& box=q.get_bbox();
     ConnectionManager *mgr=ConnectionManager::instance();
     shared_ptr<Pool<Connection,ConnectionCreator> > pool=mgr->getPool(creator_.id());
     if (pool)
     {
-        const shared_ptr<Connection>& conn = pool->borrowObject();
+        shared_ptr<Connection> conn = pool->borrowObject();
         if (conn && conn->isOK())
         {       
             PoolGuard<shared_ptr<Connection>,shared_ptr<Pool<Connection,ConnectionCreator> > > guard(conn,pool);
@@ -235,18 +202,17 @@
             {
                 s <<",\""<<*pos<<"\"";
                 ++pos;
-            }	
-    
+            }	 
             s << " from " << table_<<" where "<<geometryColumn_<<" && setSRID('BOX3D(";
             s << std::setprecision(16);
             s << box.minx() << " " << box.miny() << ",";
             s << box.maxx() << " " << box.maxy() << ")'::box3d,"<<srid_<<")";
             
             shared_ptr<ResultSet> rs=conn->executeQuery(s.str(),1);
-            fs=new postgis_featureset(rs,props.size());
+            return featureset_ptr(new postgis_featureset(rs,props.size()));
         }
     }
-    return featureset_ptr(fs);
+    return featureset_ptr();
 }
 
 featureset_ptr postgis_datasource::features_at_point(coord2d const& pt) const
@@ -256,6 +222,51 @@
 
 Envelope<double> postgis_datasource::envelope() const
 {
+    if (extent_initialized_) return extent_;
+    
+    ConnectionManager *mgr=ConnectionManager::instance();
+    shared_ptr<Pool<Connection,ConnectionCreator> > pool=mgr->getPool(creator_.id());
+    if (pool)
+    {
+        shared_ptr<Connection> conn = pool->borrowObject();
+        if (conn && conn->isOK())
+        {
+            std::ostringstream s;
+            std::string table_name = table_from_sql(table_);
+            if (params_.get("estimate_extent") == "true")
+            {
+                s << "select xmin(ext),ymin(ext),xmax(ext),ymax(ext)"
+                  << " from (select estimated_extent('" 
+                  << table_name <<"','" 
+                  << geometryColumn_ << "') as ext) as tmp";
+            }
+            else 
+            {
+                s << "select xmin(ext),ymin(ext),xmax(ext),ymax(ext)"
+                  << " from (select extent(" <<geometryColumn_<< ") as ext from " 
+                  << table_name << ") as tmp";
+            }
+            
+            shared_ptr<ResultSet> rs=conn->executeQuery(s.str());
+            if (rs->next())
+            {
+                try 
+                {
+                    double lox=lexical_cast<double>(rs->getValue(0));
+                    double loy=lexical_cast<double>(rs->getValue(1));
+                    double hix=lexical_cast<double>(rs->getValue(2));
+                    double hiy=lexical_cast<double>(rs->getValue(3));		    
+                    extent_.init(lox,loy,hix,hiy);
+                    extent_initialized_ = true;
+                }
+                catch (bad_lexical_cast &ex)
+                {
+                    clog << ex.what() << endl;
+                }
+            }
+            rs->close();
+        }
+    }
     return extent_;
 }
 

Modified: trunk/plugins/input/postgis/postgis.hpp
===================================================================
--- trunk/plugins/input/postgis/postgis.hpp	2006-11-29 10:44:42 UTC (rev 389)
+++ trunk/plugins/input/postgis/postgis.hpp	2006-11-29 12:12:23 UTC (rev 390)
@@ -48,10 +48,11 @@
     std::string geometryColumn_;
     int type_;
     int srid_;
-    mapnik::Envelope<double> extent_;
+    mutable bool extent_initialized_;
+    mutable mapnik::Envelope<double> extent_;
     layer_descriptor desc_;
     ConnectionCreator<Connection> creator_;
-    static std::string name_;
+    static const std::string name_;
 public:
     static std::string name();
     int type() const;
@@ -76,7 +77,6 @@
     mutable int count_;
 public:
     postgis_featureset(const boost::shared_ptr<ResultSet>& rs,unsigned num_attrs);
-    void dispose();
     feature_ptr next();
     ~postgis_featureset();
 private:

Modified: trunk/plugins/input/postgis/postgisfs.cpp
===================================================================
--- trunk/plugins/input/postgis/postgisfs.cpp	2006-11-29 10:44:42 UTC (rev 389)
+++ trunk/plugins/input/postgis/postgisfs.cpp	2006-11-29 12:12:23 UTC (rev 390)
@@ -22,10 +22,9 @@
 
 //$Id: postgisfs.cc 34 2005-04-04 13:27:23Z pavlenko $
 
-
-#include "postgis.hpp"
 #include <mapnik/global.hpp>
 #include <mapnik/wkb.hpp>
+#include "postgis.hpp"
 
 using boost::lexical_cast;
 using boost::bad_lexical_cast;

Modified: trunk/plugins/input/shape/shape.cpp
===================================================================
--- trunk/plugins/input/shape/shape.cpp	2006-11-29 10:44:42 UTC (rev 389)
+++ trunk/plugins/input/shape/shape.cpp	2006-11-29 12:12:23 UTC (rev 390)
@@ -91,7 +91,7 @@
 {
 }
 
-std::string shape_datasource::name_="shape";
+const std::string shape_datasource::name_="shape";
 
 void  shape_datasource::init(shape_io& shape)
 {

Modified: trunk/plugins/input/shape/shape.hpp
===================================================================
--- trunk/plugins/input/shape/shape.hpp	2006-11-29 10:44:42 UTC (rev 389)
+++ trunk/plugins/input/shape/shape.hpp	2006-11-29 12:12:23 UTC (rev 390)
@@ -55,7 +55,7 @@
     Envelope<double> extent_;
     bool indexed_;
     layer_descriptor desc_;
-    static std::string name_;
+    static const std::string name_;
 };
 
 #endif //SHAPE_HPP



From pavlenko at mail.berlios.de  Wed Nov 29 13:27:31 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Wed, 29 Nov 2006 13:27:31 +0100
Subject: [Mapnik-svn] r391 - trunk/bindings/python
Message-ID: <200611291227.kATCRVs2018090@sheep.berlios.de>

Author: pavlenko
Date: 2006-11-29 13:27:29 +0100 (Wed, 29 Nov 2006)
New Revision: 391

Modified:
   trunk/bindings/python/mapnik_text_symbolizer.cpp
Log:
updated to reflect new params



Modified: trunk/bindings/python/mapnik_text_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_text_symbolizer.cpp	2006-11-29 12:12:23 UTC (rev 390)
+++ trunk/bindings/python/mapnik_text_symbolizer.cpp	2006-11-29 12:27:29 UTC (rev 391)
@@ -55,6 +55,12 @@
         .add_property("label_spacing",
                       &text_symbolizer::get_label_spacing,
                       &text_symbolizer::set_label_spacing)
+        .add_property("label_position_tolerance",
+                      &text_symbolizer::get_label_position_tolerance,
+                      &text_symbolizer::set_label_position_tolerance)
+        .add_property("force_odd_labels",
+                      &text_symbolizer::get_force_odd_labels,
+                      &text_symbolizer::set_force_odd_labels)
         .add_property("max_char_angle_delta",
                       &text_symbolizer::get_max_char_angle_delta,
                       &text_symbolizer::set_max_char_angle_delta)



From pavlenko at mail.berlios.de  Wed Nov 29 13:28:18 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Wed, 29 Nov 2006 13:28:18 +0100
Subject: [Mapnik-svn] r392 - trunk/include/mapnik
Message-ID: <200611291228.kATCSIPu018209@sheep.berlios.de>

Author: pavlenko
Date: 2006-11-29 13:28:17 +0100 (Wed, 29 Nov 2006)
New Revision: 392

Modified:
   trunk/include/mapnik/datasource.hpp
Log:
make params_ accessible from derived classes



Modified: trunk/include/mapnik/datasource.hpp
===================================================================
--- trunk/include/mapnik/datasource.hpp	2006-11-29 12:27:29 UTC (rev 391)
+++ trunk/include/mapnik/datasource.hpp	2006-11-29 12:28:17 UTC (rev 392)
@@ -66,7 +66,6 @@
     
     class MAPNIK_DECL datasource : private boost::noncopyable
     {
-        parameters params_;
     public:        
         enum {
             Vector,
@@ -87,6 +86,8 @@
         virtual Envelope<double> envelope() const=0;
         virtual layer_descriptor get_descriptor() const=0;
         virtual ~datasource() {};
+    protected:
+        parameters params_;
     };
     
     typedef std::string datasource_name();



