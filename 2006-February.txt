From pavlenko at berlios.de  Wed Feb  1 00:12:49 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Wed, 1 Feb 2006 00:12:49 +0100
Subject: [Mapnik-svn] r133 - trunk/agg
Message-ID: <200601312312.k0VNCnMO006208@sheep.berlios.de>

Author: pavlenko
Date: 2006-02-01 00:12:49 +0100 (Wed, 01 Feb 2006)
New Revision: 133

Added:
   trunk/agg/copying
Log:
new build system

Added: trunk/agg/copying
===================================================================
--- trunk/agg/copying	2006-01-31 23:09:52 UTC (rev 132)
+++ trunk/agg/copying	2006-01-31 23:12:49 UTC (rev 133)
@@ -0,0 +1,11 @@
+The Anti-Grain Geometry Project
+A high quality rendering engine for C++
+http://antigrain.com
+
+Anti-Grain Geometry - Version 2.3 
+Copyright (C) 2002-2005 Maxim Shemanarev (McSeem) 
+
+Permission to copy, use, modify, sell and distribute this software 
+is granted provided this copyright notice appears in all copies. 
+This software is provided "as is" without express or implied
+warranty, and with no claim as to its suitability for any purpose.



From pavlenko at berlios.de  Wed Feb  1 00:18:25 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Wed, 1 Feb 2006 00:18:25 +0100
Subject: [Mapnik-svn] r134 - trunk
Message-ID: <200601312318.k0VNIPwR007074@sheep.berlios.de>

Author: pavlenko
Date: 2006-02-01 00:18:24 +0100 (Wed, 01 Feb 2006)
New Revision: 134

Modified:
   trunk/SConstruct
Log:
new build system

Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2006-01-31 23:12:49 UTC (rev 133)
+++ trunk/SConstruct	2006-01-31 23:18:24 UTC (rev 134)
@@ -1,110 +1,158 @@
 #  This file is part of Mapnik (c++ mapping toolkit)
-#  Copyright (C) 2005 Artem Pavlenko
+#  Copyright (C) 2005 Artem Pavlenko, Jean-Francois Doyon
 #
 #  Mapnik is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU General Public License
 #  as published by the Free Software Foundation; either version 2
 #  of the License, or any later version.
-# 
+#
 #  This program is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 #  GNU General Public License for more details.
-# 
+#
 #  You should have received a copy of the GNU General Public License
 #  along with this program; if not, write to the Free Software
 #  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-# 
+#
 # $Id$
 
-import os
+import os, sys
 
-#edit 'settings.py' to match your system settings
-opts = Options('settings.py')
+opts = Options()
 
-opts.Add('PREFIX', 'Set the install "prefix"', '/opt/mapnik')
-opts.Add(PathOption('BOOST_ROOT','boost source root directory','/opt/boost'))
-opts.Add(PathOption('AGG_ROOT','agg source root directory','/opt/agg23'))
-opts.Add(PathOption('FREETYPE2_ROOT','freetype2 root directory','/opt/freetype2'))
-opts.Add(PathOption('PYTHON_ROOT','python root directory','/opt/python'))
-opts.Add('PYTHON_VERSION','python version','2.4')
-opts.Add(ListOption('DATASOURCES','list of available datasources','all',['postgis','shape','raster'])) 
-opts.Add(ListOption('EXTENSIONS','list of available extensions','none',['python']))
-opts.Add('POSTGRESQL_ROOT','path to postgresql prefix','/usr/local')
-    
-platform = ARGUMENTS.get("OS",Platform())
+opts.Add('PREFIX', 'The install path "prefix"', '/usr/local')
+opts.Add(PathOption('BOOST_INCLUDES', 'Search path for boost include files', '/usr/include'))
+opts.Add(PathOption('BOOST_LIBS', 'Search path for boost library files', '/usr/lib'))
+opts.Add(PathOption('FREETYPE_INCLUDES', 'Search path for FreeType include files', '/usr/include'))
+opts.Add(PathOption('FREETYPE_LIBS', 'Search path for FreeType library files', '/usr/lib'))
+opts.Add(PathOption('PNG_INCLUDES', 'Search path for libpng include files', '/usr/include'))
+opts.Add(PathOption('PNG_LIBS', 'Search path for libpng include files', '/usr/lib'))
+opts.Add(PathOption('JPEG_INCLUDES', 'Search path for libjpeg include files', '/usr/include'))
+opts.Add(PathOption('JPEG_LIBS', 'Search path for libjpeg library files', '/usr/lib'))
+opts.Add(PathOption('TIFF_INCLUDES', 'Search path for libtiff include files', '/usr/include'))
+opts.Add(PathOption('TIFF_LIBS', 'Search path for libtiff library files', '/usr/lib'))
+opts.Add(PathOption('PGSQL_INCLUDES', 'Search path for PostgreSQL include files', '/usr/include'))
+opts.Add(PathOption('PGSQL_LIBS', 'Search path for PostgreSQL library files', '/usr/lib'))
+opts.Add(PathOption('PYTHON','Python executable','/usr/local/bin/python2.4'))
+opts.Add(ListOption('INPUT_PLUGINS','Input drivers to include','all',['postgis','shape','raster']))
+opts.Add(ListOption('BINDINGS','Language bindings to build','all',['python']))
 
-build_dir = 'build'
-build_prefix = build_dir+'/'+str(platform)
+env = Environment(ENV=os.environ, options=opts)
 
-#cxx = 'g++'
+Help(opts.GenerateHelpText(env))
 
-env = Environment(ENV=os.environ, options=opts)
+conf = Configure(env)
 
-cxx_debug='-Wall -Wno-non-virtual-dtor -Wno-ctor-dtor-privacy -ftemplate-depth-100 -O0 -fno-inline -g -pthread -DDEBUG'
-cxx_release='-Wall -Wno-non-virtual-dtor -Wno-ctor-dtor-privacy -ftemplate-depth-100 -O3 -finline-functions -Wno-inline -pthread -DNDEBUG '
+# Libraries and headers dependency checks
 
-#release_env = env.Copy(CXXFLAGS = cxx_release)
-#debug_env = env.Copy(CXXFLAGS = cxx_debug)
+env['CPPPATH'] = ['#agg/include', '#include']
 
-if ARGUMENTS.get('debug',0):
-    env.Append(CXXFLAGS = cxx_debug)
-    build_prefix+='/debug'
-else:
-    env.Append(CXXFLAGS = cxx_release)
-    build_prefix+='/release'
+for path in [env['BOOST_INCLUDES'], env['FREETYPE_INCLUDES'], env['PNG_INCLUDES'], env['JPEG_INCLUDES'], env['TIFF_INCLUDES'], env['PGSQL_INCLUDES']]:
+    if path not in env['CPPPATH']: env['CPPPATH'].append(path)
 
-Help(opts.GenerateHelpText(env))
+env['LIBPATH'] = ['#agg', '#src']
 
-conf = Configure(env)
+for path in [env['BOOST_LIBS'], env['FREETYPE_LIBS'], env['PNG_LIBS'], env['JPEG_LIBS'], env['TIFF_LIBS'], env['PGSQL_LIBS']]:
+    if path not in env['LIBPATH']: env['LIBPATH'].append(path)
 
-if not conf.CheckLibWithHeader('ltdl','ltdl.h','C'):
-    print 'Could not find libltdl/headers , exiting!'
-    Exit(1)
+C_LIBSHEADERS = [
+    ['ltdl', 'ltdl.h', True],
+    ['png', 'png.h', True],
+    ['tiff', 'tiff.h', True],
+    ['z', 'zlib.h', True],
+    ['jpeg', ['stdio.h','jpeglib.h'], True],
+    ['pq', 'libpq-fe.h', False]
+]
 
-if not conf.CheckLib('z'):
-    print 'Could not find libz , exiting!'
-    Exit(1)
+BOOST_LIBSHEADERS = [
+    ['thread', 'boost/thread/mutex.hpp', True],
+    ['filesystem', 'boost/filesystem/operations.hpp', True],
+    ['wserialization', ['boost/archive/text_oarchive.hpp',
+                        'boost/archive/text_iarchive.hpp',
+                        'boost/archive/xml_oarchive.hpp',
+                        'boost/archive/xml_iarchive.hpp'], True
+    ],
+    ['regex', 'boost/regex.hpp', True],
+    ['program_options', 'boost/program_options.hpp', False]
+]
 
-if not conf.CheckLibWithHeader('png','png.h','C'):
-    print 'Could not find png lib and/or headers, exiting!'
-    Exit(1)
+for libinfo in C_LIBSHEADERS:
+    if not conf.CheckLibWithHeader(libinfo[0], libinfo[1], 'C') and libinfo[2]:
+        print 'Could not find header or shared library for %s, exiting!' % libinfo[0]
+        Exit(1)
 
-if not conf.CheckLib('jpeg'):
-    print 'Could not find jpeg lib, exiting!'
-    Exit(1)
-    
-if not conf.CheckLibWithHeader('tiff','tiff.h','C'):
-    print 'Could not find tiff lib and/or headers, exiting!'
-    Exit(1)
-    
-env  = conf.Finish()
+for libinfo in BOOST_LIBSHEADERS:
+    if not conf.CheckLibWithHeader('boost_%s' % libinfo[0], libinfo[1], 'C++'):
+        if not conf.CheckLibWithHeader('boost_%s-%s-mt' % (libinfo[0], env['CC']), libinfo[1], 'C++') and libinfo[2]:
+            print 'Could not find header or shared library for boost %s, exiting!' % libinfo[0]
+            Exit(1)
 
+# Check out the Python situation
+
+if 'python' in env['BINDINGS']:
+    if not os.access(env['PYTHON'], os.X_OK):
+        print 'Cannot run python, make sure that you have the permissions to execute it.'
+        Exit(1)
+
+    env['PYTHON_PREFIX'] = os.popen("%s -c 'import sys; print sys.prefix'" % env['PYTHON']).read().strip()
+    env['PYTHON_VERSION'] = os.popen("%s -c 'import sys; print sys.version'" % env['PYTHON']).read()[0:3]
+
+    print 'Bindings Python version... %s' % env['PYTHON_VERSION']
+
+    majver, minver = env['PYTHON_VERSION'].split('.')
+
+    if int(majver) > 1:
+        if int(minver) < 3:
+           print "Python version 2.2 or greater required"
+           Exit(1)
+    else:
+        print "Python version 2.2 or greater required"
+        Exit(1)
+
+    print 'Python %s prefix... %s' % (env['PYTHON_VERSION'], env['PYTHON_PREFIX'])
+
+env = conf.Finish()
+
+# Setup the c++ args for our own codebase
+
+if ARGUMENTS.get('DEBUG',0):
+    env.Append(CXXFLAGS = '-Wall -ftemplate-depth-100 -O0 -fno-inline -g -pthread -DDEBUG')
+else:
+    env.Append(CXXFLAGS = '-Wall -ftemplate-depth-100 -O3 -finline-functions -Wno-inline -pthread -DNDEBUG')
+
+# Build the input plug-ins
+
+inputplugins = [ driver.strip() for driver in Split(env['INPUT_PLUGINS'])]
+
 Export('env')
-#build agg lib
-env.SConscript('agg/SConscript')
-#build boost libs (filesystem, regex, python etc)
-env.SConscript('boost/SConscript')
-#main lib
-SConscript('src/SConscript')
 
-import string
+# Build agg first, doesn't need anything special
 
-#python bindings
+SConscript('agg/SConscript')
 
-if 'python' in [string.strip(m) for m in Split(env['EXTENSIONS'])]:
-    SConscript('python/SConscript')
+# Build shapeindex and remove it's dependency from the LIBS
 
-#shapeindex
-SConscript('util/shapeindex/SConscript')
+if 'boost_program_options' in env['LIBS'] or 'boost_program_options-gcc-mt' in env['LIBS']:
+    SConscript('utils/shapeindex/SConscript')
 
-#datasources
-def build_datasource(name):
-    env.BuildDir('build/datasources/' + name,'src/datasources/'+name,duplicate=0)
-    SConscript('datasources/' + name + '/SConscript')
-    
-[build_datasource(name) for name in Split(env['DATASOURCES'])]
+if 'postgis' in inputplugins and 'pq' in env['LIBS']:
+    SConscript('plugins/input/postgis/SConscript')
+    env['LIBS'].remove('pq')
 
+if 'shape' in inputplugins:
+    SConscript('plugins/input/shape/SConscript')
 
+if 'raster' in inputplugins:
+    SConscript('plugins/input/raster/SConscript')
 
+# Build the core library
 
+SConscript('src/SConscript')
+
+# Build python bindings
+
+bindings = [ binding.strip() for binding in Split(env['BINDINGS'])]
+
+if 'python' in bindings:
+    SConscript('bindings/python/SConscript')



From pavlenko at berlios.de  Wed Feb  1 00:20:24 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Wed, 1 Feb 2006 00:20:24 +0100
Subject: [Mapnik-svn] r135 - trunk/agg
Message-ID: <200601312320.k0VNKOh3007212@sheep.berlios.de>

Author: pavlenko
Date: 2006-02-01 00:20:23 +0100 (Wed, 01 Feb 2006)
New Revision: 135

Modified:
   trunk/agg/SConscript
Log:
new build system

Modified: trunk/agg/SConscript
===================================================================
--- trunk/agg/SConscript	2006-01-31 23:18:24 UTC (rev 134)
+++ trunk/agg/SConscript	2006-01-31 23:20:23 UTC (rev 135)
@@ -1,29 +1,24 @@
 #  This file is part of Mapnik (c++ mapping toolkit)
-#  Copyright (C) 2005 Artem Pavlenko
+#  Copyright (C) 2005 Artem Pavlenko, Jean-Francois Doyon
 #
 #  Mapnik is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU General Public License
 #  as published by the Free Software Foundation; either version 2
 #  of the License, or any later version.
-# 
+#
 #  This program is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 #  GNU General Public License for more details.
-# 
+#
 #  You should have received a copy of the GNU General Public License
 #  along with this program; if not, write to the Free Software
 #  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-# 
+#
 # $Id$
 
 import glob
 
 Import('env')
-prefix = env['PREFIX']
-agg_root = env['AGG_ROOT']
-agg_headers = agg_root + '/include'
-agg_src_dir = agg_root + '/src/' 
-agg_src = glob.glob(agg_src_dir + '*.cpp')
-agg_lib = env.StaticLibrary('libagg',agg_src,LIBS=[],CPPPATH=agg_headers)
-env.Install(prefix+'/lib',agg_lib)
+
+env.StaticLibrary('agg', glob.glob('./src/' + '*.cpp'), LIBS=[], CPPPATH='./include', CXXFLAGS='-O3')



From pavlenko at berlios.de  Wed Feb  1 10:15:33 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Wed, 1 Feb 2006 10:15:33 +0100
Subject: [Mapnik-svn] r136 - tags
Message-ID: <200602010915.k119FXhv000893@sheep.berlios.de>

Author: pavlenko
Date: 2006-02-01 10:15:32 +0100 (Wed, 01 Feb 2006)
New Revision: 136

Added:
   tags/release-0.2.5a/
Log:
tagging release-0.2.5a

Copied: tags/release-0.2.5a (from rev 135, trunk)



From pavlenko at berlios.de  Wed Feb  1 10:31:03 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Wed, 1 Feb 2006 10:31:03 +0100
Subject: [Mapnik-svn] r137 - trunk
Message-ID: <200602010931.k119V3lS002606@sheep.berlios.de>

Author: pavlenko
Date: 2006-02-01 10:31:03 +0100 (Wed, 01 Feb 2006)
New Revision: 137

Removed:
   trunk/python/
Log:
removed python dir (now in bindings)



From jdoyon at berlios.de  Wed Feb  1 16:08:34 2006
From: jdoyon at berlios.de (jdoyon at BerliOS)
Date: Wed, 1 Feb 2006 16:08:34 +0100
Subject: [Mapnik-svn] r138 - trunk
Message-ID: <200602011508.k11F8YUq010383@sheep.berlios.de>

Author: jdoyon
Date: 2006-02-01 16:08:33 +0100 (Wed, 01 Feb 2006)
New Revision: 138

Modified:
   trunk/AUTHORS
Log:
dded myself to the AUTHORS list, as a test to see if I can finally commit :)



Modified: trunk/AUTHORS
===================================================================
--- trunk/AUTHORS	2006-02-01 09:31:03 UTC (rev 137)
+++ trunk/AUTHORS	2006-02-01 15:08:33 UTC (rev 138)
@@ -1,3 +1,2 @@
 Artem Pavlenko <pavlenko at users.berlios.de>
-
-
+Jean-Francois Doyon <jfdoyon at gmail.com>



From pavlenko at berlios.de  Sat Feb  4 22:30:08 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Sat, 4 Feb 2006 22:30:08 +0100
Subject: [Mapnik-svn] r139 - in trunk/agg: include src
Message-ID: <200602042130.k14LU8qr016876@sheep.berlios.de>

Author: pavlenko
Date: 2006-02-04 22:30:08 +0100 (Sat, 04 Feb 2006)
New Revision: 139

Modified:
   trunk/agg/include/agg_basics.h
   trunk/agg/include/agg_math_stroke.h
   trunk/agg/include/agg_rasterizer_compound_aa.h
   trunk/agg/include/agg_rasterizer_scanline_aa.h
   trunk/agg/include/agg_vpgen_clip_polyline.h
   trunk/agg/src/agg_vpgen_clip_polyline.cpp
Log:
updated agg-2.4



Modified: trunk/agg/include/agg_basics.h
===================================================================
--- trunk/agg/include/agg_basics.h	2006-02-01 15:08:33 UTC (rev 138)
+++ trunk/agg/include/agg_basics.h	2006-02-04 21:30:08 UTC (rev 139)
@@ -193,6 +193,13 @@
         poly_subpixel_mask  = poly_subpixel_scale-1,  //----poly_subpixel_mask 
     };
 
+    //----------------------------------------------------------filling_rule_e
+    enum filling_rule_e
+    {
+        fill_non_zero,
+        fill_even_odd
+    };
+
     //-----------------------------------------------------------------------pi
     const double pi = 3.14159265358979323846;
 

Modified: trunk/agg/include/agg_math_stroke.h
===================================================================
--- trunk/agg/include/agg_math_stroke.h	2006-02-01 15:08:33 UTC (rev 138)
+++ trunk/agg/include/agg_math_stroke.h	2006-02-04 21:30:08 UTC (rev 139)
@@ -38,9 +38,9 @@
     {
         miter_join         = 0,
         miter_join_revert  = 1,
-        miter_join_round   = 4,
         round_join         = 2,
-        bevel_join         = 3
+        bevel_join         = 3,
+        miter_join_round   = 4
     };
 
 
@@ -71,14 +71,6 @@
         double a2 = atan2(dy2, dx2);
         double da = a1 - a2;
 
-        //  Possible optimization. Not important at all; consumes time but happens rarely
-        //if(fabs(da) < stroke_theta)
-        //{
-        //    out_vertices.add(coord_type((x + x + dx1 + dx2) * 0.5, 
-        //                                (y + y + dy1 + dy2) * 0.5));
-        //    return;
-        //}
-
         bool ccw = da > 0.0 && da < pi;
 
         if(width < 0) width = -width;
@@ -280,6 +272,7 @@
         typedef typename VertexConsumer::value_type coord_type;
 
         double dx1, dy1, dx2, dy2;
+        double d;
 
         dx1 = width * (v1.y - v0.y) / len1;
         dy1 = width * (v1.x - v0.x) / len1;
@@ -312,7 +305,7 @@
             case inner_jag:
             case inner_round:
                 {
-                    double d = (dx1-dx2) * (dx1-dx2) + (dy1-dy2) * (dy1-dy2);
+                    d = (dx1-dx2) * (dx1-dx2) + (dy1-dy2) * (dy1-dy2);
                     if(d < len1 * len1 && d < len2 * len2)
                     {
                         stroke_calc_miter(out_vertices,
@@ -349,6 +342,34 @@
         {
             // Outer join
             //---------------
+            if(line_join == round_join || line_join == bevel_join)
+            {
+                // This is an optimization that reduces the number of points 
+                // in cases of almost collonear segments. If there's no
+                // visible difference between bevel and miter joins we'd rather
+                // use miter join because it adds only one point instead of two. 
+                //
+                // Here we calculate the middle point between the bevel points 
+                // and then, the distance between v1 and this middle point. 
+                // At outer joins this distance always less than stroke width, 
+                // because it's actually the height of an isosceles triangle of
+                // v1 and its two bevel points. If the difference between this
+                // width and this value is small (no visible bevel) we can switch
+                // to the miter join. 
+                //
+                // The constant in the expression makes the result approximately 
+                // the same as in round joins and caps. One can safely comment 
+                // out this "if".
+                //-------------------
+                double dx = (dx1 + dx2) / 2;
+                double dy = (dy1 + dy2) / 2;
+                d = width - sqrt(dx * dx + dy * dy);
+                if(d < 0.0625 / approximation_scale)
+                {
+                    line_join = miter_join;
+                }
+            }
+
             switch(line_join)
             {
             case miter_join:

Modified: trunk/agg/include/agg_rasterizer_compound_aa.h
===================================================================
--- trunk/agg/include/agg_rasterizer_compound_aa.h	2006-02-01 15:08:33 UTC (rev 138)
+++ trunk/agg/include/agg_rasterizer_compound_aa.h	2006-02-04 21:30:08 UTC (rev 139)
@@ -93,13 +93,16 @@
         {
             aa_shift  = 8,
             aa_scale  = 1 << aa_shift,
-            aa_mask   = aa_scale - 1
+            aa_mask   = aa_scale - 1,
+            aa_scale2 = aa_scale * 2,
+            aa_mask2  = aa_scale2 - 1
         };
 
         //--------------------------------------------------------------------
         rasterizer_compound_aa() : 
             m_outline(),
             m_clipper(),
+            m_filling_rule(fill_non_zero),
             m_styles(),  // Active Styles
             m_ast(),     // Active Style Table (unique values)
             m_asm(),     // Active Style Mask 
@@ -113,6 +116,7 @@
         void reset(); 
         void reset_clipping();
         void clip_box(double x1, double y1, double x2, double y2);
+        void filling_rule(filling_rule_e filling_rule);
 
         //--------------------------------------------------------------------
         void styles(int left, int right);
@@ -161,6 +165,14 @@
         {
             int cover = area >> (poly_subpixel_shift*2 + 1 - aa_shift);
             if(cover < 0) cover = -cover;
+            if(m_filling_rule == fill_even_odd)
+            {
+                cover &= aa_mask2;
+                if(cover > aa_scale)
+                {
+                    cover = aa_scale2 - cover;
+                }
+            }
             if(cover > aa_mask) cover = aa_mask;
             return cover;
         }
@@ -229,6 +241,7 @@
     private:
         rasterizer_cells_aa<cell_style_aa> m_outline;
         clip_type              m_clipper;
+        filling_rule_e         m_filling_rule;
         pod_vector<style_info> m_styles;  // Active Styles
         pod_vector<unsigned>   m_ast;     // Active Style Table (unique values)
         pod_vector<int8u>      m_asm;     // Active Style Mask 
@@ -260,6 +273,13 @@
 
     //------------------------------------------------------------------------
     template<class Clip> 
+    void rasterizer_compound_aa<Clip>::filling_rule(filling_rule_e filling_rule) 
+    { 
+        m_filling_rule = filling_rule; 
+    }
+
+    //------------------------------------------------------------------------
+    template<class Clip> 
     void rasterizer_compound_aa<Clip>::clip_box(double x1, double y1, 
                                                 double x2, double y2)
     {

Modified: trunk/agg/include/agg_rasterizer_scanline_aa.h
===================================================================
--- trunk/agg/include/agg_rasterizer_scanline_aa.h	2006-02-01 15:08:33 UTC (rev 138)
+++ trunk/agg/include/agg_rasterizer_scanline_aa.h	2006-02-04 21:30:08 UTC (rev 139)
@@ -65,14 +65,7 @@
         }
     };
 
-    //----------------------------------------------------------filling_rule_e
-    enum filling_rule_e
-    {
-        fill_non_zero,
-        fill_even_odd
-    };
 
-
     //==================================================rasterizer_scanline_aa
     // Polygon rasterizer that is used to render filled polygons with 
     // high-quality Anti-Aliasing. Internally, by default, the class uses 

Modified: trunk/agg/include/agg_vpgen_clip_polyline.h
===================================================================
--- trunk/agg/include/agg_vpgen_clip_polyline.h	2006-02-01 15:08:33 UTC (rev 138)
+++ trunk/agg/include/agg_vpgen_clip_polyline.h	2006-02-04 21:30:08 UTC (rev 139)
@@ -32,12 +32,9 @@
             m_clip_box(0, 0, 1, 1),
             m_x1(0),
             m_y1(0),
-            m_f1(0),
-            m_x2(0),
-            m_y2(0),
-            m_f2(0),
             m_num_vertices(0),
-            m_vertex(0)
+            m_vertex(0),
+            m_move_to(false)
         {
         }
 
@@ -50,7 +47,6 @@
             m_clip_box.normalize();
         }
 
-
         double x1() const { return m_clip_box.x1; }
         double y1() const { return m_clip_box.y1; }
         double x2() const { return m_clip_box.x2; }
@@ -65,54 +61,15 @@
         unsigned vertex(double* x, double* y);
 
     private:
-        enum clipping_flags_def
-        {
-            clip_x1 = 1,
-            clip_x2 = 2,
-            clip_y1 = 4,
-            clip_y2 = 8
-        };
-
-        // Determine the clipping code of the vertex according to the 
-        // Cyrus-Beck line clipping algorithm
-        //--------------------------------------------------------------------
-        unsigned clipping_flags_x(double x)
-        {
-            unsigned f = 0;
-            if(x < m_clip_box.x1) f |= clip_x1;
-            if(x > m_clip_box.x2) f |= clip_x2;
-            return f;
-        }
-
-        unsigned clipping_flags_y(double y)
-        {
-            unsigned f = 0;
-            if(y < m_clip_box.y1) f |= clip_y1;
-            if(y > m_clip_box.y2) f |= clip_y2;
-            return f;
-        }
-
-        unsigned clipping_flags(double x, double y)
-        {
-            return clipping_flags_x(x) | clipping_flags_y(y);
-        }
-
-        bool move_point(double& x, double& y, unsigned& flags);
-        void clip_line_segment();
-
-    private:
         rect_d        m_clip_box;
         double        m_x1;
         double        m_y1;
-        unsigned      m_f1;
-        double        m_x2;
-        double        m_y2;
-        unsigned      m_f2;
         double        m_x[2];
         double        m_y[2];
         unsigned      m_cmd[2];
         unsigned      m_num_vertices;
         unsigned      m_vertex;
+        bool          m_move_to;
     };
 
 }

Modified: trunk/agg/src/agg_vpgen_clip_polyline.cpp
===================================================================
--- trunk/agg/src/agg_vpgen_clip_polyline.cpp	2006-02-01 15:08:33 UTC (rev 138)
+++ trunk/agg/src/agg_vpgen_clip_polyline.cpp	2006-02-04 21:30:08 UTC (rev 139)
@@ -13,19 +13,17 @@
 //          http://www.antigrain.com
 //----------------------------------------------------------------------------
 
-#include <math.h>
 #include "agg_vpgen_clip_polyline.h"
+#include "agg_clip_liang_barsky.h"
 
 namespace agg
 {
-    static double clip_epsilon = 1e-10;
-
-
     //----------------------------------------------------------------------------
     void vpgen_clip_polyline::reset()
     {
         m_vertex = 0;
         m_num_vertices = 0;
+        m_move_to = false;
     }
 
     //----------------------------------------------------------------------------
@@ -33,99 +31,38 @@
     {
         m_vertex = 0;
         m_num_vertices = 0;
-        m_f1 = clipping_flags(x, y);
-        if(m_f1 == 0)
-        {
-            m_x[0] = x;
-            m_y[0] = y;
-            m_cmd[0] = path_cmd_move_to;
-            m_num_vertices = 1;
-        }
         m_x1 = x;
         m_y1 = y;
+        m_move_to = true;
     }
 
-
     //----------------------------------------------------------------------------
-    bool vpgen_clip_polyline::move_point(double& x, double& y, unsigned& flags)
+    void vpgen_clip_polyline::line_to(double x, double y)
     {
-       double bound;
+        double x2 = x;
+        double y2 = y;
+        unsigned flags = clip_line_segment(&m_x1, &m_y1, &x2, &y2, m_clip_box);
 
-       if(flags & (clip_x1 | clip_x2)) 
-       {
-           bound = (flags & clip_x1) ? m_clip_box.x1 : m_clip_box.x2;
-           y = (bound - m_x1) * (m_y2 - m_y1) / (m_x2 - m_x1) + m_y1;
-           x = bound;
-           flags = clipping_flags_y(y);
-       }
-       if(fabs(m_y2 - m_y1) < clip_epsilon && fabs(m_x2 - m_x1) < clip_epsilon) 
-       {
-           return false;
-       }
-       if(flags & (clip_y1 | clip_y2)) 
-       {
-           bound = (flags & clip_y1) ? m_clip_box.y1 : m_clip_box.y2;
-           x = (bound - m_y1) * (m_x2 - m_x1) / (m_y2 - m_y1) + m_x1;
-           y = bound;
-       }
-       flags = 0;
-       return true;
-    }
-
-    //----------------------------------------------------------------------------
-    void vpgen_clip_polyline::clip_line_segment()
-    {
-        if((m_f1 & m_f2) == 0)
+        m_vertex = 0;
+        m_num_vertices = 0;
+        if((flags & 4) == 0)
         {
-            if(m_f1) 
-            {   
-                if(!move_point(m_x1, m_y1, m_f1)) return;
-                if(m_f1) return;
+            if((flags & 1) != 0 || m_move_to)
+            {
                 m_x[0] = m_x1;
                 m_y[0] = m_y1;
                 m_cmd[0] = path_cmd_move_to;
                 m_num_vertices = 1;
             }
-            if(m_f2) 
-            {                    // Move Point 2
-                if(!move_point(m_x2, m_y2, m_f2)) return;
-            }
-            m_x[m_num_vertices] = m_x2;
-            m_y[m_num_vertices] = m_y2;
+            m_x[m_num_vertices] = x2;
+            m_y[m_num_vertices] = y2;
             m_cmd[m_num_vertices++] = path_cmd_line_to;
+            m_move_to = (flags & 2) != 0;
         }
-    }
-
-
-
-    //----------------------------------------------------------------------------
-    void vpgen_clip_polyline::line_to(double x, double y)
-    {
-        m_vertex = 0;
-        m_num_vertices = 0;
-        unsigned f = m_f2 = clipping_flags(m_x2 = x, m_y2 = y);
-
-        if(m_f2 == m_f1)
-        {
-            if(m_f2 == 0)
-            {
-                m_x[0] = x;
-                m_y[0] = y;
-                m_cmd[0] = path_cmd_line_to;
-                m_num_vertices = 1;
-            }
-        }
-        else
-        {
-            clip_line_segment();
-        }
-
-        m_f1 = f;
         m_x1 = x;
         m_y1 = y;
     }
 
-
     //----------------------------------------------------------------------------
     unsigned vpgen_clip_polyline::vertex(double* x, double* y)
     {
@@ -137,6 +74,4 @@
         }
         return path_cmd_stop;
     }
-
-
 }



From pavlenko at berlios.de  Sun Feb  5 10:45:52 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Sun, 5 Feb 2006 10:45:52 +0100
Subject: [Mapnik-svn] r140 - in trunk: bindings/python include src
Message-ID: <200602050945.k159jqRF028555@sheep.berlios.de>

Author: pavlenko
Date: 2006-02-05 10:45:51 +0100 (Sun, 05 Feb 2006)
New Revision: 140

Removed:
   trunk/include/named_style_cache.hpp
   trunk/src/named_style_cache.cpp
Modified:
   trunk/bindings/python/mapnik_map.cpp
   trunk/bindings/python/mapnik_style.cpp
   trunk/include/map.hpp
   trunk/include/mapnik.hpp
   trunk/include/render.hpp
   trunk/src/SConscript
   trunk/src/map.cpp
   trunk/src/render.cpp
Log:
1.removed named_style_cache
2.styles moved to Map object



Modified: trunk/bindings/python/mapnik_map.cpp
===================================================================
--- trunk/bindings/python/mapnik_map.cpp	2006-02-04 21:30:08 UTC (rev 139)
+++ trunk/bindings/python/mapnik_map.cpp	2006-02-05 09:45:51 UTC (rev 140)
@@ -91,6 +91,8 @@
         .def("pan",&Map::pan)
         .def("zoom",&Map::zoom)
         .def("pan_and_zoom",&Map::pan_and_zoom)
+	.def("append_style",&Map::insert_style)
+	.def("remove_style",&Map::remove_style)
 	.add_property("layers",make_function
 		      (&Map::layers,return_value_policy<reference_existing_object>()))
         .def_pickle(map_pickle_suite())

Modified: trunk/bindings/python/mapnik_style.cpp
===================================================================
--- trunk/bindings/python/mapnik_style.cpp	2006-02-04 21:30:08 UTC (rev 139)
+++ trunk/bindings/python/mapnik_style.cpp	2006-02-05 09:45:51 UTC (rev 140)
@@ -23,9 +23,6 @@
 #include "mapnik.hpp"
 
 using mapnik::feature_type_style;
-using mapnik::named_style_cache;
-using mapnik::singleton;
-using mapnik::CreateStatic;
 using mapnik::rules;
 
 void export_style()
@@ -40,18 +37,5 @@
 		      (&feature_type_style::get_rules,return_value_policy<reference_existing_object>()))
 	;
     
-    class_<singleton<named_style_cache,CreateStatic>,boost::noncopyable>("singleton",no_init)
-    	.def("instance",&singleton<named_style_cache,CreateStatic>::instance,
-    	     return_value_policy<reference_existing_object>())
-    	.staticmethod("instance")
-    	;
-    
-    class_<named_style_cache,bases<singleton<named_style_cache,CreateStatic> >,
-	boost::noncopyable>("style_cache",no_init)
-	.def("insert",&named_style_cache::insert)
-	.staticmethod("insert")
-	.def("remove",&named_style_cache::remove)
-	.staticmethod("remove")
-	;
 }
 

Modified: trunk/include/map.hpp
===================================================================
--- trunk/include/map.hpp	2006-02-04 21:30:08 UTC (rev 139)
+++ trunk/include/map.hpp	2006-02-05 09:45:51 UTC (rev 140)
@@ -23,6 +23,7 @@
 
 #include <boost/serialization/serialization.hpp>
 #include <boost/serialization/vector.hpp>
+#include "feature_type_style.hpp"
 
 namespace mapnik
 {
@@ -46,6 +47,7 @@
 	unsigned height_;
 	int srid_;
 	Color background_;
+	std::map<std::string,feature_type_style> styles_;
 	std::vector<Layer> layers_;
 	Envelope<double> currentExtent_;
     public:
@@ -53,11 +55,15 @@
 	Map(int width,int height,int srid=-1);
 	Map(const Map& rhs);
 	Map& operator=(const Map& rhs);
+
+	bool insert_style(std::string const& name,feature_type_style const& style);
+	void remove_style(const std::string& name);
+	feature_type_style find_style(std::string const& name) const;
+	
 	size_t layerCount() const;
 	void addLayer(const Layer& l);
 	const Layer& getLayer(size_t index) const;
 	void removeLayer(size_t index);
-	void removeLayer(const char* lName);
 	std::vector<Layer> const& layers() const;
 	unsigned getWidth() const;
 	unsigned getHeight() const;

Modified: trunk/include/mapnik.hpp
===================================================================
--- trunk/include/mapnik.hpp	2006-02-04 21:30:08 UTC (rev 139)
+++ trunk/include/mapnik.hpp	2006-02-05 09:45:51 UTC (rev 140)
@@ -56,7 +56,6 @@
 #include "wkb.hpp"
 #include "map.hpp"
 #include "feature_type_style.hpp"
-#include "named_style_cache.hpp"
 #include "feature_factory.hpp"
 #include "math_expr.hpp"
 #include "value.hpp"

Deleted: trunk/include/named_style_cache.hpp
===================================================================
--- trunk/include/named_style_cache.hpp	2006-02-04 21:30:08 UTC (rev 139)
+++ trunk/include/named_style_cache.hpp	2006-02-05 09:45:51 UTC (rev 140)
@@ -1,47 +0,0 @@
-/* This file is part of Mapnik (c++ mapping toolkit)
- * Copyright (C) 2005 Artem Pavlenko
- *
- * Mapnik is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- */
-
-//$Id: style_cache.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef STYLE_CACHE_HPP
-#define STYLE_CACHE_HPP
-
-#include "utils.hpp"
-#include <map>
-#include "feature_type_style.hpp"
-
-namespace mapnik {
-      
-    class named_style_cache : public singleton <named_style_cache,CreateStatic>
-    {
-	friend class CreateStatic<named_style_cache>;
-    private:
-	static std::map<std::string,feature_type_style> styles_;  
-	named_style_cache();
-	~named_style_cache();
-	named_style_cache(const named_style_cache&);
-	named_style_cache& operator=(const named_style_cache&);
-    public:
-	static bool insert(const std::string& name,const feature_type_style& style);
-	static void remove(const std::string& name);
-	static feature_type_style find(const std::string& name);
-    }; 
-}
-
-
-#endif //STYLE_CACHE_HPP

Modified: trunk/include/render.hpp
===================================================================
--- trunk/include/render.hpp	2006-02-04 21:30:08 UTC (rev 139)
+++ trunk/include/render.hpp	2006-02-05 09:45:51 UTC (rev 140)
@@ -36,7 +36,7 @@
 	static void render(const Map& map,Image& image);
     private:
 	Renderer();
-	static void render_vector_layer(datasource_p const& ds,
+	static void render_vector_layer(datasource_p const& ds,Map const& map,
 					std::vector<std::string> const& , 
 					unsigned width,
 					unsigned height,

Modified: trunk/src/SConscript
===================================================================
--- trunk/src/SConscript	2006-02-04 21:30:08 UTC (rev 139)
+++ trunk/src/SConscript	2006-02-05 09:45:51 UTC (rev 140)
@@ -41,7 +41,6 @@
     plugin.cpp
     png_reader.cpp
     render.cpp
-    named_style_cache.cpp
     text.cpp
     tiff_reader.cpp
     wkb.cpp

Modified: trunk/src/map.cpp
===================================================================
--- trunk/src/map.cpp	2006-02-04 21:30:08 UTC (rev 139)
+++ trunk/src/map.cpp	2006-02-05 09:45:51 UTC (rev 140)
@@ -37,12 +37,13 @@
 
     Map::Map(const Map& rhs)
         : width_(rhs.width_),
-        height_(rhs.height_),
-        srid_(rhs.srid_),
-        background_(rhs.background_),
-        layers_(rhs.layers_),
-        currentExtent_(rhs.currentExtent_) {}
-
+	  height_(rhs.height_),
+	  srid_(rhs.srid_),
+	  background_(rhs.background_),
+	  styles_(rhs.styles_),
+	  layers_(rhs.layers_),
+	  currentExtent_(rhs.currentExtent_) {}
+    
     Map& Map::operator=(const Map& rhs)
     {
         if (this==&rhs) return *this;
@@ -50,15 +51,34 @@
         height_=rhs.height_;
         srid_=rhs.srid_;
         background_=rhs.background_;
+	styles_=rhs.styles_;
         layers_=rhs.layers_;
         return *this;
     }
 
+    bool Map::insert_style(std::string const& name,feature_type_style const& style) 
+    {
+	return styles_.insert(make_pair(name,style)).second;
+    }
+    
+    void Map::remove_style(std::string const& name) 
+    {
+	styles_.erase(name);
+    }
+    
+    feature_type_style Map::find_style(std::string const& name) const
+    {
+	std::map<std::string,feature_type_style>::const_iterator itr=styles_.find(name);
+	if (itr!=styles_.end()) 
+	    return itr->second;
+	return feature_type_style();
+    }
+    
     size_t Map::layerCount() const
     {
         return layers_.size();
     }
-
+    
     void Map::addLayer(const Layer& l)
     {
         layers_.push_back(l);
@@ -67,10 +87,7 @@
     {
         layers_.erase(layers_.begin()+index);
     }
-    void Map::removeLayer(const char* lName)
-    {
-        //todo
-    }
+
     const Layer& Map::getLayer(size_t index) const
     {
         return layers_[index];

Deleted: trunk/src/named_style_cache.cpp
===================================================================
--- trunk/src/named_style_cache.cpp	2006-02-04 21:30:08 UTC (rev 139)
+++ trunk/src/named_style_cache.cpp	2006-02-05 09:45:51 UTC (rev 140)
@@ -1,53 +0,0 @@
-/* This file is part of Mapnik (c++ mapping toolkit)
- * Copyright (C) 2005 Artem Pavlenko
- *
- * Mapnik is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- */
-
-//$Id: style_cache.cpp 37 2005-04-07 17:09:38Z pavlenko $
-
-#include "named_style_cache.hpp"
-#include <boost/thread/mutex.hpp>
-
-namespace mapnik 
-{
-    named_style_cache::named_style_cache() {}
-    named_style_cache::~named_style_cache() {}
-    
-    std::map<std::string,feature_type_style> named_style_cache::styles_;
-
-    bool named_style_cache::insert(const std::string& name,const feature_type_style& style) 
-    {
-	mutex::scoped_lock lock(mutex_);
-	return styles_.insert(make_pair(name,style)).second;
-    }
-    
-    void named_style_cache::remove(const std::string& name) 
-    {
-	mutex::scoped_lock lock(mutex_);
-	styles_.erase(name);
-    }
-    
-    feature_type_style named_style_cache::find(const std::string& name)
-    {
-	mutex::scoped_lock lock(mutex_);
-	std::map<std::string,feature_type_style>::iterator itr=styles_.find(name);
-	if (itr!=styles_.end()) 
-	{
-	    return itr->second;
-	}
-	return feature_type_style();
-    }
-}

Modified: trunk/src/render.cpp
===================================================================
--- trunk/src/render.cpp	2006-02-04 21:30:08 UTC (rev 139)
+++ trunk/src/render.cpp	2006-02-05 09:45:51 UTC (rev 140)
@@ -21,7 +21,6 @@
 #include "render.hpp"
 #include "image_util.hpp"
 #include "utils.hpp"
-#include "named_style_cache.hpp"
 #include "symbolizer.hpp"
 #include "query.hpp"
 #include "feature_layer_desc.hpp"
@@ -36,7 +35,7 @@
 {  
     
     template <typename Image>
-    void Renderer<Image>::render_vector_layer(datasource_p const& ds,
+    void Renderer<Image>::render_vector_layer(datasource_p const& ds,Map const& map,
 					      std::vector<std::string> const& namedStyles,
 					      unsigned width,unsigned height,
 					      const Envelope<double>& bbox,Image& image)
@@ -45,7 +44,7 @@
 	std::vector<std::string>::const_iterator stylesIter=namedStyles.begin();
 	while (stylesIter!=namedStyles.end())
 	{
-	    feature_type_style style=named_style_cache::instance()->find(*stylesIter++);
+	    //feature_type_style style=named_style_cache::instance()->find(*stylesIter++);
 	    
 	    std::set<std::string> names;
 	    attribute_collector<Feature> collector(names);
@@ -56,6 +55,9 @@
 	    std::vector<rule_type*> else_rules;
 	    
 	    bool active_rules=false;
+
+	    feature_type_style style=map.find_style(*stylesIter++);
+
 	    const std::vector<rule_type>& rules=style.get_rules();
 	    std::vector<rule_type>::const_iterator ruleIter=rules.begin();
 	    
@@ -182,7 +184,7 @@
 		if (!ds) continue;
                 if (ds->type() == datasource::Vector)
 		{
-		    render_vector_layer(ds,l.styles(),width,height,extent,image);
+		    render_vector_layer(ds,map,l.styles(),width,height,extent,image);
 		}
 		else if (ds->type() == datasource::Raster)
 		{



From pavlenko at berlios.de  Sun Feb  5 13:31:31 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Sun, 5 Feb 2006 13:31:31 +0100
Subject: [Mapnik-svn] r141 - in trunk: include plugins/input/shape
Message-ID: <200602051231.k15CVVMC010940@sheep.berlios.de>

Author: pavlenko
Date: 2006-02-05 13:31:24 +0100 (Sun, 05 Feb 2006)
New Revision: 141

Modified:
   trunk/include/geometry.hpp
   trunk/include/vertex_vector.hpp
   trunk/plugins/input/shape/shape_io.cpp
Log:
added set_capacity method to geometry classes.
(now we can use std::vector<boost::tuple<value_type,value_type,char> > 
as an alternative vertex storage).
 


Modified: trunk/include/geometry.hpp
===================================================================
--- trunk/include/geometry.hpp	2006-02-05 09:45:51 UTC (rev 140)
+++ trunk/include/geometry.hpp	2006-02-05 12:31:24 UTC (rev 141)
@@ -62,6 +62,7 @@
 	virtual unsigned num_points() const = 0;
 	virtual unsigned vertex(double* x, double* y)=0;
 	virtual void rewind(unsigned )=0;
+	virtual void set_capacity(size_t size)=0;
 	virtual ~geometry() {}
     };
     
@@ -120,6 +121,7 @@
 	{
 	    return false;
 	}
+	void set_capacity(size_t) {}
 	virtual ~point() {}
     };
 
@@ -216,6 +218,10 @@
 	{	    
 	    return false;
 	} 
+	void set_capacity(size_t size) 
+	{
+	    cont_.set_capacity(size);
+	}
 	virtual ~polygon() {}
     };
     
@@ -332,12 +338,17 @@
 	{	    
 	    return false;
 	} 
+	
+	void set_capacity(size_t size) 
+	{
+	    cont_.set_capacity(size);
+	}
 	virtual ~line_string() {}
     };
 
     typedef point<vertex2d> point_impl;
-    typedef line_string<vertex2d,vertex_vector> line_string_impl;
-    typedef polygon<vertex2d,vertex_vector> polygon_impl;
+    typedef line_string<vertex2d,vertex_vector2> line_string_impl;
+    typedef polygon<vertex2d,vertex_vector2> polygon_impl;
     
     typedef geometry<vertex2d> geometry_type;
     typedef boost::shared_ptr<geometry_type> geometry_ptr;

Modified: trunk/include/vertex_vector.hpp
===================================================================
--- trunk/include/vertex_vector.hpp	2006-02-05 09:45:51 UTC (rev 140)
+++ trunk/include/vertex_vector.hpp	2006-02-05 12:31:24 UTC (rev 141)
@@ -115,7 +115,10 @@
 	    ++vertex;
 	    t.forward_y(vertex);
 	}
-	
+	void set_capacity(size_t)
+	{
+	    //do nothing
+	}
     private:
 	void allocate_block(unsigned block)
 	{
@@ -143,9 +146,8 @@
     struct vertex_vector2 : boost::noncopyable
     {
 	typedef typename T::type value_type;
-	typedef boost::tuple<value_type,value_type,char> coord;
+	typedef boost::tuple<value_type,value_type,char> vertex_type;
 	vertex_vector2() {}
-	
 	unsigned size() const 
 	{
 	    return cont_.size();
@@ -153,27 +155,30 @@
 
 	void push_back (value_type x,value_type y,unsigned command)
 	{
-	    cont_.push_back(coord(x,y,command));
+	    cont_.push_back(vertex_type(x,y,command));
 	}
 	unsigned get_vertex(unsigned pos,value_type* x,value_type* y) const
 	{
 	    if (pos >= cont_.size()) return SEG_END;
-	    coord const& c = cont_[pos];
+	    vertex_type const& c = cont_[pos];
 	    *x = boost::get<0>(c);
 	    *y = boost::get<1>(c);
 	    return boost::get<2>(c);
 	}
-
+	
 	void transform_at(unsigned pos,const CoordTransform& t)
 	{
 	    if (pos >= cont_.size()) return;
-	    coord & c = cont_[pos];
+	    vertex_type & c = cont_[pos];
 	    t.forward_x(&boost::get<0>(c));
 	    t.forward_y(&boost::get<1>(c));
 	}
-	
+	void set_capacity(size_t size)
+	{
+	    cont_.reserve(size);
+	}
     private:
-	std::vector<coord> cont_;
+	std::vector<vertex_type> cont_;
     };
 }
 

Modified: trunk/plugins/input/shape/shape_io.cpp
===================================================================
--- trunk/plugins/input/shape/shape_io.cpp	2006-02-05 09:45:51 UTC (rev 140)
+++ trunk/plugins/input/shape/shape_io.cpp	2006-02-05 12:31:24 UTC (rev 141)
@@ -92,9 +92,10 @@
     int num_parts=record.read_ndr_integer();
     int num_points=record.read_ndr_integer();
     geometry_ptr line(new line_string_impl(-1));
-    
+    line->set_capacity(num_points + num_parts);
     if (num_parts == 1)
     {
+	line->set_capacity(num_points + 1);
 	record.skip(4);
 	double x=record.read_double();
 	double y=record.read_double();
@@ -145,7 +146,7 @@
     int num_parts=record.read_ndr_integer();
     int num_points=record.read_ndr_integer();
     geometry_ptr line(new line_string_impl(-1));
-    
+    line->set_capacity(num_points + num_parts);
     if (num_parts == 1)
     {
 	record.skip(4);
@@ -207,7 +208,7 @@
     int num_parts=record.read_ndr_integer();
     int num_points=record.read_ndr_integer();
     geometry_ptr line(new line_string_impl(-1));
-    
+    line->set_capacity(num_points + num_parts);
     if (num_parts == 1)
     {
 	record.skip(4);
@@ -277,7 +278,7 @@
     int num_points=record.read_ndr_integer();
     std::vector<int> parts(num_parts);
     geometry_ptr poly(new polygon_impl(-1));
-    
+    poly->set_capacity(num_points + num_parts);
     for (int i=0;i<num_parts;++i)
     {
         parts[i]=record.read_ndr_integer();
@@ -317,7 +318,7 @@
     int num_points=record.read_ndr_integer();
     std::vector<int> parts(num_parts);
     geometry_ptr poly(new polygon_impl(-1));
-    
+    poly->set_capacity(num_points + num_parts);
     for (int i=0;i<num_parts;++i)
     {
         parts[i]=record.read_ndr_integer();
@@ -365,7 +366,7 @@
     int num_points=record.read_ndr_integer();
     std::vector<int> parts(num_parts);
     geometry_ptr poly(new polygon_impl(-1));
-    
+    poly->set_capacity(num_points + num_parts);
     for (int i=0;i<num_parts;++i)
     {
         parts[i]=record.read_ndr_integer();



From jdoyon at berlios.de  Sun Feb  5 22:01:55 2006
From: jdoyon at berlios.de (jdoyon at BerliOS)
Date: Sun, 5 Feb 2006 22:01:55 +0100
Subject: [Mapnik-svn] r142 - trunk
Message-ID: <200602052101.k15L1toh014272@sheep.berlios.de>

Author: jdoyon
Date: 2006-02-05 22:01:54 +0100 (Sun, 05 Feb 2006)
New Revision: 142

Modified:
   trunk/SConstruct
Log:
Use the current python interpreter as default for building python bindings.

Make the DEBUG option work more consistently, like all other build options.



Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2006-02-05 12:31:24 UTC (rev 141)
+++ trunk/SConstruct	2006-02-05 21:01:54 UTC (rev 142)
@@ -34,9 +34,10 @@
 opts.Add(PathOption('TIFF_LIBS', 'Search path for libtiff library files', '/usr/lib'))
 opts.Add(PathOption('PGSQL_INCLUDES', 'Search path for PostgreSQL include files', '/usr/include'))
 opts.Add(PathOption('PGSQL_LIBS', 'Search path for PostgreSQL library files', '/usr/lib'))
-opts.Add(PathOption('PYTHON','Python executable','/usr/local/bin/python2.4'))
+opts.Add(PathOption('PYTHON','Python executable', sys.executable))
 opts.Add(ListOption('INPUT_PLUGINS','Input drivers to include','all',['postgis','shape','raster']))
 opts.Add(ListOption('BINDINGS','Language bindings to build','all',['python']))
+opts.Add(ListOption('DEBUG', 'Compile a debug version of mapnik', 'no', ['no', 'yes']))
 
 env = Environment(ENV=os.environ, options=opts)
 
@@ -116,7 +117,7 @@
 
 # Setup the c++ args for our own codebase
 
-if ARGUMENTS.get('DEBUG',0):
+if env['DEBUG']:
     env.Append(CXXFLAGS = '-Wall -ftemplate-depth-100 -O0 -fno-inline -g -pthread -DDEBUG')
 else:
     env.Append(CXXFLAGS = '-Wall -ftemplate-depth-100 -O3 -finline-functions -Wno-inline -pthread -DNDEBUG')



From jdoyon at berlios.de  Sun Feb  5 22:04:31 2006
From: jdoyon at berlios.de (jdoyon at BerliOS)
Date: Sun, 5 Feb 2006 22:04:31 +0100
Subject: [Mapnik-svn] r143 - trunk
Message-ID: <200602052104.k15L4VNu014514@sheep.berlios.de>

Author: jdoyon
Date: 2006-02-05 22:04:30 +0100 (Sun, 05 Feb 2006)
New Revision: 143

Modified:
   trunk/INSTALL
Log:
Edit the INSTALL to reflect the changes in the build options.



Modified: trunk/INSTALL
===================================================================
--- trunk/INSTALL	2006-02-05 21:01:54 UTC (rev 142)
+++ trunk/INSTALL	2006-02-05 21:04:30 UTC (rev 143)
@@ -105,8 +105,8 @@
     actual: /usr/lib
 
 PYTHON: Python executable ( /path/to/PYTHON )
-    default: /usr/local/bin/python2.4
-    actual: /usr/local/bin/python2.4
+    default: /usr/bin/python
+    actual: /usr/bin/python
 
 INPUT_PLUGINS: Input drivers to include
     (all|none|comma-separated list of names)
@@ -120,6 +120,12 @@
     default: all
     actual: python
 
+DEBUG: Compile a debug version of mapnik
+    (all|none|comma-separated list of names)
+    allowed names: no yes
+    default: no
+    actual: no
+
 This help should be self-explanatory!
 
 For example, if you compiled your own set of Boost libraries, you might use:



From jdoyon at berlios.de  Sun Feb  5 23:03:44 2006
From: jdoyon at berlios.de (jdoyon at BerliOS)
Date: Sun, 5 Feb 2006 23:03:44 +0100
Subject: [Mapnik-svn] r144 - trunk
Message-ID: <200602052203.k15M3inT021225@sheep.berlios.de>

Author: jdoyon
Date: 2006-02-05 23:03:43 +0100 (Sun, 05 Feb 2006)
New Revision: 144

Modified:
   trunk/SConstruct
Log:
Cleaning SConstruct a little bit.  No new functionality.



Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2006-02-05 21:04:30 UTC (rev 143)
+++ trunk/SConstruct	2006-02-05 22:03:43 UTC (rev 144)
@@ -89,11 +89,17 @@
             print 'Could not find header or shared library for boost %s, exiting!' % libinfo[0]
             Exit(1)
 
+Export('env')
+
+inputplugins = [ driver.strip() for driver in Split(env['INPUT_PLUGINS'])]
+
+bindings = [ binding.strip() for binding in Split(env['BINDINGS'])]
+
 # Check out the Python situation
 
 if 'python' in env['BINDINGS']:
     if not os.access(env['PYTHON'], os.X_OK):
-        print 'Cannot run python, make sure that you have the permissions to execute it.'
+        print "Cannot run python interpreter at '%s', make sure that you have the permissions to execute it." % env['PYTHON']
         Exit(1)
 
     env['PYTHON_PREFIX'] = os.popen("%s -c 'import sys; print sys.prefix'" % env['PYTHON']).read().strip()
@@ -113,6 +119,8 @@
 
     print 'Python %s prefix... %s' % (env['PYTHON_VERSION'], env['PYTHON_PREFIX'])
 
+    SConscript('bindings/python/SConscript')
+
 env = conf.Finish()
 
 # Setup the c++ args for our own codebase
@@ -122,21 +130,17 @@
 else:
     env.Append(CXXFLAGS = '-Wall -ftemplate-depth-100 -O3 -finline-functions -Wno-inline -pthread -DNDEBUG')
 
-# Build the input plug-ins
-
-inputplugins = [ driver.strip() for driver in Split(env['INPUT_PLUGINS'])]
-
-Export('env')
-
 # Build agg first, doesn't need anything special
 
 SConscript('agg/SConscript')
 
-# Build shapeindex and remove it's dependency from the LIBS
+# Build shapeindex and remove its dependency from the LIBS
 
 if 'boost_program_options' in env['LIBS'] or 'boost_program_options-gcc-mt' in env['LIBS']:
     SConscript('utils/shapeindex/SConscript')
 
+# Build the input plug-ins
+
 if 'postgis' in inputplugins and 'pq' in env['LIBS']:
     SConscript('plugins/input/postgis/SConscript')
     env['LIBS'].remove('pq')
@@ -150,10 +154,3 @@
 # Build the core library
 
 SConscript('src/SConscript')
-
-# Build python bindings
-
-bindings = [ binding.strip() for binding in Split(env['BINDINGS'])]
-
-if 'python' in bindings:
-    SConscript('bindings/python/SConscript')



From jdoyon at berlios.de  Sun Feb  5 23:19:25 2006
From: jdoyon at berlios.de (jdoyon at BerliOS)
Date: Sun, 5 Feb 2006 23:19:25 +0100
Subject: [Mapnik-svn] r145 - trunk
Message-ID: <200602052219.k15MJPVJ024928@sheep.berlios.de>

Author: jdoyon
Date: 2006-02-05 23:19:25 +0100 (Sun, 05 Feb 2006)
New Revision: 145

Modified:
   trunk/SConstruct
Log:
Fixed an (ironic) bug with the debug option :)



Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2006-02-05 22:03:43 UTC (rev 144)
+++ trunk/SConstruct	2006-02-05 22:19:25 UTC (rev 145)
@@ -37,7 +37,7 @@
 opts.Add(PathOption('PYTHON','Python executable', sys.executable))
 opts.Add(ListOption('INPUT_PLUGINS','Input drivers to include','all',['postgis','shape','raster']))
 opts.Add(ListOption('BINDINGS','Language bindings to build','all',['python']))
-opts.Add(ListOption('DEBUG', 'Compile a debug version of mapnik', 'no', ['no', 'yes']))
+opts.Add('DEBUG', 'Compile a debug version of mapnik', '')
 
 env = Environment(ENV=os.environ, options=opts)
 



From jdoyon at berlios.de  Sun Feb  5 23:23:16 2006
From: jdoyon at berlios.de (jdoyon at BerliOS)
Date: Sun, 5 Feb 2006 23:23:16 +0100
Subject: [Mapnik-svn] r146 - trunk
Message-ID: <200602052223.k15MNG0p025486@sheep.berlios.de>

Author: jdoyon
Date: 2006-02-05 23:23:14 +0100 (Sun, 05 Feb 2006)
New Revision: 146

Modified:
   trunk/
Log:
Set svn:ignore to ignore:

*.pyc
*.so
*.os




Property changes on: trunk
___________________________________________________________________
Name: svn:ignore
   + *.pyc
*.os
*.so




From jdoyon at berlios.de  Sun Feb  5 23:25:34 2006
From: jdoyon at berlios.de (jdoyon at BerliOS)
Date: Sun, 5 Feb 2006 23:25:34 +0100
Subject: [Mapnik-svn] r147 - in trunk: . agg agg/include agg/src bindings bindings/python bindings/python/mapnik docs include plugins plugins/input plugins/input/postgis plugins/input/raster plugins/input/shape scons scons/scons-local-0.96.1 scons/scons-local-0.96.1/SCons scons/scons-local-0.96.1/SCons/Node scons/scons-local-0.96.1/SCons/Optik scons/scons-local-0.96.1/SCons/Options scons/scons-local-0.96.1/SCons/Platform scons/scons-local-0.96.1/SCons/Scanner scons/scons-local-0.96.1/SCons/Script scons/scons-local-0.96.1/SCons/Sig scons/scons-local-0.96.1/SCons/Tool src utils utils/shapeindex
Message-ID: <200602052225.k15MPY9B025728@sheep.berlios.de>

Author: jdoyon
Date: 2006-02-05 23:25:34 +0100 (Sun, 05 Feb 2006)
New Revision: 147

Modified:
   trunk/
   trunk/agg/
   trunk/agg/include/
   trunk/agg/src/
   trunk/bindings/
   trunk/bindings/python/
   trunk/bindings/python/mapnik/
   trunk/docs/
   trunk/include/
   trunk/plugins/
   trunk/plugins/input/
   trunk/plugins/input/postgis/
   trunk/plugins/input/raster/
   trunk/plugins/input/shape/
   trunk/scons/
   trunk/scons/scons-local-0.96.1/
   trunk/scons/scons-local-0.96.1/SCons/
   trunk/scons/scons-local-0.96.1/SCons/Node/
   trunk/scons/scons-local-0.96.1/SCons/Optik/
   trunk/scons/scons-local-0.96.1/SCons/Options/
   trunk/scons/scons-local-0.96.1/SCons/Platform/
   trunk/scons/scons-local-0.96.1/SCons/Scanner/
   trunk/scons/scons-local-0.96.1/SCons/Script/
   trunk/scons/scons-local-0.96.1/SCons/Sig/
   trunk/scons/scons-local-0.96.1/SCons/Tool/
   trunk/src/
   trunk/utils/
   trunk/utils/shapeindex/
Log:
Add .sconsign to be ignored, make filter recursive in the source tree.




Property changes on: trunk
___________________________________________________________________
Name: svn:ignore
   - *.pyc
*.os
*.so

   + *.pyc
*.os
*.so
.sconsign



Property changes on: trunk/agg
___________________________________________________________________
Name: svn:ignore
   + *.pyc
*.os
*.so
.sconsign



Property changes on: trunk/agg/include
___________________________________________________________________
Name: svn:ignore
   + *.pyc
*.os
*.so
.sconsign



Property changes on: trunk/agg/src
___________________________________________________________________
Name: svn:ignore
   + *.pyc
*.os
*.so
.sconsign



Property changes on: trunk/bindings
___________________________________________________________________
Name: svn:ignore
   + *.pyc
*.os
*.so
.sconsign



Property changes on: trunk/bindings/python
___________________________________________________________________
Name: svn:ignore
   + *.pyc
*.os
*.so
.sconsign



Property changes on: trunk/bindings/python/mapnik
___________________________________________________________________
Name: svn:ignore
   + *.pyc
*.os
*.so
.sconsign



Property changes on: trunk/docs
___________________________________________________________________
Name: svn:ignore
   + *.pyc
*.os
*.so
.sconsign



Property changes on: trunk/include
___________________________________________________________________
Name: svn:ignore
   + *.pyc
*.os
*.so
.sconsign



Property changes on: trunk/plugins
___________________________________________________________________
Name: svn:ignore
   + *.pyc
*.os
*.so
.sconsign



Property changes on: trunk/plugins/input
___________________________________________________________________
Name: svn:ignore
   + *.pyc
*.os
*.so
.sconsign



Property changes on: trunk/plugins/input/postgis
___________________________________________________________________
Name: svn:ignore
   + *.pyc
*.os
*.so
.sconsign



Property changes on: trunk/plugins/input/raster
___________________________________________________________________
Name: svn:ignore
   + *.pyc
*.os
*.so
.sconsign



Property changes on: trunk/plugins/input/shape
___________________________________________________________________
Name: svn:ignore
   + *.pyc
*.os
*.so
.sconsign



Property changes on: trunk/scons
___________________________________________________________________
Name: svn:ignore
   + *.pyc
*.os
*.so
.sconsign



Property changes on: trunk/scons/scons-local-0.96.1
___________________________________________________________________
Name: svn:ignore
   + *.pyc
*.os
*.so
.sconsign



Property changes on: trunk/scons/scons-local-0.96.1/SCons
___________________________________________________________________
Name: svn:ignore
   + *.pyc
*.os
*.so
.sconsign



Property changes on: trunk/scons/scons-local-0.96.1/SCons/Node
___________________________________________________________________
Name: svn:ignore
   + *.pyc
*.os
*.so
.sconsign



Property changes on: trunk/scons/scons-local-0.96.1/SCons/Optik
___________________________________________________________________
Name: svn:ignore
   + *.pyc
*.os
*.so
.sconsign



Property changes on: trunk/scons/scons-local-0.96.1/SCons/Options
___________________________________________________________________
Name: svn:ignore
   + *.pyc
*.os
*.so
.sconsign



Property changes on: trunk/scons/scons-local-0.96.1/SCons/Platform
___________________________________________________________________
Name: svn:ignore
   + *.pyc
*.os
*.so
.sconsign



Property changes on: trunk/scons/scons-local-0.96.1/SCons/Scanner
___________________________________________________________________
Name: svn:ignore
   + *.pyc
*.os
*.so
.sconsign



Property changes on: trunk/scons/scons-local-0.96.1/SCons/Script
___________________________________________________________________
Name: svn:ignore
   + *.pyc
*.os
*.so
.sconsign



Property changes on: trunk/scons/scons-local-0.96.1/SCons/Sig
___________________________________________________________________
Name: svn:ignore
   + *.pyc
*.os
*.so
.sconsign



Property changes on: trunk/scons/scons-local-0.96.1/SCons/Tool
___________________________________________________________________
Name: svn:ignore
   + *.pyc
*.os
*.so
.sconsign



Property changes on: trunk/src
___________________________________________________________________
Name: svn:ignore
   + *.pyc
*.os
*.so
.sconsign



Property changes on: trunk/utils
___________________________________________________________________
Name: svn:ignore
   + *.pyc
*.os
*.so
.sconsign



Property changes on: trunk/utils/shapeindex
___________________________________________________________________
Name: svn:ignore
   + *.pyc
*.os
*.so
.sconsign




From jdoyon at berlios.de  Sun Feb  5 23:36:36 2006
From: jdoyon at berlios.de (jdoyon at BerliOS)
Date: Sun, 5 Feb 2006 23:36:36 +0100
Subject: [Mapnik-svn] r148 - trunk
Message-ID: <200602052236.k15MaalL027002@sheep.berlios.de>

Author: jdoyon
Date: 2006-02-05 23:36:33 +0100 (Sun, 05 Feb 2006)
New Revision: 148

Modified:
   trunk/INSTALL
Log:
Modify to match the new SConstruct ... one last time!



Modified: trunk/INSTALL
===================================================================
--- trunk/INSTALL	2006-02-05 22:25:34 UTC (rev 147)
+++ trunk/INSTALL	2006-02-05 22:36:33 UTC (rev 148)
@@ -121,10 +121,8 @@
     actual: python
 
 DEBUG: Compile a debug version of mapnik
-    (all|none|comma-separated list of names)
-    allowed names: no yes
-    default: no
-    actual: no
+    default:
+    actual:
 
 This help should be self-explanatory!
 



From jdoyon at berlios.de  Mon Feb  6 02:08:46 2006
From: jdoyon at berlios.de (jdoyon at BerliOS)
Date: Mon, 6 Feb 2006 02:08:46 +0100
Subject: [Mapnik-svn] r149 - in trunk: . bindings/python utils/shapeindex
Message-ID: <200602060108.k1618kbk008458@sheep.berlios.de>

Author: jdoyon
Date: 2006-02-06 02:08:32 +0100 (Mon, 06 Feb 2006)
New Revision: 149

Modified:
   trunk/SConstruct
   trunk/bindings/python/SConscript
   trunk/utils/shapeindex/SConscript
Log:
Reworked the way the tail end of the boost libs (i.e. -gcc-mt) is handled.

This will eventually help with mroe platforms, and to link with debug libraries.



Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2006-02-05 22:36:33 UTC (rev 148)
+++ trunk/SConstruct	2006-02-06 01:08:32 UTC (rev 149)
@@ -83,11 +83,15 @@
         print 'Could not find header or shared library for %s, exiting!' % libinfo[0]
         Exit(1)
 
+env['BOOST_APPEND'] = ''
+
 for libinfo in BOOST_LIBSHEADERS:
-    if not conf.CheckLibWithHeader('boost_%s' % libinfo[0], libinfo[1], 'C++'):
+    if not conf.CheckLibWithHeader('boost_%s%s' % (libinfo[0], env['BOOST_APPEND']), libinfo[1], 'C++'):
         if not conf.CheckLibWithHeader('boost_%s-%s-mt' % (libinfo[0], env['CC']), libinfo[1], 'C++') and libinfo[2]:
             print 'Could not find header or shared library for boost %s, exiting!' % libinfo[0]
             Exit(1)
+        else:
+            env['BOOST_APPEND'] = '-%s-mt' % env['CC']
 
 Export('env')
 
@@ -136,8 +140,9 @@
 
 # Build shapeindex and remove its dependency from the LIBS
 
-if 'boost_program_options' in env['LIBS'] or 'boost_program_options-gcc-mt' in env['LIBS']:
+if 'boost_program_options%s' % env['BOOST_APPEND'] in env['LIBS']:
     SConscript('utils/shapeindex/SConscript')
+    env['LIBS'].remove('boost_program_options%s' % env['BOOST_APPEND'])
 
 # Build the input plug-ins
 

Modified: trunk/bindings/python/SConscript
===================================================================
--- trunk/bindings/python/SConscript	2006-02-05 22:36:33 UTC (rev 148)
+++ trunk/bindings/python/SConscript	2006-02-06 01:08:32 UTC (rev 149)
@@ -23,7 +23,7 @@
 
 prefix = env['PYTHON_PREFIX'] + '/lib/python' + env['PYTHON_VERSION'] + '/site-packages/'
 
-libraries = ['mapnik', 'boost_python-gcc-mt']
+libraries = ['mapnik', 'boost_python%s' % env['BOOST_APPEND']]
 headers = [env['PYTHON_PREFIX'] + '/include/python' + env['PYTHON_VERSION']] + env['CPPPATH']
 
 _mapnik = env.SharedLibrary('_mapnik', glob.glob('*.cpp'), LIBS=libraries, SHLIBPREFIX='', CPPPATH=headers)

Modified: trunk/utils/shapeindex/SConscript
===================================================================
--- trunk/utils/shapeindex/SConscript	2006-02-05 22:36:33 UTC (rev 148)
+++ trunk/utils/shapeindex/SConscript	2006-02-06 01:08:32 UTC (rev 149)
@@ -33,14 +33,7 @@
 
 headers = ['#plugins/input/shape'] + env['CPPPATH']
 
-if 'boost_program_options-gcc-mt' in env['LIBS']:
-    libraries = 'boost_program_options-gcc-mt'
-    env['LIBS'].remove('boost_program_options-gcc-mt')
-else:
-    libraries = 'boost_program_options'
-    env['LIBS'].remove('boost_program_options')
+shapeindex = env.Program('shapeindex', source, CPPPATH=headers, LIBS='boost_program_options%s' % env['BOOST_APPEND'])
 
-shapeindex = env.Program('shapeindex', source, CPPPATH=headers, LIBS=libraries)
-
 env.Install(prefix + '/bin', shapeindex)
 env.Alias('install', prefix + '/bin')



From pavlenko at berlios.de  Tue Feb  7 15:41:43 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Tue, 7 Feb 2006 15:41:43 +0100
Subject: [Mapnik-svn] r150 - in trunk: include src
Message-ID: <200602071441.k17Efhcl001773@sheep.berlios.de>

Author: pavlenko
Date: 2006-02-07 15:41:41 +0100 (Tue, 07 Feb 2006)
New Revision: 150

Added:
   trunk/include/agg_renderer.hpp
   trunk/include/feature_style_processor.hpp
   trunk/include/point_symbolizer.hpp
   trunk/src/agg_renderer.cpp
   trunk/src/point_symbolizer.cpp
Removed:
   trunk/include/image_symbolizer.hpp
   trunk/src/image_symbolizer.cpp
Modified:
   trunk/include/attribute_collector.hpp
   trunk/include/line_pattern_symbolizer.hpp
   trunk/include/line_symbolizer.hpp
   trunk/include/map.hpp
   trunk/include/mapnik.hpp
   trunk/include/polygon_pattern_symbolizer.hpp
   trunk/include/polygon_symbolizer.hpp
   trunk/include/rule.hpp
   trunk/include/style.hpp
   trunk/include/symbolizer.hpp
   trunk/src/SConscript
   trunk/src/line_pattern_symbolizer.cpp
   trunk/src/map.cpp
   trunk/src/polygon_pattern_symbolizer.cpp
   trunk/src/render.cpp
Log:
1. new style/feature processor abstraction allowing plugable backends. 
    (to construct custom 'Output' derive from feature_style_processor (CRTP) e.g
	class MyOutput : public feature_style_processor<MyOutput>
     and implement:
	 process(***_symbolizer const&, Feature const&)
     methods
   At the moment only AGG renderer is implemented



Added: trunk/include/agg_renderer.hpp
===================================================================
--- trunk/include/agg_renderer.hpp	2006-02-06 01:08:32 UTC (rev 149)
+++ trunk/include/agg_renderer.hpp	2006-02-07 14:41:41 UTC (rev 150)
@@ -0,0 +1,42 @@
+/* This file is part of Mapnik (c++ mapping toolkit)
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * Mapnik is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+//$Id$
+
+#ifndef AGG_RENDERER_HPP
+#define AGG_RENDERER_HPP
+
+#include "feature_style_processor.hpp"
+
+namespace mapnik
+{
+    struct agg_renderer : public feature_style_processor<agg_renderer> 
+    {
+	agg_renderer(Map const& m, Image32 & pixmap);
+	void process(point_symbolizer const& sym,Feature const& feature);	    	       
+	void process(line_symbolizer const& sym,Feature const& feature);
+	void process(line_pattern_symbolizer const& sym,Feature const& feature);
+	void process(polygon_symbolizer const& sym,Feature const& feature);
+	void process(polygon_pattern_symbolizer const& sym,Feature const& feature);
+    private:
+	Image32 & pixmap_;
+	CoordTransform t_;
+    };
+}
+
+#endif //AGG_RENDERER_HPP

Modified: trunk/include/attribute_collector.hpp
===================================================================
--- trunk/include/attribute_collector.hpp	2006-02-06 01:08:32 UTC (rev 149)
+++ trunk/include/attribute_collector.hpp	2006-02-07 14:41:41 UTC (rev 150)
@@ -18,8 +18,8 @@
 
 //$Id$
 
-#ifndef ATTRIBUTE_COLLECTOR
-#define ATTROBUTE_COLLECTOR
+#ifndef ATTRIBUTE_COLLECTOR_HPP
+#define ATTRIBUTE_COLLECTOR_HPP
 
 #include "filter.hpp"
 #include "expression.hpp"

Added: trunk/include/feature_style_processor.hpp
===================================================================
--- trunk/include/feature_style_processor.hpp	2006-02-06 01:08:32 UTC (rev 149)
+++ trunk/include/feature_style_processor.hpp	2006-02-07 14:41:41 UTC (rev 150)
@@ -0,0 +1,198 @@
+/* This file is part of Mapnik (c++ mapping toolkit)
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * Mapnik is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+//$Id$
+
+#ifndef FEATURE_STYLE_PROCESSOR_HPP
+#define FEATURE_STYLE_PROCESSOR_HPP
+
+#include <vector>
+#include <iostream>
+
+#include "envelope.hpp"
+#include "datasource.hpp"
+#include "layer.hpp"
+#include "map.hpp"
+#include "attribute_collector.hpp"
+#include "property_index.hpp"
+#include "utils.hpp"
+
+namespace mapnik
+{    
+    
+    template <typename Processor>
+    class feature_style_processor 
+    {
+	struct symbol_dispatch : public boost::static_visitor<>
+	{
+	    symbol_dispatch (Processor & output,Feature const& f)
+		: output_(output),f_(f) {}
+	    
+	    void operator () (polygon_symbolizer const& sym) const
+	    {
+		output_.process(sym,f_);
+	    }
+
+	    void operator () (polygon_pattern_symbolizer const& sym) const
+	    {
+		output_.process(sym,f_);
+	    }
+	    
+	    void operator () (line_symbolizer const& sym) const
+	    {
+		output_.process(sym,f_);
+	    }
+	    
+	    void operator () (line_pattern_symbolizer const& sym) const
+	    {
+		output_.process(sym,f_);
+	    }
+	   
+	    void operator () (point_symbolizer const& sym) const
+	    {
+		output_.process(sym,f_);
+	    }
+	    
+	    Processor & output_;
+	    Feature const& f_;
+	};
+    public:
+	feature_style_processor(Map const& m)
+	    : m_(m) {}
+	
+	void apply()
+	{
+	    timer clock;
+	    
+	    Processor & p = static_cast<Processor&>(*this);
+	    std::vector<Layer>::const_iterator itr = m_.layers().begin();
+	    while (itr != m_.layers().end())
+	    {
+		if (itr->isVisible(m_.scale()))// && itr->envelope().intersects(extent))
+		{
+		    apply_to_layer(*itr,p);
+		}
+		++itr;
+	    }
+	    clock.stop();
+	}	
+    private:
+	void apply_to_layer(Layer const& lay,Processor & p)
+	{
+	    datasource *ds=lay.datasource().get();
+	    if (ds)
+	    {
+		Envelope<double> const& bbox=m_.getCurrentExtent();
+		double scale = m_.scale();
+	
+		std::vector<std::string> const& style_names = lay.styles();
+		std::vector<std::string>::const_iterator stylesIter = style_names.begin();
+		while (stylesIter != style_names.end())
+		{
+		    std::set<std::string> names;
+		    attribute_collector<Feature> collector(names);
+		    property_index<Feature> indexer(names);
+		    std::vector<rule_type*> if_rules;
+		    std::vector<rule_type*> else_rules;
+		
+		    bool active_rules=false;
+		    
+		    feature_type_style const& style=m_.find_style(*stylesIter++);
+		    
+		    const std::vector<rule_type>& rules=style.get_rules();
+		    std::vector<rule_type>::const_iterator ruleIter=rules.begin();
+		    
+		    query q(bbox,m_.getWidth(),m_.getHeight());
+		    while (ruleIter!=rules.end())
+		    {
+			if (ruleIter->active(scale))
+			{
+			    active_rules=true;
+			    filter_ptr& filter=const_cast<filter_ptr&>(ruleIter->get_filter());
+			    filter->accept(collector);
+			    filter->accept(indexer);
+			    if (ruleIter->has_else_filter())
+			    {
+				else_rules.push_back(const_cast<rule_type*>(&(*ruleIter)));
+			    }
+			    else
+			    {
+				if_rules.push_back(const_cast<rule_type*>(&(*ruleIter))); 		    
+			    }
+			}
+			++ruleIter;
+		    }
+		    std::set<std::string>::const_iterator namesIter=names.begin();
+		    // push all property names
+		    while (namesIter!=names.end())
+		    {
+			q.add_property_name(*namesIter);
+			++namesIter;
+		    }
+		    if (active_rules)
+		    {
+			featureset_ptr fs=ds->features(q);
+			if (fs)
+			{   	    
+			    feature_ptr feature;
+			    while ((feature = fs->next()))
+			    {		   
+				bool do_else=true;		    
+				std::vector<rule_type*>::const_iterator itr=if_rules.begin();
+				while (itr!=if_rules.end())
+				{
+				    filter_ptr const& filter=(*itr)->get_filter();    
+				    if (filter->pass(*feature))
+				    {   
+					do_else=false;
+					const symbolizers& symbols = (*itr)->get_symbolizers();
+					symbolizers::const_iterator symIter=symbols.begin();
+					while (symIter!=symbols.end())
+					{   
+					    boost::apply_visitor(symbol_dispatch(p,*feature),*symIter++);
+					}
+				    }			    
+				    ++itr;
+				}
+				if (do_else)
+				{
+				    //else filter
+				    std::vector<rule_type*>::const_iterator itr=else_rules.begin();
+				    while (itr != else_rules.end())
+				    {
+					const symbolizers& symbols = (*itr)->get_symbolizers();
+					symbolizers::const_iterator symIter=symbols.begin();
+					while (symIter!=symbols.end())
+					{
+					    boost::apply_visitor(symbol_dispatch(p,*feature),*symIter++);
+					}
+					++itr;
+				    }
+				}	  
+			    }
+			}
+		    }
+		}
+	    }
+	}
+	
+	Map const& m_;
+    };
+}
+
+#endif //FEATURE_STYLE_PROCESSOR_HPP

Deleted: trunk/include/image_symbolizer.hpp
===================================================================
--- trunk/include/image_symbolizer.hpp	2006-02-06 01:08:32 UTC (rev 149)
+++ trunk/include/image_symbolizer.hpp	2006-02-07 14:41:41 UTC (rev 150)
@@ -1,43 +0,0 @@
-/* This file is part of Mapnik (c++ mapping toolkit)
- * Copyright (C) 2005 Artem Pavlenko
- *
- * Mapnik is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- */
-
-//$Id: image_symbolizer.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef IMAGE_SYMBOLIZER_HPP
-#define IMAGE_SYMBOLIZER_HPP
-
-#include "symbolizer.hpp"
-#include <boost/utility.hpp>
-
-namespace mapnik 
-{   
-    struct image_symbolizer : public symbolizer,
-			      private boost::noncopyable
-    {
-	  
-	image_symbolizer(std::string const& file,
-			 std::string const& type,
-			 unsigned width,unsigned height);
-	
-	void render(Feature const& feat, CoordTransform const& t,Image32& image) const;
-    private:
-	ImageData32 symbol_;
-    };
-}
-
-#endif // IMAGE_SYMBOLIZER_HPP

Modified: trunk/include/line_pattern_symbolizer.hpp
===================================================================
--- trunk/include/line_pattern_symbolizer.hpp	2006-02-06 01:08:32 UTC (rev 149)
+++ trunk/include/line_pattern_symbolizer.hpp	2006-02-07 14:41:41 UTC (rev 150)
@@ -21,20 +21,21 @@
 #ifndef LINE_PATTERN_SYMBOLIZER_HPP
 #define LINE_PATTERN_SYMBOLIZER_HPP
 
-#include "symbolizer.hpp"
-#include <boost/utility.hpp>
+#include <boost/shared_ptr.hpp>
+#include "graphics.hpp"
 
 namespace mapnik 
 {      
-    struct line_pattern_symbolizer : public symbolizer, 
-				     private boost::noncopyable
+    struct line_pattern_symbolizer
     {
 	line_pattern_symbolizer(std::string const& file,
 				std::string const& type,
 				unsigned width,unsigned height);
-	void render(Feature const& feat, CoordTransform const& t,Image32& image) const;
+
+	line_pattern_symbolizer(line_pattern_symbolizer const& rhs);
+	ImageData32 const& get_pattern() const;
     private:
-	ImageData32 pattern_;
+	boost::shared_ptr<ImageData32> pattern_;
     };    
 }
 

Modified: trunk/include/line_symbolizer.hpp
===================================================================
--- trunk/include/line_symbolizer.hpp	2006-02-06 01:08:32 UTC (rev 149)
+++ trunk/include/line_symbolizer.hpp	2006-02-07 14:41:41 UTC (rev 150)
@@ -22,19 +22,22 @@
 #define LINE_SYMBOLIZER_HPP
 
 
-#include "symbolizer.hpp"
+//#include "symbolizer.hpp"
 #include "stroke.hpp"
 
-#include <boost/utility.hpp>
-
 namespace mapnik 
 {
-    struct line_symbolizer : public symbolizer,
-			     private boost::noncopyable
+    struct line_symbolizer
     {
-	line_symbolizer(stroke const& stroke);
-	line_symbolizer(const Color& pen,float width=1.0);	
-	void render(Feature const& feat, CoordTransform const& t,Image32& image) const;
+	line_symbolizer(stroke const& stroke)
+	    : stroke_(stroke) {}
+	
+	line_symbolizer(const Color& pen,float width=1.0)
+	    : stroke_(pen,width) {}
+	stroke const& get_stroke() const
+	{
+	    return stroke_;
+	}
     private:
 	stroke stroke_;
     };

Modified: trunk/include/map.hpp
===================================================================
--- trunk/include/map.hpp	2006-02-06 01:08:32 UTC (rev 149)
+++ trunk/include/map.hpp	2006-02-07 14:41:41 UTC (rev 150)
@@ -58,8 +58,7 @@
 
 	bool insert_style(std::string const& name,feature_type_style const& style);
 	void remove_style(const std::string& name);
-	feature_type_style find_style(std::string const& name) const;
-	
+	feature_type_style const& find_style(std::string const& name) const;
 	size_t layerCount() const;
 	void addLayer(const Layer& l);
 	const Layer& getLayer(size_t index) const;

Modified: trunk/include/mapnik.hpp
===================================================================
--- trunk/include/mapnik.hpp	2006-02-06 01:08:32 UTC (rev 149)
+++ trunk/include/mapnik.hpp	2006-02-07 14:41:41 UTC (rev 150)
@@ -34,21 +34,21 @@
 #include "comparison.hpp"
 #include "regex_filter.hpp"
 #include "utils.hpp"
-#include "symbolizer.hpp"
+//#include "symbolizer.hpp"
 #include "geometry.hpp"
 #include "geom_util.hpp"
 #include "raster.hpp"
 #include "feature.hpp"
 #include "attribute.hpp"
 #include "attribute_collector.hpp"
-#include "render.hpp"
 #include "graphics.hpp"
 #include "image_reader.hpp"
 #include "line_symbolizer.hpp"
 #include "polygon_symbolizer.hpp"
+#include "agg_renderer.hpp"
 #include "polygon_pattern_symbolizer.hpp"
 #include "line_pattern_symbolizer.hpp"
-#include "image_symbolizer.hpp"
+#include "point_symbolizer.hpp"
 #include "image_util.hpp"
 #include "datasource.hpp"
 #include "layer.hpp"

Copied: trunk/include/point_symbolizer.hpp (from rev 148, trunk/include/image_symbolizer.hpp)
===================================================================
--- trunk/include/image_symbolizer.hpp	2006-02-05 22:36:33 UTC (rev 148)
+++ trunk/include/point_symbolizer.hpp	2006-02-07 14:41:41 UTC (rev 150)
@@ -0,0 +1,42 @@
+/* This file is part of Mapnik (c++ mapping toolkit)
+ * Copyright (C) 2005 Artem Pavlenko
+ *
+ * Mapnik is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+//$Id: image_symbolizer.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef POINT_SYMBOLIZER_HPP
+#define POINT_SYMBOLIZER_HPP
+
+#include <boost/shared_ptr.hpp>
+#include "graphics.hpp" 
+
+namespace mapnik 
+{   
+    struct point_symbolizer
+    {
+	
+	point_symbolizer(std::string const& file,
+			 std::string const& type,
+			 unsigned width,unsigned height);
+	point_symbolizer(point_symbolizer const& rhs);
+	ImageData32 const& get_data() const;
+    private:
+	boost::shared_ptr<ImageData32> symbol_;
+    };
+}
+
+#endif // POINT_SYMBOLIZER_HPP

Modified: trunk/include/polygon_pattern_symbolizer.hpp
===================================================================
--- trunk/include/polygon_pattern_symbolizer.hpp	2006-02-06 01:08:32 UTC (rev 149)
+++ trunk/include/polygon_pattern_symbolizer.hpp	2006-02-07 14:41:41 UTC (rev 150)
@@ -21,22 +21,23 @@
 #ifndef POLYGON_PATTERN_SYMBOLIZER_HPP
 #define POLYGON_PATTERN_SYMBOLIZER_HPP
 
-#include "symbolizer.hpp"
-#include <boost/utility.hpp>
+#include <boost/shared_ptr.hpp>
+#include "graphics.hpp" 
 
 namespace mapnik
 {
-    struct polygon_pattern_symbolizer : public symbolizer,
-					private boost::noncopyable
+    struct polygon_pattern_symbolizer
     {
 	
 	polygon_pattern_symbolizer(std::string const& file,
 				   std::string const& type,
 				   unsigned width,unsigned height);
         
-	void render(Feature const& feat, CoordTransform const& t,Image32& image) const;
+	polygon_pattern_symbolizer(polygon_pattern_symbolizer const& rhs);
+        
+	ImageData32 const& get_pattern() const;
     private:
-	ImageData32 pattern_;
+	boost::shared_ptr<ImageData32> pattern_;
     };
 }
 

Modified: trunk/include/polygon_symbolizer.hpp
===================================================================
--- trunk/include/polygon_symbolizer.hpp	2006-02-06 01:08:32 UTC (rev 149)
+++ trunk/include/polygon_symbolizer.hpp	2006-02-07 14:41:41 UTC (rev 150)
@@ -21,16 +21,19 @@
 #ifndef POLYGON_SYMBOLIZER_HPP
 #define POLYGON_SYMBOLIZER_HPP
 
-#include "symbolizer.hpp"
-#include <boost/utility.hpp>
+//#include "symbolizer.hpp"
+//#include <boost/utility.hpp>
 
 namespace mapnik 
 {
-    struct polygon_symbolizer : public symbolizer,
-				private boost::noncopyable
+    struct polygon_symbolizer
     {
-	polygon_symbolizer(const Color& fill);
-	void render(Feature const& feat, CoordTransform const& t,Image32& image) const;
+	polygon_symbolizer(Color const& fill)
+	    : fill_(fill) {}
+	Color const& get_fill() const
+	{
+	    return fill_;
+	}
     private:
 	Color fill_;
     };  

Modified: trunk/include/rule.hpp
===================================================================
--- trunk/include/rule.hpp	2006-02-06 01:08:32 UTC (rev 149)
+++ trunk/include/rule.hpp	2006-02-07 14:41:41 UTC (rev 150)
@@ -19,16 +19,27 @@
 #ifndef RULE_HPP
 #define RULE_HPP
 
-#include "symbolizer.hpp"
+#include "line_symbolizer.hpp"
+#include "line_pattern_symbolizer.hpp"
+#include "polygon_symbolizer.hpp"
+#include "polygon_pattern_symbolizer.hpp"
+#include "point_symbolizer.hpp"
 #include "filter.hpp"
 #include <boost/shared_ptr.hpp>
+#include <boost/variant.hpp>
 #include <string>
 #include <vector>
 
 namespace mapnik
 {
-    typedef boost::shared_ptr<symbolizer> symbolizer_ptr;
-    typedef std::vector<symbolizer_ptr> symbolizers;    
+    
+    typedef boost::variant<point_symbolizer,
+			   line_symbolizer,
+			   line_pattern_symbolizer,
+			   polygon_symbolizer,
+			   polygon_pattern_symbolizer> symbolizer;
+    
+    typedef std::vector<symbolizer> symbolizers;    
     template <typename FeatureT> class all_filter;
 
     template <typename FeatureT,template <typename> class Filter>
@@ -140,9 +151,9 @@
 	    return abstract_;
 	}
 		
-	void append(const symbolizer_ptr& symbol)
+	void append(const symbolizer& sym)
 	{
-	    syms_.push_back(symbol);
+	    syms_.push_back(sym);
 	}
 	
 	void remove_at(size_t index)

Modified: trunk/include/style.hpp
===================================================================
--- trunk/include/style.hpp	2006-02-06 01:08:32 UTC (rev 149)
+++ trunk/include/style.hpp	2006-02-07 14:41:41 UTC (rev 150)
@@ -30,49 +30,7 @@
 #include <boost/shared_ptr.hpp>
 
 namespace mapnik
-{
-    class Style 
-    {
-    private:
-	std::vector<boost::shared_ptr<symbolizer> > symbols_;
-	static boost::shared_ptr<symbolizer> zero_symbol_;
-    public:
-	typedef std::vector<boost::shared_ptr<symbolizer> >::const_iterator Iterator; 
-
-	Style() {}
-
-	Style(const boost::shared_ptr<symbolizer>& symbol) 
-	{
-	    symbols_.push_back(symbol);
-	}
-
-	~Style() {}
-
-	Style(const Style& rhs) 
-	    : symbols_(rhs.symbols_) {}
-	
-	Style& operator=(const Style& rhs)
-	{
-	    if (this==&rhs) return *this;
-	    symbols_=rhs.symbols_;
-	    return *this;
-	}
-	
-	void add(const boost::shared_ptr<symbolizer>& symbol) 
-	{
-	    symbols_.push_back(symbol);
-	}
-        
-	Iterator begin() const 
-	{
-	    return symbols_.begin();
-	} 
-
-	Iterator end() const 
-	{
-	    return symbols_.end();
-	}
-    };    
+{      
 }
 
 #endif //STYLE_HPP

Modified: trunk/include/symbolizer.hpp
===================================================================
--- trunk/include/symbolizer.hpp	2006-02-06 01:08:32 UTC (rev 149)
+++ trunk/include/symbolizer.hpp	2006-02-07 14:41:41 UTC (rev 150)
@@ -21,20 +21,20 @@
 #ifndef SYMBOLIZER_HPP
 #define SYMBOLIZER_HPP
 
-#include "graphics.hpp" 
-#include "feature.hpp"
-#include "geometry.hpp"
-#include <limits>
+//#include "graphics.hpp" 
+//#include "feature.hpp"
+//#include "geometry.hpp"
+//#include <limits>
 
 namespace mapnik 
 {
-    class Image32;
+    //class Image32;
 
-    struct symbolizer
-    {
-    	virtual void render(Feature const& feat, CoordTransform const& t, Image32& image) const=0;
-    	virtual ~symbolizer() {}
-    }; 
+    //struct symbolizer
+    //{
+    //	virtual void render(Feature const& feat, CoordTransform const& t, Image32& image) const=0;
+    //	virtual ~symbolizer() {}
+    //}; 
 }
 
 #endif //SYMBOLIZER_HPP

Modified: trunk/src/SConscript
===================================================================
--- trunk/src/SConscript	2006-02-06 01:08:32 UTC (rev 149)
+++ trunk/src/SConscript	2006-02-07 14:41:41 UTC (rev 150)
@@ -40,17 +40,21 @@
     params.cpp
     plugin.cpp
     png_reader.cpp
-    render.cpp
     text.cpp
     tiff_reader.cpp
     wkb.cpp
-    line_symbolizer.cpp
+    agg_renderer.cpp
+    point_symbolizer.cpp
+    polygon_pattern_symbolizer.cpp
     line_pattern_symbolizer.cpp
-    polygon_symbolizer.cpp
-    polygon_pattern_symbolizer.cpp
-    image_symbolizer.cpp
     """
     )
+#render.cpp
+#line_symbolizer.cpp
+#    line_pattern_symbolizer.cpp
+#    polygon_symbolizer.cpp
+#    polygon_pattern_symbolizer.cpp
+#    image_symbolizer.cpp
 
 mapnik = env.SharedLibrary('mapnik', source, LIBS=libraries, LINKFLAGS=linkflags)
 

Added: trunk/src/agg_renderer.cpp
===================================================================
--- trunk/src/agg_renderer.cpp	2006-02-06 01:08:32 UTC (rev 149)
+++ trunk/src/agg_renderer.cpp	2006-02-07 14:41:41 UTC (rev 150)
@@ -0,0 +1,335 @@
+/* This file is part of Mapnik (c++ mapping toolkit)
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * Mapnik is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+//$Id$
+
+#include "agg_renderer.hpp"
+
+#include "agg_basics.h"
+#include "agg_rendering_buffer.h"
+#include "agg_rasterizer_scanline_aa.h"
+#include "agg_scanline_p.h"
+#include "agg_scanline_u.h"
+#include "agg_renderer_scanline.h"
+#include "agg_pixfmt_rgba.h"
+#include "agg_path_storage.h"
+#include "agg_span_allocator.h"
+#include "agg_span_pattern_rgba.h"
+#include "agg_image_accessors.h"
+#include "agg_conv_stroke.h"
+#include "agg_conv_dash.h"
+#include "agg_conv_contour.h"
+#include "agg_vcgen_stroke.h"
+#include "agg_conv_adaptor_vcgen.h"
+#include "agg_conv_smooth_poly1.h"
+#include "agg_conv_marker.h"
+#include "agg_arrowhead.h"
+#include "agg_vcgen_markers_term.h"
+#include "agg_renderer_outline_aa.h"
+#include "agg_rasterizer_outline_aa.h"
+#include "agg_rasterizer_outline.h"
+#include "agg_renderer_outline_image.h"
+#include "agg_span_allocator.h"
+#include "agg_span_pattern_rgba.h"
+#include "agg_renderer_scanline.h"
+#include "agg_pattern_filters_rgba.h"
+#include "agg_renderer_outline_image.h"
+
+#include <boost/utility.hpp>
+
+namespace mapnik
+{
+
+
+    class pattern_source : private boost::noncopyable
+    {
+    public:
+	pattern_source(ImageData32 const& pattern)
+	    : pattern_(pattern) {}
+	
+	unsigned int width() const
+	{
+	    return pattern_.width();
+	}
+	unsigned int height() const
+	{
+	    return pattern_.height();
+	}
+	agg::rgba8 pixel(int x, int y) const
+	{
+	    unsigned c = pattern_(x,y);
+	    return agg::rgba8(c & 0xff, (c >> 8) & 0xff, (c >> 16) & 0xff,(c >> 24) & 0xff);
+	}
+    private:
+	ImageData32 const& pattern_;
+    };
+
+    
+    agg_renderer::agg_renderer(Map const& m, Image32 & pixmap)
+	: feature_style_processor<agg_renderer>(m),pixmap_(pixmap),
+	  t_(m.getWidth(),m.getHeight(),m.getCurrentExtent())
+    {
+	Color const& bg=m.getBackground();
+	pixmap_.setBackground(bg);
+    }
+		
+    void agg_renderer::process(polygon_symbolizer const& sym,Feature const& feature)
+    {
+	typedef  coord_transform<CoordTransform,geometry_type> path_type;
+	typedef agg::renderer_base<agg::pixfmt_rgba32> ren_base;    
+	typedef agg::renderer_scanline_aa_solid<ren_base> renderer;
+	    
+	Color const& fill_  = sym.get_fill();
+	    
+	geometry_ptr const& geom=feature.get_geometry();
+	if (geom && geom->num_points() > 2) 
+	{
+	    unsigned width = pixmap_.width();
+	    unsigned height = pixmap_.height();
+	    path_type path(t_,*geom);
+	    agg::row_ptr_cache<agg::int8u> buf(pixmap_.raw_data(),width,height,width * 4);
+	    agg::pixfmt_rgba32 pixf(buf);
+	    ren_base renb(pixf);	    
+		
+	    unsigned r=fill_.red();
+	    unsigned g=fill_.green();
+	    unsigned b=fill_.blue();
+	    unsigned a=fill_.alpha();
+	    renderer ren(renb);
+		
+	    agg::rasterizer_scanline_aa<> ras;
+	    agg::scanline_u8 sl;
+	    ras.clip_box(0,0,width,height);
+	    ras.add_path(path);
+	    ren.color(agg::rgba8(r, g, b, a));
+	    agg::render_scanlines(ras, sl, ren);
+	}
+    }
+    void agg_renderer::process(line_symbolizer const& sym,Feature const& feature)
+    {   
+	typedef agg::renderer_base<agg::pixfmt_rgba32> ren_base; 
+	typedef coord_transform<CoordTransform,geometry_type> path_type;
+	typedef agg::renderer_outline_aa<ren_base> renderer_oaa;
+	typedef agg::rasterizer_outline_aa<renderer_oaa> rasterizer_outline_aa;
+	typedef agg::renderer_scanline_aa_solid<ren_base> renderer;
+	    
+	geometry_ptr const& geom=feature.get_geometry();
+	if (geom && geom->num_points() > 1)
+	{
+	    path_type path(t_,*geom);
+	    agg::row_ptr_cache<agg::int8u> buf(pixmap_.raw_data(),pixmap_.width(),pixmap_.height(),
+					       pixmap_.width()*4);
+	    agg::pixfmt_rgba32 pixf(buf);
+	    ren_base renb(pixf);	    
+		
+	    mapnik::stroke const&  stroke_ = sym.get_stroke();
+		
+	    Color const& col = stroke_.get_color();
+	    unsigned r=col.red();
+	    unsigned g=col.green();
+	    unsigned b=col.blue();	    
+		
+	    if (stroke_.has_dash())
+	    {
+		renderer ren(renb);	
+		agg::rasterizer_scanline_aa<> ras;
+		agg::scanline_u8 sl;
+		agg::conv_dash<path_type> dash(path);
+		dash_array const& d = stroke_.get_dash_array();
+		dash_array::const_iterator itr = d.begin();
+		dash_array::const_iterator end = d.end();
+		while (itr != end)
+		{
+		    dash.add_dash(itr->first, itr->second);
+		    ++itr;
+		}
+		agg::conv_stroke<agg::conv_dash<path_type > > stroke(dash);
+		    
+		line_join_e join=stroke_.get_line_join();
+		if ( join == MITER_JOIN)
+		    stroke.generator().line_join(agg::miter_join);
+		else if( join == MITER_REVERT_JOIN) 
+		    stroke.generator().line_join(agg::miter_join);
+		else if( join == ROUND_JOIN) 
+		    stroke.generator().line_join(agg::round_join);
+		else
+		    stroke.generator().line_join(agg::bevel_join);
+		    
+		line_cap_e cap=stroke_.get_line_cap();
+		if (cap == BUTT_CAP)    
+		    stroke.generator().line_cap(agg::butt_cap);
+		else if (cap == SQUARE_CAP)
+		    stroke.generator().line_cap(agg::square_cap);
+		else 
+		    stroke.generator().line_cap(agg::round_cap);
+		    
+		stroke.generator().miter_limit(4.0);
+		stroke.generator().width(stroke_.get_width());
+		    
+		ras.clip_box(0,0,pixmap_.width(),pixmap_.height());
+		ras.add_path(stroke);
+		ren.color(agg::rgba8(r, g, b, int(255*stroke_.get_opacity())));
+		agg::render_scanlines(ras, sl, ren);
+	    }
+	    else if (0) //(stroke_.get_width() <= 1.0)
+	    {
+		//faster but clipping doesn't work 
+		agg::line_profile_aa prof;
+		prof.width(stroke_.get_width());
+		renderer_oaa ren_oaa(renb, prof);
+		rasterizer_outline_aa ras_oaa(ren_oaa);
+		    
+		ren_oaa.color(agg::rgba8(r, g, b, int(255*stroke_.get_opacity())));
+		ren_oaa.clip_box(0,0,pixmap_.width(),pixmap_.height());
+		ras_oaa.add_path(path);		
+		    
+	    }
+	    else 
+	    {
+		renderer ren(renb);	
+		agg::rasterizer_scanline_aa<> ras;
+		agg::scanline_p8 sl;
+		agg::conv_stroke<path_type>  stroke(path);
+		    
+		line_join_e join=stroke_.get_line_join();
+		if ( join == MITER_JOIN)
+		    stroke.generator().line_join(agg::miter_join);
+		else if( join == MITER_REVERT_JOIN) 
+		    stroke.generator().line_join(agg::miter_join);
+		else if( join == ROUND_JOIN) 
+		    stroke.generator().line_join(agg::round_join);
+		else
+		    stroke.generator().line_join(agg::bevel_join);
+		    
+		line_cap_e cap=stroke_.get_line_cap();
+		if (cap == BUTT_CAP)    
+		    stroke.generator().line_cap(agg::butt_cap);
+		else if (cap == SQUARE_CAP)
+		    stroke.generator().line_cap(agg::square_cap);
+		else 
+		    stroke.generator().line_cap(agg::round_cap);
+		
+		stroke.generator().miter_limit(4.0);
+		stroke.generator().width(stroke_.get_width());
+		    
+		ras.clip_box(0,0,pixmap_.width(),pixmap_.height());
+		ras.add_path(stroke);
+		ren.color(agg::rgba8(r, g, b, int(255*stroke_.get_opacity())));
+		agg::render_scanlines(ras, sl, ren);
+	    }
+	}
+    }
+    
+    void agg_renderer::process(point_symbolizer const& sym,Feature const& feature)
+    {
+	geometry_ptr const& geom=feature.get_geometry();
+	if (geom)
+	{
+	    double x;
+	    double y;
+	    ImageData32 const& data = sym.get_data();
+	    geom->label_position(&x,&y);
+	    t_.forward_x(&x);
+	    t_.forward_y(&y);
+	    int w=data.width();
+	    int h=data.height();    
+	    int px=int(ceil(x - 0.5 * w));
+	    int py=int(ceil(y - 0.5 * h));
+	    pixmap_.set_rectangle_alpha(px,py,data);
+	}
+    }
+    void  agg_renderer::process(line_pattern_symbolizer const& sym,Feature const& feature)
+    {
+	typedef  coord_transform<CoordTransform,geometry_type> path_type;
+	typedef agg::line_image_pattern<agg::pattern_filter_bilinear_rgba8> pattern_type;
+	typedef agg::renderer_base<agg::pixfmt_rgba32> renderer_base;
+	typedef agg::renderer_outline_image<renderer_base, pattern_type> renderer_type;
+	typedef agg::rasterizer_outline_aa<renderer_type> rasterizer_type;
+
+	geometry_ptr const& geom=feature.get_geometry();
+	if (geom)
+	{
+	    unsigned width = pixmap_.width();
+	    unsigned height = pixmap_.height();
+	    ImageData32 const& pat = sym.get_pattern();
+	    path_type path(t_,*geom);
+	    agg::row_ptr_cache<agg::int8u> buf(pixmap_.raw_data(), width, height,width*4);
+	    agg::pixfmt_rgba32 pixf(buf);
+	    renderer_base ren_base(pixf);  
+	    agg::pattern_filter_bilinear_rgba8 filter; 
+	    pattern_source source(pat);
+	    pattern_type pattern (filter,source);
+	    renderer_type ren(ren_base, pattern);
+	    ren.clip_box(0,0,width,height);
+	    rasterizer_type ras(ren);	    
+	    ras.add_path(path);    
+	}
+    }
+    
+    void agg_renderer::process(polygon_pattern_symbolizer const& sym,Feature const& feature)
+    {
+	typedef  coord_transform<CoordTransform,geometry_type> path_type;
+	typedef agg::renderer_base<agg::pixfmt_rgba32> ren_base; 
+	typedef agg::wrap_mode_repeat wrap_x_type;
+	typedef agg::wrap_mode_repeat wrap_y_type;
+	typedef agg::image_accessor_wrap<agg::pixfmt_rgba32, 
+	    wrap_x_type,
+	    wrap_y_type> img_source_type;
+	
+	typedef agg::span_pattern_rgba<img_source_type> span_gen_type;
+	
+	typedef agg::renderer_scanline_aa<ren_base, 
+	    agg::span_allocator<agg::rgba8>,
+	    span_gen_type> renderer_type;  
+	geometry_ptr const& geom=feature.get_geometry();
+	if (geom)
+	{
+	    ImageData32 const& pattern = sym.get_pattern();
+	    
+	    unsigned width = pixmap_.width();
+	    unsigned height = pixmap_.height();
+	    path_type path(t_,*geom);
+	    
+	    agg::row_ptr_cache<agg::int8u> buf(pixmap_.raw_data(),width,height,width * 4);
+	    agg::pixfmt_rgba32 pixf(buf);
+	    ren_base renb(pixf);
+	
+	    unsigned w=pattern.width();
+	    unsigned h=pattern.height();
+	    agg::row_ptr_cache<agg::int8u> pattern_rbuf((agg::int8u*)pattern.getBytes(),w,h,w*4);  
+	    
+	    double x0,y0;
+	    path.vertex(&x0,&y0);
+	    path.rewind(0);
+	
+	    unsigned offset_x = unsigned(width - x0);
+	    unsigned offset_y = unsigned(height - y0);
+	
+	    agg::span_allocator<agg::rgba8> sa;
+	    img_source_type img_src(pattern_rbuf);
+	    span_gen_type sg(img_src, offset_x, offset_y);
+	    renderer_type rp(renb,sa, sg);
+	
+	    agg::rasterizer_scanline_aa<> ras;
+	    agg::scanline_u8 sl;
+	    ras.clip_box(0,0,width,height);
+	    ras.add_path(path);
+	    agg::render_scanlines(ras, sl, rp);   
+	}
+    }
+}

Deleted: trunk/src/image_symbolizer.cpp
===================================================================
--- trunk/src/image_symbolizer.cpp	2006-02-06 01:08:32 UTC (rev 149)
+++ trunk/src/image_symbolizer.cpp	2006-02-07 14:41:41 UTC (rev 150)
@@ -1,62 +0,0 @@
-/* This file is part of Mapnik (c++ mapping toolkit)
- * Copyright (C) 2005 Artem Pavlenko
- *
- * Mapnik is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- */
-
-//$Id$
-
-#include "image_symbolizer.hpp"
-#include "image_data.hpp"
-#include "image_reader.hpp"
-
-namespace mapnik
-{
-    image_symbolizer::image_symbolizer(std::string const& file,
-			 std::string const& type,
-			 unsigned width,unsigned height) 
-	    : symbolizer(),
-	      symbol_(width,height)
-    {
-	try 
-	{
-	    std::auto_ptr<ImageReader> reader(get_image_reader(type,file));
-	    reader->read(0,0,symbol_);		
-	} 
-	catch (...) 
-	{
-	    std::cerr<<"exception caught..." << std::endl;
-	}
-    }
-    
-    void image_symbolizer::render(Feature const& feat,CoordTransform const& t,Image32& image) const	
-    {
-	geometry_ptr const& geom=feat.get_geometry();
-	if (geom)
-	{
-	    double x;
-	    double y;
-	    geom->label_position(&x,&y);
-	    t.forward_x(&x);
-	    t.forward_y(&y);
-	    int w=symbol_.width();
-	    int h=symbol_.height();    
-	    int px=int(ceil(x - 0.5 * w));
-	    int py=int(ceil(y - 0.5 * h));
-	    image.set_rectangle_alpha(px,py,symbol_);
-	}
-    }
-}
-

Modified: trunk/src/line_pattern_symbolizer.cpp
===================================================================
--- trunk/src/line_pattern_symbolizer.cpp	2006-02-06 01:08:32 UTC (rev 149)
+++ trunk/src/line_pattern_symbolizer.cpp	2006-02-07 14:41:41 UTC (rev 150)
@@ -20,87 +20,32 @@
 
 #include "line_pattern_symbolizer.hpp"
 #include "image_reader.hpp"
-#include "agg_basics.h"
-#include "agg_rendering_buffer.h"
-#include "agg_rasterizer_scanline_aa.h"
-#include "agg_rasterizer_outline_aa.h"
-#include "agg_scanline_p.h"
-#include "agg_scanline_u.h"
-#include "agg_renderer_scanline.h"
-#include "agg_pixfmt_rgba.h"
-#include "agg_path_storage.h"
-#include "agg_span_allocator.h"
-#include "agg_span_pattern_rgba.h"
-#include "agg_image_accessors.h"
-#include "agg_pattern_filters_rgba.h"
-#include "agg_renderer_outline_image.h"
 
+
 namespace mapnik
 {
-    class pattern_source : private boost::noncopyable
-    {
-    public:
-	pattern_source(ImageData32 const& pattern)
-	    : pattern_(pattern) {}
-	
-	unsigned int width() const
-	{
-	    return pattern_.width();
-	}
-	unsigned int height() const
-	{
-	    return pattern_.height();
-	}
-	agg::rgba8 pixel(int x, int y) const
-	{
-	    unsigned c = pattern_(x,y);
-	    return agg::rgba8(c & 0xff, (c >> 8) & 0xff, (c >> 16) & 0xff,(c >> 24) & 0xff);
-	}
-    private:
-	ImageData32 const& pattern_;
-    };
-
+    
     line_pattern_symbolizer::line_pattern_symbolizer(std::string const& file,
 			    std::string const& type,
 			    unsigned width,unsigned height) 
-	: symbolizer(),
-	  pattern_(width,height)
+	: pattern_(new ImageData32(width,height))
     {
 	try 
 	{
 	    std::auto_ptr<ImageReader> reader(get_image_reader(type,file));
-	    reader->read(0,0,pattern_);		
+	    reader->read(0,0,*pattern_);		
 	} 
 	catch (...) 
 	{
 	    std::cerr << "exception caught..." << std::endl;
 	}
     }
-    
-    void line_pattern_symbolizer::render(Feature const& feat, CoordTransform const& t,Image32& image) const
-    { 
-	typedef  coord_transform<CoordTransform,geometry_type> path_type;
-	typedef agg::line_image_pattern<agg::pattern_filter_bilinear_rgba8> pattern_type;
-	typedef agg::renderer_base<agg::pixfmt_rgba32> renderer_base;
-	typedef agg::renderer_outline_image<renderer_base, pattern_type> renderer_type;
-	typedef agg::rasterizer_outline_aa<renderer_type> rasterizer_type;
 
-	geometry_ptr const& geom=feat.get_geometry();
-	if (geom)
-	{
-	    path_type path(t,*geom);
-	    unsigned int width=image.width();
-	    unsigned int height=image.height();
-	    agg::row_ptr_cache<agg::int8u> buf(image.raw_data(), width, height,width*4);
-	    agg::pixfmt_rgba32 pixf(buf);
-	    renderer_base ren_base(pixf);  
-	    agg::pattern_filter_bilinear_rgba8 filter; 
-	    pattern_source source(pattern_);
-	    pattern_type pattern (filter,source);
-	    renderer_type ren(ren_base, pattern);
-	    ren.clip_box(0,0,width,height);
-	    rasterizer_type ras(ren);	    
-	    ras.add_path(path);    
-	}
+    line_pattern_symbolizer::line_pattern_symbolizer(line_pattern_symbolizer const& rhs)
+	: pattern_(rhs.pattern_) {}
+
+    ImageData32 const& line_pattern_symbolizer::get_pattern() const
+    {
+	return *pattern_;
     }
 }

Modified: trunk/src/map.cpp
===================================================================
--- trunk/src/map.cpp	2006-02-06 01:08:32 UTC (rev 149)
+++ trunk/src/map.cpp	2006-02-07 14:41:41 UTC (rev 150)
@@ -66,12 +66,13 @@
 	styles_.erase(name);
     }
     
-    feature_type_style Map::find_style(std::string const& name) const
+    feature_type_style const&  Map::find_style(std::string const& name) const
     {
 	std::map<std::string,feature_type_style>::const_iterator itr=styles_.find(name);
 	if (itr!=styles_.end()) 
 	    return itr->second;
-	return feature_type_style();
+	static feature_type_style default_style;
+	return default_style;
     }
     
     size_t Map::layerCount() const

Added: trunk/src/point_symbolizer.cpp
===================================================================
--- trunk/src/point_symbolizer.cpp	2006-02-06 01:08:32 UTC (rev 149)
+++ trunk/src/point_symbolizer.cpp	2006-02-07 14:41:41 UTC (rev 150)
@@ -0,0 +1,52 @@
+/* This file is part of Mapnik (c++ mapping toolkit)
+ * Copyright (C) 2005 Artem Pavlenko
+ *
+ * Mapnik is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+//$Id$
+
+#include "point_symbolizer.hpp"
+#include "image_data.hpp"
+#include "image_reader.hpp"
+
+namespace mapnik
+{
+    point_symbolizer::point_symbolizer(std::string const& file,
+				       std::string const& type,
+				       unsigned width,unsigned height) 
+	: symbol_(new ImageData32(width,height))
+    {
+	try 
+	{
+	    std::auto_ptr<ImageReader> reader(get_image_reader(type,file));
+	    reader->read(0,0,*symbol_);		
+	} 
+	catch (...) 
+	{
+	    std::cerr<<"exception caught..." << std::endl;
+	}
+    }
+    
+    point_symbolizer::point_symbolizer(point_symbolizer const& rhs)
+	: symbol_(rhs.symbol_) 
+    {}
+    
+    ImageData32 const& point_symbolizer::get_data() const
+    {
+	return *(symbol_.get());
+    }
+}
+

Modified: trunk/src/polygon_pattern_symbolizer.cpp
===================================================================
--- trunk/src/polygon_pattern_symbolizer.cpp	2006-02-06 01:08:32 UTC (rev 149)
+++ trunk/src/polygon_pattern_symbolizer.cpp	2006-02-07 14:41:41 UTC (rev 150)
@@ -21,83 +21,29 @@
 #include "polygon_pattern_symbolizer.hpp"
 
 #include "image_reader.hpp"
-#include "agg_basics.h"
-#include "agg_rendering_buffer.h"
-#include "agg_rasterizer_scanline_aa.h"
-#include "agg_scanline_p.h"
-#include "agg_scanline_u.h"
-#include "agg_renderer_scanline.h"
-#include "agg_pixfmt_rgba.h"
-#include "agg_path_storage.h"
-#include "agg_span_allocator.h"
-#include "agg_span_pattern_rgba.h"
-#include "agg_image_accessors.h"
 
 namespace mapnik
 {
     polygon_pattern_symbolizer::polygon_pattern_symbolizer(std::string const& file,
 							   std::string const& type,
 							   unsigned width,unsigned height) 
-	: symbolizer(),
-	  pattern_(width,height)
+	: pattern_(new ImageData32(width,height))
     {
 	try 
 	{
 	    std::auto_ptr<ImageReader> reader(get_image_reader(type,file));
-	    reader->read(0,0,pattern_);		
+	    reader->read(0,0,*pattern_);		
 	} 
 	catch (...) 
 	{
 	    std::cerr<<"exception caught..."<<std::endl;
 	}
     }
+    polygon_pattern_symbolizer::polygon_pattern_symbolizer(polygon_pattern_symbolizer const& rhs)
+	: pattern_(rhs.pattern_) {}
     
-    void polygon_pattern_symbolizer::render(Feature const& feat,CoordTransform const& t,Image32& image) const
+    ImageData32 const& polygon_pattern_symbolizer::get_pattern() const
     {
-	typedef  coord_transform<CoordTransform,geometry_type> path_type;
-	typedef agg::renderer_base<agg::pixfmt_rgba32> ren_base; 
-	typedef agg::wrap_mode_repeat wrap_x_type;
-	typedef agg::wrap_mode_repeat wrap_y_type;
-	typedef agg::image_accessor_wrap<agg::pixfmt_rgba32, 
-	    wrap_x_type,
-	    wrap_y_type> img_source_type;
-	
-	typedef agg::span_pattern_rgba<img_source_type> span_gen_type;
-	
-	typedef agg::renderer_scanline_aa<ren_base, 
-	    agg::span_allocator<agg::rgba8>,
-	    span_gen_type> renderer_type;  
-	geometry_ptr const& geom=feat.get_geometry();
-	if (geom)
-	{
-	    path_type path(t,*geom);
-	    
-	    agg::row_ptr_cache<agg::int8u> buf(image.raw_data(),image.width(),image.height(),
-					       image.width()*4);
-	    agg::pixfmt_rgba32 pixf(buf);
-	    ren_base renb(pixf);
-	
-	    unsigned w=pattern_.width();
-	    unsigned h=pattern_.height();
-	    agg::row_ptr_cache<agg::int8u> pattern_rbuf((agg::int8u*)pattern_.getBytes(),w,h,w*4);  
-	    
-	    double x0,y0;
-	    path.vertex(&x0,&y0);
-	    path.rewind(0);
-	
-	    unsigned offset_x = unsigned(image.width() - x0);
-	    unsigned offset_y = unsigned(image.height() - y0);
-	
-	    agg::span_allocator<agg::rgba8> sa;
-	    img_source_type img_src(pattern_rbuf);
-	    span_gen_type sg(img_src, offset_x, offset_y);
-	    renderer_type rp(renb,sa, sg);
-	
-	    agg::rasterizer_scanline_aa<> ras;
-	    agg::scanline_u8 sl;
-	    ras.clip_box(0,0,image.width(),image.height());
-	    ras.add_path(path);
-	    agg::render_scanlines(ras, sl, rp);   
-	}
+	return *pattern_;
     }
 }

Modified: trunk/src/render.cpp
===================================================================
--- trunk/src/render.cpp	2006-02-06 01:08:32 UTC (rev 149)
+++ trunk/src/render.cpp	2006-02-07 14:41:41 UTC (rev 150)
@@ -44,8 +44,6 @@
 	std::vector<std::string>::const_iterator stylesIter=namedStyles.begin();
 	while (stylesIter!=namedStyles.end())
 	{
-	    //feature_type_style style=named_style_cache::instance()->find(*stylesIter++);
-	    
 	    std::set<std::string> names;
 	    attribute_collector<Feature> collector(names);
 	    property_index<Feature> indexer(names);
@@ -56,8 +54,8 @@
 	    
 	    bool active_rules=false;
 
-	    feature_type_style style=map.find_style(*stylesIter++);
-
+	    feature_type_style const& style=map.find_style(*stylesIter++);
+	    
 	    const std::vector<rule_type>& rules=style.get_rules();
 	    std::vector<rule_type>::const_iterator ruleIter=rules.begin();
 	    



From pavlenko at berlios.de  Tue Feb  7 17:16:57 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Tue, 7 Feb 2006 17:16:57 +0100
Subject: [Mapnik-svn] r151 - in trunk: include src
Message-ID: <200602071616.k17GGvXq012754@sheep.berlios.de>

Author: pavlenko
Date: 2006-02-07 17:16:54 +0100 (Tue, 07 Feb 2006)
New Revision: 151

Added:
   trunk/include/raster_symbolizer.hpp
Modified:
   trunk/include/agg_renderer.hpp
   trunk/include/feature_style_processor.hpp
   trunk/include/mapnik.hpp
   trunk/include/rule.hpp
   trunk/src/agg_renderer.cpp
Log:
added raster_symbolizer



Modified: trunk/include/agg_renderer.hpp
===================================================================
--- trunk/include/agg_renderer.hpp	2006-02-07 14:41:41 UTC (rev 150)
+++ trunk/include/agg_renderer.hpp	2006-02-07 16:16:54 UTC (rev 151)
@@ -33,6 +33,7 @@
 	void process(line_pattern_symbolizer const& sym,Feature const& feature);
 	void process(polygon_symbolizer const& sym,Feature const& feature);
 	void process(polygon_pattern_symbolizer const& sym,Feature const& feature);
+	void process(raster_symbolizer const& sym,Feature const& feature);
     private:
 	Image32 & pixmap_;
 	CoordTransform t_;

Modified: trunk/include/feature_style_processor.hpp
===================================================================
--- trunk/include/feature_style_processor.hpp	2006-02-07 14:41:41 UTC (rev 150)
+++ trunk/include/feature_style_processor.hpp	2006-02-07 16:16:54 UTC (rev 151)
@@ -67,6 +67,11 @@
 	    {
 		output_.process(sym,f_);
 	    }
+
+	    void operator () (raster_symbolizer const& sym) const
+	    {
+		output_.process(sym,f_);
+	    }
 	    
 	    Processor & output_;
 	    Feature const& f_;

Modified: trunk/include/mapnik.hpp
===================================================================
--- trunk/include/mapnik.hpp	2006-02-07 14:41:41 UTC (rev 150)
+++ trunk/include/mapnik.hpp	2006-02-07 16:16:54 UTC (rev 151)
@@ -49,6 +49,7 @@
 #include "polygon_pattern_symbolizer.hpp"
 #include "line_pattern_symbolizer.hpp"
 #include "point_symbolizer.hpp"
+#include "raster_symbolizer.hpp"
 #include "image_util.hpp"
 #include "datasource.hpp"
 #include "layer.hpp"

Added: trunk/include/raster_symbolizer.hpp
===================================================================
--- trunk/include/raster_symbolizer.hpp	2006-02-07 14:41:41 UTC (rev 150)
+++ trunk/include/raster_symbolizer.hpp	2006-02-07 16:16:54 UTC (rev 151)
@@ -0,0 +1,31 @@
+/* This file is part of Mapnik (c++ mapping toolkit)
+ * Copyright (C) 2005 Artem Pavlenko
+ *
+ * Mapnik is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+//$Id$
+
+#ifndef RASTER_SYMBOLIZER_HPP
+#define RASTER_SYMBOLIZER_HPP
+
+#include <boost/shared_ptr.hpp> 
+
+namespace mapnik
+{
+    struct raster_symbolizer { /* TODO */};
+}
+
+#endif //RASTER_SYMBOLIZER

Modified: trunk/include/rule.hpp
===================================================================
--- trunk/include/rule.hpp	2006-02-07 14:41:41 UTC (rev 150)
+++ trunk/include/rule.hpp	2006-02-07 16:16:54 UTC (rev 151)
@@ -24,6 +24,7 @@
 #include "polygon_symbolizer.hpp"
 #include "polygon_pattern_symbolizer.hpp"
 #include "point_symbolizer.hpp"
+#include "raster_symbolizer.hpp"
 #include "filter.hpp"
 #include <boost/shared_ptr.hpp>
 #include <boost/variant.hpp>
@@ -37,7 +38,8 @@
 			   line_symbolizer,
 			   line_pattern_symbolizer,
 			   polygon_symbolizer,
-			   polygon_pattern_symbolizer> symbolizer;
+			   polygon_pattern_symbolizer,
+			   raster_symbolizer> symbolizer;
     
     typedef std::vector<symbolizer> symbolizers;    
     template <typename FeatureT> class all_filter;

Modified: trunk/src/agg_renderer.cpp
===================================================================
--- trunk/src/agg_renderer.cpp	2006-02-07 14:41:41 UTC (rev 150)
+++ trunk/src/agg_renderer.cpp	2006-02-07 16:16:54 UTC (rev 151)
@@ -332,4 +332,15 @@
 	    agg::render_scanlines(ras, sl, rp);   
 	}
     }
+    void agg_renderer::process(raster_symbolizer const& ,Feature const& feature)
+    {
+	// TODO -- at the moment raster_symbolizer is an empty class 
+	// used for type dispatching, but we can have some fancy raster
+	// processing in a future (filters??). Just copy raster into pixmap for now.
+	raster_ptr const& raster=feature.get_raster();
+	if (raster)
+	{
+	    pixmap_.set_rectangle(raster->x_,raster->y_,raster->data_);
+	}
+    }
 }



From pavlenko at berlios.de  Tue Feb  7 21:51:10 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Tue, 7 Feb 2006 21:51:10 +0100
Subject: [Mapnik-svn] r152 - trunk/include
Message-ID: <200602072051.k17KpAuB015671@sheep.berlios.de>

Author: pavlenko
Date: 2006-02-07 21:51:08 +0100 (Tue, 07 Feb 2006)
New Revision: 152

Modified:
   trunk/include/feature_style_processor.hpp
Log:
Of course,we can use one templated member functions
to handle all symbolizers.



Modified: trunk/include/feature_style_processor.hpp
===================================================================
--- trunk/include/feature_style_processor.hpp	2006-02-07 16:16:54 UTC (rev 151)
+++ trunk/include/feature_style_processor.hpp	2006-02-07 20:51:08 UTC (rev 152)
@@ -43,36 +43,12 @@
 	    symbol_dispatch (Processor & output,Feature const& f)
 		: output_(output),f_(f) {}
 	    
-	    void operator () (polygon_symbolizer const& sym) const
+	    template <typename T>
+	    void operator () (T const& sym) const
 	    {
 		output_.process(sym,f_);
 	    }
 
-	    void operator () (polygon_pattern_symbolizer const& sym) const
-	    {
-		output_.process(sym,f_);
-	    }
-	    
-	    void operator () (line_symbolizer const& sym) const
-	    {
-		output_.process(sym,f_);
-	    }
-	    
-	    void operator () (line_pattern_symbolizer const& sym) const
-	    {
-		output_.process(sym,f_);
-	    }
-	   
-	    void operator () (point_symbolizer const& sym) const
-	    {
-		output_.process(sym,f_);
-	    }
-
-	    void operator () (raster_symbolizer const& sym) const
-	    {
-		output_.process(sym,f_);
-	    }
-	    
 	    Processor & output_;
 	    Feature const& f_;
 	};



From pavlenko at berlios.de  Wed Feb  8 11:44:47 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Wed, 8 Feb 2006 11:44:47 +0100
Subject: [Mapnik-svn] r153 - trunk/include
Message-ID: <200602081044.k18Ail4T001086@sheep.berlios.de>

Author: pavlenko
Date: 2006-02-08 11:44:46 +0100 (Wed, 08 Feb 2006)
New Revision: 153

Modified:
   trunk/include/agg_renderer.hpp
Log:
make agg_renderer non-copyable

Modified: trunk/include/agg_renderer.hpp
===================================================================
--- trunk/include/agg_renderer.hpp	2006-02-07 20:51:08 UTC (rev 152)
+++ trunk/include/agg_renderer.hpp	2006-02-08 10:44:46 UTC (rev 153)
@@ -22,10 +22,12 @@
 #define AGG_RENDERER_HPP
 
 #include "feature_style_processor.hpp"
+#include <boost/utility.hpp>
 
 namespace mapnik
 {
-    struct agg_renderer : public feature_style_processor<agg_renderer> 
+    struct agg_renderer : public feature_style_processor<agg_renderer>,
+			  private boost::noncopyable
     {
 	agg_renderer(Map const& m, Image32 & pixmap);
 	void process(point_symbolizer const& sym,Feature const& feature);	    	       



From pavlenko at berlios.de  Fri Feb 10 18:07:16 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Fri, 10 Feb 2006 18:07:16 +0100
Subject: [Mapnik-svn] r154 - in trunk/agg: include src
Message-ID: <200602101707.k1AH7GtG028400@sheep.berlios.de>

Author: pavlenko
Date: 2006-02-10 18:07:15 +0100 (Fri, 10 Feb 2006)
New Revision: 154

Modified:
   trunk/agg/include/agg_scanline_boolean_algebra.h
   trunk/agg/include/agg_scanline_storage_aa.h
   trunk/agg/include/agg_scanline_storage_bin.h
   trunk/agg/include/agg_span_image_filter_gray.h
   trunk/agg/src/agg_curves.cpp
Log:
updated agg-2.4



Modified: trunk/agg/include/agg_scanline_boolean_algebra.h
===================================================================
--- trunk/agg/include/agg_scanline_boolean_algebra.h	2006-02-08 10:44:46 UTC (rev 153)
+++ trunk/agg/include/agg_scanline_boolean_algebra.h	2006-02-10 17:07:15 UTC (rev 154)
@@ -850,8 +850,8 @@
         unsigned num1 = sl1.num_spans();
         unsigned num2 = sl2.num_spans();
 
-        typename Scanline1::const_iterator span1;
-        typename Scanline2::const_iterator span2;
+        typename Scanline1::const_iterator span1;// = sl1.begin();
+        typename Scanline2::const_iterator span2;// = sl2.begin();
 
         enum invalidation_e 
         { 
@@ -1046,7 +1046,11 @@
 
         // Calculate the union of the bounding boxes
         //-----------------
-        rect_i ur = unite_rectangles(r1, r2);
+        rect_i ur(1,1,0,0);
+             if(flag1 && flag2) ur = unite_rectangles(r1, r2);
+        else if(flag1)          ur = r1;
+        else if(flag2)          ur = r2;
+
         if(!ur.is_valid()) return;
 
         ren.prepare();
@@ -1176,7 +1180,7 @@
         ren.prepare();
 
         // A fake span2 processor
-        sbool_add_span_empty<Scanline1, Scanline> add_span2;
+        sbool_add_span_empty<Scanline2, Scanline> add_span2;
 
         // The main loop
         // Here we synchronize the scanlines with 

Modified: trunk/agg/include/agg_scanline_storage_aa.h
===================================================================
--- trunk/agg/include/agg_scanline_storage_aa.h	2006-02-08 10:44:46 UTC (rev 153)
+++ trunk/agg/include/agg_scanline_storage_aa.h	2006-02-10 17:07:15 UTC (rev 154)
@@ -196,6 +196,7 @@
                     const T* covers;
                 };
 
+                const_iterator() : m_storage(0) {}
                 const_iterator(const embedded_scanline& sl) :
                     m_storage(sl.m_storage),
                     m_span_idx(sl.m_scanline.start_span)
@@ -554,6 +555,7 @@
                     const T* covers; 
                 };
 
+                const_iterator() : m_ptr(0) {}
                 const_iterator(const embedded_scanline& sl) :
                     m_ptr(sl.m_ptr),
                     m_dx(sl.m_dx)
@@ -721,9 +723,8 @@
                 m_min_y = read_int32() + m_dy;
                 m_max_x = read_int32() + m_dx;
                 m_max_y = read_int32() + m_dy;
-                return true;
             }
-            return false;
+            return m_ptr < m_end;
         }
 
         //--------------------------------------------------------------------

Modified: trunk/agg/include/agg_scanline_storage_bin.h
===================================================================
--- trunk/agg/include/agg_scanline_storage_bin.h	2006-02-08 10:44:46 UTC (rev 153)
+++ trunk/agg/include/agg_scanline_storage_bin.h	2006-02-10 17:07:15 UTC (rev 154)
@@ -63,6 +63,7 @@
             class const_iterator
             {
             public:
+                const_iterator() : m_storage(0) {}
                 const_iterator(const embedded_scanline& sl) :
                     m_storage(sl.m_storage),
                     m_span_idx(sl.m_scanline.start_span)
@@ -360,6 +361,7 @@
                     int32 len;
                 };
 
+                const_iterator() : m_ptr(0) {}
                 const_iterator(const embedded_scanline& sl) :
                     m_ptr(sl.m_ptr),
                     m_dx(sl.m_dx)
@@ -503,9 +505,8 @@
                 m_min_y = read_int32() + m_dy;
                 m_max_x = read_int32() + m_dx;
                 m_max_y = read_int32() + m_dy;
-                return true;
             }
-            return false;
+            return m_ptr < m_end;
         }
 
         //--------------------------------------------------------------------

Modified: trunk/agg/include/agg_span_image_filter_gray.h
===================================================================
--- trunk/agg/include/agg_span_image_filter_gray.h	2006-02-08 10:44:46 UTC (rev 153)
+++ trunk/agg/include/agg_span_image_filter_gray.h	2006-02-10 17:07:15 UTC (rev 154)
@@ -123,7 +123,6 @@
                 int x_lr = x_hr >> image_subpixel_shift;
                 int y_lr = y_hr >> image_subpixel_shift;
 
-                unsigned weight;
                 fg = image_subpixel_scale * image_subpixel_scale / 2;
 
                 x_hr &= image_subpixel_mask;
@@ -139,7 +138,7 @@
                 fg    += *fg_ptr * (image_subpixel_scale - x_hr) * y_hr;
 
                 fg_ptr = (const value_type*)base_type::source().next_x();
-                fg    += fg_ptr * x_hr * y_hr;
+                fg    += *fg_ptr * x_hr * y_hr;
 
                 span->v = value_type(fg >> (image_subpixel_shift * 2));
                 span->a = base_mask;

Modified: trunk/agg/src/agg_curves.cpp
===================================================================
--- trunk/agg/src/agg_curves.cpp	2006-02-08 10:44:46 UTC (rev 153)
+++ trunk/agg/src/agg_curves.cpp	2006-02-10 17:07:15 UTC (rev 154)
@@ -262,9 +262,9 @@
         double dx3 = x4 - x3;
         double dy3 = y4 - y3;
 
-        double len = sqrt(dx1 * dx1 + dy1 * dy1) + 
-                     sqrt(dx2 * dx2 + dy2 * dy2) + 
-                     sqrt(dx3 * dx3 + dy3 * dy3) * 0.25 * m_scale;
+        double len = (sqrt(dx1 * dx1 + dy1 * dy1) + 
+                      sqrt(dx2 * dx2 + dy2 * dy2) + 
+                      sqrt(dx3 * dx3 + dy3 * dy3)) * 0.25 * m_scale;
 
 #if defined(_MSC_VER) && _MSC_VER <= 1200
         m_num_steps = uround(MSC60_fix_ICE(len));



From pavlenko at berlios.de  Fri Feb 10 18:13:04 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Fri, 10 Feb 2006 18:13:04 +0100
Subject: [Mapnik-svn] r155 - in trunk: include plugins/input/postgis plugins/input/shape src
Message-ID: <200602101713.k1AHD4Gr029121@sheep.berlios.de>

Author: pavlenko
Date: 2006-02-10 18:13:02 +0100 (Fri, 10 Feb 2006)
New Revision: 155

Modified:
   trunk/include/agg_renderer.hpp
   trunk/include/attribute_collector.hpp
   trunk/include/expression.hpp
   trunk/include/feature.hpp
   trunk/include/feature_style_processor.hpp
   trunk/include/feature_type_style.hpp
   trunk/include/filter.hpp
   trunk/include/filter_visitor.hpp
   trunk/include/mapnik.hpp
   trunk/include/property_index.hpp
   trunk/include/rule.hpp
   trunk/include/text_symbolizer.hpp
   trunk/include/value.hpp
   trunk/plugins/input/postgis/postgisfs.cpp
   trunk/plugins/input/shape/dbffile.cpp
   trunk/plugins/input/shape/dbffile.hpp
   trunk/plugins/input/shape/shape_featureset.cpp
   trunk/plugins/input/shape/shape_index_featureset.cpp
   trunk/src/agg_renderer.cpp
Log:
1. new feature model - based on boost::property_map concept
       f = feature(id);
       f["name"] = "what is my name?";
       boost.put(f,"area",123123.4325);
       
2. simplified and corrected value class and operators
3. updated input plug-ins to work with new features
4. add text_symbolizer (getting there:)
5. template version of agg_renderer 
6. attribute_collector how accepts rules 
	(to collect attribute names for text labels)
  	


Modified: trunk/include/agg_renderer.hpp
===================================================================
--- trunk/include/agg_renderer.hpp	2006-02-10 17:07:15 UTC (rev 154)
+++ trunk/include/agg_renderer.hpp	2006-02-10 17:13:02 UTC (rev 155)
@@ -26,18 +26,20 @@
 
 namespace mapnik
 {
-    struct agg_renderer : public feature_style_processor<agg_renderer>,
+    template <typename T>
+    struct agg_renderer : public feature_style_processor<agg_renderer<T> >,
 			  private boost::noncopyable
     {
-	agg_renderer(Map const& m, Image32 & pixmap);
+	agg_renderer(Map const& m, T & pixmap);
 	void process(point_symbolizer const& sym,Feature const& feature);	    	       
 	void process(line_symbolizer const& sym,Feature const& feature);
 	void process(line_pattern_symbolizer const& sym,Feature const& feature);
 	void process(polygon_symbolizer const& sym,Feature const& feature);
 	void process(polygon_pattern_symbolizer const& sym,Feature const& feature);
 	void process(raster_symbolizer const& sym,Feature const& feature);
+	void process(text_symbolizer const& sym,Feature const& feature);
     private:
-	Image32 & pixmap_;
+	T & pixmap_;
 	CoordTransform t_;
     };
 }

Modified: trunk/include/attribute_collector.hpp
===================================================================
--- trunk/include/attribute_collector.hpp	2006-02-10 17:07:15 UTC (rev 154)
+++ trunk/include/attribute_collector.hpp	2006-02-10 17:13:02 UTC (rev 155)
@@ -24,15 +24,35 @@
 #include "filter.hpp"
 #include "expression.hpp"
 #include "feature_layer_desc.hpp"
-
+#include "rule.hpp"
 #include <set>
+#include <iostream>
 
 namespace mapnik
 {
+    
+    struct symbolizer_attributes : public boost::static_visitor<>
+    {
+	symbolizer_attributes(std::set<std::string>& names)
+	    : names_(names) {}
+	
+	template <typename T>
+	void operator () (T const&) const {}
+	void operator () (text_symbolizer const& sym)
+	{
+	    names_.insert(sym.get_name());
+	}
+    private:
+	std::set<std::string>& names_;
+    };
+
     template <typename FeatureT>
     class attribute_collector : public filter_visitor<FeatureT>
     {
+    private:
+	std::set<std::string>& names_;
     public:
+	
 	attribute_collector(std::set<std::string>& names)
 	    : names_(names) {}
 	
@@ -48,15 +68,27 @@
 	    {
 		names_.insert(pf->name());
 	    }
-	}	
+	}
+	void visit(rule_type const& r)
+	{	    
+	    const symbolizers& symbols = r.get_symbolizers();
+	    symbolizers::const_iterator symIter=symbols.begin();
+	    symbolizer_attributes attr(names_);
+	    while (symIter != symbols.end())
+	    {
+		boost::apply_visitor(attr,*symIter++);
+	    }
+	    filter_ptr const& filter = r.get_filter();
+	    filter->accept(*this);
+	}
+
 	virtual ~attribute_collector() {}
     private:
+	
 	// no copying 
 	attribute_collector(attribute_collector const&);
 	attribute_collector& operator=(attribute_collector const&);
-    private:
-	std::set<std::string>& names_;
-    };
+    };   
 }
 
 #endif //ATTRIBUTE_COLLECTOR_HPP

Modified: trunk/include/expression.hpp
===================================================================
--- trunk/include/expression.hpp	2006-02-10 17:07:15 UTC (rev 154)
+++ trunk/include/expression.hpp	2006-02-10 17:13:02 UTC (rev 155)
@@ -82,19 +82,19 @@
     public:
 	property(std::string const& name)
 	    : expression<FeatureT>(),
-	      name_(name),
-	      index_(0),
-	      valid_(false) {}
+	      name_(name)
+	{}
 	
 	property(property const& other)
 	    : expression<FeatureT>(),
-	      name_(other.name_),
-	      index_(other.index_),
-	      valid_(other.valid_) {}
+	      name_(other.name_)
+	      //index_(other.index_),
+	      //valid_(other.valid_)
+	{}
 
 	value get_value(FeatureT const& feature) const
 	{
-	    return feature.get_property(index_);
+	    return feature[name_];
 	}
 	void accept(filter_visitor<FeatureT>& v)
 	{
@@ -110,8 +110,8 @@
 	}
 	void set_index(size_t index) 
 	{
-	    index_=index;
-	    valid_=true;
+	    //index_=index;
+	    //valid_=true;
 	}
 	std::string to_string() const
 	{
@@ -120,8 +120,8 @@
         ~property() {}
     private:
 	std::string name_;
-	size_t index_;
-	bool valid_;
+	//size_t index_;
+	//bool valid_;
     };
 }
 

Modified: trunk/include/feature.hpp
===================================================================
--- trunk/include/feature.hpp	2006-02-10 17:07:15 UTC (rev 154)
+++ trunk/include/feature.hpp	2006-02-10 17:13:02 UTC (rev 155)
@@ -24,15 +24,20 @@
 #include "geometry.hpp"
 #include "raster.hpp"
 #include "value.hpp"
-#include <vector>
+#include <map>
 
+#include <boost/property_map.hpp>
+#include <boost/utility.hpp>
+
 namespace mapnik
 {
     typedef boost::shared_ptr<raster> raster_ptr;    
-    typedef std::vector<value> properties;
+    //typedef std::vector<value> properties;
+    typedef boost::associative_property_map<std::map<std::string,value> > properties;
     
     template <typename T1,typename T2>
-    struct feature
+    struct feature : public properties,
+		     private boost::noncopyable
     {
     public:
 	typedef T1 geometry_type;
@@ -41,32 +46,20 @@
 	int id_;
 	geometry_type geom_;
 	raster_type   raster_;
-	properties props_;
+	std::map<std::string,value> props_;
     public:
 	explicit feature(int id)
-	    : id_(id),
+	    : properties(props_),
+	      id_(id),
 	      geom_(),
 	      raster_() {}
 
 	feature(int id,const geometry_type& geom)
-	    : id_(id),
+	    : properties(props_),
+	      id_(id),
 	      geom_(geom),
 	      raster_() {}
 
-	feature(const feature<T1,T2>& rhs)
-	    : id_(rhs.id_),
-	      geom_(rhs.geom_),
-	      raster_(rhs.raster_) {}
-
-	feature<T1,T2>& operator=(const feature<T1,T2>& rhs) 
-	{
-	    feature<T1,T2> tmp;
-	    swap(tmp);
-	    return *this;
-	}
-	
-	~feature() {}
-
 	int id() const 
 	{
 	    return id_;
@@ -90,51 +83,32 @@
 	{
 	    raster_=raster;
 	}
-
-        void reserve_props(unsigned n)
-	{
-	    props_.reserve(n);
-	}
-
-	void add_property(int v)
-	{
-	    return props_.push_back(value(v));
-	}
 	
-	void add_property(double v)
-	{
-	    return props_.push_back(value(v));
-	}
-	
-	void add_property(std::string const& v)
-	{
-	    return props_.push_back(value(v));
-	}
-
-	value get_property(size_t index) const
-	{
-	    if (index < props_.size())
-		return props_[index]; 
-	    else
-		return value("");
-	}
-	
 	const properties& get_properties() const 
 	{
 	    return props_;
 	}
-   
-    private:
-	void swap(const feature<T1,T2>& rhs) throw()
+	
+	std::string to_string() const
 	{
-	    std::swap(id_,rhs.id_);
-	    std::swap(geom_,rhs.geom_);
-	    std::swap(raster_,rhs.raster_);
-	    std::swap(props_,rhs.props_);
+	    std::stringstream ss;
+	    ss << "feature (" << std::endl;
+	    for (std::map<std::string,value>::const_iterator itr=props_.begin();
+		 itr != props_.end();++itr)
+	    {
+		ss << "  " << itr->first  << ":" <<  itr->second << std::endl;
+	    }
+	    ss << ")" << std::endl;
+	    return ss.str();
 	}
     };
 
     typedef feature<geometry_ptr,raster_ptr> Feature;
     
+    inline std::ostream& operator<< (std::ostream & out,Feature const& f)
+    {
+	out << f.to_string();
+    	return out;
+    }
 }
 #endif                                            //FEATURE_HPP

Modified: trunk/include/feature_style_processor.hpp
===================================================================
--- trunk/include/feature_style_processor.hpp	2006-02-10 17:07:15 UTC (rev 154)
+++ trunk/include/feature_style_processor.hpp	2006-02-10 17:13:02 UTC (rev 155)
@@ -29,7 +29,6 @@
 #include "layer.hpp"
 #include "map.hpp"
 #include "attribute_collector.hpp"
-#include "property_index.hpp"
 #include "utils.hpp"
 
 namespace mapnik
@@ -64,7 +63,8 @@
 	    std::vector<Layer>::const_iterator itr = m_.layers().begin();
 	    while (itr != m_.layers().end())
 	    {
-		if (itr->isVisible(m_.scale()))// && itr->envelope().intersects(extent))
+		if (itr->isVisible(m_.scale()) && 
+		    itr->envelope().intersects(m_.getCurrentExtent()))
 		{
 		    apply_to_layer(*itr,p);
 		}
@@ -87,7 +87,7 @@
 		{
 		    std::set<std::string> names;
 		    attribute_collector<Feature> collector(names);
-		    property_index<Feature> indexer(names);
+		    //property_index<Feature> indexer(names);
 		    std::vector<rule_type*> if_rules;
 		    std::vector<rule_type*> else_rules;
 		
@@ -104,9 +104,10 @@
 			if (ruleIter->active(scale))
 			{
 			    active_rules=true;
-			    filter_ptr& filter=const_cast<filter_ptr&>(ruleIter->get_filter());
-			    filter->accept(collector);
-			    filter->accept(indexer);
+			    //filter_ptr& filter=const_cast<filter_ptr&>(ruleIter->get_filter());
+			    //filter->accept(collector);
+			    ruleIter->accept(collector);
+			    //filter->accept(indexer);
 			    if (ruleIter->has_else_filter())
 			    {
 				else_rules.push_back(const_cast<rule_type*>(&(*ruleIter)));

Modified: trunk/include/feature_type_style.hpp
===================================================================
--- trunk/include/feature_type_style.hpp	2006-02-10 17:07:15 UTC (rev 154)
+++ trunk/include/feature_type_style.hpp	2006-02-10 17:13:02 UTC (rev 155)
@@ -28,7 +28,6 @@
 
 namespace mapnik
 {
-    typedef rule<Feature,filter> rule_type;
     typedef std::vector<rule_type> rules;
     class feature_type_style
     {

Modified: trunk/include/filter.hpp
===================================================================
--- trunk/include/filter.hpp	2006-02-10 17:07:15 UTC (rev 154)
+++ trunk/include/filter.hpp	2006-02-10 17:13:02 UTC (rev 155)
@@ -21,12 +21,11 @@
 #ifndef FILTER_HPP
 #define FILTER_HPP
 
-#include "filter_visitor.hpp"
+//#include "filter_visitor.hpp"
 #include "feature.hpp"
+
 namespace mapnik
 {
-    typedef boost::shared_ptr<filter<Feature> > filter_ptr;
-
     template <typename FeatureT> class filter_visitor;
     template <typename FeatureT>
     struct filter
@@ -37,8 +36,9 @@
         virtual std::string to_string() const=0;
 	virtual ~filter() {}
     };
-
     
+    typedef boost::shared_ptr<filter<Feature> > filter_ptr;
+    
     template <typename FeatureT>
     struct all_filter : public filter<FeatureT>
     {

Modified: trunk/include/filter_visitor.hpp
===================================================================
--- trunk/include/filter_visitor.hpp	2006-02-10 17:07:15 UTC (rev 154)
+++ trunk/include/filter_visitor.hpp	2006-02-10 17:13:02 UTC (rev 155)
@@ -26,11 +26,14 @@
 {
     template <typename FeatureT> class filter;
     template <typename FeatureT> class expression;
+    template <typename FeatureT> class expression;
+    template <typename Feature,template <typename> class Filter> class rule;
     template <typename FeatureT>
     struct filter_visitor
     {
 	virtual void visit(filter<FeatureT>& filter)=0;
 	virtual void visit(expression<FeatureT>&)=0;
+	virtual void visit(rule<FeatureT,filter> const& r)=0;
 	virtual ~filter_visitor() {}
     };    
 }

Modified: trunk/include/mapnik.hpp
===================================================================
--- trunk/include/mapnik.hpp	2006-02-10 17:07:15 UTC (rev 154)
+++ trunk/include/mapnik.hpp	2006-02-10 17:13:02 UTC (rev 155)
@@ -50,6 +50,7 @@
 #include "line_pattern_symbolizer.hpp"
 #include "point_symbolizer.hpp"
 #include "raster_symbolizer.hpp"
+#include "text_symbolizer.hpp"
 #include "image_util.hpp"
 #include "datasource.hpp"
 #include "layer.hpp"

Modified: trunk/include/property_index.hpp
===================================================================
--- trunk/include/property_index.hpp	2006-02-10 17:07:15 UTC (rev 154)
+++ trunk/include/property_index.hpp	2006-02-10 17:13:02 UTC (rev 155)
@@ -28,6 +28,8 @@
 
 namespace mapnik
 {
+
+    /*
     template <typename FeatureT>
     class property_index : public filter_visitor<FeatureT>
     {
@@ -63,6 +65,7 @@
 	std::set<std::string> const& names_;
 
     };
+*/
 }
 
 #endif //PROPERTY_INDEX_HPP

Modified: trunk/include/rule.hpp
===================================================================
--- trunk/include/rule.hpp	2006-02-10 17:07:15 UTC (rev 154)
+++ trunk/include/rule.hpp	2006-02-10 17:13:02 UTC (rev 155)
@@ -25,7 +25,10 @@
 #include "polygon_pattern_symbolizer.hpp"
 #include "point_symbolizer.hpp"
 #include "raster_symbolizer.hpp"
+#include "text_symbolizer.hpp"
 #include "filter.hpp"
+#include "filter_visitor.hpp"
+
 #include <boost/shared_ptr.hpp>
 #include <boost/variant.hpp>
 #include <string>
@@ -39,7 +42,8 @@
 			   line_pattern_symbolizer,
 			   polygon_symbolizer,
 			   polygon_pattern_symbolizer,
-			   raster_symbolizer> symbolizer;
+			   raster_symbolizer,
+			   text_symbolizer> symbolizer;
     
     typedef std::vector<symbolizer> symbolizers;    
     template <typename FeatureT> class all_filter;
@@ -128,12 +132,12 @@
 	    name_=name;
 	}
 	
-	const std::string& get_name() const
+	std::string const& get_name() const
 	{
 	    return name_;
 	}
 	
-	const std::string& get_title() const
+	std::string const& get_title() const
 	{
 	    return  title_;
 	}
@@ -143,12 +147,12 @@
 	    title_=title;
 	}
   
-	void set_abstract(const std::string& abstract)
+	void set_abstract(std::string const& abstract)
 	{
 	    abstract_=abstract;
 	}
 	
-	const std::string& get_abstract() const
+	std::string const& get_abstract() const
 	{
 	    return abstract_;
 	}
@@ -186,7 +190,7 @@
 	    filter_=filter;
 	}
 
-	const filter_ptr& get_filter() const
+	filter_ptr const& get_filter() const
 	{
 	    return filter_;
 	}
@@ -206,6 +210,11 @@
 	    return ( scale > min_scale_ && scale < max_scale_ );
 	}
 
+	void accept(filter_visitor<FeatureT>& v) const
+	{
+	    v.visit(*this);
+	}
+	
     private:
 	
 	void swap(rule& rhs) throw()
@@ -220,6 +229,8 @@
 	    else_filter_=rhs.else_filter_;
 	}
     };
+
+    typedef rule<Feature,filter> rule_type;
 }
 
 #endif //RULE_HPP

Modified: trunk/include/text_symbolizer.hpp
===================================================================
--- trunk/include/text_symbolizer.hpp	2006-02-10 17:07:15 UTC (rev 154)
+++ trunk/include/text_symbolizer.hpp	2006-02-10 17:13:02 UTC (rev 155)
@@ -21,34 +21,33 @@
 #ifndef TEXT_SYMBOLIZER_HPP
 #define TEXT_SYMBOLIZER_HPP
 
-#include "symbolizer.hpp"
-#include "fill.hpp"
-#include "expression.hpp"
+//#include "symbolizer.hpp"
+//#include "fill.hpp"
+//#include "expression.hpp"
 
 namespace mapnik
 {
-    template <typename FeatureT>
-    struct text_symbolizer : public symbolizer
+    struct text_symbolizer
     {
-	text_symbolizer(expression<FeatureT> const& label,fill const& f)
-	    : label_(label.clone()),
-	      fill_(f) {}
+	text_symbolizer(std::string const& name,Color const& fill)
+	    : name_(name),
+	      fill_(fill) {}
+
+	text_symbolizer(text_symbolizer const& rhs)
+	    : name_(rhs.name_),
+	      fill_(rhs.fill_) {}
 	
 	~text_symbolizer()
 	{
-	    delete label_;
+	    //
 	}
-	
-	void render(geometry_type& geom,Image32& image) const
+	std::string const& get_name() const
 	{
-	    //todo : render text
+	    return name_;
 	}
     private:
-	expression<FeatureT>* label_;
-	fill fill_;		    
-    private:
-        text_symbolizer(text_symbolizer const&);
-	text_symbolizer& operator=(text_symbolizer const&);
+	std::string name_;
+	Color fill_;		    
     };
 }
 

Modified: trunk/include/value.hpp
===================================================================
--- trunk/include/value.hpp	2006-02-10 17:07:15 UTC (rev 154)
+++ trunk/include/value.hpp	2006-02-10 17:13:02 UTC (rev 155)
@@ -25,445 +25,376 @@
 #include <sstream>
 #include <boost/variant.hpp>
 
-using std::string;
 using namespace boost;
-namespace mapnik { namespace impl {
+namespace mapnik {
 
-    typedef variant<int,double,string> value_holder;
+    typedef variant<int,double,std::string> value_base;
     
-    class equals
-	: public boost::static_visitor<bool>
-    {
-    public:
-	template <typename T, typename U>
-	bool operator()( const T &, const U & ) const
+    namespace impl {
+	struct equals
+	    : public boost::static_visitor<bool>
 	{
-	    return false;
-	}
+	    template <typename T, typename U>
+	    bool operator() (const T &, const U & ) const
+	    {
+		return false;
+	    }
 	
-	bool operator() (int lhs, int rhs) const
-	{
-	    return  lhs == rhs;
-	}
+	    template <typename T>
+	    bool operator() (T lhs, T rhs) const
+	    {
+		return lhs == rhs;
+	    }
 	
-	bool operator() (double lhs, double rhs) const
-	{
-	    return  lhs == rhs;
-	}
-
-	bool operator() (int lhs, double rhs) const
-	{
-	    return  lhs == rhs;
-	}
+	    bool operator() (int lhs, double rhs) const
+	    {
+		return  lhs == rhs;
+	    }
 	
-	bool operator() (double lhs, int rhs) const
-	{
-	    return  lhs == rhs;
-	}
+	    bool operator() (double lhs, int rhs) const
+	    {
+		return  lhs == rhs;
+	    }
 	
-	template <typename T>
-	bool operator()( const T & lhs, const T & rhs ) const
-	{
-	    return lhs == rhs;
-	}
-    };
+	    bool operator() (std::string const& lhs, std::string const& rhs) const
+	    {
+		return  lhs == rhs;
+	    }
+	};
     
-    class greater_than
-	: public boost::static_visitor<bool>
-    {
-    public:	
-	template <typename T, typename U>
-	bool operator()( const T &, const U & ) const
+	struct greater_than
+	    : public boost::static_visitor<bool>
 	{
-	    return false;
-	}
+	    template <typename T, typename U>
+	    bool operator()( const T &, const U & ) const
+	    {
+		return false;
+	    }
 	
-	bool operator() (int lhs, int rhs) const
-	{
-	    return  lhs > rhs;
-	}
+	    template <typename T>
+	    bool operator()( T lhs, T rhs ) const
+	    {
+		return lhs > rhs;
+	    }
 	
-	bool operator() (double lhs, double rhs) const
-	{
-	    return  lhs > rhs;
-	}
+	    bool operator() (int lhs, double rhs) const
+	    {
+		return  lhs > rhs;
+	    }
 	
-	bool operator() (int lhs, double rhs) const
-	{
-	    return  lhs > rhs;
-	}
+	    bool operator() (double lhs, int rhs) const
+	    {
+		return  lhs > rhs;
+	    }
 	
-	bool operator() (double lhs, int rhs) const
-	{
-	    return  lhs > rhs;
-	}
+	    bool operator() (std::string const& lhs, std::string const& rhs) const
+	    {
+		return  lhs > rhs;
+	    }
+	};
+    
+	struct greater_or_equal
+	    : public boost::static_visitor<bool>
+	{	
+	    template <typename T, typename U>
+	    bool operator()( const T &, const U & ) const
+	    {
+		return false;
+	    }
 	
-	template <typename T>
-	bool operator()( const T & lhs, const T & rhs ) const
-	{
-	    return lhs > rhs;
-	}
-    };
-    class greater_or_equal
-	: public boost::static_visitor<bool>
-    {
-    public:	
-	template <typename T, typename U>
-	bool operator()( const T &, const U & ) const
-	{
-	    return false;
-	}
+	    template <typename T>
+	    bool operator() (T lhs, T rhs) const
+	    {
+		return lhs >= rhs;
+	    }
+      
+	    bool operator() (int lhs, double rhs) const
+	    {
+		return  lhs >= rhs;
+	    }
 	
-	bool operator() (int lhs, int rhs) const
-	{
-	    return  lhs >= rhs;
-	}
+	    bool operator() (double lhs, int rhs) const
+	    {
+		return  lhs >= rhs;
+	    }
 	
-	bool operator() (double lhs, double rhs) const
-	{
-	    return  lhs >= rhs;
-	}
-	
-	bool operator() (int lhs, double rhs) const
-	{
-	    return  lhs >= rhs;
-	}
-	
-	bool operator() (double lhs, int rhs) const
-	{
-	    return  lhs >= rhs;
-	}
-	
-	template <typename T>
-	bool operator()( const T & lhs, const T & rhs ) const
-	{
-	    return lhs >= rhs;
-	}
-    };
+	    bool operator() (std::string const& lhs, std::string const& rhs ) const
+	    {
+		return lhs >= rhs;
+	    }
+	};
     
-    class less_than
-	: public boost::static_visitor<bool>
-    {
-    public:	
-	template <typename T, typename U>
-	bool operator()( const T &, const U & ) const
-	{
-	    return false;
-	}
+	struct less_than
+	    : public boost::static_visitor<bool>
+	{	
+	    template <typename T, typename U>
+	    bool operator()( const T &, const U & ) const
+	    {
+		return false;
+	    }
 	
-	bool operator() (int lhs, int rhs) const
-	{
-	    return  lhs < rhs;
-	}
+	    template <typename T>
+	    bool operator()( T  lhs,T  rhs) const
+	    {
+		return lhs < rhs;
+	    }
 	
-	bool operator() (double lhs, double rhs) const
-	{
-	    return  lhs < rhs;
-	}
+	    bool operator() (int lhs, double rhs) const
+	    {
+		return  lhs < rhs;
+	    }
+	   
+	    bool operator() (double lhs, int rhs) const
+	    {
+		return  lhs < rhs;
+	    }
 	
-	bool operator() (int lhs, double rhs) const
-	{
-	    return  lhs < rhs;
-	}
-	
-	bool operator() (double lhs, int rhs) const
-	{
-	    return  lhs < rhs;
-	}
-	
-	template <typename T>
-	bool operator()( const T & lhs, const T & rhs ) const
-	{
-	    return lhs < rhs;
-	}
-    };
+	    bool operator()( std::string const& lhs, std::string const& rhs ) const
+	    {
+		return lhs < rhs;
+	    }
+	};
 
-    class less_or_equal
-	: public boost::static_visitor<bool>
-    {
-    public:	
-	template <typename T, typename U>
-	bool operator()( const T &, const U & ) const
-	{
-	    return false;
-	}
+	struct less_or_equal
+	    : public boost::static_visitor<bool>
+	{	
+	    template <typename T, typename U>
+	    bool operator()( const T &, const U & ) const
+	    {
+		return false;
+	    }
 	
-	bool operator() (int lhs, int rhs) const
-	{
-	    return  lhs <= rhs;
-	}
+	    template <typename T>
+	    bool operator()(T lhs, T rhs ) const
+	    {
+		return lhs <= rhs;
+	    }
+	    
+	    bool operator() (int lhs, double rhs) const
+	    {
+		return  lhs <= rhs;
+	    }
 	
-	bool operator() (double lhs, double rhs) const
-	{
-	    return  lhs <= rhs;
-	}
+	    bool operator() (double lhs, int rhs) const
+	    {
+		return  lhs <= rhs;
+	    }
 	
-	bool operator() (int lhs, double rhs) const
-	{
-	    return  lhs <= rhs;
-	}
-	
-	bool operator() (double lhs, int rhs) const
-	{
-	    return  lhs <= rhs;
-	}
-	
-	template <typename T>
-	bool operator()( const T & lhs, const T & rhs ) const
-	{
-	    return lhs <= rhs;
-	}
-    };
+	    template <typename T>
+	    bool operator()( std::string const& lhs, std::string const& rhs ) const
+	    {
+		return lhs <= rhs;
+	    }
+	};
     
-    struct add : public boost::static_visitor<value_holder>
-    { 
-	template <typename T1, typename T2>
-	value_holder operator() (T1 const& , T2 const&) const
-	{
-	    return value_holder();
-	}
-	template <typename T>
-	value_holder operator() (T const& lhs, T const&  rhs) const
-	{
-	    return lhs + rhs ;
-	}
-	value_holder operator() (int lhs,int rhs) const
-	{
-	    return lhs + rhs;
-	}
-	value_holder operator() (double lhs, double rhs) const
-	{
-	    return lhs + rhs;
-	}
+	template <typename V>
+	struct add : public boost::static_visitor<V>
+	{ 
+	    typedef V value_type;
+	    template <typename T1, typename T2>
+	    value_type operator() (T1 const& lhs, T2 const&) const
+	    {
+		return lhs;
+	    }
+	    template <typename T>
+	    value_type operator() (T lhs, T rhs) const
+	    {
+		return lhs + rhs ;
+	    }
 	
-	value_holder operator() (double lhs, int rhs) const
-	{
-	    return lhs + rhs;
-	}
+	    value_type operator() (std::string const& lhs,std::string const& rhs ) const
+	    {
+		return lhs + rhs;
+	    }
 	
-	value_holder operator() (int lhs, double rhs) const
-	{
-	    return lhs + rhs;
-	}
-    };
-    
-    struct sub : public boost::static_visitor<value_holder>
-    { 
-	template <typename T1, typename T2>
-	value_holder operator() (T1 const& lhs, T2 const&) const
-	{
-	    return value_holder(lhs);
-	}
+	    value_type operator() (double lhs, int rhs) const
+	    {
+		return lhs + rhs;
+	    }
+	
+	    value_type operator() (int lhs, double rhs) const
+	    {
+		return lhs + rhs;
+	    }
+	};
+	template <typename V>
+	struct sub : public boost::static_visitor<V>
+	{ 
+	    typedef V value_type;
+	    template <typename T1, typename T2>
+	    value_type operator() (T1 const& lhs, T2 const&) const
+	    {
+		return lhs;
+	    }
 
-	template <typename T>
-	value_holder operator() (T const& lhs, T const&  rhs) const
-	{
-	    return lhs - rhs ;
-	}
+	    template <typename T>
+	    value_type operator() (T  lhs, T rhs) const
+	    {
+		return lhs - rhs ;
+	    }
 
-	value_holder operator() (string const& lhs,string const& ) const
-	{
-	    return lhs;
-	}
-
-	value_holder operator() (int lhs,int rhs) const
-	{
-	    return lhs - rhs;
-	}
-
-	value_holder operator() (double lhs, double rhs) const
-	{
-	    return lhs - rhs;
-	}
+	    value_type operator() (std::string const& lhs,std::string const& ) const
+	    {
+		return lhs;
+	    }
+        	
+	    value_type operator() (double lhs, int rhs) const
+	    {
+		return lhs - rhs;
+	    }
 	
-	value_holder operator() (double lhs, int rhs) const
-	{
-	    return lhs - rhs;
-	}
-	
-	value_holder operator() (int lhs, double rhs) const
-	{
-	    return lhs - rhs;
-	}
-    };
+	    value_type operator() (int lhs, double rhs) const
+	    {
+		return lhs - rhs;
+	    }
+	};
     
-    struct mult : public boost::static_visitor<value_holder>
-    { 
-	template <typename T1, typename T2>
-	value_holder operator() (T1 const&, T2 const& ) const
-	{
-	    return value_holder();
-	}
-	template <typename T>
-	value_holder operator() (T const& lhs, T const&  rhs) const
-	{
-	    return lhs * rhs;
-	}
+	template <typename V>
+	struct mult : public boost::static_visitor<V>
+	{ 
+	    typedef V value_type;
+	    template <typename T1, typename T2>
+	    value_type operator() (T1 const& lhs , T2 const& ) const
+	    {
+		return lhs;
+	    }
+	    template <typename T>
+	    value_type operator() (T lhs, T rhs) const
+	    {
+		return lhs * rhs;
+	    }
 	
-	value_holder operator() (string const& lhs,string const& ) const
-	{
-	    return lhs;
-	}
-
-	value_holder operator() (int lhs,int rhs) const
-	{
-	    return lhs * rhs;
-	}
-
-	value_holder operator() (double lhs, double rhs) const
-	{
-	    return lhs * rhs;
-	}
+	    value_type operator() (std::string const& lhs,std::string const& ) const
+	    {
+		return lhs;
+	    }	
 	
-	value_holder operator() (double lhs, int rhs) const
-	{
-	    return lhs * rhs;
-	}
+	    value_type operator() (double lhs, int rhs) const
+	    {
+		return lhs * rhs;
+	    }
 	
-	value_holder operator() (int lhs, double rhs) const
-	{
-	    return lhs * rhs;
-	}
-    };
+	    value_type operator() (int lhs, double rhs) const
+	    {
+		return lhs * rhs;
+	    }
+	};
 
-    struct div: public boost::static_visitor<value_holder>
-    { 
-	template <typename T1, typename T2>
-	value_holder operator() (T1 const&, T2 const&) const
-	{
-	    return value_holder();
-	}
-	template <typename T>
-	value_holder operator() (T const& lhs, T const&  rhs) const
-	{
-	    return lhs / rhs;
-	}
+	template <typename V>
+	struct div: public boost::static_visitor<V>
+	{ 
+	    typedef V value_type;
+	    template <typename T1, typename T2>
+	    value_type operator() (T1 const& lhs, T2 const&) const
+	    {
+		return lhs;
+	    }
+	    
+	    template <typename T>
+	    value_type operator() (T lhs, T rhs) const
+	    {
+		return lhs / rhs;
+	    }
 	
-	value_holder operator() (string const& lhs,string const&) const
-	{
-	    return lhs;
-	}
-
-	value_holder operator() (int lhs,int rhs) const
-	{
-	    return lhs / rhs;
-	}
-
-	value_holder operator() (double lhs, double rhs) const
-	{
-	    return lhs / rhs;
-	}
+	    value_type operator() (std::string const& lhs,std::string const&) const
+	    {
+		return lhs;
+	    }
 	
-	value_holder operator() (double lhs, int rhs) const
-	{
-	    return lhs / rhs;
-	}
+	    value_type operator() (double lhs, int rhs) const
+	    {
+		return lhs / rhs;
+	    }
 	
-	value_holder operator() (int lhs, double rhs) const
-	{
-	    return lhs / rhs;
-	}
-    };
+	    value_type operator() (int lhs, double rhs) const
+	    {
+		return lhs / rhs;
+	    }
+	};
     
-    struct to_string : public boost::static_visitor<std::string>
-    {
-	template <typename T>
-	std::string operator() (T val) const
+	struct to_string : public boost::static_visitor<std::string>
 	{
-	    std::stringstream ss;
-	    ss << val;
-	    return ss.str();
-	} 
-	std::string operator() (std::string const& val) const
-	{
-	    return "'" + val + "'";
-	}
-    };
-}
+	    template <typename T>
+	    std::string operator() (T val) const
+	    {
+		std::stringstream ss;
+		ss << val;
+		return ss.str();
+	    } 
+	    std::string operator() (std::string const& val) const
+	    {
+		return "'" + val + "'";
+	    }
+	};
+    }
     
-    using namespace impl;
-
-    class value 
+    class value : public value_base
     {
     public:
-	value(int i)
-	    : v_(i) {}
+	value ()
+	    : value_base(0) {}
 	
-	value(double d)
-	    : v_(d) {}
+	template <typename T> value(T _val_)
+	    : value_base(_val_) {}
 	
-	value(string const& str)
-	    : v_(str) {}
-	
-	value(value const& other)
-	    : v_ (other.v_) {}
-	
 	bool operator==(value const& other) const
 	{
-	    return apply_visitor(equals(),v_,other.get());
+	    return boost::apply_visitor(impl::equals(),*this,other);
 	}
 
 	bool operator!=(value const& other) const
 	{
-	    return !(apply_visitor(equals(),v_,other.get()));
+	    return !(boost::apply_visitor(impl::equals(),*this,other));
 	}
 	
 	bool operator>(value const& other) const
 	{
-	    return apply_visitor(greater_than(),v_,other.get());
+	    return boost::apply_visitor(impl::greater_than(),*this,other);
 	}
 
 	bool operator>=(value const& other) const
 	{
-	    return apply_visitor(greater_or_equal(),v_,other.get());
+	    return boost::apply_visitor(impl::greater_or_equal(),*this,other);
 	}
 
 	bool operator<(value const& other) const
 	{
-	    return apply_visitor(less_than(),v_,other.get());
+	    return boost::apply_visitor(impl::less_than(),*this,other);
 	}
 
 	bool operator<=(value const& other) const
 	{
-	    return apply_visitor(less_or_equal(),v_,other.get());
+	    return boost::apply_visitor(impl::less_or_equal(),*this,other);
 	}
 
 	value& operator+=(value const& other)
 	{
-	    v_ = apply_visitor(add(),v_,other.get());
+	    *this = boost::apply_visitor(impl::add<value>(),*this,other);
 	    return *this;
 	}
 
 	value& operator-=(value const& other)
 	{
-	    v_ = apply_visitor(sub(),v_,other.get());
+	    *this = boost::apply_visitor(impl::sub<value>(),*this,other);
 	    return *this;
 	}
 
 	value& operator*=(value const& other)
 	{
-	    v_ = apply_visitor(mult(),v_,other.get());
+	    *this = boost::apply_visitor(impl::mult<value>(),*this,other);
 	    return *this;
 	}
 	
 	value& operator/=(value const& other)
 	{
-	    v_ = apply_visitor(div(),v_,other.get());
+	    *this = boost::apply_visitor(impl::div<value>(),*this,other);
 	    return *this;
 	}
 	
-	value_holder const& get() const
+	std::string to_string() const
 	{
-	    return v_;
+	    return boost::apply_visitor(impl::to_string(),*this);
 	}
-
-	string to_string() const
-	{
-	    return apply_visitor(impl::to_string(),v_);
-	}
-     
-    private:
-	value_holder v_;
     };
     
     inline const value operator+(value const& p1,value const& p2)
@@ -494,14 +425,14 @@
 	return tmp;
     }
 
-    template <typename charT, typename traits>
-    inline std::basic_ostream<charT,traits>& 
-    operator << (std::basic_ostream<charT,traits>& out,
-		 value const& v)
-    {
-	out << v.get();
-	return out; 
-    }
+    //template <typename charT, typename traits>
+    //inline std::basic_ostream<charT,traits>& 
+    //operator << (std::basic_ostream<charT,traits>& out,/
+    //		 value const& v)
+    // {
+    //	out << v.get();
+    //	return out; 
+    //}
 }
 
 #endif //VALUE_HPP

Modified: trunk/plugins/input/postgis/postgisfs.cpp
===================================================================
--- trunk/plugins/input/postgis/postgisfs.cpp	2006-02-10 17:07:15 UTC (rev 154)
+++ trunk/plugins/input/postgis/postgisfs.cpp	2006-02-10 17:13:02 UTC (rev 155)
@@ -49,10 +49,10 @@
         if (geom)
         {
             feature->set_geometry(geom);
-	    feature->reserve_props(num_attrs_);
 	    unsigned start=2;
 	    for (unsigned pos=0;pos<num_attrs_;++pos)
 	    {
+		std::string name = rs_->getFieldName(start + pos);
 		const char* buf=rs_->getValue(start + pos);
 		//int field_size = rs_->getFieldLength(start + pos);
 		int oid = rs_->getTypeOID(start + pos);
@@ -60,32 +60,32 @@
 		if (oid==23) //int4
 		{
 		    int val = int4net(buf);
-		    feature->add_property(val);
+		    boost::put(*feature,name,val);
 		}
 		else if (oid==21) //int2
 		{
 		    int val = int2net(buf);
-		    feature->add_property(val);
+		    boost::put(*feature,name,val);
 		}
 		else if (oid == 700) // float4
 		{
 		    float val;
 		    float4net(val,buf);
-		    feature->add_property((double)val);
+		    boost::put(*feature,name,val);
 		}
 		else if (oid == 701) // float8
 		{
 		    double val;
 		    float8net(val,buf);
-		    feature->add_property(val);
+		    boost::put(*feature,name,val);
 		}
 		else if (oid==1042 || oid==1043) //bpchar or varchar
 		{
-		    feature->add_property(string(buf));
+		    boost::put(*feature,name,buf);
 		}
 		else 
 		{
-		    feature->add_property(string("null"));
+		    boost::put(*feature,name,0);
 		}
 	    }
             ++count_;

Modified: trunk/plugins/input/shape/dbffile.cpp
===================================================================
--- trunk/plugins/input/shape/dbffile.cpp	2006-02-10 17:07:15 UTC (rev 154)
+++ trunk/plugins/input/shape/dbffile.cpp	2006-02-10 17:13:02 UTC (rev 155)
@@ -110,11 +110,11 @@
 }
 
 
-void dbf_file::add_attribute(int col,Feature* f) const throw()
+void dbf_file::add_attribute(int col,Feature const& f) const throw()
 {
     if (col>=0 && col<num_fields_)
     {
-        
+        std::string name=fields_[col].name_;
 	std::string str=trim(std::string(record_+fields_[col].offset_,fields_[col].length_));
         
         switch (fields_[col].type_)
@@ -123,27 +123,27 @@
 	case 'D'://todo handle date?
 	case 'M':
 	case 'L':
-	    f->add_property(str);
+	    f[name] = str; 
 	    break;
 	case 'N':
         case 'F':
 	    {
 		if (str[0]=='*')
 		{
-		    f->add_property("null");
+		    boost::put(f,name,0);
 		    break;
 		}
 		if (fields_[col].dec_>0)
 		{   
 		    double d;
 		    fromString(str,d);
-		    f->add_property(d);
+		    boost::put(f,name,d);
 		}
 		else
 		{
 		    int i;
 		    fromString(str,i);
-		    f->add_property(i);
+		    boost::put(f,name,i);
 		}
 		break;
 	    }

Modified: trunk/plugins/input/shape/dbffile.hpp
===================================================================
--- trunk/plugins/input/shape/dbffile.hpp	2006-02-10 17:07:15 UTC (rev 154)
+++ trunk/plugins/input/shape/dbffile.hpp	2006-02-10 17:13:02 UTC (rev 155)
@@ -61,7 +61,7 @@
         field_descriptor const& descriptor(int col) const;
         void move_to(int index);
         std::string string_value(int col) const;
-        void add_attribute(int col,Feature* f) const throw();
+        void add_attribute(int col,Feature const& f) const throw();
     private:
         dbf_file(const dbf_file&);
         dbf_file& operator=(const dbf_file&);

Modified: trunk/plugins/input/shape/shape_featureset.cpp
===================================================================
--- trunk/plugins/input/shape/shape_featureset.cpp	2006-02-10 17:07:15 UTC (rev 154)
+++ trunk/plugins/input/shape/shape_featureset.cpp	2006-02-10 17:13:02 UTC (rev 155)
@@ -162,7 +162,7 @@
 	    {
 		try 
 		{
-		    shape_.dbf().add_attribute(*pos,feature.get());//TODO optimize!!!
+		    shape_.dbf().add_attribute(*pos,*feature);//TODO optimize!!!
 		}
 		catch (...)
 		{

Modified: trunk/plugins/input/shape/shape_index_featureset.cpp
===================================================================
--- trunk/plugins/input/shape/shape_index_featureset.cpp	2006-02-10 17:07:15 UTC (rev 154)
+++ trunk/plugins/input/shape/shape_index_featureset.cpp	2006-02-10 17:13:02 UTC (rev 155)
@@ -157,14 +157,14 @@
         }
 	if (attr_ids_.size())
 	{
-	    feature->reserve_props(attr_ids_.size());
+	    //feature->reserve_props(attr_ids_.size());
 	    shape_.dbf().move_to(shape_.id_);
 	    std::vector<int>::const_iterator pos=attr_ids_.begin();
 	    while (pos!=attr_ids_.end())
 	    {
 		try 
 		{
-		    shape_.dbf().add_attribute(*pos,feature.get());
+		    shape_.dbf().add_attribute(*pos,*feature);
 		}
 		catch (...)
 		{

Modified: trunk/src/agg_renderer.cpp
===================================================================
--- trunk/src/agg_renderer.cpp	2006-02-10 17:07:15 UTC (rev 154)
+++ trunk/src/agg_renderer.cpp	2006-02-10 17:13:02 UTC (rev 155)
@@ -52,10 +52,10 @@
 
 #include <boost/utility.hpp>
 
+#include <iostream>
+
 namespace mapnik
 {
-
-
     class pattern_source : private boost::noncopyable
     {
     public:
@@ -79,16 +79,18 @@
 	ImageData32 const& pattern_;
     };
 
-    
-    agg_renderer::agg_renderer(Map const& m, Image32 & pixmap)
-	: feature_style_processor<agg_renderer>(m),pixmap_(pixmap),
+    template <typename T>
+    agg_renderer<T>::agg_renderer(Map const& m, T & pixmap)
+	: feature_style_processor<agg_renderer>(m),
+	  pixmap_(pixmap),
 	  t_(m.getWidth(),m.getHeight(),m.getCurrentExtent())
     {
 	Color const& bg=m.getBackground();
 	pixmap_.setBackground(bg);
+	std::cout << "scale="<<m.scale()<<std::endl;
     }
-		
-    void agg_renderer::process(polygon_symbolizer const& sym,Feature const& feature)
+    template <typename T>	
+    void agg_renderer<T>::process(polygon_symbolizer const& sym,Feature const& feature)
     {
 	typedef  coord_transform<CoordTransform,geometry_type> path_type;
 	typedef agg::renderer_base<agg::pixfmt_rgba32> ren_base;    
@@ -120,7 +122,9 @@
 	    agg::render_scanlines(ras, sl, ren);
 	}
     }
-    void agg_renderer::process(line_symbolizer const& sym,Feature const& feature)
+
+    template <typename T>
+    void agg_renderer<T>::process(line_symbolizer const& sym,Feature const& feature)
     {   
 	typedef agg::renderer_base<agg::pixfmt_rgba32> ren_base; 
 	typedef coord_transform<CoordTransform,geometry_type> path_type;
@@ -186,7 +190,7 @@
 		ren.color(agg::rgba8(r, g, b, int(255*stroke_.get_opacity())));
 		agg::render_scanlines(ras, sl, ren);
 	    }
-	    else if (0) //(stroke_.get_width() <= 1.0)
+	    else if (stroke_.get_width() <= 1.0)
 	    {
 		//faster but clipping doesn't work 
 		agg::line_profile_aa prof;
@@ -234,8 +238,9 @@
 	    }
 	}
     }
-    
-    void agg_renderer::process(point_symbolizer const& sym,Feature const& feature)
+
+    template <typename T>
+    void agg_renderer<T>::process(point_symbolizer const& sym,Feature const& feature)
     {
 	geometry_ptr const& geom=feature.get_geometry();
 	if (geom)
@@ -253,7 +258,9 @@
 	    pixmap_.set_rectangle_alpha(px,py,data);
 	}
     }
-    void  agg_renderer::process(line_pattern_symbolizer const& sym,Feature const& feature)
+    
+    template <typename T>
+    void  agg_renderer<T>::process(line_pattern_symbolizer const& sym,Feature const& feature)
     {
 	typedef  coord_transform<CoordTransform,geometry_type> path_type;
 	typedef agg::line_image_pattern<agg::pattern_filter_bilinear_rgba8> pattern_type;
@@ -281,7 +288,8 @@
 	}
     }
     
-    void agg_renderer::process(polygon_pattern_symbolizer const& sym,Feature const& feature)
+    template <typename T>
+    void agg_renderer<T>::process(polygon_pattern_symbolizer const& sym,Feature const& feature)
     {
 	typedef  coord_transform<CoordTransform,geometry_type> path_type;
 	typedef agg::renderer_base<agg::pixfmt_rgba32> ren_base; 
@@ -332,7 +340,9 @@
 	    agg::render_scanlines(ras, sl, rp);   
 	}
     }
-    void agg_renderer::process(raster_symbolizer const& ,Feature const& feature)
+
+    template <typename T>
+    void agg_renderer<T>::process(raster_symbolizer const& ,Feature const& feature)
     {
 	// TODO -- at the moment raster_symbolizer is an empty class 
 	// used for type dispatching, but we can have some fancy raster
@@ -343,4 +353,14 @@
 	    pixmap_.set_rectangle(raster->x_,raster->y_,raster->data_);
 	}
     }
+    
+    template <typename T>
+    void agg_renderer<T>::process(text_symbolizer const& sym ,Feature const& feature)
+    {
+	//TODO - implement text
+	//std::cout << feature << std::endl;
+	std::cout << sym.get_name() <<":" << feature[sym.get_name()] << std::endl;
+    }
+
+    template class agg_renderer<Image32>;
 }



From pavlenko at berlios.de  Sat Feb 11 01:39:57 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Sat, 11 Feb 2006 01:39:57 +0100
Subject: [Mapnik-svn] r156 - in trunk: agg/include src
Message-ID: <200602110039.k1B0dvTq029152@sheep.berlios.de>

Author: pavlenko
Date: 2006-02-11 01:39:50 +0100 (Sat, 11 Feb 2006)
New Revision: 156

Modified:
   trunk/agg/include/agg_renderer_outline_aa.h
   trunk/src/agg_renderer.cpp
Log:
some line rendering fixes and optimizations



Modified: trunk/agg/include/agg_renderer_outline_aa.h
===================================================================
--- trunk/agg/include/agg_renderer_outline_aa.h	2006-02-10 17:13:02 UTC (rev 155)
+++ trunk/agg/include/agg_renderer_outline_aa.h	2006-02-11 00:39:50 UTC (rev 156)
@@ -1657,7 +1657,7 @@
                         }
                         else
                         {
-                            while(abs(sx - lp.x1) + abs(sy - lp.y1) > lp2.len)
+                            while(abs(sx - lp.x1) + abs(sy - lp.y1) > 2 * lp2.len)
                             {
                                 sx = (lp.x1 + sx) >> 1;
                                 sy = (lp.y1 + sy) >> 1;
@@ -1724,7 +1724,7 @@
                         }
                         else
                         {
-                            while(abs(ex - lp.x2) + abs(ey - lp.y2) > lp2.len)
+                            while(abs(ex - lp.x2) + abs(ey - lp.y2) > 2 * lp2.len)
                             {
                                 ex = (lp.x2 + ex) >> 1;
                                 ey = (lp.y2 + ey) >> 1;
@@ -1796,7 +1796,7 @@
                         }
                         else
                         {
-                            while(abs(sx - lp.x1) + abs(sy - lp.y1) > lp2.len)
+                            while(abs(sx - lp.x1) + abs(sy - lp.y1) > 2 * lp2.len)
                             {
                                 sx = (lp.x1 + sx) >> 1;
                                 sy = (lp.y1 + sy) >> 1;
@@ -1809,7 +1809,7 @@
                         }
                         else
                         {
-                            while(abs(ex - lp.x2) + abs(ey - lp.y2) > lp2.len)
+                            while(abs(ex - lp.x2) + abs(ey - lp.y2) > 2 * lp2.len)
                             {
                                 ex = (lp.x2 + ex) >> 1;
                                 ey = (lp.y2 + ey) >> 1;

Modified: trunk/src/agg_renderer.cpp
===================================================================
--- trunk/src/agg_renderer.cpp	2006-02-10 17:13:02 UTC (rev 155)
+++ trunk/src/agg_renderer.cpp	2006-02-11 00:39:50 UTC (rev 156)
@@ -192,7 +192,6 @@
 	    }
 	    else if (stroke_.get_width() <= 1.0)
 	    {
-		//faster but clipping doesn't work 
 		agg::line_profile_aa prof;
 		prof.width(stroke_.get_width());
 		renderer_oaa ren_oaa(renb, prof);



From pavlenko at berlios.de  Mon Feb 13 21:26:57 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Mon, 13 Feb 2006 21:26:57 +0100
Subject: [Mapnik-svn] r157 - tags/release-0.2.5a/src
Message-ID: <200602132026.k1DKQv3I014783@sheep.berlios.de>

Author: pavlenko
Date: 2006-02-13 21:26:42 +0100 (Mon, 13 Feb 2006)
New Revision: 157

Modified:
   tags/release-0.2.5a/src/mapnik.cpp
Log:
changed headers order to keep boost::serialization library (1_33_0) happy.



Modified: tags/release-0.2.5a/src/mapnik.cpp
===================================================================
--- tags/release-0.2.5a/src/mapnik.cpp	2006-02-11 00:39:50 UTC (rev 156)
+++ tags/release-0.2.5a/src/mapnik.cpp	2006-02-13 20:26:42 UTC (rev 157)
@@ -18,13 +18,14 @@
 
 //$Id$
 
-#include "mapnik.hpp"
 #include <fstream>
 #include <boost/archive/text_oarchive.hpp>
 #include <boost/archive/text_iarchive.hpp>
 #include <boost/archive/xml_iarchive.hpp>
 #include <boost/archive/xml_oarchive.hpp>
 
+#include "mapnik.hpp"
+
 namespace mapnik
 {
     void save_to_xml(Map const& m,const char* filename)



From pavlenko at berlios.de  Mon Feb 13 21:28:32 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Mon, 13 Feb 2006 21:28:32 +0100
Subject: [Mapnik-svn] r158 - trunk/src
Message-ID: <200602132028.k1DKSWLK024727@sheep.berlios.de>

Author: pavlenko
Date: 2006-02-13 21:28:21 +0100 (Mon, 13 Feb 2006)
New Revision: 158

Modified:
   trunk/src/mapnik.cpp
Log:
changed headers order to keep boost::serialization (1_33_0) happy! (trunk)

Modified: trunk/src/mapnik.cpp
===================================================================
--- trunk/src/mapnik.cpp	2006-02-13 20:26:42 UTC (rev 157)
+++ trunk/src/mapnik.cpp	2006-02-13 20:28:21 UTC (rev 158)
@@ -18,12 +18,12 @@
 
 //$Id$
 
-#include "mapnik.hpp"
 #include <fstream>
 #include <boost/archive/text_oarchive.hpp>
 #include <boost/archive/text_iarchive.hpp>
 #include <boost/archive/xml_iarchive.hpp>
 #include <boost/archive/xml_oarchive.hpp>
+#include "mapnik.hpp"
 
 namespace mapnik
 {



From jdoyon at berlios.de  Wed Feb 15 00:59:56 2006
From: jdoyon at berlios.de (jdoyon at BerliOS)
Date: Wed, 15 Feb 2006 00:59:56 +0100
Subject: [Mapnik-svn] r159 - trunk
Message-ID: <200602142359.k1ENxupm015122@sheep.berlios.de>

Author: jdoyon
Date: 2006-02-15 00:59:53 +0100 (Wed, 15 Feb 2006)
New Revision: 159

Modified:
   trunk/SConstruct
Log:
Fix a bug that would switch to the wrong BOOST_APPEND if one of the boost libs is missing.

We now make sure the first one, and only the first one, found is the reference for the BOOST_APPEND.



Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2006-02-13 20:28:21 UTC (rev 158)
+++ trunk/SConstruct	2006-02-14 23:59:53 UTC (rev 159)
@@ -85,9 +85,9 @@
 
 env['BOOST_APPEND'] = ''
 
-for libinfo in BOOST_LIBSHEADERS:
+for count, libinfo in enumerate(BOOST_LIBSHEADERS):
     if not conf.CheckLibWithHeader('boost_%s%s' % (libinfo[0], env['BOOST_APPEND']), libinfo[1], 'C++'):
-        if not conf.CheckLibWithHeader('boost_%s-%s-mt' % (libinfo[0], env['CC']), libinfo[1], 'C++') and libinfo[2]:
+        if not conf.CheckLibWithHeader('boost_%s-%s-mt' % (libinfo[0], env['CC']), libinfo[1], 'C++') and libinfo[2] and count == 0:
             print 'Could not find header or shared library for boost %s, exiting!' % libinfo[0]
             Exit(1)
         else:



From jdoyon at berlios.de  Mon Feb 20 02:17:14 2006
From: jdoyon at berlios.de (jdoyon at BerliOS)
Date: Mon, 20 Feb 2006 02:17:14 +0100
Subject: [Mapnik-svn] r160 - trunk
Message-ID: <200602200117.k1K1HETm016734@sheep.berlios.de>

Author: jdoyon
Date: 2006-02-20 02:17:04 +0100 (Mon, 20 Feb 2006)
New Revision: 160

Modified:
   trunk/SConstruct
Log:
Simple fix to how the python version is tested.



Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2006-02-14 23:59:53 UTC (rev 159)
+++ trunk/SConstruct	2006-02-20 01:17:04 UTC (rev 160)
@@ -113,11 +113,7 @@
 
     majver, minver = env['PYTHON_VERSION'].split('.')
 
-    if int(majver) > 1:
-        if int(minver) < 3:
-           print "Python version 2.2 or greater required"
-           Exit(1)
-    else:
+    if (int(majver), int(minver)) < (2, 2):
         print "Python version 2.2 or greater required"
         Exit(1)
 



From jdoyon at berlios.de  Mon Feb 20 02:34:06 2006
From: jdoyon at berlios.de (jdoyon at BerliOS)
Date: Mon, 20 Feb 2006 02:34:06 +0100
Subject: [Mapnik-svn] r161 - trunk/bindings/python
Message-ID: <200602200134.k1K1Y67Y021282@sheep.berlios.de>

Author: jdoyon
Date: 2006-02-20 02:34:02 +0100 (Mon, 20 Feb 2006)
New Revision: 161

Modified:
   trunk/bindings/python/mapnik_color.cpp
   trunk/bindings/python/mapnik_datasource_cache.cpp
   trunk/bindings/python/mapnik_envelope.cpp
   trunk/bindings/python/mapnik_filter.cpp
   trunk/bindings/python/mapnik_image.cpp
   trunk/bindings/python/mapnik_layer.cpp
   trunk/bindings/python/mapnik_map.cpp
   trunk/bindings/python/mapnik_parameters.cpp
   trunk/bindings/python/mapnik_python.cpp
   trunk/bindings/python/mapnik_rule.cpp
   trunk/bindings/python/mapnik_stroke.cpp
   trunk/bindings/python/mapnik_style.cpp
Log:
Capitalized class names as per the "Style Guide for Python Code" at:

http://www.python.org/peps/pep-0008.html

Because the bindings are out of synch, this is untested.



Modified: trunk/bindings/python/mapnik_color.cpp
===================================================================
--- trunk/bindings/python/mapnik_color.cpp	2006-02-20 01:17:04 UTC (rev 160)
+++ trunk/bindings/python/mapnik_color.cpp	2006-02-20 01:34:02 UTC (rev 161)
@@ -1,5 +1,5 @@
 /* This file is part of python_mapnik (c++/python mapping toolkit)
- * Copyright (C) 2005 Artem Pavlenko
+ * Copyright (C) 2005 Artem Pavlenko, Jean-Francois Doyon
  *
  * Mapnik is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -44,7 +44,7 @@
 void export_color () 
 {
     using namespace boost::python;
-    class_<Color>("color",init<>())
+    class_<Color>("Color",init<>())
         .def(init<int,int,int,boost::python::optional<int> >())
         .add_property("r",&Color::red,&Color::set_red)
         .add_property("g",&Color::green,&Color::set_green)

Modified: trunk/bindings/python/mapnik_datasource_cache.cpp
===================================================================
--- trunk/bindings/python/mapnik_datasource_cache.cpp	2006-02-20 01:17:04 UTC (rev 160)
+++ trunk/bindings/python/mapnik_datasource_cache.cpp	2006-02-20 01:34:02 UTC (rev 161)
@@ -1,5 +1,5 @@
 /* This file is part of python_mapnik (c++/python mapping toolkit)
- * Copyright (C) 2005 Artem Pavlenko
+ * Copyright (C) 2005 Artem Pavlenko, Jean-Francois Doyon
  *
  * Mapnik is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -28,14 +28,14 @@
     using mapnik::singleton;
     using mapnik::CreateStatic;
     using namespace boost::python;
-    class_<singleton<datasource_cache,CreateStatic>,boost::noncopyable>("singleton",no_init)
+    class_<singleton<datasource_cache,CreateStatic>,boost::noncopyable>("Singleton",no_init)
         .def("instance",&singleton<datasource_cache,CreateStatic>::instance,
 	     return_value_policy<reference_existing_object>())
         .staticmethod("instance")
         ;
 
     class_<datasource_cache,bases<singleton<datasource_cache,CreateStatic> >,
-        boost::noncopyable>("datasource_cache",no_init)
+        boost::noncopyable>("DatasourceCache",no_init)
         .def("create",&datasource_cache::create)
         .staticmethod("create")
 	.def("register_datasources",&datasource_cache::register_datasources)

Modified: trunk/bindings/python/mapnik_envelope.cpp
===================================================================
--- trunk/bindings/python/mapnik_envelope.cpp	2006-02-20 01:17:04 UTC (rev 160)
+++ trunk/bindings/python/mapnik_envelope.cpp	2006-02-20 01:34:02 UTC (rev 161)
@@ -1,5 +1,5 @@
 /* This file is part of python_mapnik (c++/python mapping toolkit)
- * Copyright (C) 2005 Artem Pavlenko
+ * Copyright (C) 2005 Artem Pavlenko, Jean-Francois Doyon
  *
  * Mapnik is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -58,7 +58,7 @@
 void export_envelope()
 {
     using namespace boost::python;
-    class_<Envelope<double> >("envelope",init<double,double,double,double>())
+    class_<Envelope<double> >("Envelope",init<double,double,double,double>())
         .def(init<>())
 	.def(init<const coord<double,2>&, const coord<double,2>&>())
         .add_property("minx",&Envelope<double>::minx)

Modified: trunk/bindings/python/mapnik_filter.cpp
===================================================================
--- trunk/bindings/python/mapnik_filter.cpp	2006-02-20 01:17:04 UTC (rev 160)
+++ trunk/bindings/python/mapnik_filter.cpp	2006-02-20 01:34:02 UTC (rev 161)
@@ -1,5 +1,5 @@
 /* This file is part of python_mapnik (c++/python mapping toolkit)
- * Copyright (C) 2005 Artem Pavlenko
+ * Copyright (C) 2005 Artem Pavlenko, Jean-Francois Doyon
  *
  * Mapnik is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -38,7 +38,7 @@
 void export_filter()
 {
     using namespace boost::python;
-    class_<filter<Feature>,boost::noncopyable>("filter",no_init)
+    class_<filter<Feature>,boost::noncopyable>("Filter",no_init)
 	.def("__str__",&filter<Feature>::to_string);
 	;
     def("filter",&create_filter);

Modified: trunk/bindings/python/mapnik_image.cpp
===================================================================
--- trunk/bindings/python/mapnik_image.cpp	2006-02-20 01:17:04 UTC (rev 160)
+++ trunk/bindings/python/mapnik_image.cpp	2006-02-20 01:34:02 UTC (rev 161)
@@ -1,5 +1,5 @@
 /* This file is part of python_mapnik (c++/python mapping toolkit)
- * Copyright (C) 2005 Artem Pavlenko
+ * Copyright (C) 2005 Artem Pavlenko, Jean-Francois Doyon
  *
  * Mapnik is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -32,7 +32,7 @@
 void export_image()
 {
     using namespace boost::python;
-    class_<Image32>("image",init<int,int>())
+    class_<Image32>("Image",init<int,int>())
     ;
     def("rawdata",&rawdata);
 }

Modified: trunk/bindings/python/mapnik_layer.cpp
===================================================================
--- trunk/bindings/python/mapnik_layer.cpp	2006-02-20 01:17:04 UTC (rev 160)
+++ trunk/bindings/python/mapnik_layer.cpp	2006-02-20 01:34:02 UTC (rev 161)
@@ -1,5 +1,5 @@
 /* This file is part of python_mapnik (c++/python mapping toolkit)
- * Copyright (C) 2005 Artem Pavlenko
+ * Copyright (C) 2005 Artem Pavlenko, Jean-Francois Doyon
  *
  * Mapnik is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -100,11 +100,11 @@
 void export_layer()
 {
     using namespace boost::python;
-    class_<std::vector<std::string> >("styles")
+    class_<std::vector<std::string> >("Styles")
     	.def(vector_indexing_suite<std::vector<std::string>,true >())
     	;
     //class_<Layer>("layer",init<const Parameters&>("Layer constructor"))
-    class_<Layer>("layer",no_init)
+    class_<Layer>("Layer",no_init)
         .def("name",&Layer::name,return_value_policy<copy_const_reference>())
         .def("params",&Layer::params,return_value_policy<reference_existing_object>())
         .def("envelope",&Layer::envelope)

Modified: trunk/bindings/python/mapnik_map.cpp
===================================================================
--- trunk/bindings/python/mapnik_map.cpp	2006-02-20 01:17:04 UTC (rev 160)
+++ trunk/bindings/python/mapnik_map.cpp	2006-02-20 01:34:02 UTC (rev 161)
@@ -1,5 +1,5 @@
 /* This file is part of python_mapnik (c++/python mapping toolkit)
- * Copyright (C) 2005 Artem Pavlenko
+ * Copyright (C) 2005 Artem Pavlenko, Jean-Francois Doyon
  *
  * Mapnik is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -76,10 +76,10 @@
 void export_map() 
 {
     using namespace boost::python;
-    class_<std::vector<Layer> >("layers")
+    class_<std::vector<Layer> >("Layers")
     	.def(vector_indexing_suite<std::vector<Layer> >())
     	;
-    class_<Map>("map",init<int,int,boost::python::optional<int> >())
+    class_<Map>("Map",init<int,int,boost::python::optional<int> >())
         .add_property("width",&Map::getWidth)
         .add_property("height",&Map::getHeight)
 	.add_property("srid",&Map::srid)

Modified: trunk/bindings/python/mapnik_parameters.cpp
===================================================================
--- trunk/bindings/python/mapnik_parameters.cpp	2006-02-20 01:17:04 UTC (rev 160)
+++ trunk/bindings/python/mapnik_parameters.cpp	2006-02-20 01:34:02 UTC (rev 161)
@@ -1,5 +1,5 @@
 /* This file is part of python_mapnik (c++/python mapping toolkit)
- * Copyright (C) 2005 Artem Pavlenko
+ * Copyright (C) 2005 Artem Pavlenko, Jean-Francois Doyon
  *
  * Mapnik is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -80,11 +80,11 @@
 void export_parameters()
 {
     using namespace boost::python;
-    class_<parameter>("parameter",init<std::string,std::string>())
+    class_<parameter>("Parameter",init<std::string,std::string>())
         .def_pickle(parameter_pickle_suite())
         ;
 
-    class_<parameters>("parameters",init<>())
+    class_<parameters>("Parameters",init<>())
         //.def("add",add1)
         //.def("add",add2)
         .def("get",&parameters::get)

Modified: trunk/bindings/python/mapnik_python.cpp
===================================================================
--- trunk/bindings/python/mapnik_python.cpp	2006-02-20 01:17:04 UTC (rev 160)
+++ trunk/bindings/python/mapnik_python.cpp	2006-02-20 01:34:02 UTC (rev 161)
@@ -1,5 +1,5 @@
 /* This file is part of python_mapnik (c++/python mapping toolkit)
- * Copyright (C) 2005 Artem Pavlenko
+ * Copyright (C) 2005 Artem Pavlenko, Jean-Francois Doyon
  *
  * Mapnik is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -87,15 +87,15 @@
     using namespace boost::python;
     
     class_<datasource,boost::shared_ptr<datasource>,
-	boost::noncopyable>("datasource",no_init)
+	boost::noncopyable>("Datasource",no_init)
         .def("envelope",&datasource::envelope,
 	     return_value_policy<reference_existing_object>())
         ;
     
-    class_<symbolizer,boost::noncopyable> ("symbolizer_",no_init) 
+    class_<symbolizer,boost::noncopyable> ("Symbolizer_",no_init) 
     	;
     class_<boost::shared_ptr<symbolizer>,
-	boost::noncopyable>("symbolizer",no_init)
+	boost::noncopyable>("Symbolizer",no_init)
 	;
     export_parameters();
     export_color(); 
@@ -109,7 +109,7 @@
     export_datasource_cache();
     
     
-    class_<coord<double,2> >("coord",init<double,double>())
+    class_<coord<double,2> >("Coord",init<double,double>())
         .def_readwrite("x", &coord<double,2>::x)
         .def_readwrite("y", &coord<double,2>::y)
         ;

Modified: trunk/bindings/python/mapnik_rule.cpp
===================================================================
--- trunk/bindings/python/mapnik_rule.cpp	2006-02-20 01:17:04 UTC (rev 160)
+++ trunk/bindings/python/mapnik_rule.cpp	2006-02-20 01:34:02 UTC (rev 161)
@@ -1,5 +1,5 @@
 /* This file is part of python_mapnik (c++/python mapping toolkit)
- * Copyright (C) 2005 Artem Pavlenko
+ * Copyright (C) 2005 Artem Pavlenko, Jean-Francois Doyon
  *
  * Mapnik is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -33,11 +33,11 @@
 {
     using namespace boost::python;
     
-    class_<symbolizers>("symbolizers",init<>("TODO"))
+    class_<symbolizers>("Symbolizers",init<>("TODO"))
 	.def(vector_indexing_suite<symbolizers>())
 	;
     
-    class_<rule_type>("rule",init<>("default ctor"))
+    class_<rule_type>("Rule",init<>("default ctor"))
 	.def(init<std::string const&,
 	     boost::python::optional<std::string const&,double,double> >())
 	.add_property("name",make_function

Modified: trunk/bindings/python/mapnik_stroke.cpp
===================================================================
--- trunk/bindings/python/mapnik_stroke.cpp	2006-02-20 01:17:04 UTC (rev 160)
+++ trunk/bindings/python/mapnik_stroke.cpp	2006-02-20 01:34:02 UTC (rev 161)
@@ -1,5 +1,5 @@
 /* This file is part of python_mapnik (c++/python mapping toolkit)
- * Copyright (C) 2005 Artem Pavlenko
+ * Copyright (C) 2005 Artem Pavlenko, Jean-Francois Doyon
  *
  * Mapnik is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -38,7 +38,7 @@
 	.value("BEVEL_JOIN",BEVEL_JOIN)
 	;
 
-    class_<stroke>("stroke",init<>())
+    class_<stroke>("Stroke",init<>())
 	.def(init<Color,float>())
 	.add_property("color",make_function
 		      (&stroke::get_color,return_value_policy<reference_existing_object>()),

Modified: trunk/bindings/python/mapnik_style.cpp
===================================================================
--- trunk/bindings/python/mapnik_style.cpp	2006-02-20 01:17:04 UTC (rev 160)
+++ trunk/bindings/python/mapnik_style.cpp	2006-02-20 01:34:02 UTC (rev 161)
@@ -1,5 +1,5 @@
 /* This file is part of python_mapnik (c++/python mapping toolkit)
- * Copyright (C) 2005 Artem Pavlenko
+ * Copyright (C) 2005 Artem Pavlenko, Jean-Francois Doyon
  *
  * Mapnik is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -29,10 +29,10 @@
 {
     using namespace boost::python;
 
-    class_<rules>("rules",init<>("default ctor"))
+    class_<rules>("Rules",init<>("default ctor"))
 	.def(vector_indexing_suite<rules>())
 	;
-    class_<feature_type_style>("style",init<>("default style constructor"))
+    class_<feature_type_style>("Style",init<>("default style constructor"))
 	.add_property("rules",make_function
 		      (&feature_type_style::get_rules,return_value_policy<reference_existing_object>()))
 	;



From pavlenko at berlios.de  Tue Feb 21 20:56:00 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Tue, 21 Feb 2006 20:56:00 +0100
Subject: [Mapnik-svn] r162 - in trunk: . include src
Message-ID: <200602211956.k1LJu080015873@sheep.berlios.de>

Author: pavlenko
Date: 2006-02-21 20:55:24 +0100 (Tue, 21 Feb 2006)
New Revision: 162

Added:
   trunk/include/font_engine_freetype.hpp
   trunk/src/font_engine_freetype.cpp
Modified:
   trunk/SConstruct
   trunk/include/agg_renderer.hpp
   trunk/include/expression.hpp
   trunk/include/graphics.hpp
   trunk/include/text_symbolizer.hpp
   trunk/include/value.hpp
   trunk/src/SConscript
   trunk/src/agg_renderer.cpp
   trunk/src/text.cpp
Log:
added font_engine impl - work in progress:)

Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2006-02-20 01:34:02 UTC (rev 161)
+++ trunk/SConstruct	2006-02-21 19:55:24 UTC (rev 162)
@@ -24,8 +24,8 @@
 opts.Add('PREFIX', 'The install path "prefix"', '/usr/local')
 opts.Add(PathOption('BOOST_INCLUDES', 'Search path for boost include files', '/usr/include'))
 opts.Add(PathOption('BOOST_LIBS', 'Search path for boost library files', '/usr/lib'))
-opts.Add(PathOption('FREETYPE_INCLUDES', 'Search path for FreeType include files', '/usr/include'))
-opts.Add(PathOption('FREETYPE_LIBS', 'Search path for FreeType library files', '/usr/lib'))
+opts.Add(PathOption('FREETYPE_INCLUDES', 'Search path for FreeType include files', '/opt/freetype/include/freetype2'))
+opts.Add(PathOption('FREETYPE_LIBS', 'Search path for FreeType library files', '/opt/freetype/lib'))
 opts.Add(PathOption('PNG_INCLUDES', 'Search path for libpng include files', '/usr/include'))
 opts.Add(PathOption('PNG_LIBS', 'Search path for libpng include files', '/usr/lib'))
 opts.Add(PathOption('JPEG_INCLUDES', 'Search path for libjpeg include files', '/usr/include'))
@@ -63,6 +63,7 @@
     ['tiff', 'tiff.h', True],
     ['z', 'zlib.h', True],
     ['jpeg', ['stdio.h','jpeglib.h'], True],
+    #['freetype', 'ft2build.h', True],
     ['pq', 'libpq-fe.h', False]
 ]
 

Modified: trunk/include/agg_renderer.hpp
===================================================================
--- trunk/include/agg_renderer.hpp	2006-02-20 01:34:02 UTC (rev 161)
+++ trunk/include/agg_renderer.hpp	2006-02-21 19:55:24 UTC (rev 162)
@@ -23,6 +23,8 @@
 
 #include "feature_style_processor.hpp"
 #include <boost/utility.hpp>
+//#include "agg_font_freetype.h"
+#include "font_engine_freetype.hpp"
 
 namespace mapnik
 {
@@ -31,6 +33,10 @@
 			  private boost::noncopyable
     {
 	agg_renderer(Map const& m, T & pixmap);
+	void start_map_processing();
+	void end_map_processing();
+	void start_layer_processing();
+	void end_layer_processing();
 	void process(point_symbolizer const& sym,Feature const& feature);	    	       
 	void process(line_symbolizer const& sym,Feature const& feature);
 	void process(line_pattern_symbolizer const& sym,Feature const& feature);
@@ -41,6 +47,7 @@
     private:
 	T & pixmap_;
 	CoordTransform t_;
+	face_manager<freetype_engine> font_manager_;
     };
 }
 

Modified: trunk/include/expression.hpp
===================================================================
--- trunk/include/expression.hpp	2006-02-20 01:34:02 UTC (rev 161)
+++ trunk/include/expression.hpp	2006-02-21 19:55:24 UTC (rev 162)
@@ -68,7 +68,7 @@
 	}
 	std::string to_string() const
 	{
-	    return value_.to_string();
+	    return value_.to_expression_string();
 	}
         ~literal() {}
     private:
@@ -88,8 +88,6 @@
 	property(property const& other)
 	    : expression<FeatureT>(),
 	      name_(other.name_)
-	      //index_(other.index_),
-	      //valid_(other.valid_)
 	{}
 
 	value get_value(FeatureT const& feature) const
@@ -108,11 +106,7 @@
 	{
 	    return name_;
 	}
-	void set_index(size_t index) 
-	{
-	    //index_=index;
-	    //valid_=true;
-	}
+
 	std::string to_string() const
 	{
 	    return "["+name_+"]";
@@ -120,8 +114,7 @@
         ~property() {}
     private:
 	std::string name_;
-	//size_t index_;
-	//bool valid_;
+
     };
 }
 

Added: trunk/include/font_engine_freetype.hpp
===================================================================
--- trunk/include/font_engine_freetype.hpp	2006-02-20 01:34:02 UTC (rev 161)
+++ trunk/include/font_engine_freetype.hpp	2006-02-21 19:55:24 UTC (rev 162)
@@ -0,0 +1,395 @@
+ /* This file is part of Mapnik (c++ mapping toolkit)
+ * Copyright (C) 2005 Artem Pavlenko
+ *
+ * Mapnik is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+//$Id$
+
+#if !defined FONT_ENGINE_FREETYPE_HPP
+#define FONT_ENGINE_FREETYPE_HPP
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+#include FT_GLYPH_H
+
+#include <boost/shared_ptr.hpp>
+#include <boost/utility.hpp>
+#include <boost/thread/mutex.hpp>
+
+#include <string>
+#include <vector>
+#include <map>
+#include <iostream>
+
+#include <color.hpp>
+#include <utils.hpp>
+
+namespace mapnik
+{
+
+  class font_face : boost::noncopyable
+    {
+    public:
+    	font_face(FT_Face face)
+	    : face_(face) {}
+	
+    	std::string  family_name() const
+    	{
+    	    return std::string(face_->family_name);
+    	}
+
+	std::string  style_name() const
+    	{
+    	    return std::string(face_->style_name);
+    	}
+	
+	unsigned num_glyphs() const
+	{
+	    return face_->num_glyphs;
+	}
+
+	FT_GlyphSlot glyph() const
+	{
+	    return face_->glyph;
+	}
+
+	/*
+	unsigned glyph_index(unsigned charcode) const
+	{
+	    return FT_Get_Char_Index(face_, charcode );
+	}
+	
+	void set_transform (FT_Matrix * m,FT_Vector *v)
+	{
+	    FT_Set_Transform(face_,m,v);
+	}
+	
+	bool render_glyph (unsigned charcode) const
+	{
+	    unsigned glyph_index = FT_Get_Char_Index(face_, charcode );
+	    FT_Error  error;
+	    error = FT_Load_Glyph(face_,glyph_index,FT_LOAD_DEFAULT);
+	    if (error == 0 )
+	    {
+		error = FT_Render_Glyph(face_->glyph, FT_RENDER_MODE_NORMAL );
+		if (error == 0)
+		{
+		    return true;
+		}
+	    }
+	    return false;
+	}
+	*/
+	
+	FT_Face get_face() const
+	{
+	    return face_;
+	}
+	
+	bool set_pixel_sizes(unsigned size)
+	{
+	    if (! FT_Set_Pixel_Sizes( face_, 0, size ))
+		return true;
+	    return false;
+	}
+        
+	
+    	~font_face()
+    	{
+    	    std::cout << "clean up face:" << family_name()<<":" << style_name() << std::endl;
+    	    FT_Done_Face(face_);
+    	}
+	
+    private:
+    	FT_Face face_;
+    };
+    
+    typedef boost::shared_ptr<font_face> face_ptr;
+    
+    class freetype_engine : public mapnik::singleton<freetype_engine,mapnik::CreateStatic>,
+		       private boost::noncopyable
+    {
+	friend class mapnik::CreateStatic<freetype_engine>;
+    public:
+	
+	static bool register_font(std::string const& file_name)
+	{
+	    mutex::scoped_lock lock(mapnik::singleton<freetype_engine, 
+				    mapnik::CreateStatic>::mutex_);
+	    FT_Face face;
+	    FT_Error error = FT_New_Face (library_,file_name.c_str(),0,&face);
+	    if ( !error )
+	    {
+		std::string name = std::string(face->family_name) + " " + std::string(face->style_name);
+		name2file_.insert(std::make_pair(name,file_name));
+		FT_Done_Face(face );
+		return true;
+	    }
+	    return false;
+	}
+	
+	static std::vector<std::string> face_names ()
+	{
+	    std::vector<std::string> names;
+	    std::map<std::string,std::string>::const_iterator itr;
+	    for (itr = name2file_.begin();itr!=name2file_.end();++itr)
+	    {
+		names.push_back(itr->first);
+	    }
+	    return names;
+	}
+	
+	static face_ptr create_face(std::string const& family_name)
+	{
+	    mutex::scoped_lock lock(mapnik::singleton<freetype_engine, 
+				    mapnik::CreateStatic>::mutex_);
+
+	    std::map<std::string,std::string>::iterator itr;
+	    itr = name2file_.find(family_name);
+	    if (itr != name2file_.end())
+	    {
+		FT_Face face;
+		FT_Error error = FT_New_Face (library_,itr->second.c_str(),0,&face);
+		
+		if (!error)
+		{
+		    return face_ptr (new font_face(face));
+		}
+	    }
+	    return face_ptr();
+	}
+	
+    private:
+	freetype_engine()
+	{
+	    FT_Error error = FT_Init_FreeType( &library_ );
+	    if (error)
+	    {
+		throw std::runtime_error("can not load FreeType2 library");
+	    }
+	}
+	virtual ~freetype_engine()
+	{   
+	    FT_Done_FreeType(library_);   
+	}
+	
+        static FT_Library library_;
+	static std::map<std::string,std::string> name2file_;
+    }; 
+    
+    
+    template <typename T>
+    class face_manager : private boost::noncopyable
+    {
+	typedef T font_engine_type;
+	typedef std::map<std::string,face_ptr> faces;
+	
+    public:
+	face_ptr get_face(std::string const& name)
+	{
+	    typename faces::iterator itr;
+	    itr = faces_.find(name);
+	    if (itr != faces_.end())
+	    {
+		return itr->second;
+	    }
+	    else
+	    {
+		face_ptr face = font_engine_type::instance()->create_face(name);
+		if (face)
+		{
+		    faces_.insert(make_pair(name,face));
+		}
+		return face;	
+	    }
+	}
+    private:
+	faces faces_;
+    };
+
+    template <typename T>
+    struct text_renderer : private boost::noncopyable
+    {
+	typedef T pixmap_type;
+    
+	text_renderer (pixmap_type & pixmap, face_ptr face)
+	    : pixmap_(pixmap),
+	      face_(face),
+	      fill_(0,0,0), 
+	      halo_fill_(255,255,255),
+	      halo_radius_(0),
+	      angle_(0.0) {}
+    
+	void set_pixel_size(unsigned size)
+	{
+	    face_->set_pixel_sizes(size);
+	}
+    
+	void set_angle(float angle)
+	{
+	    angle_=angle;
+	}
+
+	void set_fill(mapnik::Color const& fill)
+	{
+	    fill_=fill;
+	}
+    
+	void set_halo_fill(mapnik::Color const& halo)
+	{
+	    halo_fill_=halo;
+	}
+    
+	void set_halo_radius( int radius=1)
+	{
+	    halo_radius_=radius;
+	}
+    
+	void render(std::string const& text, double x0, double y0)
+	{
+	    FT_Matrix matrix;
+	    FT_Vector origin;
+	    FT_Vector pen;
+	    FT_Error  error;	
+	    FT_Glyph glyph;
+	
+	    FT_Face face = face_->get_face();
+	    FT_GlyphSlot slot = face->glyph;
+	    FT_UInt glyph_index;
+	    FT_Bool use_kerning;
+	    FT_UInt previous;
+	
+	    unsigned height = pixmap_.height();
+	
+	    origin.x = 0;
+	    origin.y = 0;
+	    pen.x = unsigned(x0 * 64);
+	    pen.y = unsigned((height - y0) * 64);
+        
+	    use_kerning = FT_HAS_KERNING(face);
+	
+	    //unsigned count=1;
+	
+	    for (std::string::const_iterator i=text.begin();i!=text.end();++i)
+	    {
+	    
+		matrix.xx = (FT_Fixed)( cos( angle_ ) * 0x10000L ); 
+		matrix.xy = (FT_Fixed)(-sin( angle_ ) * 0x10000L ); 
+		matrix.yx = (FT_Fixed)( sin( angle_ ) * 0x10000L ); 
+		matrix.yy = (FT_Fixed)( cos( angle_ ) * 0x10000L );
+	    	     
+		FT_Set_Transform (face,&matrix,&pen);
+	    
+		glyph_index = FT_Get_Char_Index( face, *i );
+		if ( use_kerning && previous && glyph_index)
+		{
+		    FT_Vector delta;
+		    FT_Get_Kerning(face,previous,glyph_index,
+				   FT_KERNING_DEFAULT,&delta);
+		    pen.x += delta.x;
+		    pen.y += delta.y;
+		    std::cout<< "use kerning "<< std::endl;
+		}
+	    
+		error = FT_Load_Glyph (face,glyph_index,FT_LOAD_DEFAULT); 
+		if ( error )
+		    continue;
+
+		error = FT_Get_Glyph( face->glyph, &glyph );
+		if ( error )
+		    continue;
+	  
+		//FT_Glyph_Transform(glyph,&matrix,&pen);
+	    
+		error = FT_Glyph_To_Bitmap( &glyph,FT_RENDER_MODE_NORMAL,0,1);
+		if ( error )
+		    continue;
+
+		FT_BitmapGlyph bit = (FT_BitmapGlyph)glyph;
+		if (halo_radius_)
+		{
+		    render_halo(&bit->bitmap, halo_fill_.rgba(), 
+				bit->left,
+				height - bit->top,halo_radius_);
+		}
+            	    
+		render_bitmap(&bit->bitmap, fill_.rgba(), 
+			      bit->left,
+			      height - bit->top);
+
+		FT_Done_Glyph(glyph);   
+		pen.x += slot->advance.x;
+		pen.y += slot->advance.y;
+	    
+		previous = glyph_index;
+	    
+		//angle_ = sin ( 0.1 * count++);
+	    
+	    }
+	}
+    private:
+    
+	void render_halo(FT_Bitmap *bitmap,unsigned rgba,int x,int y,int radius)
+	{
+	    int x_max=x+bitmap->width;
+	    int y_max=y+bitmap->rows;
+	    int i,p,j,q;
+	
+	    for (i=x,p=0;i<x_max;++i,++p)
+	    {
+		for (j=y,q=0;j<y_max;++j,++q)
+		{
+		    int gray = bitmap->buffer[q*bitmap->width+p];
+		    if (gray)
+		    {
+			for (int n=-halo_radius_; n <=halo_radius_; ++n)
+			    for (int m=-halo_radius_;m <= halo_radius_; ++m)
+				pixmap_.blendPixel(i+m,j+n,rgba,gray);		        
+		    }
+		}
+	    }
+	}
+    
+	void render_bitmap(FT_Bitmap *bitmap,unsigned rgba,int x,int y)
+	{
+	    int x_max=x+bitmap->width;
+	    int y_max=y+bitmap->rows;
+	    int i,p,j,q;
+	
+	    for (i=x,p=0;i<x_max;++i,++p)
+	    {
+		for (j=y,q=0;j<y_max;++j,++q)
+		{
+		    int gray=bitmap->buffer[q*bitmap->width+p];
+		    if (gray)
+		    {
+			pixmap_.blendPixel(i,j,rgba,gray);
+		    }
+		}
+	    }
+	}
+    
+	pixmap_type & pixmap_;
+	face_ptr face_;
+	mapnik::Color fill_;
+	mapnik::Color halo_fill_;
+	int halo_radius_;
+	float angle_;
+    }; 
+}
+
+
+#endif // FONT_ENGINE_FREETYPE_HPP

Modified: trunk/include/graphics.hpp
===================================================================
--- trunk/include/graphics.hpp	2006-02-20 01:34:02 UTC (rev 161)
+++ trunk/include/graphics.hpp	2006-02-21 19:55:24 UTC (rev 162)
@@ -95,13 +95,30 @@
 	    return 0xff << 24 | r << 16 | g << 8 | b;
 	}
 
-	inline void blendPixel(int x,int y,unsigned int rgba,int t)
+	inline void blendPixel(int x,int y,unsigned int rgba1,int t)
 	{
 	    if (checkBounds(x,y))
 	    {
-		int bg=data_(x,y);
-		int nc=blendColor(rgba,bg,t);
-		data_(x,y)=nc;
+		unsigned rgba0 = data_(x,y);	
+		unsigned a1 = t;//(rgba1 >> 24) & 0xff;
+		if (a1 == 0) return;
+		unsigned r1 = rgba1 & 0xff;
+		unsigned g1 = (rgba1 >> 8 ) & 0xff;
+		unsigned b1 = (rgba1 >> 16) & 0xff;
+		
+		unsigned a0 = (rgba0 >> 24) & 0xff;
+		unsigned r0 = (rgba0 & 0xff) * a0;
+		unsigned g0 = ((rgba0 >> 8 ) & 0xff) * a0;
+		unsigned b0 = ((rgba0 >> 16) & 0xff) * a0;
+		
+		
+		a0 = ((a1 + a0) << 8) - a0*a1;
+		
+		r0 = ((((r1 << 8) - r0) * a1 + (r0 << 8)) / a0);
+		g0 = ((((g1 << 8) - g0) * a1 + (g0 << 8)) / a0);
+		b0 = ((((b1 << 8) - b0) * a1 + (b0 << 8)) / a0);
+		a0 = a0 >> 8;
+		data_(x,y)= (a0 << 24)| (b0 << 16) |  (g0 << 8) | (r0) ;
 	    }
 	}
 

Modified: trunk/include/text_symbolizer.hpp
===================================================================
--- trunk/include/text_symbolizer.hpp	2006-02-20 01:34:02 UTC (rev 161)
+++ trunk/include/text_symbolizer.hpp	2006-02-21 19:55:24 UTC (rev 162)
@@ -27,15 +27,22 @@
 
 namespace mapnik
 {
+    enum label_placement_e {
+	point_placement=1,
+	line_placement=2
+    };
+        
     struct text_symbolizer
-    {
+    {		
 	text_symbolizer(std::string const& name,Color const& fill)
 	    : name_(name),
-	      fill_(fill) {}
-
+	      fill_(fill),
+	      label_p_(point_placement){}
+	
 	text_symbolizer(text_symbolizer const& rhs)
 	    : name_(rhs.name_),
-	      fill_(rhs.fill_) {}
+	      fill_(rhs.fill_),
+	      label_p_(rhs.label_p_) {}
 	
 	~text_symbolizer()
 	{
@@ -45,9 +52,25 @@
 	{
 	    return name_;
 	}
+	Color const& get_fill() const
+	{
+	    return fill_;
+	}
+	
+	void set_label_placement(label_placement_e label_p)
+	{
+	    label_p_ = label_p;
+	}
+	
+	label_placement_e get_label_placement() const
+	{
+	    return label_p_;
+	}
+	
     private:
 	std::string name_;
-	Color fill_;		    
+	Color fill_;
+	label_placement_e label_p_;
     };
 }
 

Modified: trunk/include/value.hpp
===================================================================
--- trunk/include/value.hpp	2006-02-20 01:34:02 UTC (rev 161)
+++ trunk/include/value.hpp	2006-02-21 19:55:24 UTC (rev 162)
@@ -321,6 +321,21 @@
 		ss << val;
 		return ss.str();
 	    } 
+	    std::string const& operator() (std::string const& val) const
+	    {
+		return val;
+	    }
+	};
+	
+	struct to_expression_string : public boost::static_visitor<std::string>
+	{
+	    template <typename T>
+	    std::string operator() (T val) const
+	    {
+		std::stringstream ss;
+		ss << val;
+		return ss.str();
+	    } 
 	    std::string operator() (std::string const& val) const
 	    {
 		return "'" + val + "'";
@@ -390,7 +405,12 @@
 	    *this = boost::apply_visitor(impl::div<value>(),*this,other);
 	    return *this;
 	}
-	
+
+	std::string to_expression_string() const
+	{
+	    return boost::apply_visitor(impl::to_expression_string(),*this);
+	}
+
 	std::string to_string() const
 	{
 	    return boost::apply_visitor(impl::to_string(),*this);

Modified: trunk/src/SConscript
===================================================================
--- trunk/src/SConscript	2006-02-20 01:34:02 UTC (rev 161)
+++ trunk/src/SConscript	2006-02-21 19:55:24 UTC (rev 162)
@@ -24,6 +24,8 @@
 prefix = env['PREFIX']
 
 libraries = ['agg'] + env['LIBS']
+libraries += ['freetype']
+
 linkflags = '-Wl,-rpath-link,. -Wl,-soname,libmapnik.so'
 
 source = Split(
@@ -47,6 +49,7 @@
     point_symbolizer.cpp
     polygon_pattern_symbolizer.cpp
     line_pattern_symbolizer.cpp
+    font_engine_freetype.cpp
     """
     )
 #render.cpp

Modified: trunk/src/agg_renderer.cpp
===================================================================
--- trunk/src/agg_renderer.cpp	2006-02-20 01:34:02 UTC (rev 161)
+++ trunk/src/agg_renderer.cpp	2006-02-21 19:55:24 UTC (rev 162)
@@ -51,7 +51,6 @@
 #include "agg_renderer_outline_image.h"
 
 #include <boost/utility.hpp>
-
 #include <iostream>
 
 namespace mapnik
@@ -89,6 +88,31 @@
 	pixmap_.setBackground(bg);
 	std::cout << "scale="<<m.scale()<<std::endl;
     }
+    
+    template <typename T>
+    void agg_renderer<T>::start_map_processing()
+    {
+	std::cout << "start map processing" << std::endl;
+    }
+
+    template <typename T>
+    void agg_renderer<T>::end_map_processing()
+    {
+	std::cout << "end map processing" << std::endl;
+    }
+    
+    template <typename T>
+    void agg_renderer<T>::start_layer_processing()
+    {
+	std::cout << "start layer processing" << std::endl;
+    }
+    
+    template <typename T>
+    void agg_renderer<T>::end_layer_processing()
+    {
+	std::cout << "end layer processing" << std::endl;
+    }
+    
     template <typename T>	
     void agg_renderer<T>::process(polygon_symbolizer const& sym,Feature const& feature)
     {
@@ -356,10 +380,51 @@
     template <typename T>
     void agg_renderer<T>::process(text_symbolizer const& sym ,Feature const& feature)
     {
-	//TODO - implement text
-	//std::cout << feature << std::endl;
-	std::cout << sym.get_name() <<":" << feature[sym.get_name()] << std::endl;
+	typedef  coord_transform<CoordTransform,geometry_type> path_type;
+	geometry_ptr const& geom=feature.get_geometry();
+	if (geom)
+	{
+	    double angle = 0.0;	    
+	    if (sym.get_label_placement() == line_placement && 
+		geom->num_points() > 1)
+	    {
+	       
+		path_type path(t_,*geom);
+		double x0,y0,x1,y1;
+		path.vertex(&x0,&y0);
+		path.vertex(&x1,&y1);
+		double dx = x1 - x0;
+		double dy = y1 - y0;
+		angle = atan( dx/ dy ) - 0.5 * 3.1459;
+		
+		//TODO!!!!!!!!!!!!!!!!!!!!
+	    }   
+	    
+	    std::string text = feature[sym.get_name()].to_string();
+	    if (text.length() > 0)
+	    {
+		Color const& fill  = sym.get_fill();
+	
+		double x;
+		double y;
+		geom->label_position(&x,&y);
+		t_.forward_x(&x);
+		t_.forward_y(&y);
+		
+		face_ptr face = font_manager_.get_face("Bitstream Vera Sans Roman");//TODO
+		
+		if (face)
+		{
+		    text_renderer<mapnik::Image32> ren(pixmap_,face);
+		    ren.set_pixel_size(12);
+		    ren.set_fill(fill);
+		    ren.set_halo_radius(1);
+		    ren.set_angle(angle);
+		    ren.render(text,x,y);
+		}
+	    }  
+	}
     }
-
+    
     template class agg_renderer<Image32>;
 }

Added: trunk/src/font_engine_freetype.cpp
===================================================================
--- trunk/src/font_engine_freetype.cpp	2006-02-20 01:34:02 UTC (rev 161)
+++ trunk/src/font_engine_freetype.cpp	2006-02-21 19:55:24 UTC (rev 162)
@@ -0,0 +1,27 @@
+/* This file is part of Mapnik (c++ mapping toolkit)
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * Mapnik is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+//$Id$
+
+#include "font_engine_freetype.hpp"
+
+namespace mapnik
+{
+    FT_Library freetype_engine::library_;
+    std::map<std::string,std::string> freetype_engine::name2file_;
+}

Modified: trunk/src/text.cpp
===================================================================
--- trunk/src/text.cpp	2006-02-20 01:34:02 UTC (rev 161)
+++ trunk/src/text.cpp	2006-02-21 19:55:24 UTC (rev 162)
@@ -69,7 +69,7 @@
     }
 
     template <class PixBuffer>
-        void TextRasterizer<PixBuffer>::render_bitmap(FT_Bitmap *bitmap,int x,int y)
+    void TextRasterizer<PixBuffer>::render_bitmap(FT_Bitmap *bitmap,int x,int y)
     {
         int x_max=x+bitmap->width;
         int y_max=y+bitmap->rows;



From pavlenko at berlios.de  Tue Feb 21 21:17:40 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Tue, 21 Feb 2006 21:17:40 +0100
Subject: [Mapnik-svn] r163 - in trunk: include src
Message-ID: <200602212017.k1LKHeZC025813@sheep.berlios.de>

Author: pavlenko
Date: 2006-02-21 21:17:08 +0100 (Tue, 21 Feb 2006)
New Revision: 163

Modified:
   trunk/include/agg_renderer.hpp
   trunk/include/feature_style_processor.hpp
   trunk/src/agg_renderer.cpp
Log:
added:
1. start/end map/layer handlers 
2. some cleanups




Modified: trunk/include/agg_renderer.hpp
===================================================================
--- trunk/include/agg_renderer.hpp	2006-02-21 19:55:24 UTC (rev 162)
+++ trunk/include/agg_renderer.hpp	2006-02-21 20:17:08 UTC (rev 163)
@@ -23,7 +23,6 @@
 
 #include "feature_style_processor.hpp"
 #include <boost/utility.hpp>
-//#include "agg_font_freetype.h"
 #include "font_engine_freetype.hpp"
 
 namespace mapnik
@@ -35,8 +34,8 @@
 	agg_renderer(Map const& m, T & pixmap);
 	void start_map_processing();
 	void end_map_processing();
-	void start_layer_processing();
-	void end_layer_processing();
+	void start_layer_processing(Layer const& lay);
+	void end_layer_processing(Layer const& lay);
 	void process(point_symbolizer const& sym,Feature const& feature);	    	       
 	void process(line_symbolizer const& sym,Feature const& feature);
 	void process(line_pattern_symbolizer const& sym,Feature const& feature);

Modified: trunk/include/feature_style_processor.hpp
===================================================================
--- trunk/include/feature_style_processor.hpp	2006-02-21 19:55:24 UTC (rev 162)
+++ trunk/include/feature_style_processor.hpp	2006-02-21 20:17:08 UTC (rev 163)
@@ -58,8 +58,10 @@
 	void apply()
 	{
 	    timer clock;
+	    Processor & p = static_cast<Processor&>(*this);
+
+	    p.start_map_processing();
 	    
-	    Processor & p = static_cast<Processor&>(*this);
 	    std::vector<Layer>::const_iterator itr = m_.layers().begin();
 	    while (itr != m_.layers().end())
 	    {
@@ -70,11 +72,16 @@
 		}
 		++itr;
 	    }
+	    
+	    p.end_map_processing();
+	    
 	    clock.stop();
+	    
 	}	
     private:
 	void apply_to_layer(Layer const& lay,Processor & p)
 	{
+	    p.start_layer_processing(lay);
 	    datasource *ds=lay.datasource().get();
 	    if (ds)
 	    {
@@ -87,7 +94,6 @@
 		{
 		    std::set<std::string> names;
 		    attribute_collector<Feature> collector(names);
-		    //property_index<Feature> indexer(names);
 		    std::vector<rule_type*> if_rules;
 		    std::vector<rule_type*> else_rules;
 		
@@ -104,10 +110,8 @@
 			if (ruleIter->active(scale))
 			{
 			    active_rules=true;
-			    //filter_ptr& filter=const_cast<filter_ptr&>(ruleIter->get_filter());
-			    //filter->accept(collector);
 			    ruleIter->accept(collector);
-			    //filter->accept(indexer);
+
 			    if (ruleIter->has_else_filter())
 			    {
 				else_rules.push_back(const_cast<rule_type*>(&(*ruleIter)));
@@ -171,6 +175,7 @@
 		    }
 		}
 	    }
+	    p.end_layer_processing(lay);
 	}
 	
 	Map const& m_;

Modified: trunk/src/agg_renderer.cpp
===================================================================
--- trunk/src/agg_renderer.cpp	2006-02-21 19:55:24 UTC (rev 162)
+++ trunk/src/agg_renderer.cpp	2006-02-21 20:17:08 UTC (rev 163)
@@ -102,13 +102,13 @@
     }
     
     template <typename T>
-    void agg_renderer<T>::start_layer_processing()
+    void agg_renderer<T>::start_layer_processing(Layer const& lay)
     {
-	std::cout << "start layer processing" << std::endl;
+	std::cout << "start layer processing : " << lay.name()  << std::endl;
     }
     
     template <typename T>
-    void agg_renderer<T>::end_layer_processing()
+    void agg_renderer<T>::end_layer_processing(Layer const&)
     {
 	std::cout << "end layer processing" << std::endl;
     }



From pavlenko at berlios.de  Sat Feb 25 12:03:32 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Sat, 25 Feb 2006 12:03:32 +0100
Subject: [Mapnik-svn] r164 - in trunk: bindings/python bindings/python/mapnik include src
Message-ID: <200602251103.k1PB3Who013283@sheep.berlios.de>

Author: pavlenko
Date: 2006-02-25 12:03:30 +0100 (Sat, 25 Feb 2006)
New Revision: 164

Added:
   trunk/bindings/python/mapnik_line_pattern_symbolizer.cpp
   trunk/bindings/python/mapnik_line_symbolizer.cpp
   trunk/bindings/python/mapnik_point_symbolizer.cpp
   trunk/bindings/python/mapnik_polygon_pattern_symbolizer.cpp
   trunk/bindings/python/mapnik_polygon_symbolizer.cpp
   trunk/bindings/python/mapnik_raster_symbolizer.cpp
   trunk/bindings/python/mapnik_text_symbolizer.cpp
   trunk/include/label_collision_detector.hpp
Modified:
   trunk/bindings/python/mapnik/__init__.py
   trunk/bindings/python/mapnik_layer.cpp
   trunk/bindings/python/mapnik_python.cpp
   trunk/bindings/python/mapnik_rule.cpp
   trunk/include/agg_renderer.hpp
   trunk/include/feature_style_processor.hpp
   trunk/include/font_engine_freetype.hpp
   trunk/include/line_symbolizer.hpp
   trunk/include/point_symbolizer.hpp
   trunk/include/polygon_symbolizer.hpp
   trunk/include/rule.hpp
   trunk/include/text_symbolizer.hpp
   trunk/src/agg_renderer.cpp
Log:
1.python bindings updated to reflect symbolizers changes
2.added label collision detector ( TODO - proper impl!)



Modified: trunk/bindings/python/mapnik/__init__.py
===================================================================
--- trunk/bindings/python/mapnik/__init__.py	2006-02-21 20:17:08 UTC (rev 163)
+++ trunk/bindings/python/mapnik/__init__.py	2006-02-25 11:03:30 UTC (rev 164)
@@ -29,7 +29,7 @@
 from paths import inputpluginspath
 
 # The base Boost.Python class
-BoostPythonMetaclass = coord.__class__
+BoostPythonMetaclass = Coord.__class__
 
 class _injector(object):
     class __metaclass__(BoostPythonMetaclass):
@@ -40,23 +40,23 @@
                         setattr(b,k,v)
             return type.__init__(self, name, bases, dict)
 
-class _coord(coord,_injector):
+class _Coord(Coord,_injector):
     def __repr__(self):
-        return 'coord(%s,%s)' % (self.x, self.y)
+        return 'Coord(%s,%s)' % (self.x, self.y)
 
-class _envelope(envelope,_injector):
+class _Envelope(Envelope,_injector):
     def __repr__(self):
-        return 'envelope(%s,%s,%s,%s)' % \
+        return 'Envelope(%s,%s,%s,%s)' % \
                (self.minx,self.miny,self.maxx,self.maxy)
 
-class _color(color,_injector):
+class _Color(Color,_injector):
     def __repr__(self):
-        return 'color(%s,%s,%s,%s)' % \
+        return 'Color(%s,%s,%s,%s)' % \
                (self.r,self.g,self.b,self.a)
 
 #register datasources
-from mapnik import datasource_cache
-datasource_cache.instance().register_datasources('%s' % inputpluginspath)
+from mapnik import DatasourceCache
+DatasourceCache.instance().register_datasources('%s' % inputpluginspath)
 #set dlopen flags back to the original
 setdlopenflags(flags)
 

Modified: trunk/bindings/python/mapnik_layer.cpp
===================================================================
--- trunk/bindings/python/mapnik_layer.cpp	2006-02-21 20:17:08 UTC (rev 163)
+++ trunk/bindings/python/mapnik_layer.cpp	2006-02-25 11:03:30 UTC (rev 164)
@@ -103,7 +103,7 @@
     class_<std::vector<std::string> >("Styles")
     	.def(vector_indexing_suite<std::vector<std::string>,true >())
     	;
-    //class_<Layer>("layer",init<const Parameters&>("Layer constructor"))
+    
     class_<Layer>("Layer",no_init)
         .def("name",&Layer::name,return_value_policy<copy_const_reference>())
         .def("params",&Layer::params,return_value_policy<reference_existing_object>())

Added: trunk/bindings/python/mapnik_line_pattern_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_line_pattern_symbolizer.cpp	2006-02-21 20:17:08 UTC (rev 163)
+++ trunk/bindings/python/mapnik_line_pattern_symbolizer.cpp	2006-02-25 11:03:30 UTC (rev 164)
@@ -0,0 +1,34 @@
+/* This file is part of python_mapnik (c++/python mapping toolkit)
+ * Copyright (C) 2005 Artem Pavlenko, Jean-Francois Doyon
+ *
+ * Mapnik is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+//$Id$
+
+#include <boost/python.hpp>
+#include <mapnik.hpp>
+
+using mapnik::line_pattern_symbolizer;
+
+void export_line_pattern_symbolizer()
+{
+    using namespace boost::python;
+    
+    class_<line_pattern_symbolizer>("LinePatternSymbolizer",
+				    init<std::string const&,
+				    std::string const&,unsigned,unsigned>("TODO"))
+	;    
+}

Added: trunk/bindings/python/mapnik_line_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_line_symbolizer.cpp	2006-02-21 20:17:08 UTC (rev 163)
+++ trunk/bindings/python/mapnik_line_symbolizer.cpp	2006-02-25 11:03:30 UTC (rev 164)
@@ -0,0 +1,38 @@
+/* This file is part of python_mapnik (c++/python mapping toolkit)
+ * Copyright (C) 2005 Artem Pavlenko, Jean-Francois Doyon
+ *
+ * Mapnik is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+//$Id$
+
+#include <boost/python.hpp>
+#include <mapnik.hpp>
+
+using mapnik::line_symbolizer;
+using mapnik::stroke;
+using mapnik::Color;
+
+void export_line_symbolizer()
+{
+    using namespace boost::python;
+    
+    class_<line_symbolizer>("LineSymbolizer",init<stroke const&>("TODO"))
+	.def(init<Color const& ,float>())
+	.add_property("stroke",make_function
+		      (&line_symbolizer::get_stroke,return_value_policy<reference_existing_object>()),
+		      &line_symbolizer::set_stroke)
+	;    
+}

Added: trunk/bindings/python/mapnik_point_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_point_symbolizer.cpp	2006-02-21 20:17:08 UTC (rev 163)
+++ trunk/bindings/python/mapnik_point_symbolizer.cpp	2006-02-25 11:03:30 UTC (rev 164)
@@ -0,0 +1,34 @@
+/* This file is part of python_mapnik (c++/python mapping toolkit)
+ * Copyright (C) 2005 Artem Pavlenko, Jean-Francois Doyon
+ *
+ * Mapnik is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+//$Id$
+
+#include <boost/python.hpp>
+#include <mapnik.hpp>
+
+using mapnik::point_symbolizer;
+
+void export_point_symbolizer()
+{
+    using namespace boost::python;
+    
+    class_<point_symbolizer>("PointSymbolizer",init<std::string const&,
+			     std::string const&,unsigned,unsigned>("TODO"))
+	;
+    
+}

Added: trunk/bindings/python/mapnik_polygon_pattern_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_polygon_pattern_symbolizer.cpp	2006-02-21 20:17:08 UTC (rev 163)
+++ trunk/bindings/python/mapnik_polygon_pattern_symbolizer.cpp	2006-02-25 11:03:30 UTC (rev 164)
@@ -0,0 +1,35 @@
+/* This file is part of python_mapnik (c++/python mapping toolkit)
+ * Copyright (C) 2005 Artem Pavlenko, Jean-Francois Doyon
+ *
+ * Mapnik is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+//$Id$
+
+#include <boost/python.hpp>
+#include <mapnik.hpp>
+
+using mapnik::polygon_pattern_symbolizer;
+
+void export_polygon_pattern_symbolizer()
+{
+    using namespace boost::python;
+    
+    class_<polygon_pattern_symbolizer>("PolygonPatternSymbolizer",
+				       init<std::string const&,
+				       std::string const&,
+				       unsigned,unsigned>("TODO"))
+	;    
+}

Added: trunk/bindings/python/mapnik_polygon_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_polygon_symbolizer.cpp	2006-02-21 20:17:08 UTC (rev 163)
+++ trunk/bindings/python/mapnik_polygon_symbolizer.cpp	2006-02-25 11:03:30 UTC (rev 164)
@@ -0,0 +1,39 @@
+/* This file is part of python_mapnik (c++/python mapping toolkit)
+ * Copyright (C) 2005 Artem Pavlenko, Jean-Francois Doyon
+ *
+ * Mapnik is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+//$Id$
+
+#include <boost/python.hpp>
+#include <mapnik.hpp>
+
+using mapnik::polygon_symbolizer;
+using mapnik::Color;
+
+void export_polygon_symbolizer()
+{
+    using namespace boost::python;
+    
+    class_<polygon_symbolizer>("PolygonSymbolizer",
+				    init<Color const&>("TODO"))
+	.add_property("fill",make_function
+		      (&polygon_symbolizer::get_fill,
+		       return_value_policy<reference_existing_object>()),
+		      &polygon_symbolizer::set_fill)
+	;    
+
+}

Modified: trunk/bindings/python/mapnik_python.cpp
===================================================================
--- trunk/bindings/python/mapnik_python.cpp	2006-02-21 20:17:08 UTC (rev 163)
+++ trunk/bindings/python/mapnik_python.cpp	2006-02-25 11:03:30 UTC (rev 164)
@@ -38,50 +38,28 @@
 void export_style();
 void export_stroke();
 void export_datasource_cache();
+void export_point_symbolizer();
+void export_line_symbolizer();
+void export_line_pattern_symbolizer();
+void export_polygon_symbolizer();
+void export_polygon_pattern_symbolizer();
+void export_raster_symbolizer();
+void export_text_symbolizer();
 
 void render_to_file(const Map& map,const std::string& file,const std::string& format)
 {
     Image32 image(map.getWidth(),map.getHeight());
-    Renderer<Image32>::render(map,image);
+    agg_renderer<Image32> ren(map,image);
+    ren.apply();
     image.saveToFile(file,format);
 }
 
 void render(const Map& map,Image32& image)
 {
-    Renderer<Image32>::render(map,image);    
+    agg_renderer<Image32> ren(map,image);
+    ren.apply();
 }
 
-
-boost::shared_ptr<symbolizer> create_point_symbolizer(std::string const& file,unsigned w,unsigned h)
-{
-    return boost::shared_ptr<symbolizer>(new image_symbolizer(file,"png",w,h));
-}
-
-boost::shared_ptr<symbolizer> create_line_symbolizer(const Color& pen,float width)
-{
-    return boost::shared_ptr<symbolizer>(new line_symbolizer(pen,width));
-} 
-
-boost::shared_ptr<symbolizer> create_line_symbolizer2(stroke const& strk)
-{
-    return boost::shared_ptr<symbolizer>(new line_symbolizer(strk));
-} 
-
-boost::shared_ptr<symbolizer> create_line_symbolizer3(std::string const& file,unsigned w,unsigned h)
-{
-    return boost::shared_ptr<symbolizer>(new line_pattern_symbolizer(file,"png",w,h));
-} 
-
-boost::shared_ptr<symbolizer> create_polygon_symbolizer(const Color& fill) 
-{   
-    return boost::shared_ptr<symbolizer>(new polygon_symbolizer(fill));
-} 
-
-boost::shared_ptr<symbolizer> create_polygon_symbolizer2(std::string const& file,unsigned w,unsigned h) 
-{   
-    return boost::shared_ptr<symbolizer>(new polygon_pattern_symbolizer(file,"png",w,h));
-} 
-
 BOOST_PYTHON_MODULE(_mapnik)
 {
     using namespace boost::python;
@@ -91,12 +69,7 @@
         .def("envelope",&datasource::envelope,
 	     return_value_policy<reference_existing_object>())
         ;
-    
-    class_<symbolizer,boost::noncopyable> ("Symbolizer_",no_init) 
-    	;
-    class_<boost::shared_ptr<symbolizer>,
-	boost::noncopyable>("Symbolizer",no_init)
-	;
+        
     export_parameters();
     export_color(); 
     export_envelope();   
@@ -107,8 +80,14 @@
     export_layer();
     export_stroke();
     export_datasource_cache();
-    
-    
+    export_point_symbolizer();
+    export_line_symbolizer();
+    export_line_pattern_symbolizer();
+    export_polygon_symbolizer();
+    export_polygon_pattern_symbolizer();
+    export_raster_symbolizer();
+    export_text_symbolizer();
+
     class_<coord<double,2> >("Coord",init<double,double>())
         .def_readwrite("x", &coord<double,2>::x)
         .def_readwrite("y", &coord<double,2>::y)
@@ -118,12 +97,5 @@
   
     def("render_to_file",&render_to_file);
     def("render",&render);
-    def("point_symbolizer",&create_point_symbolizer);
-    def("line_symbolizer",&create_line_symbolizer);
-    def("line_symbolizer",&create_line_symbolizer2);
-    def("line_symbolizer",&create_line_symbolizer3);
-    def("polygon_symbolizer",&create_polygon_symbolizer);
-    def("polygon_symbolizer",&create_polygon_symbolizer2);
-    register_ptr_to_python<boost::shared_ptr<symbolizer> >();
     register_ptr_to_python<filter_ptr>();
 }

Added: trunk/bindings/python/mapnik_raster_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_raster_symbolizer.cpp	2006-02-21 20:17:08 UTC (rev 163)
+++ trunk/bindings/python/mapnik_raster_symbolizer.cpp	2006-02-25 11:03:30 UTC (rev 164)
@@ -0,0 +1,33 @@
+/* This file is part of python_mapnik (c++/python mapping toolkit)
+ * Copyright (C) 2005 Artem Pavlenko, Jean-Francois Doyon
+ *
+ * Mapnik is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+//$Id$
+
+#include <boost/python.hpp>
+#include <mapnik.hpp>
+
+using mapnik::raster_symbolizer;
+
+void export_raster_symbolizer()
+{
+    using namespace boost::python;
+    
+    class_<raster_symbolizer>("RasterSymbolizer",
+				    init<>("TODO"))
+	;    
+}

Modified: trunk/bindings/python/mapnik_rule.cpp
===================================================================
--- trunk/bindings/python/mapnik_rule.cpp	2006-02-21 20:17:08 UTC (rev 163)
+++ trunk/bindings/python/mapnik_rule.cpp	2006-02-25 11:03:30 UTC (rev 164)
@@ -20,6 +20,7 @@
 
 
 #include <boost/python.hpp>
+#include <boost/python/implicit.hpp>
 #include <boost/python/suite/indexing/vector_indexing_suite.hpp>
 #include <mapnik.hpp>
 
@@ -27,17 +28,34 @@
 using mapnik::filter;
 using mapnik::filter_ptr;
 using mapnik::Feature;
+
+using mapnik::point_symbolizer;
+using mapnik::line_symbolizer;
+using mapnik::line_pattern_symbolizer;
+using mapnik::polygon_symbolizer;
+using mapnik::polygon_pattern_symbolizer;
+using mapnik::raster_symbolizer;
+using mapnik::text_symbolizer;
+using mapnik::symbolizer;
 using mapnik::symbolizers;
 
 void export_rule()
 {
     using namespace boost::python;
+
+    implicitly_convertible<point_symbolizer,symbolizer>();
+    implicitly_convertible<line_symbolizer,symbolizer>();
+    implicitly_convertible<line_pattern_symbolizer,symbolizer>();
+    implicitly_convertible<polygon_symbolizer,symbolizer>();
+    implicitly_convertible<polygon_pattern_symbolizer,symbolizer>();
+    implicitly_convertible<raster_symbolizer,symbolizer>();
+    implicitly_convertible<text_symbolizer,symbolizer>();
     
     class_<symbolizers>("Symbolizers",init<>("TODO"))
-	.def(vector_indexing_suite<symbolizers>())
-	;
+    	.def(vector_indexing_suite<symbolizers>())
+    	;
     
-    class_<rule_type>("Rule",init<>("default ctor"))
+    class_<rule_type>("Rule",init<>("default constructor"))
 	.def(init<std::string const&,
 	     boost::python::optional<std::string const&,double,double> >())
 	.add_property("name",make_function

Added: trunk/bindings/python/mapnik_text_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_text_symbolizer.cpp	2006-02-21 20:17:08 UTC (rev 163)
+++ trunk/bindings/python/mapnik_text_symbolizer.cpp	2006-02-25 11:03:30 UTC (rev 164)
@@ -0,0 +1,34 @@
+/* This file is part of python_mapnik (c++/python mapping toolkit)
+ * Copyright (C) 2005 Artem Pavlenko, Jean-Francois Doyon
+ *
+ * Mapnik is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+//$Id$
+
+#include <boost/python.hpp>
+#include <mapnik.hpp>
+
+using mapnik::text_symbolizer;
+using mapnik::Color;
+
+void export_text_symbolizer()
+{
+    using namespace boost::python;
+    
+    class_<text_symbolizer>("TextSymbolizer",
+			    init<std::string const&,Color const&>("TODO"))
+	;
+}

Modified: trunk/include/agg_renderer.hpp
===================================================================
--- trunk/include/agg_renderer.hpp	2006-02-21 20:17:08 UTC (rev 163)
+++ trunk/include/agg_renderer.hpp	2006-02-25 11:03:30 UTC (rev 164)
@@ -24,6 +24,7 @@
 #include "feature_style_processor.hpp"
 #include <boost/utility.hpp>
 #include "font_engine_freetype.hpp"
+#include "label_collision_detector.hpp"
 
 namespace mapnik
 {
@@ -32,8 +33,8 @@
 			  private boost::noncopyable
     {
 	agg_renderer(Map const& m, T & pixmap);
-	void start_map_processing();
-	void end_map_processing();
+	void start_map_processing(Map const& map);
+	void end_map_processing(Map const& map);
 	void start_layer_processing(Layer const& lay);
 	void end_layer_processing(Layer const& lay);
 	void process(point_symbolizer const& sym,Feature const& feature);	    	       
@@ -47,6 +48,7 @@
 	T & pixmap_;
 	CoordTransform t_;
 	face_manager<freetype_engine> font_manager_;
+	label_collision_detector detector_;
     };
 }
 

Modified: trunk/include/feature_style_processor.hpp
===================================================================
--- trunk/include/feature_style_processor.hpp	2006-02-21 20:17:08 UTC (rev 163)
+++ trunk/include/feature_style_processor.hpp	2006-02-25 11:03:30 UTC (rev 164)
@@ -60,7 +60,7 @@
 	    timer clock;
 	    Processor & p = static_cast<Processor&>(*this);
 
-	    p.start_map_processing();
+	    p.start_map_processing(m_);
 	    
 	    std::vector<Layer>::const_iterator itr = m_.layers().begin();
 	    while (itr != m_.layers().end())
@@ -73,7 +73,7 @@
 		++itr;
 	    }
 	    
-	    p.end_map_processing();
+	    p.end_map_processing(m_);
 	    
 	    clock.stop();
 	    

Modified: trunk/include/font_engine_freetype.hpp
===================================================================
--- trunk/include/font_engine_freetype.hpp	2006-02-21 20:17:08 UTC (rev 163)
+++ trunk/include/font_engine_freetype.hpp	2006-02-25 11:03:30 UTC (rev 164)
@@ -219,7 +219,57 @@
     private:
 	faces faces_;
     };
-
+        
+    inline std::wstring to_unicode(std::string const& text)
+    {
+	std::wstring out;
+	unsigned long code = 0;
+	int expect = 0;
+	std::string::const_iterator itr=text.begin();
+	
+	while ( itr != text.end())
+	{
+	    unsigned p = (*itr++) & 0xff;
+	    if ( p >= 0xc0)
+	    {
+		if ( p < 0xe0)      // U+0080 - U+07ff
+		{
+		    expect = 1;
+		    code = p & 0x1f;
+		}
+		else if ( p < 0xf0)  // U+0800 - U+ffff
+		{
+		    expect = 2;
+		    code = p & 0x0f;
+		}
+		else if ( p  < 0xf8) // U+1000 - U+10ffff
+		{
+		    expect = 3;
+		    code = p & 0x07;
+		}
+		continue;
+	    }
+	    else if (p >= 0x80)
+	    {
+		--expect;
+		if (expect >= 0)
+		{
+		    code <<= 6;
+		    code += p & 0x3f;
+		}
+		if (expect > 0)
+		    continue;
+		expect = 0;
+	    }
+	    else 
+	    {
+		code = p;            // U+0000 - U+007f (ascii)
+	    }
+	    out.push_back(code);
+	}
+	return out;
+    }
+    
     template <typename T>
     struct text_renderer : private boost::noncopyable
     {
@@ -270,7 +320,7 @@
 	    FT_GlyphSlot slot = face->glyph;
 	    FT_UInt glyph_index;
 	    FT_Bool use_kerning;
-	    FT_UInt previous;
+	    FT_UInt previous = 0;
 	
 	    unsigned height = pixmap_.height();
 	
@@ -280,12 +330,10 @@
 	    pen.y = unsigned((height - y0) * 64);
         
 	    use_kerning = FT_HAS_KERNING(face);
-	
-	    //unsigned count=1;
-	
-	    for (std::string::const_iterator i=text.begin();i!=text.end();++i)
+
+	    std::string::const_iterator i;
+	    for (i=text.begin();i!=text.end();++i)
 	    {
-	    
 		matrix.xx = (FT_Fixed)( cos( angle_ ) * 0x10000L ); 
 		matrix.xy = (FT_Fixed)(-sin( angle_ ) * 0x10000L ); 
 		matrix.yx = (FT_Fixed)( sin( angle_ ) * 0x10000L ); 
@@ -293,7 +341,7 @@
 	    	     
 		FT_Set_Transform (face,&matrix,&pen);
 	    
-		glyph_index = FT_Get_Char_Index( face, *i );
+		glyph_index = FT_Get_Char_Index( face, unsigned(*i) & 0xff );
 		if ( use_kerning && previous && glyph_index)
 		{
 		    FT_Vector delta;
@@ -301,7 +349,6 @@
 				   FT_KERNING_DEFAULT,&delta);
 		    pen.x += delta.x;
 		    pen.y += delta.y;
-		    std::cout<< "use kerning "<< std::endl;
 		}
 	    
 		error = FT_Load_Glyph (face,glyph_index,FT_LOAD_DEFAULT); 
@@ -337,8 +384,8 @@
 		previous = glyph_index;
 	    
 		//angle_ = sin ( 0.1 * count++);
-	    
 	    }
+	    std::cout << std::endl;
 	}
     private:
     

Added: trunk/include/label_collision_detector.hpp
===================================================================
--- trunk/include/label_collision_detector.hpp	2006-02-21 20:17:08 UTC (rev 163)
+++ trunk/include/label_collision_detector.hpp	2006-02-25 11:03:30 UTC (rev 164)
@@ -0,0 +1,56 @@
+/* This file is part of Mapnik (c++ mapping toolkit)
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * Mapnik is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+//$Id$
+
+
+#if !defined LABEL_COLLISION_DETECTOR
+#define LABEL_COLLISION_DETECTOR
+
+#include "envelope.hpp"
+#include <vector>
+
+namespace mapnik
+{
+    //this needs to be tree structure 
+    //as a proof of a concept _only_ we use sequential scan 
+
+    struct label_collision_detector
+    {
+	typedef std::vector<Envelope<double> > label_placements;
+
+	bool allowed_to_render(Envelope<double> const& box)
+	{
+	    label_placements::const_iterator itr=labels_.begin();
+	    for( ; itr !=labels_.end();++itr)
+	    {
+		if (itr->intersects(box))
+		{
+		    return false;
+		}
+	    }
+	    labels_.push_back(box);
+	    return true;
+	}
+    private:
+
+	label_placements labels_;
+    };
+}
+
+#endif 

Modified: trunk/include/line_symbolizer.hpp
===================================================================
--- trunk/include/line_symbolizer.hpp	2006-02-21 20:17:08 UTC (rev 163)
+++ trunk/include/line_symbolizer.hpp	2006-02-25 11:03:30 UTC (rev 164)
@@ -38,6 +38,11 @@
 	{
 	    return stroke_;
 	}
+	void set_stroke(stroke const& stroke)
+	{
+	    stroke_ = stroke;
+	}
+
     private:
 	stroke stroke_;
     };

Modified: trunk/include/point_symbolizer.hpp
===================================================================
--- trunk/include/point_symbolizer.hpp	2006-02-21 20:17:08 UTC (rev 163)
+++ trunk/include/point_symbolizer.hpp	2006-02-25 11:03:30 UTC (rev 164)
@@ -27,8 +27,7 @@
 namespace mapnik 
 {   
     struct point_symbolizer
-    {
-	
+    {	
 	point_symbolizer(std::string const& file,
 			 std::string const& type,
 			 unsigned width,unsigned height);

Modified: trunk/include/polygon_symbolizer.hpp
===================================================================
--- trunk/include/polygon_symbolizer.hpp	2006-02-21 20:17:08 UTC (rev 163)
+++ trunk/include/polygon_symbolizer.hpp	2006-02-25 11:03:30 UTC (rev 164)
@@ -34,6 +34,10 @@
 	{
 	    return fill_;
 	}
+	void set_fill(Color const& fill)
+	{
+	    fill_ = fill;
+	}
     private:
 	Color fill_;
     };  

Modified: trunk/include/rule.hpp
===================================================================
--- trunk/include/rule.hpp	2006-02-21 20:17:08 UTC (rev 163)
+++ trunk/include/rule.hpp	2006-02-25 11:03:30 UTC (rev 164)
@@ -28,7 +28,6 @@
 #include "text_symbolizer.hpp"
 #include "filter.hpp"
 #include "filter_visitor.hpp"
-
 #include <boost/shared_ptr.hpp>
 #include <boost/variant.hpp>
 #include <string>
@@ -36,7 +35,46 @@
 
 namespace mapnik
 {
+    inline bool operator==(point_symbolizer const& lhs,
+			   point_symbolizer const& rhs)
+    {
+	return (&lhs == &rhs); 
+    }
+    inline bool operator==(line_symbolizer const& lhs,
+			   line_symbolizer const& rhs)
+    {
+	return (&lhs == &rhs); 
+    }
+    inline bool operator==(line_pattern_symbolizer const& lhs,
+			   line_pattern_symbolizer const& rhs)
+    {
+	return (&lhs == &rhs); 
+    }
+
+    inline bool operator==(polygon_symbolizer const& lhs,
+			   polygon_symbolizer const& rhs)
+    {
+	return (&lhs == &rhs); 
+    }
     
+    inline bool operator==(polygon_pattern_symbolizer const& lhs,
+			   polygon_pattern_symbolizer const& rhs)
+    {
+	return (&lhs == &rhs); 
+    }
+    
+    inline bool operator==(raster_symbolizer const& lhs,
+			   raster_symbolizer const& rhs)
+    {
+	return (&lhs == &rhs); 
+    }
+    
+    inline bool operator==(text_symbolizer const& lhs,
+			   text_symbolizer const& rhs)
+    {
+	return (&lhs == &rhs); 
+    }
+    
     typedef boost::variant<point_symbolizer,
 			   line_symbolizer,
 			   line_pattern_symbolizer,
@@ -45,6 +83,7 @@
 			   raster_symbolizer,
 			   text_symbolizer> symbolizer;
     
+        
     typedef std::vector<symbolizer> symbolizers;    
     template <typename FeatureT> class all_filter;
 

Modified: trunk/include/text_symbolizer.hpp
===================================================================
--- trunk/include/text_symbolizer.hpp	2006-02-21 20:17:08 UTC (rev 163)
+++ trunk/include/text_symbolizer.hpp	2006-02-25 11:03:30 UTC (rev 164)
@@ -21,10 +21,6 @@
 #ifndef TEXT_SYMBOLIZER_HPP
 #define TEXT_SYMBOLIZER_HPP
 
-//#include "symbolizer.hpp"
-//#include "fill.hpp"
-//#include "expression.hpp"
-
 namespace mapnik
 {
     enum label_placement_e {

Modified: trunk/src/agg_renderer.cpp
===================================================================
--- trunk/src/agg_renderer.cpp	2006-02-21 20:17:08 UTC (rev 163)
+++ trunk/src/agg_renderer.cpp	2006-02-25 11:03:30 UTC (rev 164)
@@ -90,13 +90,13 @@
     }
     
     template <typename T>
-    void agg_renderer<T>::start_map_processing()
+    void agg_renderer<T>::start_map_processing(Map const& map)
     {
-	std::cout << "start map processing" << std::endl;
+	std::cout << "start map processing bbox=" << map.getCurrentExtent() <<  std::endl;
     }
 
     template <typename T>
-    void agg_renderer<T>::end_map_processing()
+    void agg_renderer<T>::end_map_processing(Map const& )
     {
 	std::cout << "end map processing" << std::endl;
     }
@@ -275,10 +275,16 @@
 	    t_.forward_x(&x);
 	    t_.forward_y(&y);
 	    int w=data.width();
-	    int h=data.height();    
-	    int px=int(ceil(x - 0.5 * w));
-	    int py=int(ceil(y - 0.5 * h));
-	    pixmap_.set_rectangle_alpha(px,py,data);
+	    int h=data.height();
+	    if (detector_.allowed_to_render(Envelope<double>(x - 0.5 * w,
+							     y - 0.5 * h,
+							     x + 0.5 * w,
+							     y + 0.5 * h)))
+	    {
+		int px=int(ceil(x - 0.5 * w));
+		int py=int(ceil(y - 0.5 * h));
+		pixmap_.set_rectangle_alpha(px,py,data);
+	    }
 	}
     }
     
@@ -412,7 +418,7 @@
 		t_.forward_y(&y);
 		
 		face_ptr face = font_manager_.get_face("Bitstream Vera Sans Roman");//TODO
-		
+		//face_ptr face = font_manager_.get_face("Times New Roman Regular");//TODO
 		if (face)
 		{
 		    text_renderer<mapnik::Image32> ren(pixmap_,face);
@@ -420,7 +426,7 @@
 		    ren.set_fill(fill);
 		    ren.set_halo_radius(1);
 		    ren.set_angle(angle);
-		    ren.render(text,x,y);
+		    ren.render(text,x+6,y+6);
 		}
 	    }  
 	}



From jdoyon at berlios.de  Sun Feb 26 22:47:36 2006
From: jdoyon at berlios.de (jdoyon at BerliOS)
Date: Sun, 26 Feb 2006 22:47:36 +0100
Subject: [Mapnik-svn] r165 - in trunk: . agg agg/include agg/src bindings bindings/python bindings/python/mapnik docs include plugins plugins/input plugins/input/postgis plugins/input/raster plugins/input/shape scons scons/scons-local-0.96.1 scons/scons-local-0.96.1/SCons scons/scons-local-0.96.1/SCons/Node scons/scons-local-0.96.1/SCons/Optik scons/scons-local-0.96.1/SCons/Options scons/scons-local-0.96.1/SCons/Platform scons/scons-local-0.96.1/SCons/Scanner scons/scons-local-0.96.1/SCons/Script scons/scons-local-0.96.1/SCons/Sig scons/scons-local-0.96.1/SCons/Tool src utils utils/shapeindex
Message-ID: <200602262147.k1QLlamE006765@sheep.berlios.de>

Author: jdoyon
Date: 2006-02-26 22:47:35 +0100 (Sun, 26 Feb 2006)
New Revision: 165

Modified:
   trunk/
   trunk/INSTALL
   trunk/SConstruct
   trunk/agg/
   trunk/agg/include/
   trunk/agg/src/
   trunk/bindings/
   trunk/bindings/python/
   trunk/bindings/python/mapnik/
   trunk/bindings/python/mapnik_envelope.cpp
   trunk/bindings/python/mapnik_filter.cpp
   trunk/bindings/python/mapnik_image.cpp
   trunk/bindings/python/mapnik_layer.cpp
   trunk/docs/
   trunk/include/
   trunk/plugins/
   trunk/plugins/input/
   trunk/plugins/input/postgis/
   trunk/plugins/input/raster/
   trunk/plugins/input/shape/
   trunk/scons/
   trunk/scons/scons-local-0.96.1/
   trunk/scons/scons-local-0.96.1/SCons/
   trunk/scons/scons-local-0.96.1/SCons/Node/
   trunk/scons/scons-local-0.96.1/SCons/Optik/
   trunk/scons/scons-local-0.96.1/SCons/Options/
   trunk/scons/scons-local-0.96.1/SCons/Platform/
   trunk/scons/scons-local-0.96.1/SCons/Scanner/
   trunk/scons/scons-local-0.96.1/SCons/Script/
   trunk/scons/scons-local-0.96.1/SCons/Sig/
   trunk/scons/scons-local-0.96.1/SCons/Tool/
   trunk/src/
   trunk/src/SConscript
   trunk/utils/
   trunk/utils/shapeindex/
Log:
Reworked all the svn:ignore properties.  They are all set explicitely now, and nothing should be left unacounted for.

Changed SConstruct to use freetype-config.  Updated INSTALL to reflect.

Added a RAM requirement for building in the INSTALL doc.

Fixed some python styling and added some basic docstrings.




Property changes on: trunk
___________________________________________________________________
Name: svn:ignore
   - *.pyc
*.os
*.so
.sconsign

   + .sconf_temp
config.log


Modified: trunk/INSTALL
===================================================================
--- trunk/INSTALL	2006-02-25 11:03:30 UTC (rev 164)
+++ trunk/INSTALL	2006-02-26 21:47:35 UTC (rev 165)
@@ -31,6 +31,7 @@
 
 If your system does NOT have one of these installed, you will need to install the mandatory ones at the very least before proceeding further.  Instructions on how to do this will come with each individual package.
 
+Also, a minimum of 256MB of RAM is recommended for the build process.
 
 Building
 --------
@@ -64,14 +65,10 @@
     default: /usr/lib
     actual: /usr/lib
 
-FREETYPE_INCLUDES: Search path for FreeType include files ( /path/to/FREETYPE_INCLUDES )
-    default: /usr/include
-    actual: /usr/include
+FREETYPE_CONFIG: The path to the freetype-config executable. ( /path/to/FREETYPE_CONFIG )
+    default: /usr/bin/freetype-config
+    actual: /usr/bin/freetype-config
 
-FREETYPE_LIBS: Search path for FreeType library files ( /path/to/FREETYPE_LIBS )
-    default: /usr/lib
-    actual: /usr/lib
-
 PNG_INCLUDES: Search path for libpng include files ( /path/to/PNG_INCLUDES )
     default: /usr/include
     actual: /usr/include
@@ -152,7 +149,7 @@
 Test
 ----
 
-There currently are no easy way to test your setup, other than write some code to generate a map.
+There currently is no easy way to test your setup, other than write some code to generate a map.
 
 One simple thing you can do is try to load the Python module, and make sure it does so without errors:
 

Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2006-02-25 11:03:30 UTC (rev 164)
+++ trunk/SConstruct	2006-02-26 21:47:35 UTC (rev 165)
@@ -24,8 +24,7 @@
 opts.Add('PREFIX', 'The install path "prefix"', '/usr/local')
 opts.Add(PathOption('BOOST_INCLUDES', 'Search path for boost include files', '/usr/include'))
 opts.Add(PathOption('BOOST_LIBS', 'Search path for boost library files', '/usr/lib'))
-opts.Add(PathOption('FREETYPE_INCLUDES', 'Search path for FreeType include files', '/opt/freetype/include/freetype2'))
-opts.Add(PathOption('FREETYPE_LIBS', 'Search path for FreeType library files', '/opt/freetype/lib'))
+opts.Add(PathOption('FREETYPE_CONFIG', 'The path to the freetype-config executable.', '/usr/bin/freetype-config'))
 opts.Add(PathOption('PNG_INCLUDES', 'Search path for libpng include files', '/usr/include'))
 opts.Add(PathOption('PNG_LIBS', 'Search path for libpng include files', '/usr/lib'))
 opts.Add(PathOption('JPEG_INCLUDES', 'Search path for libjpeg include files', '/usr/include'))
@@ -49,21 +48,22 @@
 
 env['CPPPATH'] = ['#agg/include', '#include']
 
-for path in [env['BOOST_INCLUDES'], env['FREETYPE_INCLUDES'], env['PNG_INCLUDES'], env['JPEG_INCLUDES'], env['TIFF_INCLUDES'], env['PGSQL_INCLUDES']]:
+for path in [env['BOOST_INCLUDES'], env['PNG_INCLUDES'], env['JPEG_INCLUDES'], env['TIFF_INCLUDES'], env['PGSQL_INCLUDES']]:
     if path not in env['CPPPATH']: env['CPPPATH'].append(path)
 
 env['LIBPATH'] = ['#agg', '#src']
 
-for path in [env['BOOST_LIBS'], env['FREETYPE_LIBS'], env['PNG_LIBS'], env['JPEG_LIBS'], env['TIFF_LIBS'], env['PGSQL_LIBS']]:
+for path in [env['BOOST_LIBS'], env['PNG_LIBS'], env['JPEG_LIBS'], env['TIFF_LIBS'], env['PGSQL_LIBS']]:
     if path not in env['LIBPATH']: env['LIBPATH'].append(path)
 
+env.ParseConfig(env['FREETYPE_CONFIG'] + ' --libs --cflags')
+
 C_LIBSHEADERS = [
     ['ltdl', 'ltdl.h', True],
     ['png', 'png.h', True],
     ['tiff', 'tiff.h', True],
     ['z', 'zlib.h', True],
-    ['jpeg', ['stdio.h','jpeglib.h'], True],
-    #['freetype', 'ft2build.h', True],
+    ['jpeg', ['stdio.h', 'jpeglib.h'], True],
     ['pq', 'libpq-fe.h', False]
 ]
 


Property changes on: trunk/agg
___________________________________________________________________
Name: svn:ignore
   - *.pyc
*.os
*.so
.sconsign

   + libagg.a
.sconsign



Property changes on: trunk/agg/include
___________________________________________________________________
Name: svn:ignore
   - *.pyc
*.os
*.so
.sconsign

   + .sconsign



Property changes on: trunk/agg/src
___________________________________________________________________
Name: svn:ignore
   - *.pyc
*.os
*.so
.sconsign

   + .sconsign



Property changes on: trunk/bindings
___________________________________________________________________
Name: svn:ignore
   - *.pyc
*.os
*.so
.sconsign



Property changes on: trunk/bindings/python
___________________________________________________________________
Name: svn:ignore
   - *.pyc
*.os
*.so
.sconsign

   + .sconsign
*.os
_mapnik.so



Property changes on: trunk/bindings/python/mapnik
___________________________________________________________________
Name: svn:ignore
   - *.pyc
*.os
*.so
.sconsign

   + *.pyc
paths.py


Modified: trunk/bindings/python/mapnik_envelope.cpp
===================================================================
--- trunk/bindings/python/mapnik_envelope.cpp	2006-02-25 11:03:30 UTC (rev 164)
+++ trunk/bindings/python/mapnik_envelope.cpp	2006-02-26 21:47:35 UTC (rev 165)
@@ -58,7 +58,7 @@
 void export_envelope()
 {
     using namespace boost::python;
-    class_<Envelope<double> >("Envelope",init<double,double,double,double>())
+    class_<Envelope<double> >("Envelope","A spacial envelope (i.e. bounding box) which also defines some basic operators.",init<double,double,double,double>())
         .def(init<>())
 	.def(init<const coord<double,2>&, const coord<double,2>&>())
         .add_property("minx",&Envelope<double>::minx)

Modified: trunk/bindings/python/mapnik_filter.cpp
===================================================================
--- trunk/bindings/python/mapnik_filter.cpp	2006-02-25 11:03:30 UTC (rev 164)
+++ trunk/bindings/python/mapnik_filter.cpp	2006-02-26 21:47:35 UTC (rev 165)
@@ -38,7 +38,7 @@
 void export_filter()
 {
     using namespace boost::python;
-    class_<filter<Feature>,boost::noncopyable>("Filter",no_init)
+    class_<filter<Feature>,boost::noncopyable>("Filter","An expression which allows to select features.",no_init)
 	.def("__str__",&filter<Feature>::to_string);
 	;
     def("filter",&create_filter);

Modified: trunk/bindings/python/mapnik_image.cpp
===================================================================
--- trunk/bindings/python/mapnik_image.cpp	2006-02-25 11:03:30 UTC (rev 164)
+++ trunk/bindings/python/mapnik_image.cpp	2006-02-26 21:47:35 UTC (rev 165)
@@ -32,7 +32,7 @@
 void export_image()
 {
     using namespace boost::python;
-    class_<Image32>("Image",init<int,int>())
+    class_<Image32>("Image","This class represents a 32 bit image.",init<int,int>())
     ;
     def("rawdata",&rawdata);
 }

Modified: trunk/bindings/python/mapnik_layer.cpp
===================================================================
--- trunk/bindings/python/mapnik_layer.cpp	2006-02-25 11:03:30 UTC (rev 164)
+++ trunk/bindings/python/mapnik_layer.cpp	2006-02-26 21:47:35 UTC (rev 165)
@@ -104,7 +104,7 @@
     	.def(vector_indexing_suite<std::vector<std::string>,true >())
     	;
     
-    class_<Layer>("Layer",no_init)
+    class_<Layer>("Layer","A map layer.",no_init)
         .def("name",&Layer::name,return_value_policy<copy_const_reference>())
         .def("params",&Layer::params,return_value_policy<reference_existing_object>())
         .def("envelope",&Layer::envelope)


Property changes on: trunk/docs
___________________________________________________________________
Name: svn:ignore
   - *.pyc
*.os
*.so
.sconsign



Property changes on: trunk/include
___________________________________________________________________
Name: svn:ignore
   - *.pyc
*.os
*.so
.sconsign

   + .sconsign



Property changes on: trunk/plugins
___________________________________________________________________
Name: svn:ignore
   - *.pyc
*.os
*.so
.sconsign



Property changes on: trunk/plugins/input
___________________________________________________________________
Name: svn:ignore
   - *.pyc
*.os
*.so
.sconsign



Property changes on: trunk/plugins/input/postgis
___________________________________________________________________
Name: svn:ignore
   - *.pyc
*.os
*.so
.sconsign

   + .sconsign
*.os
postgis.so



Property changes on: trunk/plugins/input/raster
___________________________________________________________________
Name: svn:ignore
   - *.pyc
*.os
*.so
.sconsign

   + .sconsign
*.os
raster.so



Property changes on: trunk/plugins/input/shape
___________________________________________________________________
Name: svn:ignore
   - *.pyc
*.os
*.so
.sconsign

   + .sconsign
*.os
shape.so



Property changes on: trunk/scons
___________________________________________________________________
Name: svn:ignore
   - *.pyc
*.os
*.so
.sconsign

   + *.pyc



Property changes on: trunk/scons/scons-local-0.96.1
___________________________________________________________________
Name: svn:ignore
   - *.pyc
*.os
*.so
.sconsign

   + *.pyc



Property changes on: trunk/scons/scons-local-0.96.1/SCons
___________________________________________________________________
Name: svn:ignore
   - *.pyc
*.os
*.so
.sconsign

   + *.pyc



Property changes on: trunk/scons/scons-local-0.96.1/SCons/Node
___________________________________________________________________
Name: svn:ignore
   - *.pyc
*.os
*.so
.sconsign

   + *.pyc



Property changes on: trunk/scons/scons-local-0.96.1/SCons/Optik
___________________________________________________________________
Name: svn:ignore
   - *.pyc
*.os
*.so
.sconsign

   + *.pyc



Property changes on: trunk/scons/scons-local-0.96.1/SCons/Options
___________________________________________________________________
Name: svn:ignore
   - *.pyc
*.os
*.so
.sconsign

   + *.pyc



Property changes on: trunk/scons/scons-local-0.96.1/SCons/Platform
___________________________________________________________________
Name: svn:ignore
   - *.pyc
*.os
*.so
.sconsign

   + *.pyc



Property changes on: trunk/scons/scons-local-0.96.1/SCons/Scanner
___________________________________________________________________
Name: svn:ignore
   - *.pyc
*.os
*.so
.sconsign

   + *.pyc



Property changes on: trunk/scons/scons-local-0.96.1/SCons/Script
___________________________________________________________________
Name: svn:ignore
   - *.pyc
*.os
*.so
.sconsign

   + *.pyc



Property changes on: trunk/scons/scons-local-0.96.1/SCons/Sig
___________________________________________________________________
Name: svn:ignore
   - *.pyc
*.os
*.so
.sconsign

   + *.pyc



Property changes on: trunk/scons/scons-local-0.96.1/SCons/Tool
___________________________________________________________________
Name: svn:ignore
   - *.pyc
*.os
*.so
.sconsign

   + *.pyc



Property changes on: trunk/src
___________________________________________________________________
Name: svn:ignore
   - *.pyc
*.os
*.so
.sconsign

   + .sconsign
*.os
libmapnik.so


Modified: trunk/src/SConscript
===================================================================
--- trunk/src/SConscript	2006-02-25 11:03:30 UTC (rev 164)
+++ trunk/src/SConscript	2006-02-26 21:47:35 UTC (rev 165)
@@ -24,7 +24,6 @@
 prefix = env['PREFIX']
 
 libraries = ['agg'] + env['LIBS']
-libraries += ['freetype']
 
 linkflags = '-Wl,-rpath-link,. -Wl,-soname,libmapnik.so'
 


Property changes on: trunk/utils
___________________________________________________________________
Name: svn:ignore
   - *.pyc
*.os
*.so
.sconsign



Property changes on: trunk/utils/shapeindex
___________________________________________________________________
Name: svn:ignore
   - *.pyc
*.os
*.so
.sconsign

   + .sconsign
shapeindex




From jdoyon at berlios.de  Mon Feb 27 00:04:48 2006
From: jdoyon at berlios.de (jdoyon at BerliOS)
Date: Mon, 27 Feb 2006 00:04:48 +0100
Subject: [Mapnik-svn] r166 - trunk/bindings/python
Message-ID: <200602262304.k1QN4mlh016759@sheep.berlios.de>

Author: jdoyon
Date: 2006-02-27 00:04:47 +0100 (Mon, 27 Feb 2006)
New Revision: 166

Modified:
   trunk/bindings/python/mapnik_color.cpp
   trunk/bindings/python/mapnik_filter.cpp
   trunk/bindings/python/mapnik_layer.cpp
Log:
Fixed up some more styling.

color_from_string is now Color
filter is now Filter

and maybe a few more ...



Modified: trunk/bindings/python/mapnik_color.cpp
===================================================================
--- trunk/bindings/python/mapnik_color.cpp	2006-02-26 21:47:35 UTC (rev 165)
+++ trunk/bindings/python/mapnik_color.cpp	2006-02-26 23:04:47 UTC (rev 166)
@@ -53,6 +53,6 @@
 	.def(self == self)
         .def_pickle(color_pickle_suite())
         ;
-    def("color_from_string",&create_from_string);
+    def("Color",&create_from_string);
 }
 

Modified: trunk/bindings/python/mapnik_filter.cpp
===================================================================
--- trunk/bindings/python/mapnik_filter.cpp	2006-02-26 21:47:35 UTC (rev 165)
+++ trunk/bindings/python/mapnik_filter.cpp	2006-02-26 23:04:47 UTC (rev 166)
@@ -41,5 +41,5 @@
     class_<filter<Feature>,boost::noncopyable>("Filter","An expression which allows to select features.",no_init)
 	.def("__str__",&filter<Feature>::to_string);
 	;
-    def("filter",&create_filter);
+    def("Filter",&create_filter);
 }

Modified: trunk/bindings/python/mapnik_layer.cpp
===================================================================
--- trunk/bindings/python/mapnik_layer.cpp	2006-02-26 21:47:35 UTC (rev 165)
+++ trunk/bindings/python/mapnik_layer.cpp	2006-02-26 23:04:47 UTC (rev 166)
@@ -114,5 +114,5 @@
 		      (&Layer::styles,return_value_policy<reference_existing_object>()))
         .def_pickle(layer_pickle_suite())
         ;
-    def("create_layer",&create_layer);
+    def("Layer",&create_layer);
 }



From pavlenko at berlios.de  Mon Feb 27 22:25:27 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Mon, 27 Feb 2006 22:25:27 +0100
Subject: [Mapnik-svn] r167 - in trunk: bindings/python include src
Message-ID: <200602272125.k1RLPRNC024838@sheep.berlios.de>

Author: pavlenko
Date: 2006-02-27 22:25:25 +0100 (Mon, 27 Feb 2006)
New Revision: 167

Added:
   trunk/include/quad_tree.hpp
Modified:
   trunk/bindings/python/mapnik_color.cpp
   trunk/include/agg_renderer.hpp
   trunk/include/font_engine_freetype.hpp
   trunk/include/label_collision_detector.hpp
   trunk/src/agg_renderer.cpp
Log:
added quad_tree implementaion

Modified: trunk/bindings/python/mapnik_color.cpp
===================================================================
--- trunk/bindings/python/mapnik_color.cpp	2006-02-26 23:04:47 UTC (rev 166)
+++ trunk/bindings/python/mapnik_color.cpp	2006-02-27 21:25:25 UTC (rev 167)
@@ -52,7 +52,9 @@
 	.add_property("a",&Color::alpha)
 	.def(self == self)
         .def_pickle(color_pickle_suite())
+	.def("fromString",&create_from_string)
+	.staticmethod("fromString")	
         ;
-    def("Color",&create_from_string);
+    //def("Color",&create_from_string);
 }
 

Modified: trunk/include/agg_renderer.hpp
===================================================================
--- trunk/include/agg_renderer.hpp	2006-02-26 23:04:47 UTC (rev 166)
+++ trunk/include/agg_renderer.hpp	2006-02-27 21:25:25 UTC (rev 167)
@@ -48,7 +48,7 @@
 	T & pixmap_;
 	CoordTransform t_;
 	face_manager<freetype_engine> font_manager_;
-	label_collision_detector detector_;
+	label_collision_detector2 detector_;
     };
 }
 

Modified: trunk/include/font_engine_freetype.hpp
===================================================================
--- trunk/include/font_engine_freetype.hpp	2006-02-26 23:04:47 UTC (rev 166)
+++ trunk/include/font_engine_freetype.hpp	2006-02-27 21:25:25 UTC (rev 167)
@@ -385,7 +385,6 @@
 	    
 		//angle_ = sin ( 0.1 * count++);
 	    }
-	    std::cout << std::endl;
 	}
     private:
     

Modified: trunk/include/label_collision_detector.hpp
===================================================================
--- trunk/include/label_collision_detector.hpp	2006-02-26 23:04:47 UTC (rev 166)
+++ trunk/include/label_collision_detector.hpp	2006-02-27 21:25:25 UTC (rev 167)
@@ -22,7 +22,7 @@
 #if !defined LABEL_COLLISION_DETECTOR
 #define LABEL_COLLISION_DETECTOR
 
-#include "envelope.hpp"
+#include "quad_tree.hpp"
 #include <vector>
 
 namespace mapnik
@@ -34,7 +34,7 @@
     {
 	typedef std::vector<Envelope<double> > label_placements;
 
-	bool allowed_to_render(Envelope<double> const& box)
+	bool has_plasement(Envelope<double> const& box)
 	{
 	    label_placements::const_iterator itr=labels_.begin();
 	    for( ; itr !=labels_.end();++itr)
@@ -51,6 +51,34 @@
 
 	label_placements labels_;
     };
+
+    // quad_tree based label collision detector
+    class label_collision_detector2 : boost::noncopyable
+    {
+	typedef quad_tree<Envelope<double> > tree_t;
+	tree_t tree_;
+    public:
+	
+	explicit label_collision_detector2(Envelope<double> const& extent)
+	    : tree_(extent) {}
+	
+	bool has_placement(Envelope<double> const& box)
+	{
+	    tree_t::query_iterator itr = tree_.query_in_box(box);
+	    tree_t::query_iterator end = tree_.query_end();
+	    
+	    for ( ;itr != end; ++itr)
+	    {
+		if (itr->intersects(box))
+		{
+		    return false;
+		}
+	    }
+	    
+	    tree_.insert(box,box);
+	    return true;
+	}	
+    };
 }
 
 #endif 

Added: trunk/include/quad_tree.hpp
===================================================================
--- trunk/include/quad_tree.hpp	2006-02-26 23:04:47 UTC (rev 166)
+++ trunk/include/quad_tree.hpp	2006-02-27 21:25:25 UTC (rev 167)
@@ -0,0 +1,206 @@
+/* This file is part of Mapnik (c++ mapping toolkit)
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * Mapnik is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+//$Id$
+
+#if !defined QUAD_TREE_HPP
+#define QUAD_TREE_HPP
+
+#include <boost/ptr_container/ptr_vector.hpp>
+#include <boost/noncopyable.hpp>
+#include <vector>
+#include <mapnik/envelope.hpp>
+
+
+namespace mapnik
+{
+    template <typename T>
+    class quad_tree : boost::noncopyable
+    {
+	struct node
+	{
+	    typedef T value_t;
+	    typedef std::vector<T> cont_t;
+	    typedef typename cont_t::iterator iterator;
+	    typedef typename cont_t::const_iterator const_iterator;
+	    Envelope<double> extent_;
+	    cont_t cont_;
+	    node * children_[4];
+
+	    explicit node(Envelope<double> const& ext)
+		: extent_(ext)
+	    {
+		std::memset(children_,0,4*sizeof(node*));
+	    }
+   
+	    Envelope<double> const& extent() const
+	    {
+		return extent_;
+	    }
+	    
+	    iterator begin() 
+	    {
+		return cont_.begin();
+	    }
+	    
+	    const_iterator begin() const 
+	    {
+		return cont_.begin();
+	    }
+	    
+	    iterator end() 
+	    {
+		return cont_.end();
+	    }
+	    
+	    const_iterator end() const 
+	    {
+		return cont_.end();
+	    }
+	    ~node () {}
+	};
+	
+	typedef boost::ptr_vector<node> nodes_t;	
+	typedef typename node::cont_t cont_t;
+	typedef typename cont_t::iterator node_data_iterator;
+	
+	nodes_t nodes_;
+	node * root_;	
+	const double ratio_; 
+	
+    public:
+	typedef typename nodes_t::iterator iterator;
+	typedef typename nodes_t::const_iterator const_iterator;
+	typedef typename boost::ptr_vector<T,boost::view_clone_allocator> result_t;	
+	typedef typename result_t::iterator query_iterator;
+   
+	result_t query_result_;
+	
+	explicit quad_tree(Envelope<double> const& ext,double ratio=0.55) 
+	    : ratio_(ratio)
+	{
+	    nodes_.push_back(new node(ext));
+	    root_ = &nodes_[0];
+	}
+		
+	void insert(T data, Envelope<double> const& box)
+	{
+	    do_insert_data(data,box,root_);
+	}
+        
+	query_iterator query_in_box(Envelope<double> const& box)
+	{
+	    query_result_.clear();
+	    query_node(box,query_result_,root_);
+	    return query_result_.begin();
+	}
+	
+	query_iterator query_end()
+	{
+	    return query_result_.end();
+	}
+
+	iterator begin()
+	{
+	    return nodes_.begin();
+	}
+	
+	const_iterator begin() const
+	{
+	    return nodes_.begin();
+	}
+
+	iterator end()
+	{
+	    return  nodes_.end();
+	}
+	
+	const_iterator end() const
+	{
+	    return  nodes_.end();
+	}
+	
+    private:
+        
+	void query_node(Envelope<double> const& box, result_t & result, node * node_) const
+	{
+	    if (node_)
+	    {
+		Envelope<double> const& node_extent = node_->extent();
+		if (box.intersects(node_extent))
+		{
+		    node_data_iterator i=node_->begin();
+		    node_data_iterator end=node_->end();
+		    while ( i!=end)
+		    {
+			result.push_back(&(*i));
+			++i;
+		    }
+		    for (int k = 0; k < 4; ++k)
+		    {
+		        query_node(box,result,node_->children_[k]);
+		    }
+		}
+	    }
+	}
+	
+	void do_insert_data(T data, Envelope<double> const& box, node * n)
+	{
+	    if (n)
+	    {
+		Envelope<double> const& node_extent = n->extent();
+		Envelope<double> ext[4];
+		split_box(node_extent,ext);		
+		for (int i=0;i<4;++i)
+		{
+		    if (ext[i].contains(box))
+		    {
+			if (!n->children_[i])
+			{
+			    nodes_.push_back(new node(ext[i]));
+			    n->children_[i]=&nodes_.back();
+			}
+			do_insert_data(data,box,n->children_[i]);
+			return;
+		    }
+		}
+		n->cont_.push_back(data);
+	    }
+	}
+	
+	void split_box(Envelope<double> const& node_extent,Envelope<double> * ext)
+	{
+	    coord2d c=node_extent.center();
+
+	    double width=node_extent.width();
+	    double height=node_extent.height();
+	    
+	    double lox=node_extent.minx();
+	    double loy=node_extent.miny();
+	    double hix=node_extent.maxx();
+	    double hiy=node_extent.maxy();
+	    
+	    ext[0]=Envelope<double>(lox,loy,lox + width * ratio_,loy + height * ratio_);
+	    ext[1]=Envelope<double>(hix - width * ratio_,loy,hix,loy + height * ratio_);
+	    ext[2]=Envelope<double>(lox,hiy - height*ratio_,lox + width * ratio_,hiy);
+	    ext[3]=Envelope<double>(hix - width * ratio_,hiy - height*ratio_,hix,hiy);
+	}
+    };    
+} 
+
+#endif

Modified: trunk/src/agg_renderer.cpp
===================================================================
--- trunk/src/agg_renderer.cpp	2006-02-26 23:04:47 UTC (rev 166)
+++ trunk/src/agg_renderer.cpp	2006-02-27 21:25:25 UTC (rev 167)
@@ -82,7 +82,8 @@
     agg_renderer<T>::agg_renderer(Map const& m, T & pixmap)
 	: feature_style_processor<agg_renderer>(m),
 	  pixmap_(pixmap),
-	  t_(m.getWidth(),m.getHeight(),m.getCurrentExtent())
+	  t_(m.getWidth(),m.getHeight(),m.getCurrentExtent()),
+	  detector_(Envelope<double>(0,0,m.getWidth(),m.getHeight()))
     {
 	Color const& bg=m.getBackground();
 	pixmap_.setBackground(bg);
@@ -276,7 +277,7 @@
 	    t_.forward_y(&y);
 	    int w=data.width();
 	    int h=data.height();
-	    if (detector_.allowed_to_render(Envelope<double>(x - 0.5 * w,
+	    if (detector_.has_placement(Envelope<double>(x - 0.5 * w,
 							     y - 0.5 * h,
 							     x + 0.5 * w,
 							     y + 0.5 * h)))



From pavlenko at berlios.de  Mon Feb 27 22:57:10 2006
From: pavlenko at berlios.de (pavlenko at BerliOS)
Date: Mon, 27 Feb 2006 22:57:10 +0100
Subject: [Mapnik-svn] r168 - in trunk: bindings/python bindings/python/mapnik include
Message-ID: <200602272157.k1RLvAGk029486@sheep.berlios.de>

Author: pavlenko
Date: 2006-02-27 22:57:08 +0100 (Mon, 27 Feb 2006)
New Revision: 168

Modified:
   trunk/bindings/python/mapnik/__init__.py
   trunk/bindings/python/mapnik_color.cpp
   trunk/include/color.hpp
Log:
1.added to_string method to Color
2.added factory methods to python Color

use factory methods 


Modified: trunk/bindings/python/mapnik/__init__.py
===================================================================
--- trunk/bindings/python/mapnik/__init__.py	2006-02-27 21:25:25 UTC (rev 167)
+++ trunk/bindings/python/mapnik/__init__.py	2006-02-27 21:57:08 UTC (rev 168)
@@ -49,11 +49,6 @@
         return 'Envelope(%s,%s,%s,%s)' % \
                (self.minx,self.miny,self.maxx,self.maxy)
 
-class _Color(Color,_injector):
-    def __repr__(self):
-        return 'Color(%s,%s,%s,%s)' % \
-               (self.r,self.g,self.b,self.a)
-
 #register datasources
 from mapnik import DatasourceCache
 DatasourceCache.instance().register_datasources('%s' % inputpluginspath)

Modified: trunk/bindings/python/mapnik_color.cpp
===================================================================
--- trunk/bindings/python/mapnik_color.cpp	2006-02-27 21:25:25 UTC (rev 167)
+++ trunk/bindings/python/mapnik_color.cpp	2006-02-27 21:57:08 UTC (rev 168)
@@ -41,20 +41,31 @@
     return color_factory::from_string(str);
 }
 
+Color create_from_rgb(unsigned r, unsigned g,unsigned b)
+{
+    return Color(r,g,b);
+}
+
+Color create_from_rgba(unsigned r, unsigned g,unsigned b,unsigned a)
+{
+    return Color(r,g,b,a);
+}
+
 void export_color () 
 {
     using namespace boost::python;
     class_<Color>("Color",init<>())
-        .def(init<int,int,int,boost::python::optional<int> >())
         .add_property("r",&Color::red,&Color::set_red)
         .add_property("g",&Color::green,&Color::set_green)
         .add_property("b",&Color::blue,&Color::set_blue)
 	.add_property("a",&Color::alpha)
 	.def(self == self)
         .def_pickle(color_pickle_suite())
-	.def("fromString",&create_from_string)
-	.staticmethod("fromString")	
-        ;
-    //def("Color",&create_from_string);
+	.def("__str__",&Color::to_string)
+	;
+    
+    def("Color",&create_from_string);
+    def("Color",&create_from_rgba);
+    def("Color",&create_from_rgb);
 }
 

Modified: trunk/include/color.hpp
===================================================================
--- trunk/include/color.hpp	2006-02-27 21:25:25 UTC (rev 167)
+++ trunk/include/color.hpp	2006-02-27 21:57:08 UTC (rev 168)
@@ -21,6 +21,8 @@
 #ifndef COLOR_HPP
 #define COLOR_HPP
 
+#include <sstream>
+
 namespace mapnik {
 
     class Color
@@ -91,6 +93,13 @@
 	{
 	    return rgba_ == other.rgba_;
 	}
+
+	inline std::string to_string() const
+	{
+	    std::stringstream ss;
+	    ss << "rgb (" << red() << ","  << green() << ","  << blue() <<")";
+	    return ss.str();
+	} 
     };    
 }
 



