From pavlenko at mail.berlios.de  Tue Oct  3 10:37:35 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Tue, 3 Oct 2006 10:37:35 +0200
Subject: [Mapnik-svn] r302 - trunk
Message-ID: <200610030837.k938bZNq019504@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-03 10:37:34 +0200 (Tue, 03 Oct 2006)
New Revision: 302

Modified:
   trunk/SConstruct
Log:
Apparently, we need this check on some systems (??)



Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2006-09-17 19:45:01 UTC (rev 301)
+++ trunk/SConstruct	2006-10-03 08:37:34 UTC (rev 302)
@@ -73,6 +73,7 @@
 env.ParseConfig(env['FREETYPE_CONFIG'] + ' --libs --cflags')
 
 C_LIBSHEADERS = [
+    ['m', 'math.h', True],
     ['ltdl', 'ltdl.h', True],
     ['png', 'png.h', True],
     ['tiff', 'tiff.h', True],



From pavlenko at mail.berlios.de  Tue Oct  3 10:39:46 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Tue, 3 Oct 2006 10:39:46 +0200
Subject: [Mapnik-svn] r303 - in trunk: include src
Message-ID: <200610030839.k938dkAI019581@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-03 10:39:43 +0200 (Tue, 03 Oct 2006)
New Revision: 303

Added:
   trunk/include/load_map.hpp
   trunk/include/save_map.hpp
   trunk/src/load_map.cpp
   trunk/src/save_map.cpp
Log:
added save/load functionality based on boost::property_tree (aka ElementTree in c++)



Added: trunk/include/load_map.hpp
===================================================================
--- trunk/include/load_map.hpp	2006-10-03 08:37:34 UTC (rev 302)
+++ trunk/include/load_map.hpp	2006-10-03 08:39:43 UTC (rev 303)
@@ -0,0 +1,35 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+// $Id$
+
+#ifndef MAP_LOADER_HPP
+#define MAP_LOADER_HPP
+
+#include <string>
+#include "map.hpp"
+
+namespace mapnik
+{
+    void load_map(Map & map, std::string const& filename);
+}
+
+#endif // LOAD_MAP_HPP

Added: trunk/include/save_map.hpp
===================================================================
--- trunk/include/save_map.hpp	2006-10-03 08:37:34 UTC (rev 302)
+++ trunk/include/save_map.hpp	2006-10-03 08:39:43 UTC (rev 303)
@@ -0,0 +1,35 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+// $Id$
+
+#ifndef SAVE_MAP_HPP
+#define SAVE_MAP_HPP
+
+#include <string>
+#include "map.hpp"
+
+namespace mapnik
+{
+    void save_map(Map const& map, std::string const& filename);
+}
+
+#endif // SAVE_MAP_HPP

Added: trunk/src/load_map.cpp
===================================================================
--- trunk/src/load_map.cpp	2006-10-03 08:37:34 UTC (rev 302)
+++ trunk/src/load_map.cpp	2006-10-03 08:39:43 UTC (rev 303)
@@ -0,0 +1,296 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+
+#include <iostream>
+
+#include <boost/foreach.hpp>
+#include <boost/optional.hpp>
+#include <boost/algorithm/string.hpp>
+#include <boost/lexical_cast.hpp>
+#include <boost/tokenizer.hpp>
+#include <boost/property_tree/ptree.hpp>
+#include <boost/property_tree/xml_parser.hpp>
+
+#include "color.hpp"
+#include "color_factory.hpp"
+#include "filter_factory.hpp"
+#include "layer.hpp"
+#include "datasource_cache.hpp"
+#include "load_map.hpp"
+
+namespace mapnik 
+{
+    void load_map(Map & map, std::string const& filename)
+    {
+        using boost::property_tree::ptree;
+        ptree pt;
+        
+        read_xml(filename,pt);
+        
+        boost::optional<std::string> bgcolor = 
+            pt.get_optional<std::string>("Map.<xmlattr>.bgcolor");
+        if ( bgcolor)
+        {
+            Color bg = color_factory::from_string(bgcolor->c_str());
+            map.setBackground(bg);
+        }
+        
+        BOOST_FOREACH (ptree::value_type & v, pt.get_child("Map"))
+        {
+            if (v.first == "Style")
+            {
+                std::string name = v.second.get<std::string>("<xmlattr>.name");
+                feature_type_style style;
+                
+                BOOST_FOREACH(ptree::value_type & rule_tag, v.second)
+                {
+                    if (rule_tag.first == "Rule")
+                    {
+                        std::string name = 
+                            rule_tag.second.get<std::string>("<xmlattr>.name","");
+                        std::string title = 
+                            rule_tag.second.get<std::string>("<xmlattr>.title","");
+                        rule_type rule(name,title);
+
+                        boost::optional<std::string> filter_expr = 
+                            rule_tag.second.get_optional<std::string>("Filter");
+                        
+                        if (filter_expr)
+                        {
+                            rule.set_filter(create_filter(*filter_expr));
+                        }
+                        
+                        boost::optional<double> min_scale = 
+                            rule_tag.second.get_optional<double>("MinScaleDenominator");
+                        if (min_scale)
+                        {
+                            rule.set_min_scale(*min_scale);
+                        }
+                        
+                        boost::optional<double> max_scale = 
+                            rule_tag.second.get_optional<double>("MaxScaleDenominator");
+                        if (max_scale) 
+                        {
+                            rule.set_max_scale(*max_scale);   
+                        }    
+                        
+                        BOOST_FOREACH(ptree::value_type & sym, rule_tag.second)
+                        {
+                            if ( sym.first == "PointSymbolizer")
+                            {
+                                std::cout << sym.first << "\n";
+                            } 
+                            else  if ( sym.first == "LineSymbolizer")
+                            {
+                                stroke strk;
+                                BOOST_FOREACH (ptree::value_type & css, sym.second)
+                                {
+                                    std::string css_name  = 
+                                        css.second.get<std::string>("<xmlattr>.name");
+                                    std::string data = css.second.data();
+                                    if (css_name == "stroke")
+                                    {
+                                        Color c = color_factory::from_string(css.second.data().c_str());
+                                        strk.set_color(c);
+                                    }
+                                    else if (css_name == "stroke-width")
+                                    {
+                                        try 
+                                        {
+                                            float width = lexical_cast<float>(data);
+                                            strk.set_width(width);
+                                        }
+                                        catch (bad_lexical_cast & ex)
+                                        {
+                                            std::clog << ex.what() << "\n";
+                                        }
+                                    }
+                                    else if (css_name == "stroke-opacity")
+                                    {
+                                        try 
+                                        {
+                                            float opacity = lexical_cast<float>(data);
+                                            strk.set_opacity(opacity);
+                                        }
+                                        catch (bad_lexical_cast & ex)
+                                        {
+                                            std::clog << ex.what() << "\n";
+                                        }
+                                    }
+                                    else if (css_name == "stroke-linejoin")
+                                    {
+                                         if ("miter" == data)
+                                         {
+                                             strk.set_line_join(mapnik::MITER_JOIN);
+                                         }
+                                         else if ("round" == data)
+                                         {
+                                             strk.set_line_join(mapnik::ROUND_JOIN);
+                                         }
+                                         else if ("bevel" == data)
+                                         {
+                                             strk.set_line_join(mapnik::BEVEL_JOIN);
+                                         }
+                                    }
+                                    else if (css_name == "stroke-linecap")
+                                    {
+                                        if ("round" == data)
+                                        {
+                                            strk.set_line_cap(mapnik::ROUND_CAP);
+                                        }
+                                        else if ("butt" == data)
+                                        {
+                                            strk.set_line_cap(mapnik::BUTT_CAP);
+                                        }
+                                        else if ("square" == data)
+                                        {
+                                            strk.set_line_cap(mapnik::SQUARE_CAP);
+                                        }
+                                    }
+                                    else if (css_name == "stroke-dasharray")
+                                    {
+                                        tokenizer<> tok (data);
+                                        std::vector<float> dash_array;
+                                        for (tokenizer<>::iterator itr = tok.begin(); itr != tok.end(); ++itr)
+                                        {
+                                            try 
+                                            {
+                                                float f = boost::lexical_cast<float>(*itr);
+                                                dash_array.push_back(f);
+                                            }
+                                            catch ( boost::bad_lexical_cast & ex)
+                                            {
+                                                std::clog << ex.what() << "\n";
+                                            }
+                                        }
+                                        if (dash_array.size())
+                                        {
+                                            size_t size = dash_array.size();
+                                            if ( size % 2) 
+                                            { 
+                                                for (size_t i=0; i < size ;++i)
+                                                {
+                                                    dash_array.push_back(dash_array[i]);
+                                                }
+                                            }
+                                            std::vector<float>::const_iterator pos = dash_array.begin();
+                                            while (pos != dash_array.end())
+                                            {
+                                                strk.add_dash(*pos,*(pos + 1));
+                                                pos +=2;
+                                            }
+                                        }
+                                    }
+                                }
+                                rule.append(line_symbolizer(strk));
+                            } 
+                            else if ( sym.first == "PolygonSymbolizer")
+                            {
+                                polygon_symbolizer poly_sym;
+                                BOOST_FOREACH (ptree::value_type & css, sym.second)
+                                {
+                                    std::string css_name  = 
+                                        css.second.get<std::string>("<xmlattr>.name");
+                                    std::string data = css.second.data();
+                                    if (css_name == "fill")
+                                    {
+                                        Color c = color_factory::from_string(css.second.data().c_str());
+                                        poly_sym.set_fill(c);
+                                    }
+                                    else if (css_name == "fill-opacity")
+                                    {
+                                        try 
+                                        {
+                                            float opacity = lexical_cast<float>(data);
+                                            poly_sym.set_opacity(opacity);
+                                        }
+                                        catch (bad_lexical_cast & ex)
+                                        {
+                                            std::clog << ex.what() << "\n";
+                                        }
+                                    }
+                                }
+                                rule.append(poly_sym);
+                            }
+                            else if ( sym.first == "TextSymbolizer")
+                            {
+                                std::cout << sym.first << "\n";
+                            } 
+                            else if ( sym.first == "RasterSymbolizer")
+                            {
+                                rule.append(raster_symbolizer());
+                            } 
+                        } 
+                        
+                        style.add_rule(rule);
+                    }
+                }
+                
+                map.insert_style(name, style);
+                
+            }
+            else if (v.first == "Layer")
+            {
+                
+                std::string name = v.second.get<std::string>("<xmlattr>.name","");
+                Layer lyr(name);
+                
+                boost::optional<std::string> status = 
+                    v.second.get<std::string>("<xmlattr>.status");
+                
+                if (status && *status == "off")
+                {
+                    lyr.setActive(false);
+                }
+                
+                
+                BOOST_FOREACH (ptree::value_type & child, v.second)
+                {
+                    if (child.first == "StyleName")
+                    {
+                        lyr.add_style(child.second.data());
+                    }
+                    else if (child.first == "Datasource")
+                    {
+                        parameters params;
+                        BOOST_FOREACH (ptree::value_type & param_tag, child.second)
+                        {
+
+                            if (param_tag.first == "Parameter")
+                            {
+                                std::string name = param_tag.second.get<std::string>("<xmlattr>.name");
+                                std::string value = param_tag.second.data();
+                                std::clog << "name = " << name << " value = " << value << "\n";
+                                params[name] = value; 
+                            }
+                        }
+                        //now we're ready to create datasource 
+                        boost::shared_ptr<datasource> ds = datasource_cache::instance()->create(params);
+                        lyr.set_datasource(ds);
+                    }
+                }
+                map.addLayer(lyr);
+            }
+        }
+    }   
+}

Added: trunk/src/save_map.cpp
===================================================================
--- trunk/src/save_map.cpp	2006-10-03 08:37:34 UTC (rev 302)
+++ trunk/src/save_map.cpp	2006-10-03 08:39:43 UTC (rev 303)
@@ -0,0 +1,50 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+
+#include <iostream>
+
+#include <boost/foreach.hpp>
+//#include <boost/optional.hpp>
+#include <boost/algorithm/string.hpp>
+#include <boost/lexical_cast.hpp>
+#include <boost/tokenizer.hpp>
+#include <boost/property_tree/ptree.hpp>
+#include <boost/property_tree/xml_parser.hpp>
+
+//#include "color.hpp"
+//#include "color_factory.hpp"
+//#include "filter_factory.hpp"
+//#include "layer.hpp"
+//#include "datasource_cache.hpp"
+//#include "save_map.hpp"
+
+namespace mapnik 
+{
+    void save_map(Map & map, std::string const& filename)
+    {
+        using boost::property_tree::ptree;
+        ptree pt;
+        // TODO
+        write_xml(filename,pt);
+    }
+}



From pavlenko at mail.berlios.de  Tue Oct  3 10:44:11 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Tue, 3 Oct 2006 10:44:11 +0200
Subject: [Mapnik-svn] r304 - in trunk: bindings/python demo/c++ demo/python
	include src
Message-ID: <200610030844.k938iB3X019824@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-03 10:44:04 +0200 (Tue, 03 Oct 2006)
New Revision: 304

Added:
   trunk/src/filter_factory.cpp
Removed:
   trunk/include/mapnik.hpp
   trunk/src/mapnik.cpp
Modified:
   trunk/bindings/python/mapnik_datasource_cache.cpp
   trunk/bindings/python/mapnik_envelope.cpp
   trunk/bindings/python/mapnik_filter.cpp
   trunk/bindings/python/mapnik_layer.cpp
   trunk/bindings/python/mapnik_python.cpp
   trunk/bindings/python/mapnik_style.cpp
   trunk/demo/c++/rundemo.cpp
   trunk/demo/python/rundemo.py
   trunk/include/color_factory.hpp
   trunk/include/filter_factory.hpp
   trunk/include/filter_parser.hpp
   trunk/include/layer.hpp
   trunk/include/map.hpp
   trunk/src/SConscript
   trunk/src/datasource_cache.cpp
   trunk/src/layer.cpp
   trunk/src/map.cpp
Log:
1. datasource is now a property of Layer object.
2. modified python/c++ demos to reflect the above.
3. removed large 'blobby' mapnik.hpp (compilation times!!!)
  


Modified: trunk/bindings/python/mapnik_datasource_cache.cpp
===================================================================
--- trunk/bindings/python/mapnik_datasource_cache.cpp	2006-10-03 08:39:43 UTC (rev 303)
+++ trunk/bindings/python/mapnik_datasource_cache.cpp	2006-10-03 08:44:04 UTC (rev 304)
@@ -33,15 +33,15 @@
     using namespace boost::python;
     class_<singleton<datasource_cache,CreateStatic>,boost::noncopyable>("Singleton",no_init)
         .def("instance",&singleton<datasource_cache,CreateStatic>::instance,
-	     return_value_policy<reference_existing_object>())
+             return_value_policy<reference_existing_object>())
         .staticmethod("instance")
         ;
-
+    
     class_<datasource_cache,bases<singleton<datasource_cache,CreateStatic> >,
         boost::noncopyable>("DatasourceCache",no_init)
         .def("create",&datasource_cache::create)
         .staticmethod("create")
-	.def("register_datasources",&datasource_cache::register_datasources)
-	.staticmethod("register_datasources")
+        .def("register_datasources",&datasource_cache::register_datasources)
+        .staticmethod("register_datasources")
         ;
 }

Modified: trunk/bindings/python/mapnik_envelope.cpp
===================================================================
--- trunk/bindings/python/mapnik_envelope.cpp	2006-10-03 08:39:43 UTC (rev 303)
+++ trunk/bindings/python/mapnik_envelope.cpp	2006-10-03 08:44:04 UTC (rev 304)
@@ -60,29 +60,32 @@
 void export_envelope()
 {
     using namespace boost::python;
-    class_<Envelope<double> >("Envelope","A spacial envelope (i.e. bounding box) which also defines some basic operators.",init<double,double,double,double>())
+    class_<Envelope<double> >("Envelope",
+                              "A spacial envelope (i.e. bounding box) " 
+                              "which also defines some basic operators." ,
+                              init<double,double,double,double>())
         .def(init<>())
-	.def(init<const coord<double,2>&, const coord<double,2>&>())
+        .def(init<const coord<double,2>&, const coord<double,2>&>())
         .add_property("minx",&Envelope<double>::minx, "X coordinate for the lower left corner")
         .add_property("miny",&Envelope<double>::miny, "Y coordinate for the lower left corner")
         .add_property("maxx",&Envelope<double>::maxx, "X coordinate for the upper right corner")
         .add_property("maxy",&Envelope<double>::maxy, "Y coordinate for the upper right corner")
         .def("center",&Envelope<double>::center)
-	.def("center",&Envelope<double>::re_center)
-	.def("width",width_p1)
-	.def("width",width_p2)
-	.def("height",height_p1)
-	.def("height",height_p2)
-	.def("expand_to_include",expand_to_include_p1)
-	.def("expand_to_include",expand_to_include_p2)
-	.def("expand_to_include",expand_to_include_p3)
-	.def("contains",contains_p1)
-	.def("contains",contains_p2)
-	.def("contains",contains_p3)
-	.def("intersects",intersects_p1)
-	.def("intersects",intersects_p2)
-	.def("intersects",intersects_p3)
-	.def(self == self)
+        .def("center",&Envelope<double>::re_center)
+        .def("width",width_p1)
+        .def("width",width_p2)
+        .def("height",height_p1)
+        .def("height",height_p2)
+        .def("expand_to_include",expand_to_include_p1)
+        .def("expand_to_include",expand_to_include_p2)
+        .def("expand_to_include",expand_to_include_p3)
+        .def("contains",contains_p1)
+        .def("contains",contains_p2)
+        .def("contains",contains_p3)
+        .def("intersects",intersects_p1)
+        .def("intersects",intersects_p2)
+        .def("intersects",intersects_p3)
+        .def(self == self)
         .def_pickle(envelope_pickle_suite())
         ;
 }

Modified: trunk/bindings/python/mapnik_filter.cpp
===================================================================
--- trunk/bindings/python/mapnik_filter.cpp	2006-10-03 08:39:43 UTC (rev 303)
+++ trunk/bindings/python/mapnik_filter.cpp	2006-10-03 08:44:04 UTC (rev 304)
@@ -28,7 +28,6 @@
 #include <regex_filter.hpp>
 #include <filter.hpp>
 #include <filter_factory.hpp>
-#include <mapnik.hpp>
 
 using mapnik::filter;
 using mapnik::filter_ptr;

Modified: trunk/bindings/python/mapnik_layer.cpp
===================================================================
--- trunk/bindings/python/mapnik_layer.cpp	2006-10-03 08:39:43 UTC (rev 303)
+++ trunk/bindings/python/mapnik_layer.cpp	2006-10-03 08:44:04 UTC (rev 304)
@@ -30,76 +30,6 @@
 using mapnik::Layer;
 using mapnik::parameters;
 
-struct layer_pickle_suite : boost::python::pickle_suite
-{
-    
-    static boost::python::tuple
-    getinitargs(const Layer& l)
-    {    
-	using namespace boost::python;
-        return boost::python::make_tuple(l.params());
-    }
-    static boost::python::tuple
-    getstate(const Layer& l)
-    {
-	using namespace boost::python;
-	
-	std::vector<std::string> const& styles=l.styles();
-	std::vector<std::string>::const_iterator itr=styles.begin();
-	boost::python::list py_styles;
-        
-	while (itr!=styles.end())
-	{
-	    py_styles.append(*itr++);
-	}
-	
-	return boost::python::make_tuple(l.getMinZoom(),
-			  l.getMaxZoom(),
-			  py_styles);
-    }
-
-    static void
-    setstate (Layer& l, boost::python::tuple state)
-    {
-	using namespace boost::python;
-	if (len(state) != 3)
-	{
-	    PyErr_SetObject(PyExc_ValueError,
-			    ("expected 3-item tuple in call to __setstate__; got %s"
-			     % state).ptr()
-			    );
-	    throw_error_already_set();
-	}
-
-	l.setMinZoom(extract<double>(state[0]));
-	l.setMaxZoom(extract<double>(state[1]));
-
-	boost::python::list styles=extract<boost::python::list>(state[2]);
-	for (int i=0;i<len(styles);++i)
-	{
-	    l.add_style(extract<std::string>(styles[i]));
-	}
-    }
-};
-
-namespace  
-{
-    //user-friendly wrapper that uses Python dictionary
-    using namespace boost::python;
-    Layer create_layer(const dict& d)
-    {
-	parameters params;
-	boost::python::list keys=d.keys();
-	for (int i=0;i<len(keys);++i)
-	{
-	    std::string key=extract<std::string>(keys[i]);
-            std::string value=extract<std::string>(d[key]);
-	    params[key] = value;
-	}
-	return Layer(params);
-    }
-}
-
 void export_layer()
 {
     using namespace boost::python;
@@ -107,17 +37,42 @@
     	.def(vector_indexing_suite<std::vector<std::string>,true >())
     	;
     
-    class_<Layer>("Layer","A map layer.",no_init)
-        .def("name",&Layer::name,return_value_policy<copy_const_reference>(), "Return the name of the layer.")
-        .def("title",&Layer::title,return_value_policy<copy_const_reference>(), "Return the title of the layer.")
-        .def("abstract",&Layer::abstract,return_value_policy<copy_const_reference>(), "Return the abstract of the layer.")
-        .def("params",&Layer::params,return_value_policy<reference_existing_object>(), "The configuration parameters of the layer.  These vary depending on the type of data source.")
-        .def("envelope",&Layer::envelope, "Return the geographic envelope/bounding box of the data in the layer.")
-	.add_property("minzoom",&Layer::getMinZoom,&Layer::setMinZoom)
-	.add_property("maxzoom",&Layer::getMaxZoom,&Layer::setMaxZoom)
-	.add_property("styles",make_function
-		      (&Layer::styles,return_value_policy<reference_existing_object>()))
-        .def_pickle(layer_pickle_suite())
+    class_<Layer>("Layer","A map layer.", init<std::string const&>())
+        .add_property("name", 
+                      make_function(&Layer::name, return_value_policy<reference_existing_object>()),
+                      &Layer::set_name,
+                      "Get/Set the name of the layer.")
+        
+        .add_property("title",
+                      make_function(&Layer::title, return_value_policy<reference_existing_object>()),
+                      &Layer::set_title,
+                      "Get/Set the title of the layer.")
+ 
+        .add_property("abstract", 
+                      make_function(&Layer::abstract,return_value_policy<reference_existing_object>()),
+                      &Layer::set_abstract,
+                      "Get/Set the abstract of the layer.")
+        
+        .add_property("minzoom",
+                      &Layer::getMinZoom,
+                      &Layer::setMinZoom)
+        
+        .add_property("maxzoom",
+                      &Layer::getMaxZoom,
+                      &Layer::setMaxZoom)
+        
+        .add_property("styles",
+                      make_function(&Layer::styles,
+                                    return_value_policy<reference_existing_object>()))
+
+        .add_property("datasource",
+                      &Layer::datasource,
+                      &Layer::set_datasource,
+                      "The datasource attached to this layer")
+        
+        .def("envelope",&Layer::envelope, 
+             "Return the geographic envelope/bounding box "
+             "of the data in the layer.")
+        
         ;
-    def("CreateLayer",&create_layer);
 }

Modified: trunk/bindings/python/mapnik_python.cpp
===================================================================
--- trunk/bindings/python/mapnik_python.cpp	2006-10-03 08:39:43 UTC (rev 303)
+++ trunk/bindings/python/mapnik_python.cpp	2006-10-03 08:44:04 UTC (rev 304)
@@ -25,8 +25,6 @@
 #include <boost/get_pointer.hpp>
 #include <boost/python/detail/api_placeholder.hpp>
 
-//#include <mapnik.hpp>
-
 void export_color();
 void export_layer();
 void export_parameters();
@@ -49,12 +47,10 @@
 void export_text_symbolizer();
 void export_font_engine();
 
-//using namespace mapnik;
 #include <map.hpp>
 #include <agg_renderer.hpp>
 #include <graphics.hpp>
-//#include <filter.hpp>
-//#include <coord.hpp>
+#include <datasource_cache.hpp>
 
 void render_to_file(const mapnik::Map& map,
                     const std::string& file,
@@ -72,6 +68,25 @@
     ren.apply();
 }
 
+namespace  
+{
+    //user-friendly wrapper that uses Python dictionary
+    using namespace boost::python;
+    boost::shared_ptr<mapnik::datasource> create_datasource(const dict& d)
+    {
+        mapnik::parameters params;
+        boost::python::list keys=d.keys();
+        for (int i=0; i<len(keys); ++i)
+        {
+            std::string key=extract<std::string>(keys[i]);
+            std::string value=extract<std::string>(d[key]);
+            params[key] = value;
+        }
+        
+        return mapnik::datasource_cache::create(params);
+    }
+}
+
 BOOST_PYTHON_MODULE(_mapnik)
 {
     using namespace boost::python;
@@ -87,12 +102,17 @@
       ;
     
     class_<datasource,boost::shared_ptr<datasource>,
-      boost::noncopyable>("Datasource",no_init)
-      .def("envelope",&datasource::envelope,
-	   return_value_policy<reference_existing_object>())
-      .def("features",&datasource::features)
-      ;
+        boost::noncopyable>("Datasource",no_init)
+        .def("envelope",&datasource::envelope,
+             return_value_policy<reference_existing_object>())
+        .def("features",&datasource::features)
+        .def("params",&datasource::params,return_value_policy<reference_existing_object>(), 
+             "The configuration parameters of the data source. "  
+             "These vary depending on the type of data source.")
+        ;
     
+    def("CreateDatasource",&create_datasource);
+    
     export_parameters();
     export_color(); 
     export_envelope();   
@@ -111,13 +131,14 @@
     export_raster_symbolizer();
     export_text_symbolizer();
     export_font_engine();
+    
     class_<coord<double,2> >("Coord",init<double,double>())
         .def_readwrite("x", &coord<double,2>::x)
         .def_readwrite("y", &coord<double,2>::y)
         ;
-
+    
     export_map();
-  
+    
     def("render_to_file",&render_to_file);
     def("render",&render);
     register_ptr_to_python<filter_ptr>();

Modified: trunk/bindings/python/mapnik_style.cpp
===================================================================
--- trunk/bindings/python/mapnik_style.cpp	2006-10-03 08:39:43 UTC (rev 303)
+++ trunk/bindings/python/mapnik_style.cpp	2006-10-03 08:44:04 UTC (rev 304)
@@ -34,13 +34,13 @@
     using mapnik::rules;
 
     class_<rules>("Rules",init<>("default ctor"))
-	.def(vector_indexing_suite<rules>())
-	;
+        .def(vector_indexing_suite<rules>())
+        ;
     class_<feature_type_style>("Style",init<>("default style constructor"))
-	.add_property("rules",make_function
-		      (&feature_type_style::get_rules,
-               return_value_policy<reference_existing_object>()))
-	;
+        .add_property("rules",make_function
+                      (&feature_type_style::get_rules,
+                       return_value_policy<reference_existing_object>()))
+        ;
     
 }
 

Modified: trunk/demo/c++/rundemo.cpp
===================================================================
--- trunk/demo/c++/rundemo.cpp	2006-10-03 08:39:43 UTC (rev 303)
+++ trunk/demo/c++/rundemo.cpp	2006-10-03 08:44:04 UTC (rev 304)
@@ -1,5 +1,13 @@
 
-#include <mapnik.hpp>
+#include <map.hpp>
+
+#include <datasource_cache.hpp>
+#include <font_engine_freetype.hpp>
+#include <agg_renderer.hpp>
+#include <filter_factory.hpp>
+#include <color_factory.hpp>
+#include <image_util.hpp>
+
 #include <iostream>
 
 using namespace mapnik;
@@ -133,11 +141,11 @@
     // Provincial  polygons
     {
         parameters p;
-        p["name"]="Provinces";
         p["type"]="shape";
         p["file"]="../data/boundaries";
         
-        Layer lyr(p); 
+        Layer lyr("Provinces"); 
+        lyr.set_datasource(datasource_cache::instance()->create(p));
         lyr.add_style("provinces");    
         m.addLayer(lyr);
     }
@@ -145,21 +153,21 @@
     // Drainage
     {
         parameters p;
-        p["name"]="Quebec Hydrography";
         p["type"]="shape";
         p["file"]="../data/qcdrainage";
-        
-        Layer lyr(p); 
+        Layer lyr("Quebec Hydrography");
+        lyr.set_datasource(datasource_cache::instance()->create(p));
         lyr.add_style("drainage");    
         m.addLayer(lyr);
     }
+    
     {
         parameters p;
-        p["name"]="Ontario Hydrography";
         p["type"]="shape";
         p["file"]="../data/ontdrainage";
         
-        Layer lyr(p); 
+        Layer lyr("Ontario Hydrography"); 
+        lyr.set_datasource(datasource_cache::instance()->create(p));
         lyr.add_style("drainage");    
         m.addLayer(lyr);
     }
@@ -167,11 +175,10 @@
     // Provincial boundaries
     {
         parameters p;
-        p["name"]="Provincial borders";
         p["type"]="shape";
         p["file"]="../data/boundaries_l";
-        
-        Layer lyr(p); 
+        Layer lyr("Provincial borders"); 
+        lyr.set_datasource(datasource_cache::instance()->create(p));
         lyr.add_style("provlines");    
         m.addLayer(lyr);
     }
@@ -179,29 +186,29 @@
     // Roads
     {
         parameters p;
-        p["name"]="Roads";
         p["type"]="shape";
-        p["file"]="../data/roads";
-        
-        Layer lyr(p); 
+        p["file"]="../data/roads";        
+        Layer lyr("Roads"); 
+        lyr.set_datasource(datasource_cache::instance()->create(p));
         lyr.add_style("smallroads");
         lyr.add_style("road-border");
         lyr.add_style("road-fill");
         lyr.add_style("highway-border");
         lyr.add_style("highway-fill");
+
         m.addLayer(lyr);        
     }
     // popplaces
     {
         parameters p;
-        p["name"]="Populated Places";
         p["type"]="shape";
         p["file"]="../data/popplaces";
-        
-        Layer lyr(p); 
+        Layer lyr("Populated Places");
+        lyr.set_datasource(datasource_cache::instance()->create(p));
         lyr.add_style("popplaces");    
         m.addLayer(lyr);
     }
+    
     m.zoomToBox(Envelope<double>(1405120.04127408,-247003.813399447,1706357.31328276,-25098.593149577));
     
     Image32 buf(m.getWidth(),m.getHeight());

Modified: trunk/demo/python/rundemo.py
===================================================================
--- trunk/demo/python/rundemo.py	2006-10-03 08:39:43 UTC (rev 303)
+++ trunk/demo/python/rundemo.py	2006-10-03 08:44:04 UTC (rev 304)
@@ -55,7 +55,8 @@
 #     password='mypassword'
 #     table= TODO
 
-provpoly_lyr = Layer(name='Provinces', type='shape', file='../data/boundaries')
+provpoly_lyr = Layer('Provinces')
+provpoly_lyr.datasource = Datasource(type='shape', file='../data/boundaries')
 
 # We then define a style for the layer.  A layer can have one or many styles.
 # Styles are named, so they can be shared across different layers.
@@ -118,9 +119,11 @@
 
 # A simple example ...
 
-qcdrain_lyr = Layer(name='Quebec Hydrography', type='shape',
-                    file='../data/qcdrainage')
+qcdrain_lyr = Layer('Quebec Hydrography')
 
+qcdrain_lyr.datasource = Datasource( type='shape',
+                                     file='../data/qcdrainage')
+
 qcdrain_style = Style()
 qcdrain_rule = Rule()
 qcdrain_rule.filter = Filter('[HYC] = 8')
@@ -135,15 +138,18 @@
 # attributes, and same desired style), so we're going to
 # re-use the style defined in the above layer for the next one.
 
-ondrain_lyr = Layer(name='Ontario Hydrography', type='shape',
-                    file='../data/ontdrainage')
+ondrain_lyr = Layer('Ontario Hydrography')
+ondrain_lyr.datasource = Datasource(type='shape',
+                                    file='../data/ontdrainage')
+
 ondrain_lyr.styles.append('drainage')
 m.layers.append(ondrain_lyr)
 
 # Provincial boundaries
 
-provlines_lyr = Layer(name='Provincial borders', type='shape',
-                      file='../data/boundaries_l')
+provlines_lyr = Layer('Provincial borders')
+provlines_lyr.datasource = Datasource (type='shape',
+                                       file='../data/boundaries_l')
 
 # Here we define a "dash dot dot dash" pattern for the provincial boundaries.
 
@@ -165,7 +171,8 @@
 
 # Roads 3 and 4 (The "grey" roads)
 
-roads34_lyr = Layer(name='Roads', type='shape', file='../data/roads')
+roads34_lyr = Layer('Roads')
+roads34_lyr.datasource = Datasource(type='shape', file='../data/roads')
 
 roads34_style = Style()
 roads34_rule = Rule()
@@ -195,7 +202,8 @@
 
 # Roads 2 (The thin yellow ones)
 
-roads2_lyr = Layer(name='Roads', type='shape', file='../data/roads')
+roads2_lyr = Layer('Roads')
+roads2_lyr.datasource = Datasource (type='shape', file='../data/roads')
 
 roads2_style_1 = Style()
 roads2_rule_1 = Rule()
@@ -228,7 +236,8 @@
 
 # Roads 1 (The big orange ones, the highways)
 
-roads1_lyr = Layer(name='Roads', type='shape', file='../data/roads')
+roads1_lyr = Layer('Roads')
+roads1_lyr.datasource = Datasource(type='shape', file='../data/roads')
 
 roads1_style_1 = Style()
 roads1_rule_1 = Rule()
@@ -260,8 +269,9 @@
 
 # Populated Places
 
-popplaces_lyr = Layer(name='Populated Places', type='shape',
-                      file='../data/popplaces')
+popplaces_lyr = Layer('Populated Places')
+popplaces_lyr.datasource = Datasource (type='shape',
+                                       file='../data/popplaces')
 
 popplaces_style = Style()
 popplaces_rule = Rule()

Modified: trunk/include/color_factory.hpp
===================================================================
--- trunk/include/color_factory.hpp	2006-10-03 08:39:43 UTC (rev 303)
+++ trunk/include/color_factory.hpp	2006-10-03 08:44:04 UTC (rev 304)
@@ -25,6 +25,7 @@
 #ifndef COLOR_FACTORY_HPP
 #define COLOR_FACTORY_HPP
 
+#include "config.hpp"
 #include "css_color_parser.hpp"
 
 namespace mapnik
@@ -33,19 +34,19 @@
     class MAPNIK_DECL color_factory
     {
     public:
-	static Color from_string(char const* css_color)
-	{   
-	    Color color;
-	    actions<Color> a(color);
-	    css_color_grammar<actions<Color> > grammar(a);
-	    parse_info<> info = parse(css_color, grammar, space_p);
-	    if (info.full) return color;
-	    return Color(0,0,0);	
-	}    
+        static Color from_string(char const* css_color)
+        {   
+            Color color;
+            actions<Color> a(color);
+            css_color_grammar<actions<Color> > grammar(a);
+            parse_info<> info = parse(css_color, grammar, space_p);
+            if (info.full) return color;
+            return Color(0,0,0);	
+        }    
     private:
-	color_factory();
-	color_factory(color_factory const&);
-	color_factory& operator=(color_factory const&);
+        color_factory();
+        color_factory(color_factory const&);
+        color_factory& operator=(color_factory const&);
     };
 }
 

Modified: trunk/include/filter_factory.hpp
===================================================================
--- trunk/include/filter_factory.hpp	2006-10-03 08:39:43 UTC (rev 303)
+++ trunk/include/filter_factory.hpp	2006-10-03 08:44:04 UTC (rev 304)
@@ -35,24 +35,26 @@
     class MAPNIK_DECL filter_factory
     {
     public:
-	static filter_ptr compile(string const& str)
-	{
-	    stack<shared_ptr<filter<FeatureT> > > filters;
-	    stack<shared_ptr<expression<FeatureT> > > exps;
-	    filter_grammar<FeatureT> grammar(filters,exps);
-	    char const *text = str.c_str();
-	    parse_info<> info = parse(text,text+strlen(text),grammar,space_p);
-	    if (info.full && !filters.empty())
-	    {
-		return filters.top();	
-	    }
-	    else 
-	    {
-		clog << "failed at :" << info.stop << "\n";
-		return filter_ptr(new none_filter<FeatureT>());
-	    }  
-	}
+        static filter_ptr compile(string const& str)
+        {
+            stack<shared_ptr<filter<FeatureT> > > filters;
+            stack<shared_ptr<expression<FeatureT> > > exps;
+            filter_grammar<FeatureT> grammar(filters,exps);
+            char const *text = str.c_str();
+            parse_info<> info = parse(text,text+strlen(text),grammar,space_p);
+            if (info.full && !filters.empty())
+            {
+                return filters.top();	
+            }
+            else 
+            {
+                clog << "failed at :" << info.stop << "\n";
+                return filter_ptr(new none_filter<FeatureT>());
+            }  
+        }
     };
+
+    MAPNIK_DECL filter_ptr create_filter (std::string const& wkt);
 }
 
 #endif //FILTER_FACTORY_HPP

Modified: trunk/include/filter_parser.hpp
===================================================================
--- trunk/include/filter_parser.hpp	2006-10-03 08:39:43 UTC (rev 303)
+++ trunk/include/filter_parser.hpp	2006-10-03 08:44:04 UTC (rev 304)
@@ -42,8 +42,8 @@
 #include "expression.hpp"
 #include "filter.hpp"
 #include "regex_filter.hpp"
+#include "logical.hpp"
 
-
 using namespace boost::spirit;
 using std::string;
 using std::clog;

Modified: trunk/include/layer.hpp
===================================================================
--- trunk/include/layer.hpp	2006-10-03 08:39:43 UTC (rev 303)
+++ trunk/include/layer.hpp	2006-10-03 08:44:04 UTC (rev 304)
@@ -15,11 +15,10 @@
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * #include <boost/serialization/serialization.hpp>
-License along with this library; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*
-*****************************************************************************/
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
 //$Id: layer.hpp 39 2005-04-10 20:39:53Z pavlenko $
 
 #ifndef LAYER_HPP
@@ -34,7 +33,6 @@
 {
     class MAPNIK_DECL Layer
     {
-        parameters params_;
         std::string name_;
         std::string title_;
         std::string abstract_;
@@ -42,20 +40,18 @@
         double maxZoom_;
         bool active_;
         bool selectable_;
-	
+        
         std::vector<std::string>  styles_;
         std::string selection_style_;
-
+        
         mutable std::vector<boost::shared_ptr<Feature> > selection_;
         mutable datasource_p ds_;
         
     public:
-        Layer();
-        explicit Layer(const parameters& params);
+        explicit Layer(std::string const& name);
         Layer(Layer const& l);
         Layer& operator=(Layer const& l);
         bool operator==(Layer const& other) const;
-        parameters const& params() const;
         void set_name(std::string const& name);
         const std::string& name() const;
         void set_title(std::string const& title);
@@ -79,9 +75,9 @@
         std::vector<boost::shared_ptr<Feature> >& selection() const;
         void clear_selection() const;
         void set_datasource(datasource_p const& ds);
-        datasource_p const& datasource() const;
+        datasource_p datasource() const;
         Envelope<double> envelope() const;
-        virtual ~Layer();
+        ~Layer();
     private:
         void swap(const Layer& other);
     };

Modified: trunk/include/map.hpp
===================================================================
--- trunk/include/map.hpp	2006-10-03 08:39:43 UTC (rev 303)
+++ trunk/include/map.hpp	2006-10-03 08:44:04 UTC (rev 304)
@@ -43,9 +43,9 @@
         Envelope<double> currentExtent_;
         
     public:
+ 
+        typedef std::map<std::string,feature_type_style>::const_iterator style_iterator;
         
-        typedef  std::map<std::string,feature_type_style>::const_iterator style_iterator;
-        
         Map();
         Map(int width,int height,int srid=-1);
         Map(const Map& rhs);
@@ -76,7 +76,7 @@
         void pan_and_zoom(int x,int y,double zoom);
         const Envelope<double>& getCurrentExtent() const;
         double scale() const;
-        virtual ~Map();
+        ~Map();
     private:
         void fixAspectRatio();
     };

Deleted: trunk/include/mapnik.hpp
===================================================================
--- trunk/include/mapnik.hpp	2006-10-03 08:39:43 UTC (rev 303)
+++ trunk/include/mapnik.hpp	2006-10-03 08:44:04 UTC (rev 304)
@@ -1,84 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: mapnik.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef MAPNIK_HPP
-#define MAPNIK_HPP
-
-#include <map>
-#include <vector>
-#include <cassert>
-
-#include "global.hpp"
-#include "factory.hpp"
-#include "filter.hpp"
-#include "query.hpp"
-#include "rule.hpp"
-#include "spatial.hpp"
-#include "logical.hpp"
-#include "comparison.hpp"
-#include "regex_filter.hpp"
-#include "utils.hpp"
-#include "geometry.hpp"
-#include "geom_util.hpp"
-#include "raster.hpp"
-#include "feature.hpp"
-#include "attribute.hpp"
-#include "attribute_collector.hpp"
-#include "graphics.hpp"
-#include "image_reader.hpp"
-#include "line_symbolizer.hpp"
-#include "polygon_symbolizer.hpp"
-#include "agg_renderer.hpp"
-#include "polygon_pattern_symbolizer.hpp"
-#include "line_pattern_symbolizer.hpp"
-#include "point_symbolizer.hpp"
-#include "raster_symbolizer.hpp"
-#include "text_symbolizer.hpp"
-#include "image_util.hpp"
-#include "datasource.hpp"
-#include "layer.hpp"
-#include "datasource_cache.hpp"
-#include "wkb.hpp"
-#include "map.hpp"
-#include "feature_type_style.hpp"
-#include "feature_factory.hpp"
-#include "math_expr.hpp"
-#include "value.hpp"
-#include "expression.hpp"
-#include "filter_visitor.hpp"
-#include "filter_parser.hpp"
-#include "filter_factory.hpp"
-#include "text_symbolizer.hpp"
-#include "label_placement.hpp"
-#include "feature_layer_desc.hpp"
-#include "css_color_parser.hpp"
-#include "color_factory.hpp"
-#include "config.hpp"
-
-namespace mapnik
-{
-    MAPNIK_DECL filter_ptr create_filter (std::string const& wkt);
-}
-
-#endif //MAPNIK_HPP

Modified: trunk/src/SConscript
===================================================================
--- trunk/src/SConscript	2006-10-03 08:39:43 UTC (rev 303)
+++ trunk/src/SConscript	2006-10-03 08:44:04 UTC (rev 304)
@@ -32,7 +32,6 @@
 
 source = Split(
     """
-    mapnik.cpp
     datasource_cache.cpp
     envelope.cpp
     graphics.cpp

Modified: trunk/src/datasource_cache.cpp
===================================================================
--- trunk/src/datasource_cache.cpp	2006-10-03 08:39:43 UTC (rev 303)
+++ trunk/src/datasource_cache.cpp	2006-10-03 08:44:04 UTC (rev 304)
@@ -1,4 +1,4 @@
- /*****************************************************************************
+/*****************************************************************************
  * 
  * This file is part of Mapnik (c++ mapping toolkit)
  *
@@ -75,26 +75,26 @@
             }
             std::clog<<"datasource="<<ds<<" type="<<type<<std::endl;
         }
-	catch (datasource_exception& ex)
-	{
-	    std::clog<<ex.what()<<std::endl;
-	}
+        catch (datasource_exception& ex)
+        {
+            std::clog<<ex.what()<<std::endl;
+        }
         catch (...)
         {
-            std::clog<<"exception caught "<<std::endl;
+            std::clog<<" exception caught\n";
         }
         return ds;
     }
 
     bool datasource_cache::insert(const std::string& type,const lt_dlhandle module)
     {	      
-	return plugins_.insert(make_pair(type,boost::shared_ptr<PluginInfo>(new PluginInfo(type,module)))).second;     
+        return plugins_.insert(make_pair(type,boost::shared_ptr<PluginInfo>(new PluginInfo(type,module)))).second;     
     }
 
     void datasource_cache::register_datasources(const std::string& str)
     {	
         mutex::scoped_lock lock(mapnik::singleton<mapnik::datasource_cache, 
-            mapnik::CreateStatic>::mutex_);
+                                mapnik::CreateStatic>::mutex_);
         filesystem::path path(str);
         filesystem::directory_iterator end_itr;
         if (exists(path))

Added: trunk/src/filter_factory.cpp
===================================================================
--- trunk/src/filter_factory.cpp	2006-10-03 08:39:43 UTC (rev 303)
+++ trunk/src/filter_factory.cpp	2006-10-03 08:44:04 UTC (rev 304)
@@ -0,0 +1,33 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id$
+
+#include "filter_factory.hpp"
+
+namespace mapnik
+{
+    filter_ptr create_filter (std::string const& wkt)
+    {
+        filter_factory<Feature> factory;
+        return factory.compile(wkt);
+    }
+}

Modified: trunk/src/layer.cpp
===================================================================
--- trunk/src/layer.cpp	2006-10-03 08:39:43 UTC (rev 303)
+++ trunk/src/layer.cpp	2006-10-03 08:44:04 UTC (rev 304)
@@ -34,9 +34,8 @@
 namespace mapnik
 {
     using namespace std;
-    Layer::Layer()
-        : params_(),
-          name_("unknown"),
+    Layer::Layer(std::string const& name)
+        : name_(name),
           title_(""),
           abstract_(""),
           minZoom_(0),
@@ -45,31 +44,18 @@
           selectable_(false),
           selection_style_("default_selection")
     {}
-
-    Layer::Layer(const parameters& params)
-        :params_(params),
-         name_(params_["name"]),
-         title_(params_["title"]),
-         abstract_(params_["abstract"]),
-         minZoom_(0),
-         maxZoom_(std::numeric_limits<double>::max()),
-         active_(true),
-         selectable_(false),
-         selection_style_("default_selection")
-    {}
     
     Layer::Layer(const Layer& rhs)
-        :params_(rhs.params_),
-         name_(rhs.name_),
-         title_(rhs.title_),
-         abstract_(rhs.abstract_),
-         minZoom_(rhs.minZoom_),
-         maxZoom_(rhs.maxZoom_),
-         active_(rhs.active_),
-         selectable_(rhs.selectable_),
-         ds_(rhs.ds_),
-         styles_(rhs.styles_),
-         selection_style_(rhs.selection_style_) {}
+        : name_(rhs.name_),
+          title_(rhs.title_),
+          abstract_(rhs.abstract_),
+          minZoom_(rhs.minZoom_),
+          maxZoom_(rhs.maxZoom_),
+          active_(rhs.active_),
+          selectable_(rhs.selectable_),
+          styles_(rhs.styles_),
+          ds_(rhs.ds_),
+          selection_style_(rhs.selection_style_) {}
     
     Layer& Layer::operator=(const Layer& rhs)
     {
@@ -85,7 +71,6 @@
     
     void Layer::swap(const Layer& rhs)
     {
-        params_=rhs.params_;
         name_=rhs.name_;
         title_=rhs.title_;
         abstract_=rhs.abstract_;
@@ -93,17 +78,12 @@
         maxZoom_=rhs.maxZoom_;
         active_=rhs.active_;
         selectable_=rhs.selectable_;
-        ds_=rhs.ds_;
         styles_=rhs.styles_;
+        ds_=rhs.ds_;
         selection_style_=rhs.selection_style_;
     }
-
+    
     Layer::~Layer() {}
-
-    parameters const& Layer::params() const
-    {
-        return params_;
-    }
     
     void Layer::set_name( std::string const& name)
     {
@@ -124,7 +104,7 @@
     {
         return title_;
     }
-
+    
     void Layer::set_abstract( std::string const& abstract)
     {
         abstract_ = abstract;
@@ -190,22 +170,11 @@
         return selectable_;
     }
 
-    const datasource_p& Layer::datasource() const
+    datasource_p Layer::datasource() const
     {
-        if (!ds_)
-        {
-            try
-            {
-                ds_=datasource_cache::instance()->create(params_);
-            }
-            catch (...)
-            {
-                std::clog << "exception caught : can not create datasource" << std::endl;  
-            }
-        }
         return ds_;
     }
-    // TODO: !!!!
+    
     void Layer::set_datasource(datasource_p const& ds)
     {
         ds_ = ds;
@@ -213,14 +182,10 @@
     
     Envelope<double> Layer::envelope() const
     {
-        datasource_p const& ds = datasource();
-        if (ds)
-        {
-            return ds->envelope();
-        }
+        if (ds_) return ds_->envelope();
     	return Envelope<double>();
     }
-
+    
     void Layer::selection_style(const std::string& name) 
     {
         selection_style_=name;

Modified: trunk/src/map.cpp
===================================================================
--- trunk/src/map.cpp	2006-10-03 08:39:43 UTC (rev 303)
+++ trunk/src/map.cpp	2006-10-03 08:44:04 UTC (rev 304)
@@ -251,6 +251,6 @@
             return currentExtent_.width()/width_;
         return currentExtent_.width();
     }
-
+    
     Map::~Map() {}
 }

Deleted: trunk/src/mapnik.cpp
===================================================================
--- trunk/src/mapnik.cpp	2006-10-03 08:39:43 UTC (rev 303)
+++ trunk/src/mapnik.cpp	2006-10-03 08:44:04 UTC (rev 304)
@@ -1,36 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#include "mapnik.hpp"
-
-namespace mapnik
-{
-    filter_ptr create_filter (std::string const& wkt)
-    {
-        filter_factory<Feature> factory;
-        return factory.compile(wkt);
-    }
-}
-
-



From pavlenko at mail.berlios.de  Tue Oct  3 10:49:56 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Tue, 3 Oct 2006 10:49:56 +0200
Subject: [Mapnik-svn] r305 - in trunk: . boost boost/property_tree
	boost/property_tree/detail
Message-ID: <200610030849.k938nuqs020266@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-03 10:49:51 +0200 (Tue, 03 Oct 2006)
New Revision: 305

Added:
   trunk/boost/
   trunk/boost/property_tree/
   trunk/boost/property_tree/cmdline_parser.hpp
   trunk/boost/property_tree/detail/
   trunk/boost/property_tree/detail/file_parser_error.hpp
   trunk/boost/property_tree/detail/info_parser_error.hpp
   trunk/boost/property_tree/detail/info_parser_read.hpp
   trunk/boost/property_tree/detail/info_parser_utils.hpp
   trunk/boost/property_tree/detail/info_parser_write.hpp
   trunk/boost/property_tree/detail/json_parser_error.hpp
   trunk/boost/property_tree/detail/json_parser_read.hpp
   trunk/boost/property_tree/detail/json_parser_write.hpp
   trunk/boost/property_tree/detail/ptree_implementation.hpp
   trunk/boost/property_tree/detail/ptree_interface.hpp
   trunk/boost/property_tree/detail/ptree_utils.hpp
   trunk/boost/property_tree/detail/xml_parser_error.hpp
   trunk/boost/property_tree/detail/xml_parser_flags.hpp
   trunk/boost/property_tree/detail/xml_parser_read_spirit.hpp
   trunk/boost/property_tree/detail/xml_parser_read_tinyxml.hpp
   trunk/boost/property_tree/detail/xml_parser_utils.hpp
   trunk/boost/property_tree/detail/xml_parser_write.hpp
   trunk/boost/property_tree/info_parser.hpp
   trunk/boost/property_tree/ini_parser.hpp
   trunk/boost/property_tree/json_parser.hpp
   trunk/boost/property_tree/ptree.hpp
   trunk/boost/property_tree/ptree_fwd.hpp
   trunk/boost/property_tree/registry_parser.hpp
   trunk/boost/property_tree/xml_parser.hpp
Log:
This is boost::property headers only library. It was accepted into main boost ditribution, but for now we use our own copy.

   


Added: trunk/boost/property_tree/cmdline_parser.hpp
===================================================================
--- trunk/boost/property_tree/cmdline_parser.hpp	2006-10-03 08:44:04 UTC (rev 304)
+++ trunk/boost/property_tree/cmdline_parser.hpp	2006-10-03 08:49:51 UTC (rev 305)
@@ -0,0 +1,85 @@
+// ----------------------------------------------------------------------------
+// Copyright (C) 2002-2005 Marcin Kalicinski
+//
+// Distributed under the Boost Software License, Version 1.0. 
+// (See accompanying file LICENSE_1_0.txt or copy at 
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// For more information, see www.boost.org
+// ----------------------------------------------------------------------------
+#ifndef BOOST_PROPERTY_TREE_CMDLINE_PARSER_HPP_INCLUDED
+#define BOOST_PROPERTY_TREE_CMDLINE_PARSER_HPP_INCLUDED
+
+#include <boost/property_tree/ptree.hpp>
+#include <boost/property_tree/detail/ptree_utils.hpp>
+
+namespace boost { namespace property_tree { namespace cmdline_parser
+{
+
+    template<class Ptree>
+    void read_cmdline(int argc, 
+                      typename Ptree::char_type *argv[], 
+                      const std::basic_string<typename Ptree::char_type> &metachars,
+                      Ptree &pt)
+    {
+
+        typedef typename Ptree::char_type Ch;
+        typedef std::basic_string<Ch> Str;
+
+        Ptree local;
+        
+        // For all arguments
+        for (int i = 0; i < argc; ++i)
+        {
+            Str text = detail::trim<Ch>(argv[i]);
+            if (!text.empty())
+                if (metachars.find(text[0]) != Str::npos)
+                {
+                    if (text.size() == 1)
+                    {
+                        Ptree &child = local.put(text, Str());
+                        Str key; 
+                        if (child.size() < 10) 
+                            key.push_back(typename Ptree::char_type('0' + child.size()));
+                        child.push_back(std::make_pair(key, Ptree(child.data())));
+                    }
+                    else if (text.size() == 2)
+                    {
+                        Ptree &child = local.put(text.substr(1, 1), Str());
+                        Str key; 
+                        if (child.size() < 10) 
+                            key.push_back(typename Ptree::char_type('0' + child.size()));
+                        child.push_back(std::make_pair(key, Ptree(child.data())));
+                    }
+                    else
+                    {
+                        Ptree &child = local.put(text.substr(1, 1), detail::trim<Ch>(text.substr(2, Str::npos)));
+                        Str key; 
+                        if (child.size() < 10) 
+                            key.push_back(typename Ptree::char_type('0' + child.size()));
+                        child.push_back(std::make_pair(key, Ptree(child.data())));
+                    }
+                }
+                else
+                {
+                    Ptree &child = local.put(Str(), detail::trim<Ch>(text));
+                    Str key; 
+                    if (child.size() < 10) 
+                        key.push_back(typename Ptree::char_type('0' + child.size()));
+                    child.push_back(std::make_pair(key, Ptree(child.data())));
+                }
+        }
+
+        // Swap local and pt
+        pt.swap(local);
+
+    }
+
+} } }
+
+namespace boost { namespace property_tree
+{
+    using cmdline_parser::read_cmdline;
+} }
+
+#endif

Added: trunk/boost/property_tree/detail/file_parser_error.hpp
===================================================================
--- trunk/boost/property_tree/detail/file_parser_error.hpp	2006-10-03 08:44:04 UTC (rev 304)
+++ trunk/boost/property_tree/detail/file_parser_error.hpp	2006-10-03 08:49:51 UTC (rev 305)
@@ -0,0 +1,88 @@
+// ----------------------------------------------------------------------------
+// Copyright (C) 2002-2005 Marcin Kalicinski
+//
+// Distributed under the Boost Software License, Version 1.0. 
+// (See accompanying file LICENSE_1_0.txt or copy at 
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// For more information, see www.boost.org
+// ----------------------------------------------------------------------------
+#ifndef BOOST_PROPERTY_TREE_DETAIL_FILE_PARSER_ERROR_HPP_INCLUDED
+#define BOOST_PROPERTY_TREE_DETAIL_FILE_PARSER_ERROR_HPP_INCLUDED
+
+#include <boost/property_tree/ptree.hpp>
+#include <string>
+
+namespace boost { namespace property_tree
+{
+
+    //! File parse error
+    class file_parser_error: public ptree_error
+    {
+
+    public:
+
+        ///////////////////////////////////////////////////////////////////////
+        // Construction & destruction
+        
+        // Construct error
+        file_parser_error(const std::string &message, 
+                          const std::string &filename, 
+                          unsigned long line): 
+            ptree_error(format_what(message, filename, line)), 
+            m_message(message), m_filename(filename), m_line(line)
+        { 
+        }
+
+        ~file_parser_error() throw()    
+            // gcc 3.4.2 complains about lack of throw specifier on compiler generated dtor
+        {
+        }
+
+        ///////////////////////////////////////////////////////////////////////
+        // Data access
+        
+        // Get error message (without line and file - use what() to get full message)
+        std::string message()
+        {
+            return m_message;
+        }
+        
+        // Get error filename
+        std::string filename()
+        {
+            return m_filename;
+        }
+
+        // Get error line number
+        unsigned long line() 
+        { 
+            return m_line; 
+        }
+
+    private:
+        
+        std::string m_message;
+        std::string m_filename;
+        unsigned long m_line;
+
+        // Format error message to be returned by std::runtime_error::what()
+        std::string format_what(const std::string &message,
+                                const std::string &filename, 
+                                unsigned long line)
+        {
+            std::stringstream stream;
+            if (line > 0)
+                stream << (filename.empty() ? "<unspecified file>" : filename.c_str()) << 
+                          '(' << line << "): " << message;
+            else
+                stream << (filename.empty() ? "<unspecified file>" : filename.c_str()) << 
+                          ": " << message;
+            return stream.str();
+        }
+
+    };
+
+} }
+
+#endif

Added: trunk/boost/property_tree/detail/info_parser_error.hpp
===================================================================
--- trunk/boost/property_tree/detail/info_parser_error.hpp	2006-10-03 08:44:04 UTC (rev 304)
+++ trunk/boost/property_tree/detail/info_parser_error.hpp	2006-10-03 08:49:51 UTC (rev 305)
@@ -0,0 +1,32 @@
+// ----------------------------------------------------------------------------
+// Copyright (C) 2002-2005 Marcin Kalicinski
+//
+// Distributed under the Boost Software License, Version 1.0. 
+// (See accompanying file LICENSE_1_0.txt or copy at 
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// For more information, see www.boost.org
+// ----------------------------------------------------------------------------
+#ifndef BOOST_PROPERTY_TREE_DETAIL_INFO_PARSER_ERROR_HPP_INCLUDED
+#define BOOST_PROPERTY_TREE_DETAIL_INFO_PARSER_ERROR_HPP_INCLUDED
+
+#include <boost/property_tree/detail/file_parser_error.hpp>
+#include <string>
+
+namespace boost { namespace property_tree { namespace info_parser
+{
+
+    class info_parser_error: public file_parser_error
+    {
+    public:
+        info_parser_error(const std::string &message, 
+                          const std::string &filename, 
+                          unsigned long line): 
+            file_parser_error(message, filename, line)
+        { 
+        }
+    };
+
+} } }
+
+#endif

Added: trunk/boost/property_tree/detail/info_parser_read.hpp
===================================================================
--- trunk/boost/property_tree/detail/info_parser_read.hpp	2006-10-03 08:44:04 UTC (rev 304)
+++ trunk/boost/property_tree/detail/info_parser_read.hpp	2006-10-03 08:49:51 UTC (rev 305)
@@ -0,0 +1,369 @@
+// ----------------------------------------------------------------------------
+// Copyright (C) 2002-2005 Marcin Kalicinski
+//
+// Distributed under the Boost Software License, Version 1.0. 
+// (See accompanying file LICENSE_1_0.txt or copy at 
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// For more information, see www.boost.org
+// ----------------------------------------------------------------------------
+#ifndef BOOST_PROPERTY_TREE_DETAIL_INFO_PARSER_READ_HPP_INCLUDED
+#define BOOST_PROPERTY_TREE_DETAIL_INFO_PARSER_READ_HPP_INCLUDED
+
+#include "boost/property_tree/ptree.hpp"
+#include "boost/property_tree/detail/info_parser_error.hpp"
+#include "boost/property_tree/detail/info_parser_utils.hpp"
+#include <iterator>
+#include <string>
+#include <stack>
+#include <fstream>
+#include <cctype>
+
+namespace boost { namespace property_tree { namespace info_parser
+{
+    
+    // Expand known escape sequences
+    template<class It>
+    std::basic_string<typename std::iterator_traits<It>::value_type> 
+        expand_escapes(It b, It e)
+    {
+        typedef typename std::iterator_traits<It>::value_type Ch;
+        std::basic_string<Ch> result;
+        while (b != e)
+        {
+            if (*b == Ch('\\'))
+            {
+                ++b;
+                if (b == e)
+                    throw info_parser_error("character expected after backslash", "", 0);
+                else if (*b == Ch('0')) result += Ch('\0');
+                else if (*b == Ch('a')) result += Ch('\a');
+                else if (*b == Ch('b')) result += Ch('\b');
+                else if (*b == Ch('f')) result += Ch('\f');
+                else if (*b == Ch('n')) result += Ch('\n');
+                else if (*b == Ch('r')) result += Ch('\r');
+                else if (*b == Ch('t')) result += Ch('\t');
+                else if (*b == Ch('v')) result += Ch('\v');
+                else if (*b == Ch('"')) result += Ch('"');
+                else if (*b == Ch('\'')) result += Ch('\'');
+                else if (*b == Ch('\\')) result += Ch('\\');
+                else
+                    throw info_parser_error("unknown escape sequence", "", 0);
+            }
+            else
+                result += *b;
+            ++b;
+        }
+        return result;
+    }
+    
+    // Advance pointer past whitespace
+    template<class Ch>
+    void skip_whitespace(const Ch *&text)
+    {
+        using namespace std;
+        while (isspace(*text))
+            ++text;
+    }
+    
+    // Extract word (whitespace delimited) and advance pointer accordingly
+    template<class Ch>
+    std::basic_string<Ch> read_word(const Ch *&text)
+    {
+        using namespace std;
+        skip_whitespace(text);
+        const Ch *start = text;
+        while (!isspace(*text) && *text != Ch(';') && *text != Ch('\0'))
+            ++text;
+        return expand_escapes(start, text);
+    }
+
+    // Extract line (eol delimited) and advance pointer accordingly
+    template<class Ch>
+    std::basic_string<Ch> read_line(const Ch *&text)
+    {
+        using namespace std;
+        skip_whitespace(text);
+        const Ch *start = text;
+        while (*text != Ch('\0') && *text != Ch(';'))
+            ++text;
+        while (text > start && isspace(*(text - 1)))
+            --text;
+        return expand_escapes(start, text);
+    }
+
+    // Extract string (inside ""), and advance pointer accordingly
+    // Set need_more_lines to true if \ continuator found
+    template<class Ch>
+    std::basic_string<Ch> read_string(const Ch *&text, bool *need_more_lines)
+    {
+        skip_whitespace(text);
+        if (*text == Ch('\"'))
+        {
+            
+            // Skip "
+            ++text;
+            
+            // Find end of string, but skip escaped "
+            bool escaped = false;
+            const Ch *start = text;
+            while ((escaped || *text != Ch('\"')) && *text != Ch('\0'))
+            {
+                escaped = (!escaped && *text == Ch('\\'));
+                ++text;
+            }
+            
+            // If end of string found
+            if (*text == Ch('\"'))
+            {
+                std::basic_string<Ch> result = expand_escapes(start, text++);
+                skip_whitespace(text);
+                if (*text == Ch('\\'))
+                {
+                    if (!need_more_lines)
+                        throw info_parser_error("unexpected \\", "", 0);
+                    ++text;
+                    skip_whitespace(text);
+                    if (*text == Ch('\0') || *text == Ch(';'))
+                        *need_more_lines = true;
+                    else
+                        throw info_parser_error("expected end of line after \\", "", 0);
+                }
+                else
+                    if (need_more_lines)
+                        *need_more_lines = false;
+                return result;
+            }
+            else
+                throw info_parser_error("unexpected end of line", "", 0);
+
+        }
+        else
+            throw info_parser_error("expected \"", "", 0);
+    }
+    
+    // Extract key
+    template<class Ch>
+    std::basic_string<Ch> read_key(const Ch *&text)
+    {
+        skip_whitespace(text);
+        if (*text == Ch('\"'))
+            return read_string(text, NULL);
+        else
+            return read_word(text);
+    }
+
+    // Extract data
+    template<class Ch>
+    std::basic_string<Ch> read_data(const Ch *&text, bool *need_more_lines)
+    {
+        skip_whitespace(text);
+        if (*text == Ch('\"'))
+            return read_string(text, need_more_lines);
+        else
+        {
+            *need_more_lines = false;
+            return read_word(text);
+        }
+    }
+
+    // Build ptree from info stream
+    template<class Ptree>
+    void read_info_internal(std::basic_istream<typename Ptree::char_type> &stream, 
+                            Ptree &pt, 
+                            const std::string &filename,
+                            int include_depth)
+    {
+        
+        // Character type
+        typedef typename Ptree::char_type Ch;
+        
+        // Possible parser states
+        enum state_t { 
+            s_key,              // Parser expects key
+            s_data,             // Parser expects data
+            s_data_cont         // Parser expects data continuation
+        };
+        
+        unsigned long line_no = 0;
+        state_t state = s_key;          // Parser state
+        Ptree *last = NULL;             // Pointer to last created ptree
+        std::basic_string<Ch> line;     // Define line here to minimize reallocations
+            
+        // Initialize ptree stack (used to handle nesting)
+        std::stack<Ptree *> stack;
+        stack.push(&pt);                // Push root ptree on stack initially
+        
+        try
+        {
+        
+            // While there are characters in the stream
+            while (stream.good())
+            {
+            
+                // Read one line from stream
+                ++line_no;
+                std::getline(stream, line);
+                if (!stream.good() && !stream.eof())
+                    throw info_parser_error("read error", "", 0);
+                const Ch *text = line.c_str();
+
+                // If directive found
+                skip_whitespace(text);
+                if (*text == Ch('#'))
+                {
+                    
+                    // Determine directive type
+                    ++text;     // skip #
+                    std::basic_string<Ch> directive = read_word(text);
+                    if (directive == convert_chtype<Ch, char>("include"))     // #include
+                    {
+                        if (include_depth > 100)
+                            throw info_parser_error("include depth too large, probably recursive include", "", 0);
+                        std::basic_string<Ch> s = read_string(text, NULL);
+                        std::string inc_name = convert_chtype<char, Ch>(s.c_str());
+                        std::basic_ifstream<Ch> inc_stream(inc_name.c_str());
+                        if (!inc_stream.good())
+                            throw info_parser_error("cannot open include file " + inc_name, "", 0);
+                        read_info_internal(inc_stream, *stack.top(), inc_name, include_depth + 1);
+                    }
+                    else    // Unknown directive
+                        throw info_parser_error("unknown directive", "", 0);
+
+                    // Directive must be followed by end of line
+                    skip_whitespace(text);
+                    if (*text != Ch('\0'))
+                        throw info_parser_error("expected end of line", "", 0);
+
+                    // Go to next line
+                    continue;
+
+                }
+
+                // While there are characters left in line
+                while (1)
+                {
+
+                    // Stop parsing on end of line or comment
+                    skip_whitespace(text);
+                    if (*text == Ch('\0') || *text == Ch(';'))
+                    {
+                        if (state == s_data)    // If there was no data set state to s_key
+                            state = s_key;
+                        break; 
+                    }
+
+                    // Process according to current parser state
+                    switch (state)
+                    {
+
+                        // Parser expects key
+                        case s_key:
+                        {
+
+                            if (*text == Ch('{'))   // Brace opening found
+                            {
+                                if (!last)
+                                    throw info_parser_error("unexpected {", "", 0);
+                                stack.push(last);
+                                last = NULL;
+                                ++text;
+                            }
+                            else if (*text == Ch('}'))  // Brace closing found
+                            {
+                                if (stack.size() <= 1)
+                                    throw info_parser_error("unmatched }", "", 0);
+                                stack.pop();
+                                last = NULL;
+                                ++text;
+                            }
+                            else    // Key text found
+                            {
+                                std::basic_string<Ch> key = read_key(text);
+                                last = &stack.top()->push_back(std::make_pair(key, Ptree()))->second;
+                                state = s_data;
+                            }
+
+                        }; break;
+
+                        // Parser expects data
+                        case s_data:
+                        {
+                            
+                            // Last ptree must be defined because we are going to add data to it
+                            BOOST_ASSERT(last);
+                            
+                            if (*text == Ch('{'))   // Brace opening found
+                            {
+                                stack.push(last);
+                                last = NULL;
+                                ++text;
+                                state = s_key;
+                            }
+                            else if (*text == Ch('}'))  // Brace closing found
+                            {
+                                if (stack.size() <= 1)
+                                    throw info_parser_error("unmatched }", "", 0);
+                                stack.pop();
+                                last = NULL;
+                                ++text;
+                                state = s_key;
+                            }
+                            else    // Data text found
+                            {
+                                bool need_more_lines;
+                                std::basic_string<Ch> data = read_data(text, &need_more_lines);
+                                last->data() = data;
+                                state = need_more_lines ? s_data_cont : s_key;
+                            }
+
+
+                        }; break;
+
+                        // Parser expects continuation of data after \ on previous line
+                        case s_data_cont:
+                        {
+                            
+                            // Last ptree must be defined because we are going to update its data
+                            BOOST_ASSERT(last);
+                            
+                            if (*text == Ch('\"'))  // Continuation must start with "
+                            {
+                                bool need_more_lines;
+                                std::basic_string<Ch> data = read_string(text, &need_more_lines);
+                                last->put_own(last->template get_own<std::basic_string<Ch> >() + data);
+                                state = need_more_lines ? s_data_cont : s_key;
+                            }
+                            else
+                                throw info_parser_error("expected \" after \\ in previous line", "", 0);
+
+                        }; break;
+
+                        // Should never happen
+                        default:
+                            BOOST_ASSERT(0);
+
+                    }
+                }
+            }
+
+            // Check if stack has initial size, otherwise some {'s have not been closed
+            if (stack.size() != 1)
+                throw info_parser_error("unmatched {", "", 0);
+
+        }
+        catch (info_parser_error &e)
+        {
+            // If line undefined rethrow error with correct filename and line
+            if (e.line() == 0)
+                throw info_parser_error(e.message(), filename, line_no);
+            else
+                throw e;
+
+        }
+
+    }
+    
+} } }
+
+#endif

Added: trunk/boost/property_tree/detail/info_parser_utils.hpp
===================================================================
--- trunk/boost/property_tree/detail/info_parser_utils.hpp	2006-10-03 08:44:04 UTC (rev 304)
+++ trunk/boost/property_tree/detail/info_parser_utils.hpp	2006-10-03 08:49:51 UTC (rev 305)
@@ -0,0 +1,32 @@
+// ----------------------------------------------------------------------------
+// Copyright (C) 2002-2005 Marcin Kalicinski
+//
+// Distributed under the Boost Software License, Version 1.0. 
+// (See accompanying file LICENSE_1_0.txt or copy at 
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// For more information, see www.boost.org
+// ----------------------------------------------------------------------------
+#ifndef BOOST_PROPERTY_TREE_DETAIL_INFO_PARSER_CHCONV_HPP_INCLUDED
+#define BOOST_PROPERTY_TREE_DETAIL_INFO_PARSER_CHCONV_HPP_INCLUDED
+
+#include <string>
+
+namespace boost { namespace property_tree { namespace info_parser
+{
+
+    template<class ChDest, class ChSrc>
+    std::basic_string<ChDest> convert_chtype(const ChSrc *text)
+    {
+        std::basic_string<ChDest> result;
+        while (*text)
+        {
+            result += ChDest(*text);
+            ++text;
+        }
+        return result;
+    }
+
+} } }
+
+#endif

Added: trunk/boost/property_tree/detail/info_parser_write.hpp
===================================================================
--- trunk/boost/property_tree/detail/info_parser_write.hpp	2006-10-03 08:44:04 UTC (rev 304)
+++ trunk/boost/property_tree/detail/info_parser_write.hpp	2006-10-03 08:49:51 UTC (rev 305)
@@ -0,0 +1,131 @@
+// ----------------------------------------------------------------------------
+// Copyright (C) 2002-2005 Marcin Kalicinski
+//
+// Distributed under the Boost Software License, Version 1.0. 
+// (See accompanying file LICENSE_1_0.txt or copy at 
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// For more information, see www.boost.org
+// ----------------------------------------------------------------------------
+#ifndef BOOST_PROPERTY_TREE_DETAIL_INFO_PARSER_WRITE_HPP_INCLUDED
+#define BOOST_PROPERTY_TREE_DETAIL_INFO_PARSER_WRITE_HPP_INCLUDED
+
+#include "boost/property_tree/ptree.hpp"
+#include "boost/property_tree/detail/info_parser_utils.hpp"
+#include <string>
+
+namespace boost { namespace property_tree { namespace info_parser
+{
+    
+    // Create necessary escape sequences from illegal characters
+    template<class Ch>
+    std::basic_string<Ch> create_escapes(const std::basic_string<Ch> &s)
+    {
+        std::basic_string<Ch> result;
+        typename std::basic_string<Ch>::const_iterator b = s.begin();
+        typename std::basic_string<Ch>::const_iterator e = s.end();
+        while (b != e)
+        {
+            if (*b == Ch('\0')) result += Ch('\\'), result += Ch('0');
+            else if (*b == Ch('\a')) result += Ch('\\'), result += Ch('a');
+            else if (*b == Ch('\b')) result += Ch('\\'), result += Ch('b');
+            else if (*b == Ch('\f')) result += Ch('\\'), result += Ch('f');
+            else if (*b == Ch('\n')) result += Ch('\\'), result += Ch('n');
+            else if (*b == Ch('\r')) result += Ch('\\'), result += Ch('r');
+            else if (*b == Ch('\v')) result += Ch('\\'), result += Ch('v');
+            else if (*b == Ch('"')) result += Ch('\\'), result += Ch('"');
+            else if (*b == Ch('\\')) result += Ch('\\'), result += Ch('\\');
+            else
+                result += *b;
+            ++b;
+        }
+        return result;
+    }
+
+    template<class Ch>
+    bool is_simple_key(const std::basic_string<Ch> &key)
+    {
+        const static std::basic_string<Ch> chars = convert_chtype<Ch, char>(" \t{};\n\"");
+        return !key.empty() && key.find_first_of(chars) == key.npos;
+    }
+    
+    template<class Ch>
+    bool is_simple_data(const std::basic_string<Ch> &data)
+    {
+        const static std::basic_string<Ch> chars = convert_chtype<Ch, char>(" \t{};\n\"");
+        return !data.empty() && data.find_first_of(chars) == data.npos;
+    }
+
+    template<class Ptree>
+    void write_info_helper(std::basic_ostream<typename Ptree::char_type> &stream, 
+                           const Ptree &pt, 
+                           int indent)
+    {
+
+        // Character type
+        typedef typename Ptree::char_type Ch;
+        
+        // Write data
+        if (indent >= 0)
+        {
+            if (!pt.data().empty())
+            {
+                std::basic_string<Ch> data = create_escapes(pt.template get_own<std::basic_string<Ch> >());
+                if (is_simple_data(data))
+                    stream << Ch(' ') << data << Ch('\n');
+                else
+                    stream << Ch(' ') << Ch('\"') << data << Ch('\"') << Ch('\n');
+            }
+            else if (pt.empty())
+                stream << Ch(' ') << Ch('\"') << Ch('\"') << Ch('\n');
+            else
+                stream << Ch('\n');
+        }
+        
+        // Write keys
+        if (!pt.empty())
+        {
+            
+            // Open brace
+            if (indent >= 0) 
+                stream << std::basic_string<Ch>(4 * indent, Ch(' ')) << Ch('{') << Ch('\n');
+            
+            // Write keys
+            typename Ptree::const_iterator it = pt.begin();
+            for (; it != pt.end(); ++it)
+            {
+
+                // Output key
+                std::basic_string<Ch> key = create_escapes(it->first);
+                stream << std::basic_string<Ch>(4 * (indent + 1), Ch(' '));
+                if (is_simple_key(key))
+                    stream << key;
+                else
+                    stream << Ch('\"') << key << Ch('\"');
+
+                // Output data and children  
+                write_info_helper(stream, it->second, indent + 1);
+
+            }
+            
+            // Close brace
+            if (indent >= 0) 
+                stream << std::basic_string<Ch>(4 * indent, Ch(' ')) << Ch('}') << Ch('\n');
+
+        }
+    }
+
+    // Write ptree to info stream
+    template<class Ptree>
+    void write_info_internal(std::basic_ostream<typename Ptree::char_type> &stream, 
+                             const Ptree &pt,
+                             const std::string &filename)
+    {
+        write_info_helper(stream, pt, -1);
+        if (!stream.good())
+            throw info_parser_error("write error", filename, 0);
+    }
+
+} } }
+
+#endif

Added: trunk/boost/property_tree/detail/json_parser_error.hpp
===================================================================
--- trunk/boost/property_tree/detail/json_parser_error.hpp	2006-10-03 08:44:04 UTC (rev 304)
+++ trunk/boost/property_tree/detail/json_parser_error.hpp	2006-10-03 08:49:51 UTC (rev 305)
@@ -0,0 +1,33 @@
+// ----------------------------------------------------------------------------
+// Copyright (C) 2002-2005 Marcin Kalicinski
+//
+// Distributed under the Boost Software License, Version 1.0. 
+// (See accompanying file LICENSE_1_0.txt or copy at 
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// For more information, see www.boost.org
+// ----------------------------------------------------------------------------
+#ifndef BOOST_PROPERTY_TREE_DETAIL_JSON_PARSER_ERROR_HPP_INCLUDED
+#define BOOST_PROPERTY_TREE_DETAIL_JSON_PARSER_ERROR_HPP_INCLUDED
+
+#include <boost/property_tree/detail/file_parser_error.hpp>
+#include <string>
+
+namespace boost { namespace property_tree { namespace json_parser
+{
+
+    //! Json parser error
+    class json_parser_error: public file_parser_error
+    {
+    public:
+        json_parser_error(const std::string &message, 
+                          const std::string &filename, 
+                          unsigned long line): 
+            file_parser_error(message, filename, line)
+        { 
+        }
+    };
+
+} } }
+
+#endif

Added: trunk/boost/property_tree/detail/json_parser_read.hpp
===================================================================
--- trunk/boost/property_tree/detail/json_parser_read.hpp	2006-10-03 08:44:04 UTC (rev 304)
+++ trunk/boost/property_tree/detail/json_parser_read.hpp	2006-10-03 08:49:51 UTC (rev 305)
@@ -0,0 +1,316 @@
+// ----------------------------------------------------------------------------
+// Copyright (C) 2002-2005 Marcin Kalicinski
+//
+// Distributed under the Boost Software License, Version 1.0. 
+// (See accompanying file LICENSE_1_0.txt or copy at 
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// For more information, see www.boost.org
+// ----------------------------------------------------------------------------
+#ifndef BOOST_PROPERTY_TREE_DETAIL_JSON_PARSER_READ_HPP_INCLUDED
+#define BOOST_PROPERTY_TREE_DETAIL_JSON_PARSER_READ_HPP_INCLUDED
+
+//#define BOOST_SPIRIT_DEBUG
+
+#include <boost/property_tree/ptree.hpp>
+#include <boost/property_tree/detail/ptree_utils.hpp>
+#include <boost/property_tree/detail/json_parser_error.hpp>
+#include <boost/spirit.hpp>
+#include <string>
+#include <locale>
+#include <istream>
+#include <vector>
+#include <algorithm>
+
+namespace boost { namespace property_tree { namespace json_parser
+{
+
+    ///////////////////////////////////////////////////////////////////////
+    // Json parser context
+        
+    template<class Ptree>
+    struct context
+    {
+
+        typedef typename Ptree::char_type Ch;
+        typedef std::basic_string<Ch> Str;
+        typedef typename std::vector<Ch>::iterator It;
+        
+        Str string;
+        Str name;
+        Ptree root;
+        std::vector<Ptree *> stack;
+
+        struct a_object_s
+        {
+            context &c;
+            a_object_s(context &c): c(c) { }
+            void operator()(Ch) const
+            {
+                if (c.stack.empty())
+                    c.stack.push_back(&c.root);
+                else
+                {
+                    Ptree *parent = c.stack.back();
+                    Ptree *child = &parent->push_back(std::make_pair(c.name, Ptree()))->second;
+                    c.stack.push_back(child);
+                    c.name.clear();
+                }
+            }
+        };
+        
+        struct a_object_e
+        {
+            context &c;
+            a_object_e(context &c): c(c) { }
+            void operator()(Ch) const
+            {
+                BOOST_ASSERT(c.stack.size() >= 1);
+                c.stack.pop_back();
+            }
+        };
+
+        struct a_name
+        {
+            context &c;
+            a_name(context &c): c(c) { }
+            void operator()(It, It) const
+            {
+                c.name.swap(c.string);
+                c.string.clear();
+            }
+        };
+
+        struct a_string_val
+        {
+            context &c;
+            a_string_val(context &c): c(c) { }
+            void operator()(It, It) const
+            {
+                BOOST_ASSERT(c.stack.size() >= 1);
+                c.stack.back()->push_back(std::make_pair(c.name, Ptree(c.string)));
+                c.name.clear();
+                c.string.clear();
+            }
+        };
+
+        struct a_literal_val
+        {
+            context &c;
+            a_literal_val(context &c): c(c) { }
+            void operator()(It b, It e) const
+            {
+                BOOST_ASSERT(c.stack.size() >= 1);
+                c.stack.back()->push_back(std::make_pair(c.name, Str(b, e)));
+                c.name.clear();
+                c.string.clear();
+            }
+        };
+
+        struct a_char
+        {
+            context &c;
+            a_char(context &c): c(c) { }
+            void operator()(It b, It e) const
+            {
+                c.string += *b;
+            }
+        };
+
+        struct a_escape
+        {
+            context &c;
+            a_escape(context &c): c(c) { }
+            void operator()(Ch ch) const
+            {
+                switch (ch)
+                {
+                    case Ch('\"'): c.string += Ch('\"'); break;
+                    case Ch('\\'): c.string += Ch('\\'); break;
+                    case Ch('0'): c.string += Ch('\0'); break;
+                    case Ch('b'): c.string += Ch('\b'); break;
+                    case Ch('f'): c.string += Ch('\f'); break;
+                    case Ch('n'): c.string += Ch('\n'); break;
+                    case Ch('r'): c.string += Ch('\r'); break;
+                    case Ch('t'): c.string += Ch('\t'); break;
+                    default: BOOST_ASSERT(0);
+                }
+            }
+        };
+
+        struct a_unicode
+        {
+            context &c;
+            a_unicode(context &c): c(c) { }
+            void operator()(unsigned long u) const
+            {
+                u = (std::min)(u, static_cast<unsigned long>((std::numeric_limits<Ch>::max)()));
+                c.string += Ch(u);
+            }
+        };
+
+    };
+
+    ///////////////////////////////////////////////////////////////////////
+    // Json grammar
+        
+    template<class Ptree>
+    struct json_grammar: public boost::spirit::grammar<json_grammar<Ptree> >
+    {
+        
+        typedef context<Ptree> Context;
+        typedef typename Ptree::char_type Ch;
+
+        mutable Context c;
+        
+        template<class Scanner>
+        struct definition
+        {
+            
+            boost::spirit::rule<Scanner> root, object, member, array, item, value, string, number;
+            boost::spirit::rule<typename boost::spirit::lexeme_scanner<Scanner>::type> character, escape;
+
+            definition(const json_grammar &self)
+            {
+                
+                using namespace boost::spirit;
+
+                // Assertions
+                assertion<std::string> expect_object("expected object");
+                assertion<std::string> expect_eoi("expected end of input");
+                assertion<std::string> expect_objclose("expected ',' or '}'");
+                assertion<std::string> expect_arrclose("expected ',' or ']'");
+                assertion<std::string> expect_name("expected object name");
+                assertion<std::string> expect_colon("expected ':'");
+                assertion<std::string> expect_value("expected value");
+                assertion<std::string> expect_escape("invalid escape sequence");
+
+                // JSON grammar rules
+                root 
+                    =   expect_object(object) 
+                        >> expect_eoi(end_p)
+                        ;
+                
+                object 
+                    =   ch_p('{')[typename Context::a_object_s(self.c)]
+                        >> (ch_p('}')[typename Context::a_object_e(self.c)] 
+                           | (list_p(member, ch_p(','))
+                              >> expect_objclose(ch_p('}')[typename Context::a_object_e(self.c)])
+                             )
+                           )
+                        ;
+                
+                member 
+                    =   expect_name(string[typename Context::a_name(self.c)]) 
+                        >> expect_colon(ch_p(':')) 
+                        >> expect_value(value)
+                        ;
+                
+                array 
+                    =   ch_p('[')[typename Context::a_object_s(self.c)]
+                        >> (ch_p(']')[typename Context::a_object_e(self.c)] 
+                            | (list_p(item, ch_p(','))
+                               >> expect_arrclose(ch_p(']')[typename Context::a_object_e(self.c)])
+                              )
+                           )
+                    ;
+
+                item 
+                    =   expect_value(value)
+                        ;
+
+                value 
+                    =   string[typename Context::a_string_val(self.c)] 
+                        | (number | str_p("true") | "false" | "null")[typename Context::a_literal_val(self.c)]
+                        | object 
+                        | array
+                        ;
+                
+                number 
+                    =   strict_real_p 
+                        | int_p
+                        ;
+                
+                string 
+                    =   +(lexeme_d[confix_p('\"', *character, '\"')])
+                        ;
+                
+                character 
+                    =   (anychar_p - "\\" - "\"")[typename Context::a_char(self.c)] 
+                        | ch_p("\\") >> expect_escape(escape)
+                        ;
+                
+                escape 
+                    =   chset_p(detail::widen<Ch>("\"\\0bfnrt").c_str())[typename Context::a_escape(self.c)] 
+                        | 'u' >> uint_parser<unsigned long, 16, 4, 4>()[typename Context::a_unicode(self.c)]
+                        ;
+                
+                // Debug
+                BOOST_SPIRIT_DEBUG_RULE(root);
+                BOOST_SPIRIT_DEBUG_RULE(object);
+                BOOST_SPIRIT_DEBUG_RULE(member);
+                BOOST_SPIRIT_DEBUG_RULE(array);
+                BOOST_SPIRIT_DEBUG_RULE(item);
+                BOOST_SPIRIT_DEBUG_RULE(value);
+                BOOST_SPIRIT_DEBUG_RULE(string);
+                BOOST_SPIRIT_DEBUG_RULE(number);
+                BOOST_SPIRIT_DEBUG_RULE(escape);
+                BOOST_SPIRIT_DEBUG_RULE(character);
+
+            }
+
+            const boost::spirit::rule<Scanner> &start() const
+            {
+                return root;
+            }
+
+        };
+
+    };
+
+    template<class It, class Ch>
+    unsigned long count_lines(It begin, It end)
+    {
+        return static_cast<unsigned long>(std::count(begin, end, Ch('\n')) + 1);
+    }
+
+    template<class Ptree>
+    void read_json_internal(std::basic_istream<typename Ptree::char_type> &stream,
+                            Ptree &pt,
+                            const std::string &filename)
+    {
+
+        using namespace boost::spirit;
+        typedef typename Ptree::char_type Ch;
+        typedef typename std::vector<Ch>::iterator It;
+
+        // Load data into vector
+        std::vector<Ch> v(std::istreambuf_iterator<Ch>(stream.rdbuf()),
+                          std::istreambuf_iterator<Ch>());
+        if (!stream.good())
+            throw json_parser_error("read error", filename, 0);
+        
+        // Prepare grammar
+        json_grammar<Ptree> g;
+
+        // Parse
+        try
+        {
+            parse_info<It> pi = parse(v.begin(), v.end(), g, 
+                                      space_p | comment_p("//") | comment_p("/*", "*/"));
+            if (!pi.hit || !pi.full)
+                throw parser_error<std::string, It>(v.begin(), "syntax error");
+        }
+        catch (parser_error<std::string, It> &e)
+        {
+            throw json_parser_error(e.descriptor, filename, count_lines<It, Ch>(v.begin(), e.where));
+        }
+
+        // Swap grammar context root and pt
+        pt.swap(g.c.root);
+
+    }
+
+} } }
+
+#endif

Added: trunk/boost/property_tree/detail/json_parser_write.hpp
===================================================================
--- trunk/boost/property_tree/detail/json_parser_write.hpp	2006-10-03 08:44:04 UTC (rev 304)
+++ trunk/boost/property_tree/detail/json_parser_write.hpp	2006-10-03 08:49:51 UTC (rev 305)
@@ -0,0 +1,163 @@
+// ----------------------------------------------------------------------------
+// Copyright (C) 2002-2005 Marcin Kalicinski
+//
+// Distributed under the Boost Software License, Version 1.0. 
+// (See accompanying file LICENSE_1_0.txt or copy at 
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// For more information, see www.boost.org
+// ----------------------------------------------------------------------------
+#ifndef BOOST_PROPERTY_TREE_DETAIL_JSON_PARSER_WRITE_HPP_INCLUDED
+#define BOOST_PROPERTY_TREE_DETAIL_JSON_PARSER_WRITE_HPP_INCLUDED
+
+#include <boost/property_tree/ptree.hpp>
+#include <string>
+#include <ostream>
+#include <iomanip>
+
+namespace boost { namespace property_tree { namespace json_parser
+{
+
+    // Create necessary escape sequences from illegal characters
+    template<class Ch>
+    std::basic_string<Ch> create_escapes(const std::basic_string<Ch> &s,
+                                         const std::locale &loc)
+    {
+        std::basic_string<Ch> result;
+        typename std::basic_string<Ch>::const_iterator b = s.begin();
+        typename std::basic_string<Ch>::const_iterator e = s.end();
+        while (b != e)
+        {
+            if (*b == Ch('\0')) result += Ch('\\'), result += Ch('0');
+            else if (*b == Ch('\b')) result += Ch('\\'), result += Ch('b');
+            else if (*b == Ch('\f')) result += Ch('\\'), result += Ch('f');
+            else if (*b == Ch('\n')) result += Ch('\\'), result += Ch('n');
+            else if (*b == Ch('\r')) result += Ch('\\'), result += Ch('r');
+            else if (*b == Ch('"')) result += Ch('\\'), result += Ch('"');
+            else if (*b == Ch('\\')) result += Ch('\\'), result += Ch('\\');
+            else
+            {
+                if (std::isprint(*b, loc))
+                    result += *b;
+                else
+                {   
+                    const char *hexdigits = "0123456789ABCDEF";
+                    unsigned long u = (std::min)(static_cast<unsigned long>(*b), 0xFFFFul);
+                    int d1 = u / 4096; u -= d1 * 4096;
+                    int d2 = u / 256; u -= d2 * 256;
+                    int d3 = u / 16; u -= d3 * 16;
+                    int d4 = u;
+                    result += Ch('\\'); result += Ch('u');
+                    result += Ch(hexdigits[d1]); result += Ch(hexdigits[d2]);
+                    result += Ch(hexdigits[d3]); result += Ch(hexdigits[d4]);
+                }
+            }
+            ++b;
+        }
+        return result;
+    }
+
+    template<class Ptree>
+    void write_json_helper(std::basic_ostream<typename Ptree::char_type> &stream, 
+                           const Ptree &pt, 
+                           int indent)
+    {
+
+        typedef typename Ptree::char_type Ch;
+        typedef typename std::basic_string<Ch> Str;
+        
+        // Value or object or array
+        if (indent > 0 && pt.empty())
+        {
+            
+            // Write value
+            Str data = create_escapes(pt.template get_own<Str>(), stream.getloc());
+            stream << Ch('"') << data << Ch('"');
+
+        }
+        else if (indent > 0 && pt.count(Str()) == pt.size())
+        {
+                
+            // Write array
+            stream << Ch('[') << Ch('\n');
+            typename Ptree::const_iterator it = pt.begin();
+            for (; it != pt.end(); ++it)
+            {
+                stream << Str(4 * (indent + 1), Ch(' '));
+                write_json_helper(stream, it->second, indent + 1);
+                if (boost::next(it) != pt.end())
+                    stream << Ch(',');
+                stream << Ch('\n');
+            }
+            stream << Str(4 * indent, Ch(' ')) << Ch(']');
+
+        }
+        else
+        {
+        
+            // Write object
+            stream << Ch('{') << Ch('\n');
+            typename Ptree::const_iterator it = pt.begin();
+            for (; it != pt.end(); ++it)
+            {
+                stream << Str(4 * (indent + 1), Ch(' '));
+                stream << Ch('"') << create_escapes(it->first, stream.getloc()) << Ch('"') << Ch(':');
+                if (it->second.empty())
+                    stream << Ch(' ');
+                else
+                    stream << Ch('\n') << Str(4 * (indent + 1), Ch(' '));
+                write_json_helper(stream, it->second, indent + 1);
+                if (boost::next(it) != pt.end())
+                    stream << Ch(',');
+                stream << Ch('\n');
+            }
+            stream << Str(4 * indent, Ch(' ')) << Ch('}');
+
+        }
+
+    }
+
+    // Verify if ptree does not contain information that cannot be written to json
+    template<class Ptree>
+    bool verify_json(const Ptree &pt, int depth)
+    {
+
+        typedef typename Ptree::char_type Ch;
+        typedef typename std::basic_string<Ch> Str;
+
+        // Root ptree cannot have data
+        if (depth == 0 && !pt.template get_own<Str>().empty())
+            return false;
+        
+        // Ptree cannot have both children and data
+        if (!pt.template get_own<Str>().empty() && !pt.empty())
+            return false;
+
+        // Check children
+        typename Ptree::const_iterator it = pt.begin();
+        for (; it != pt.end(); ++it)
+            if (!verify_json(it->second, depth + 1))
+                return false;
+
+        // Success
+        return true;
+
+    }
+    
+    // Write ptree to json stream
+    template<class Ptree>
+    void write_json_internal(std::basic_ostream<typename Ptree::char_type> &stream, 
+                             const Ptree &pt,
+                             const std::string &filename)
+    {
+        if (!verify_json(pt, 0))
+            throw json_parser_error("ptree contains data that cannot be represented in JSON format", filename, 0);
+        write_json_helper(stream, pt, 0);
+        stream << std::endl;
+        if (!stream.good())
+            throw json_parser_error("write error", filename, 0);
+    }
+
+} } }
+
+#endif

Added: trunk/boost/property_tree/detail/ptree_implementation.hpp
===================================================================
--- trunk/boost/property_tree/detail/ptree_implementation.hpp	2006-10-03 08:44:04 UTC (rev 304)
+++ trunk/boost/property_tree/detail/ptree_implementation.hpp	2006-10-03 08:49:51 UTC (rev 305)
@@ -0,0 +1,996 @@
+// ----------------------------------------------------------------------------
+// Copyright (C) 2002-2005 Marcin Kalicinski
+//
+// Distributed under the Boost Software License, Version 1.0. 
+// (See accompanying file LICENSE_1_0.txt or copy at 
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// For more information, see www.boost.org
+// ----------------------------------------------------------------------------
+#ifndef BOOST_PROPERTY_TREE_DETAIL_PTREE_IMPLEMENTATION_HPP_INCLUDED
+#define BOOST_PROPERTY_TREE_DETAIL_PTREE_IMPLEMENTATION_HPP_INCLUDED
+
+#include <sstream>
+#include <locale>
+#include <algorithm>
+#include <limits>
+#include <stdexcept>
+#include <functional>               // for std::less
+#include <memory>                   // for std::auto_ptr
+#include <boost/assert.hpp>
+#include <boost/static_assert.hpp>
+#include <boost/type_traits.hpp>
+#include <boost/utility.hpp>        // for boost::prior
+#include <boost/property_tree/detail/ptree_utils.hpp>
+
+//////////////////////////////////////////////////////////////////////////////
+// Debug macros
+
+#ifdef BOOST_PROPERTY_TREE_DEBUG
+
+    // Increment instances counter
+    #define BOOST_PROPERTY_TREE_DEBUG_INCREMENT_INSTANCES_COUNT()       \
+        {                                                               \
+            typedef boost::detail::lightweight_mutex::scoped_lock lock; \
+            lock l(debug_mutex);                                        \
+            ++debug_instances_count;                                    \
+        }
+
+    // Decrement instances counter
+    #define BOOST_PROPERTY_TREE_DEBUG_DECREMENT_INSTANCES_COUNT()       \
+        {                                                               \
+            typedef boost::detail::lightweight_mutex::scoped_lock lock; \
+            lock l(debug_mutex);                                        \
+            BOOST_ASSERT(debug_instances_count > 0);                    \
+            --debug_instances_count;                                    \
+        }
+
+#else // BOOST_PROPERTY_TREE_DEBUG
+
+    #define BOOST_PROPERTY_TREE_DEBUG_INCREMENT_INSTANCES_COUNT() static_cast<void>(0)
+    #define BOOST_PROPERTY_TREE_DEBUG_DECREMENT_INSTANCES_COUNT() static_cast<void>(0)
+
+#endif // BOOST_PROPERTY_TREE_DEBUG
+
+namespace boost { namespace property_tree
+{
+
+    namespace detail
+    {
+        
+        template<class T>
+        struct array_to_pointer_decay
+        {
+            typedef T type;
+        };
+
+        template<class T, std::size_t N>
+        struct array_to_pointer_decay<T[N]>
+        {
+            typedef const T *type;
+        };
+
+        ////////////////////////////////////////////////////////////////////////////
+        // Extractor and inserter
+
+        template<class Ch, class Type>
+        struct extractor
+        {
+            inline bool operator()(const std::basic_string<Ch> &data, 
+                                   Type &extracted,
+                                   const std::locale &loc) const
+            {
+                std::basic_istringstream<Ch> stream(data);
+                stream.imbue(loc);
+                stream >> extracted >> std::ws;
+                return stream.eof() && !stream.fail() && !stream.bad();
+            }
+        };
+
+        template<class Ch>
+        struct extractor<Ch, std::basic_string<Ch> >
+        {
+            inline bool operator()(const std::basic_string<Ch> &data, 
+                                   std::basic_string<Ch> &extracted,
+                                   const std::locale &loc) const
+            {
+                extracted = data;
+                return true;
+            }
+        };
+
+        template<class Ch, class Type>
+        struct inserter
+        {
+            inline bool operator()(std::basic_string<Ch> &data, 
+                                   const Type &to_insert,
+                                   const std::locale &loc) const
+            {
+                typedef typename detail::array_to_pointer_decay<Type>::type Type2;
+                std::basic_ostringstream<Ch> stream;
+                stream.imbue(loc);
+                if (std::numeric_limits<Type2>::is_specialized)
+                    stream.precision(std::numeric_limits<Type2>::digits10 + 1);
+                stream << to_insert;
+                data = stream.str();
+                return !stream.fail() && !stream.bad();
+            }
+        };
+
+        template<class Ch>
+        struct inserter<Ch, std::basic_string<Ch> >
+        {
+            inline bool operator()(std::basic_string<Ch> &data, 
+                                   const std::basic_string<Ch> &to_insert,
+                                   const std::locale &loc) const
+            {
+                data = to_insert;
+                return true;
+            }
+        };
+
+    }
+
+    ///////////////////////////////////////////////////////////////////////////
+    // Impl
+
+    template<class Tr>
+    struct basic_ptree<Tr>::impl
+    {
+        data_type m_data;
+        container_type m_container;
+        index_type m_index;
+    };
+
+    ////////////////////////////////////////////////////////////////////////////
+    // Traits
+
+    template<class Ch>
+    struct ptree_traits
+    {
+        typedef Ch char_type;
+        typedef std::basic_string<Ch> key_type;
+        typedef std::basic_string<Ch> data_type;
+        template<class Type>
+        struct extractor: public detail::extractor<Ch, Type> { };
+        template<class Type>
+        struct inserter: public detail::inserter<Ch, Type> { };
+        inline bool operator()(const key_type &key1, 
+                               const key_type &key2) const
+        {
+            return key1 < key2;
+        }
+    };
+
+    template<class Ch>
+    struct iptree_traits
+    {
+        std::locale loc;
+        typedef Ch char_type;
+        typedef std::basic_string<Ch> key_type;
+        typedef std::basic_string<Ch> data_type;
+        template<class Type>
+        struct extractor: public detail::extractor<Ch, Type> { };
+        template<class Type>
+        struct inserter: public detail::inserter<Ch, Type> { };
+        inline bool operator()(Ch c1, Ch c2) const      // Helper for comparing characters
+        {
+            return std::toupper(c1, loc) < std::toupper(c2, loc);
+        }
+        inline bool operator()(const key_type &key1, 
+                               const key_type &key2) const
+        {
+            return std::lexicographical_compare(key1.begin(), key1.end(), key2.begin(), key2.end(), *this);
+        }
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    // Exceptions
+
+    class ptree_error: public std::runtime_error
+    {
+    public:
+        ptree_error(const std::string &what): std::runtime_error(what) { }
+        ~ptree_error() throw() { }
+    };
+
+    class ptree_bad_data: public ptree_error
+    {
+    public:
+        ptree_bad_data(const std::string &what): ptree_error(what) { }
+        ~ptree_bad_data() throw() { }
+    };
+    
+    class ptree_bad_path: public ptree_error
+    {
+    public:
+        ptree_bad_path(const std::string &what): ptree_error(what) { }
+        ~ptree_bad_path() throw() { }
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    // Construction & destruction
+
+    template<class Tr>
+    basic_ptree<Tr>::basic_ptree()
+    {
+        m_impl = new impl;
+        BOOST_PROPERTY_TREE_DEBUG_INCREMENT_INSTANCES_COUNT();
+    }
+
+    template<class Tr>
+    basic_ptree<Tr>::basic_ptree(const data_type &rhs)
+    {
+        std::auto_ptr<impl> tmp(new impl);
+        tmp->m_data = rhs;
+        m_impl = tmp.release();
+        BOOST_PROPERTY_TREE_DEBUG_INCREMENT_INSTANCES_COUNT();
+    }
+
+    template<class Tr>
+    basic_ptree<Tr>::basic_ptree(const basic_ptree<Tr> &rhs)
+    {
+        std::auto_ptr<impl> tmp(new impl);
+        tmp->m_data = rhs.data();
+        m_impl = tmp.get();
+        insert(end(), rhs.begin(), rhs.end());
+        tmp.release();
+        BOOST_PROPERTY_TREE_DEBUG_INCREMENT_INSTANCES_COUNT();
+    }
+
+    template<class Tr>
+    basic_ptree<Tr>::~basic_ptree()
+    {
+        BOOST_PROPERTY_TREE_DEBUG_DECREMENT_INSTANCES_COUNT();
+        delete m_impl;
+    }
+
+    ///////////////////////////////////////////////////////////////////////////
+    // Iterator access
+
+    template<class Tr>
+    typename basic_ptree<Tr>::iterator 
+        basic_ptree<Tr>::begin()
+    {
+        return m_impl->m_container.begin();
+    }
+
+    template<class Tr>
+    typename basic_ptree<Tr>::const_iterator 
+        basic_ptree<Tr>::begin() const
+    {
+        return m_impl->m_container.begin();
+    }
+
+    template<class Tr>
+    typename basic_ptree<Tr>::iterator 
+        basic_ptree<Tr>::end()
+    {
+        return m_impl->m_container.end();
+    }
+
+    template<class Tr>
+    typename basic_ptree<Tr>::const_iterator 
+        basic_ptree<Tr>::end() const
+    {
+        return m_impl->m_container.end();
+    }
+
+    template<class Tr>
+    typename basic_ptree<Tr>::reverse_iterator 
+        basic_ptree<Tr>::rbegin()
+    {
+        return m_impl->m_container.rbegin();
+    }
+
+    template<class Tr>
+    typename basic_ptree<Tr>::const_reverse_iterator 
+        basic_ptree<Tr>::rbegin() const
+    {
+        return m_impl->m_container.rbegin();
+    }
+
+    template<class Tr>
+    typename basic_ptree<Tr>::reverse_iterator 
+        basic_ptree<Tr>::rend()
+    {
+        return m_impl->m_container.rend();
+    }
+
+    template<class Tr>
+    typename basic_ptree<Tr>::const_reverse_iterator 
+        basic_ptree<Tr>::rend() const
+    {
+        return m_impl->m_container.rend();
+    }
+
+    ///////////////////////////////////////////////////////////////////////////
+    // Data access
+
+    template<class Tr>
+    typename basic_ptree<Tr>::size_type 
+        basic_ptree<Tr>::size() const
+    {
+        return m_impl->m_index.size();
+    }
+
+    template<class Tr>
+    bool basic_ptree<Tr>::empty() const
+    {
+        return m_impl->m_index.empty();
+    }
+
+    template<class Tr>
+    typename basic_ptree<Tr>::data_type &
+        basic_ptree<Tr>::data()
+    {
+        return m_impl->m_data;
+    }
+
+    template<class Tr>
+    const typename basic_ptree<Tr>::data_type &
+        basic_ptree<Tr>::data() const
+    {
+        return m_impl->m_data;
+    }
+
+    template<class Tr>
+    typename basic_ptree<Tr>::value_type &
+        basic_ptree<Tr>::front()
+    {
+        return m_impl->m_container.front();
+    }
+    
+    template<class Tr>
+    const typename basic_ptree<Tr>::value_type &
+        basic_ptree<Tr>::front() const
+    {
+        return m_impl->m_container.front();
+    }
+
+    template<class Tr>
+    typename basic_ptree<Tr>::value_type &
+        basic_ptree<Tr>::back()
+    {
+        return m_impl->m_container.back();
+    }
+
+    template<class Tr>
+    const typename basic_ptree<Tr>::value_type &
+        basic_ptree<Tr>::back() const
+    {
+        return m_impl->m_container.back();
+    }
+
+    ///////////////////////////////////////////////////////////////////////////
+    // Operators
+
+    template<class Tr>
+    basic_ptree<Tr> &
+        basic_ptree<Tr>::operator =(const basic_ptree<Tr> &rhs)
+    {
+        if (&rhs != this)
+        {
+            clear();
+            data() = rhs.data();
+            insert(end(), rhs.begin(), rhs.end());
+        }
+        return *this;
+    }
+
+    template<class Tr>
+    bool basic_ptree<Tr>::operator ==(const basic_ptree<Tr> &rhs) const
+    {
+        
+        // Data and sizes must be equal
+        if (size() != rhs.size() || data() != rhs.data())
+            return false;
+
+        // Keys and children must be equal
+        Tr tr;
+        const_iterator it = begin();
+        const_iterator it_rhs = rhs.begin();
+        const_iterator it_end = end();
+        for (; it != it_end; ++it, ++it_rhs)
+            if (tr(it->first, it_rhs->first) || 
+                tr(it_rhs->first, it->first) || 
+                it->second != it_rhs->second)
+                return false;
+
+        // Equal
+        return true;
+
+    }
+
+    template<class Tr>
+    bool basic_ptree<Tr>::operator !=(const basic_ptree<Tr> &rhs) const
+    {
+        return !operator ==(rhs);
+    }
+
+    ///////////////////////////////////////////////////////////////////////////
+    // Container operations
+
+    template<class Tr>
+    typename basic_ptree<Tr>::iterator 
+        basic_ptree<Tr>::find(const key_type &key)
+    {
+        typename index_type::iterator it = m_impl->m_index.find(key);
+        return it == m_impl->m_index.end() ? end() : it->second;
+    }
+
+    template<class Tr>
+    typename basic_ptree<Tr>::const_iterator 
+        basic_ptree<Tr>::find(const key_type &key) const
+    {
+        typename index_type::const_iterator it = m_impl->m_index.find(key);
+        return it == m_impl->m_index.end() ? end() : it->second;
+    }
+
+    template<class Tr>
+    typename basic_ptree<Tr>::size_type 
+        basic_ptree<Tr>::count(const key_type &key) const
+    {
+        return m_impl->m_index.count(key);
+    }
+
+    template<class Tr>
+    void basic_ptree<Tr>::clear()
+    {
+        m_impl->m_data = data_type();
+        m_impl->m_container.clear();
+        m_impl->m_index.clear();
+    }
+
+    template<class Tr>
+    typename basic_ptree<Tr>::iterator 
+    basic_ptree<Tr>::insert(iterator where, 
+                                const value_type &value)
+    {
+
+        // Insert new value into container. If that throws nothing needs to be rolled back
+        where = m_impl->m_container.insert(where, value);
+
+        // Update index. If that throws we need to rollback the insert
+        try {
+            m_impl->m_index.insert(typename index_type::value_type(where->first, where));
+        } 
+        catch (...) {
+            m_impl->m_container.erase(where);   // rollback the insert
+            throw;
+        }
+
+        return where;
+    }
+
+    template<class Tr>
+    template<class It>
+    void basic_ptree<Tr>::insert(iterator where, 
+                                     It first, 
+                                     It last)
+    {
+        for (; first != last; ++first, ++where)
+            where = insert(where, value_type(first->first, first->second));
+    }
+
+    template<class Tr>
+    typename basic_ptree<Tr>::iterator 
+        basic_ptree<Tr>::erase(iterator where)
+    {
+
+        // Remove from index
+        typename index_type::iterator lo = m_impl->m_index.lower_bound(where->first);
+        typename index_type::iterator hi = m_impl->m_index.upper_bound(where->first);
+        for (; lo != hi; ++lo)
+            if (lo->second == where)
+            {
+                m_impl->m_index.erase(lo);
+                break;
+            }
+        
+        // Remove from container    
+        return m_impl->m_container.erase(where);
+
+    }
+
+    template<class Tr>
+    typename basic_ptree<Tr>::size_type 
+        basic_ptree<Tr>::erase(const key_type &key)
+    {
+        size_type count = 0;
+        typename index_type::iterator lo = m_impl->m_index.lower_bound(key);
+        if (lo != m_impl->m_index.end())
+        {
+            typename index_type::iterator hi = m_impl->m_index.upper_bound(key);
+            while (lo != hi)
+            {
+                typename index_type::iterator it = lo++;
+                erase(it->second);
+                ++count;
+            }
+        }
+        return count;
+    }
+
+    template<class Tr>
+    template<class It> 
+    typename basic_ptree<Tr>::iterator 
+        basic_ptree<Tr>::erase(It first, 
+                                   It last)
+    {
+        while (first != last)
+            first = erase(first);
+        return first;
+    }
+
+    template<class Tr>
+    typename basic_ptree<Tr>::iterator
+        basic_ptree<Tr>::push_front(const value_type &value)
+    {
+        return insert(begin(), value);
+    }
+
+    template<class Tr>
+    typename basic_ptree<Tr>::iterator
+        basic_ptree<Tr>::push_back(const value_type &value)
+    {
+        return insert(end(), value);
+    }
+
+    template<class Tr>
+    void basic_ptree<Tr>::pop_front()
+    {
+        erase(begin());
+    }
+
+    template<class Tr>
+    void basic_ptree<Tr>::pop_back()
+    {
+        erase(boost::prior(end()));
+    }
+        
+    template<class Tr>
+    void basic_ptree<Tr>::swap(basic_ptree<Tr> &rhs)
+    {
+        std::swap(m_impl, rhs.m_impl);
+    }
+
+    template<class Tr>
+    void basic_ptree<Tr>::reverse()
+    {
+        m_impl->m_container.reverse();
+    }
+    
+    template<class Tr>
+    template<class SortTr> 
+    void basic_ptree<Tr>::sort(SortTr tr)
+    {
+        m_impl->m_container.sort(tr);
+    }
+
+    ///////////////////////////////////////////////////////////////////////////
+    // ptree operations
+
+    // Get child ptree with custom separator
+    template<class Tr>
+    basic_ptree<Tr> &
+        basic_ptree<Tr>::get_child(char_type separator, 
+                                       const key_type &path)
+    {
+        if (optional<basic_ptree<Tr> &> result = get_child_optional(separator, path))
+            return result.get();
+        else
+            throw ptree_bad_path("key \"" + detail::narrow(path.c_str()) + "\" does not exist");
+    }
+
+    // Get child ptree with custom separator
+    template<class Tr>
+    const basic_ptree<Tr> &
+        basic_ptree<Tr>::get_child(char_type separator, 
+                                       const key_type &path) const
+    {
+        basic_ptree<Tr> *nc_this = const_cast<basic_ptree<Tr> *>(this);
+        return nc_this->get_child(separator, path);
+    }
+
+    // Get child ptree with custom separator
+    template<class Tr>
+    basic_ptree<Tr> &
+        basic_ptree<Tr>::get_child(char_type separator, 
+                                       const key_type &path, 
+                                       basic_ptree<Tr> &default_value)
+    {
+        if (optional<basic_ptree<Tr> &> result = get_child_optional(separator, path))
+            return result.get();
+        else
+            return default_value;
+    }
+
+    // Get child ptree with custom separator
+    template<class Tr>
+    const basic_ptree<Tr> &
+        basic_ptree<Tr>::get_child(char_type separator, 
+                                       const key_type &path, 
+                                       const basic_ptree<Tr> &default_value) const
+    {
+        basic_ptree<Tr> *nc_this = const_cast<basic_ptree<Tr> *>(this);
+        basic_ptree<Tr> &nc_default_value = const_cast<basic_ptree<Tr> &>(default_value);
+        return nc_this->get_child(separator, path, nc_default_value);
+    }
+
+
+    // Get child ptree with custom separator
+    template<class Tr>
+    optional<basic_ptree<Tr> &> 
+        basic_ptree<Tr>::get_child_optional(char_type separator, 
+                                                const key_type &path)
+    {
+        typename key_type::size_type n = path.find(separator);
+        if (n != key_type::npos)
+        {
+            key_type head = path.substr(0, n);
+            key_type tail = path.substr(n + 1, key_type::npos);
+            iterator it = find(head);
+            if (it != end())
+                return it->second.get_child_optional(separator, tail);
+            else
+                return optional<basic_ptree<Tr> &>();
+        }
+        else
+        {
+            iterator it = find(path);
+            if (it != end())
+                return it->second;
+            else
+                return optional<basic_ptree<Tr> &>();
+        }
+    }
+
+    // Get child ptree with custom separator
+    template<class Tr>
+    optional<const basic_ptree<Tr> &> 
+        basic_ptree<Tr>::get_child_optional(char_type separator, const key_type &path) const
+    {
+        basic_ptree<Tr> *nc_this = const_cast<basic_ptree<Tr> *>(this);
+        optional<basic_ptree<Tr> &> tmp = nc_this->get_child_optional(separator, path);
+        if (tmp)
+            return optional<const basic_ptree<Tr> &>(tmp.get());
+        else
+            return optional<const basic_ptree<Tr> &>();
+    }
+
+    // Get child ptree with default separator
+    template<class Tr>
+    basic_ptree<Tr> &
+        basic_ptree<Tr>::get_child(const key_type &path)
+    {
+        return get_child(char_type('.'), path);
+    }
+
+    // Get child ptree with default separator
+    template<class Tr>
+    const basic_ptree<Tr> &
+        basic_ptree<Tr>::get_child(const key_type &path) const
+    {
+        return get_child(char_type('.'), path);
+    }
+
+    // Get child ptree with default separator
+    template<class Tr>
+    basic_ptree<Tr> &
+        basic_ptree<Tr>::get_child(const key_type &path, 
+                                       basic_ptree<Tr> &default_value)
+    {
+        return get_child(char_type('.'), path, default_value);
+    }
+    
+    // Get child ptree with default separator
+    template<class Tr>
+    const basic_ptree<Tr> &
+        basic_ptree<Tr>::get_child(const key_type &path, 
+                                       const basic_ptree<Tr> &default_value) const
+    {
+        return get_child(char_type('.'), path, default_value);
+    }
+    
+    // Get child ptree with default separator
+    template<class Tr>
+    optional<basic_ptree<Tr> &> 
+        basic_ptree<Tr>::get_child_optional(const key_type &path)
+    {
+        return get_child_optional(char_type('.'), path);
+    }
+
+    // Get child ptree with default separator
+    template<class Tr>
+    optional<const basic_ptree<Tr> &> 
+        basic_ptree<Tr>::get_child_optional(const key_type &path) const
+    {
+        return get_child_optional(char_type('.'), path);
+    }
+
+    // Put child ptree with custom separator
+    template<class Tr>
+    basic_ptree<Tr> &
+        basic_ptree<Tr>::put_child(char_type separator, 
+                                   const key_type &path, 
+                                   const basic_ptree<Tr> &value,
+                                   bool do_not_replace)
+    {
+        typename key_type::size_type n = path.find(separator);
+        if (n == key_type::npos)
+        {
+            if (do_not_replace)
+                return push_back(value_type(path, value))->second;
+            else
+            {
+                iterator it = find(path);
+                if (it == end())
+                    return push_back(value_type(path, value))->second;
+                else
+                {
+                    it->second = value;
+                    return it->second;
+                }
+            }
+        }
+        else
+        {
+            key_type head = path.substr(0, n);
+            key_type tail = path.substr(n + 1, key_type::npos);
+            iterator it = find(head);
+            if (it == end())
+                it = push_back(value_type(head, basic_ptree<Tr>()));
+            return it->second.put_child(separator, tail, value, do_not_replace);
+        }
+    }
+
+    // Put child ptree with default separator
+    template<class Tr>
+    basic_ptree<Tr> &
+        basic_ptree<Tr>::put_child(const key_type &path,
+                                   const basic_ptree<Tr> &value,
+                                   bool do_not_replace)
+    {
+        return put_child(char_type('.'), path, value, do_not_replace);
+    }
+
+    // Get value from data of ptree
+    template<class Tr>
+    template<class Type>
+    Type basic_ptree<Tr>::get_own(const std::locale &loc) const
+    {
+        if (optional<Type> result = get_own_optional<Type>(loc))
+            return result.get();
+        else
+            throw ptree_bad_data(std::string("conversion of data into type '") + 
+                                 typeid(Type).name() + "' failed");
+    }
+
+    // Get value from data of ptree
+    template<class Tr>
+    template<class Type>
+    Type basic_ptree<Tr>::get_own(const Type &default_value, 
+                                      const std::locale &loc) const
+    {
+        if (optional<Type> result = get_own_optional<Type>(loc))
+            return result.get();
+        else
+            return default_value;
+    }
+
+    // Get value from data of ptree
+    template<class Tr>
+    template<class CharType>
+    std::basic_string<CharType> 
+        basic_ptree<Tr>::get_own(const CharType *default_value, 
+                                     const std::locale &loc) const
+    {
+        BOOST_STATIC_ASSERT((boost::is_same<char_type, CharType>::value == true)); // Character types must match
+        return get_own(std::basic_string<CharType>(default_value), loc);
+    }
+
+    // Get value from data of ptree
+    template<class Tr>
+    template<class Type>
+    optional<Type> 
+        basic_ptree<Tr>::get_own_optional(const std::locale &loc) const
+    {
+        BOOST_STATIC_ASSERT(boost::is_pointer<Type>::value == false);   // Disallow pointer types, they are unsafe
+        Type tmp;
+        if (typename traits_type::template extractor<Type>()(m_impl->m_data, tmp, loc))
+        {
+            return optional<Type>(tmp);
+        }
+        else
+            return optional<Type>();
+    }
+
+    // Get value from data of child ptree (custom path separator)
+    template<class Tr>
+    template<class Type>
+    Type basic_ptree<Tr>::get(char_type separator,
+                                  const key_type &path,
+                                  const std::locale &loc) const
+    {
+        return get_child(separator, path).get_own<Type>(loc);
+    }
+
+    // Get value from data of child ptree (custom path separator)
+    template<class Tr>
+    template<class Type>
+    Type basic_ptree<Tr>::get(char_type separator,
+                                  const key_type &path, 
+                                  const Type &default_value, 
+                                  const std::locale &loc) const
+    {
+        if (optional<Type> result = get_optional<Type>(separator, path, loc))
+            return *result;
+        else
+            return default_value;
+    }
+
+    // Get value from data of child ptree (custom path separator)
+    template<class Tr>
+    template<class CharType>
+    std::basic_string<CharType> 
+        basic_ptree<Tr>::get(char_type separator,
+                                 const key_type &path, 
+                                 const CharType *default_value,
+                                 const std::locale &loc) const
+    {
+        BOOST_STATIC_ASSERT((boost::is_same<char_type, CharType>::value == true)); // Character types must match
+        return get(separator, path, std::basic_string<CharType>(default_value), loc);
+    }
+
+    // Get value from data of child ptree (custom path separator)
+    template<class Tr>
+    template<class Type>
+    optional<Type> 
+        basic_ptree<Tr>::get_optional(char_type separator,
+                                          const key_type &path, 
+                                          const std::locale &loc) const
+    {
+        if (optional<const basic_ptree<Tr> &> child = get_child_optional(separator, path))
+            return child.get().get_own_optional<Type>(loc);
+        else
+            return optional<Type>();
+    }
+
+    // Get value from data of child ptree (default path separator)
+    template<class Tr>
+    template<class Type>
+    Type basic_ptree<Tr>::get(const key_type &path,
+                                  const std::locale &loc) const
+    {
+        return get<Type>(char_type('.'), path, loc);
+    }
+
+    // Get value from data of child ptree (default path separator)
+    template<class Tr>
+    template<class Type>
+    Type basic_ptree<Tr>::get(const key_type &path, 
+                                  const Type &default_value,
+                                  const std::locale &loc) const
+    {
+        return get(char_type('.'), path, default_value, loc);
+    }
+
+    // Get value from data of child ptree (default path separator)
+    template<class Tr>
+    template<class CharType>
+    std::basic_string<CharType> 
+        basic_ptree<Tr>::get(const key_type &path, 
+                                 const CharType *default_value,
+                                 const std::locale &loc) const
+    {
+        return get(char_type('.'), path, default_value, loc);
+    }
+
+    // Get value from data of child ptree (default path separator)
+    template<class Tr>
+    template<class Type>
+    optional<Type> 
+        basic_ptree<Tr>::get_optional(const key_type &path, 
+                                          const std::locale &loc) const
+    {
+        return get_optional<Type>(char_type('.'), path, loc);
+    }
+
+    // Put value in data of ptree
+    template<class Tr>
+    template<class Type> 
+    void basic_ptree<Tr>::put_own(const Type &value, const std::locale &loc)
+    {
+        using namespace boost;
+        // Make sure that no pointer other than char_type * is allowed
+        BOOST_STATIC_ASSERT((is_pointer<Type>::value == false ||
+                             is_same<char_type, typename remove_const<typename remove_pointer<Type>::type>::type>::value == true));
+        typename traits_type::template inserter<Type>()(m_impl->m_data, value, loc);
+    }
+
+    // Put value in data of child ptree (custom path separator)
+    template<class Tr>
+    template<class Type> 
+    basic_ptree<Tr> &
+        basic_ptree<Tr>::put(char_type separator,
+                             const key_type &path, 
+                             const Type &value,
+                             bool do_not_replace,
+                             const std::locale &loc)
+    {
+        optional<basic_ptree<Tr> &> child;
+        if (!do_not_replace &&
+            (child = get_child_optional(separator, path)))
+        {
+            child.get().put_own(value, loc);
+            return *child;
+        }
+        else
+        {
+            basic_ptree<Tr> &child2 = put_child(separator, path, empty_ptree<basic_ptree<Tr> >(), do_not_replace);
+            child2.put_own(value, loc);
+            return child2;
+        }
+    }
+
+    // Put value in data of child ptree (default path separator)
+    template<class Tr>
+    template<class Type> 
+    basic_ptree<Tr> &
+        basic_ptree<Tr>::put(const key_type &path, 
+                             const Type &value,
+                             bool do_not_replace,
+                             const std::locale &loc)
+    {
+        return put(char_type('.'), path, value, do_not_replace, loc);
+    }
+
+    ////////////////////////////////////////////////////////////////////////////
+    // Debugging
+
+#ifdef BOOST_PROPERTY_TREE_DEBUG
+
+    template<class Tr>
+    typename basic_ptree<Tr>::size_type 
+        basic_ptree<Tr>::debug_get_instances_count() 
+    { 
+        empty_ptree<basic_ptree<Tr> >();    // Make sure empty ptree exists
+        return debug_instances_count - 1;       // Do not count empty ptree
+    }
+
+    template<class Tr>
+    typename basic_ptree<Tr>::size_type 
+        basic_ptree<Tr>::debug_instances_count;
+
+    template<class Tr>
+    boost::detail::lightweight_mutex 
+        basic_ptree<Tr>::debug_mutex;
+
+#endif
+
+    ///////////////////////////////////////////////////////////////////////////
+    // Free functions
+
+    template<class Ptree> 
+    inline const Ptree &empty_ptree()
+    {
+        static Ptree pt;
+        return pt;
+    }
+
+    template<class Tr>
+    inline void swap(basic_ptree<Tr> &pt1, basic_ptree<Tr> &pt2)
+    {
+        pt1.swap(pt2);
+    }
+
+} }
+
+// Undefine debug macros
+#ifdef BOOST_PROPERTY_TREE_DEBUG
+#   undef BOOST_PROPERTY_TREE_DEBUG_INCREMENT_INSTANCES_COUNT
+#   undef BOOST_PROPERTY_TREE_DEBUG_DECREMENT_INSTANCES_COUNT
+#endif
+
+#endif

Added: trunk/boost/property_tree/detail/ptree_interface.hpp
===================================================================
--- trunk/boost/property_tree/detail/ptree_interface.hpp	2006-10-03 08:44:04 UTC (rev 304)
+++ trunk/boost/property_tree/detail/ptree_interface.hpp	2006-10-03 08:49:51 UTC (rev 305)
@@ -0,0 +1,198 @@
+// ----------------------------------------------------------------------------
+// Copyright (C) 2002-2005 Marcin Kalicinski
+//
+// Distributed under the Boost Software License, Version 1.0. 
+// (See accompanying file LICENSE_1_0.txt or copy at 
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// For more information, see www.boost.org
+// ----------------------------------------------------------------------------
+#ifndef BOOST_PROPERTY_TREE_DETAIL_PTREE_INTERFACE_HPP_INCLUDED
+#define BOOST_PROPERTY_TREE_DETAIL_PTREE_INTERFACE_HPP_INCLUDED
+
+#include <boost/config.hpp>
+#include <boost/optional.hpp>
+#include <string>
+#include <list>
+#include <map>
+#include <utility>          // For std::pair
+#include <locale>
+
+#include "boost/property_tree/ptree_fwd.hpp"
+
+#ifdef BOOST_PROPERTY_TREE_DEBUG
+#   include <boost/detail/lightweight_mutex.hpp>   // For syncing debug instances counter
+#endif
+
+namespace boost { namespace property_tree
+{
+
+    ///////////////////////////////////////////////////////////////////////////
+    // basic_ptree class template
+
+    template<class Tr>
+    class basic_ptree
+    {
+
+    public:
+
+        // Basic types
+        typedef Tr traits_type;
+        typedef typename traits_type::char_type char_type;
+        typedef typename traits_type::key_type key_type;
+        typedef typename traits_type::data_type data_type;
+        
+        // Container-related types
+        typedef std::pair<key_type, basic_ptree<Tr> > value_type;
+        typedef std::list<value_type> container_type;
+        typedef typename container_type::size_type size_type;
+        typedef typename container_type::iterator iterator;
+        typedef typename container_type::const_iterator const_iterator;
+        typedef typename container_type::reverse_iterator reverse_iterator;
+        typedef typename container_type::const_reverse_iterator const_reverse_iterator;
+        
+        ///////////////////////////////////////////////////////////////////////////
+        // Construction & destruction
+
+        basic_ptree();
+        explicit basic_ptree(const data_type &data);
+        basic_ptree(const basic_ptree<Tr> &rhs);
+        ~basic_ptree();
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Iterator access
+
+        iterator begin();
+        const_iterator begin() const;
+        iterator end();
+        const_iterator end() const;
+        reverse_iterator rbegin();
+        const_reverse_iterator rbegin() const;
+        reverse_iterator rend();
+        const_reverse_iterator rend() const;
+        
+        ///////////////////////////////////////////////////////////////////////////
+        // Data access
+
+        size_type size() const;
+        bool empty() const;
+        
+        data_type &data();
+        const data_type &data() const;
+
+        value_type &front();
+        const value_type &front() const;
+        value_type &back();
+        const value_type &back() const;
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Operators
+
+        basic_ptree<Tr> &operator =(const basic_ptree<Tr> &rhs);
+
+        bool operator ==(const basic_ptree<Tr> &rhs) const;
+        bool operator !=(const basic_ptree<Tr> &rhs) const;
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Container operations
+
+        iterator find(const key_type &key);
+        const_iterator find(const key_type &key) const;
+
+        size_type count(const key_type &key) const;
+
+        void clear();
+
+        iterator insert(iterator where, const value_type &value);
+        template<class It> void insert(iterator where, It first, It last);
+
+        iterator erase(iterator where);
+        size_type erase(const key_type &key);
+        template<class It> iterator erase(It first, It last);
+
+        iterator push_front(const value_type &value);
+        iterator push_back(const value_type &value);
+
+        void pop_front();
+        void pop_back();
+
+        void swap(basic_ptree<Tr> &rhs);
+
+        void reverse();
+        template<class SortTr> void sort(SortTr tr);
+
+        ///////////////////////////////////////////////////////////////////////////
+        // ptree operations
+
+        // Get child ptree with custom separator
+        basic_ptree<Tr> &get_child(char_type separator, const key_type &path);
+        const basic_ptree<Tr> &get_child(char_type separator, const key_type &path) const;
+        basic_ptree<Tr> &get_child(char_type separator, const key_type &path, basic_ptree<Tr> &default_value);
+        const basic_ptree<Tr> &get_child(char_type separator, const key_type &path, const basic_ptree<Tr> &default_value) const;
+        optional<basic_ptree<Tr> &> get_child_optional(char_type separator, const key_type &path);
+        optional<const basic_ptree<Tr> &> get_child_optional(char_type separator, const key_type &path) const;
+
+        // Get child ptree with default separator
+        basic_ptree<Tr> &get_child(const key_type &path);
+        const basic_ptree<Tr> &get_child(const key_type &path) const;
+        basic_ptree<Tr> &get_child(const key_type &path, basic_ptree<Tr> &default_value);
+        const basic_ptree<Tr> &get_child(const key_type &path, const basic_ptree<Tr> &default_value) const;
+        optional<basic_ptree<Tr> &> get_child_optional(const key_type &path);
+        optional<const basic_ptree<Tr> &> get_child_optional(const key_type &path) const;
+
+        // Put child ptree with custom separator
+        basic_ptree<Tr> &put_child(char_type separator, const key_type &path, const basic_ptree<Tr> &value, bool do_not_replace = false);
+
+        // Put child ptree with default separator
+        basic_ptree<Tr> &put_child(const key_type &path, const basic_ptree<Tr> &value, bool do_not_replace = false);
+
+        // Get value from data of ptree
+        template<class Type> Type get_own(const std::locale &loc = std::locale()) const;
+        template<class Type> Type get_own(const Type &default_value, const std::locale &loc = std::locale()) const;
+        template<class CharType> std::basic_string<CharType> get_own(const CharType *default_value, const std::locale &loc = std::locale()) const;
+        template<class Type> optional<Type> get_own_optional(const std::locale &loc = std::locale()) const;
+
+        // Get value from data of child ptree (custom path separator)
+        template<class Type> Type get(char_type separator, const key_type &path, const std::locale &loc = std::locale()) const;
+        template<class Type> Type get(char_type separator, const key_type &path, const Type &default_value, const std::locale &loc = std::locale()) const;
+        template<class CharType> std::basic_string<CharType> get(char_type separator, const key_type &path, const CharType *default_value, const std::locale &loc = std::locale()) const;
+        template<class Type> optional<Type> get_optional(char_type separator, const key_type &path, const std::locale &loc = std::locale()) const;
+
+        // Get value from data of child ptree (default path separator)
+        template<class Type> Type get(const key_type &path, const std::locale &loc = std::locale()) const;
+        template<class Type> Type get(const key_type &path, const Type &default_value, const std::locale &loc = std::locale()) const;
+        template<class CharType> std::basic_string<CharType> get(const key_type &path, const CharType *default_value, const std::locale &loc = std::locale()) const;
+        template<class Type> optional<Type> get_optional(const key_type &path, const std::locale &loc = std::locale()) const;
+
+        // Put value in data of ptree
+        template<class Type> void put_own(const Type &value, const std::locale &loc = std::locale());
+
+        // Put value in data of child ptree (custom path separator)
+        template<class Type> basic_ptree<Tr> &put(char_type separator, const key_type &path, const Type &value, bool do_not_replace = false, const std::locale &loc = std::locale());
+
+        // Put value in data of child ptree (default path separator)
+        template<class Type> basic_ptree<Tr> &put(const key_type &path, const Type &value, bool do_not_replace = false, const std::locale &loc = std::locale());
+
+    private:
+
+        typedef std::multimap<key_type, iterator, Tr> index_type;
+        
+        struct impl;
+        impl *m_impl;
+
+        ////////////////////////////////////////////////////////////////////////////
+        // Debugging
+
+#ifdef BOOST_PROPERTY_TREE_DEBUG
+    private:
+        static boost::detail::lightweight_mutex debug_mutex;    // Mutex for syncing instances counter
+        static size_type debug_instances_count;                 // Total number of instances of this ptree class
+    public:
+        static size_type debug_get_instances_count();
+#endif
+
+    };
+
+} }
+
+#endif

Added: trunk/boost/property_tree/detail/ptree_utils.hpp
===================================================================
--- trunk/boost/property_tree/detail/ptree_utils.hpp	2006-10-03 08:44:04 UTC (rev 304)
+++ trunk/boost/property_tree/detail/ptree_utils.hpp	2006-10-03 08:49:51 UTC (rev 305)
@@ -0,0 +1,72 @@
+// ----------------------------------------------------------------------------
+// Copyright (C) 2002-2005 Marcin Kalicinski
+//
+// Distributed under the Boost Software License, Version 1.0. 
+// (See accompanying file LICENSE_1_0.txt or copy at 
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// For more information, see www.boost.org
+// ----------------------------------------------------------------------------
+#ifndef BOOST_PROPERTY_TREE_DETAIL_PTREE_UTILS_HPP_INCLUDED
+#define BOOST_PROPERTY_TREE_DETAIL_PTREE_UTILS_HPP_INCLUDED
+
+#include <boost/property_tree/ptree.hpp>
+#include <string>
+#include <locale>
+
+namespace boost { namespace property_tree { namespace detail
+{
+
+    // Naively convert narrow string to another character type
+    template<class Ch>
+    std::basic_string<Ch> widen(const char *text)
+    {
+        std::locale loc;
+        std::basic_string<Ch> result;
+        while (*text)
+        {
+            result += Ch(*text);
+            ++text;
+        }
+        return result;
+    }
+
+    // Naively convert string to narrow character type
+    template<class Ch>
+    std::string narrow(const Ch *text)
+    {
+        std::locale loc;
+        std::string result;
+        while (*text)
+        {
+            if (*text < 0 || *text > (std::numeric_limits<char>::max)())
+                result += '*';
+            else
+                result += char(*text);
+            ++text;
+        }
+        return result;
+    }
+
+    // Remove trailing and leading spaces
+    template<class Ch>
+    std::basic_string<Ch> trim(const std::basic_string<Ch> &s, 
+                               const std::locale &loc = std::locale())
+    {
+        typename std::basic_string<Ch>::const_iterator first = s.begin();
+        typename std::basic_string<Ch>::const_iterator end = s.end();
+        while (first != end && std::isspace(*first, loc)) 
+            ++first;
+        if (first == end)
+            return std::basic_string<Ch>();
+        typename std::basic_string<Ch>::const_iterator last = end;
+        do --last; while (std::isspace(*last, loc)); 
+        if (first != s.begin() || last + 1 != end)
+            return std::basic_string<Ch>(first, last + 1);
+        else
+            return s;
+    }
+
+} } }
+
+#endif

Added: trunk/boost/property_tree/detail/xml_parser_error.hpp
===================================================================
--- trunk/boost/property_tree/detail/xml_parser_error.hpp	2006-10-03 08:44:04 UTC (rev 304)
+++ trunk/boost/property_tree/detail/xml_parser_error.hpp	2006-10-03 08:49:51 UTC (rev 305)
@@ -0,0 +1,33 @@
+// ----------------------------------------------------------------------------
+// Copyright (C) 2002-2005 Marcin Kalicinski
+//
+// Distributed under the Boost Software License, Version 1.0. 
+// (See accompanying file LICENSE_1_0.txt or copy at 
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// For more information, see www.boost.org
+// ----------------------------------------------------------------------------
+#ifndef BOOST_PROPERTY_TREE_DETAIL_XML_PARSER_ERROR_HPP_INCLUDED
+#define BOOST_PROPERTY_TREE_DETAIL_XML_PARSER_ERROR_HPP_INCLUDED
+
+#include <boost/property_tree/detail/file_parser_error.hpp>
+#include <string>
+
+namespace boost { namespace property_tree { namespace xml_parser
+{
+
+    //! Xml parser error
+    class xml_parser_error: public file_parser_error
+    {
+    public:
+        xml_parser_error(const std::string &message, 
+                         const std::string &filename, 
+                         unsigned long line): 
+            file_parser_error(message, filename, line)
+        { 
+        }
+    };
+
+} } }
+
+#endif

Added: trunk/boost/property_tree/detail/xml_parser_flags.hpp
===================================================================
--- trunk/boost/property_tree/detail/xml_parser_flags.hpp	2006-10-03 08:44:04 UTC (rev 304)
+++ trunk/boost/property_tree/detail/xml_parser_flags.hpp	2006-10-03 08:49:51 UTC (rev 305)
@@ -0,0 +1,26 @@
+// ----------------------------------------------------------------------------
+// Copyright (C) 2002-2005 Marcin Kalicinski
+//
+// Distributed under the Boost Software License, Version 1.0. 
+// (See accompanying file LICENSE_1_0.txt or copy at 
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// For more information, see www.boost.org
+// ----------------------------------------------------------------------------
+#ifndef BOOST_PROPERTY_TREE_DETAIL_XML_PARSER_FLAGS_HPP_INCLUDED
+#define BOOST_PROPERTY_TREE_DETAIL_XML_PARSER_FLAGS_HPP_INCLUDED
+
+namespace boost { namespace property_tree { namespace xml_parser
+{
+    
+    static const int no_concat_text = 1;     // Text elements should be put in separate keys, not concatenated in parent data
+    static const int no_comments = 2;        // Comments should be omitted
+
+    inline bool validate_flags(int flags)
+    {
+        return (flags & ~(no_concat_text | no_comments)) == 0;
+    }
+
+} } }
+
+#endif

Added: trunk/boost/property_tree/detail/xml_parser_read_spirit.hpp
===================================================================
--- trunk/boost/property_tree/detail/xml_parser_read_spirit.hpp	2006-10-03 08:44:04 UTC (rev 304)
+++ trunk/boost/property_tree/detail/xml_parser_read_spirit.hpp	2006-10-03 08:49:51 UTC (rev 305)
@@ -0,0 +1,729 @@
+// ----------------------------------------------------------------------------
+// Copyright (C) 2002-2005 Marcin Kalicinski
+//
+// Distributed under the Boost Software License, Version 1.0. 
+// (See accompanying file LICENSE_1_0.txt or copy at 
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// Based on XML grammar by Daniel C. Nuffer 
+// http://spirit.sourceforge.net/repository/applications/xml.zip
+// 
+// For more information, see www.boost.org
+// ----------------------------------------------------------------------------
+#ifndef BOOST_PROPERTY_TREE_DETAIL_XML_PARSER_READ_SPIRIT_HPP_INCLUDED
+#define BOOST_PROPERTY_TREE_DETAIL_XML_PARSER_READ_SPIRIT_HPP_INCLUDED
+
+//#define BOOST_SPIRIT_DEBUG
+
+#include <boost/property_tree/ptree.hpp>
+#include <boost/property_tree/detail/xml_parser_error.hpp>
+#include <boost/property_tree/detail/xml_parser_flags.hpp>
+#include <boost/property_tree/detail/xml_parser_utils.hpp>
+#include <boost/spirit.hpp>
+#include <boost/spirit/iterator/position_iterator.hpp>
+#include <string>
+#include <locale>
+#include <istream>
+#include <vector>
+
+namespace boost { namespace property_tree { namespace xml_parser
+{
+
+    // XML parser context
+    template<class Ptree>
+    struct context
+    {
+        
+        typedef typename Ptree::char_type Ch;
+        typedef std::basic_string<Ch> Str;
+        typedef boost::spirit::position_iterator<typename std::vector<Ch>::const_iterator> It;
+
+        int flags;
+        std::vector<Ptree *> stack;
+
+        ///////////////////////////////////////////////////////////////////////
+        // Actions
+        
+        struct a_key_s
+        {
+            context &c;
+            a_key_s(context &c): c(c) { }
+            void operator()(It b, It e) const
+            {
+                if (c.stack.empty())
+                    throw xml_parser_error("xml parse error", 
+                                           b.get_position().file, 
+                                           b.get_position().line);
+                Str name(b, e);
+                Ptree *child = &c.stack.back()->push_back(std::make_pair(name, Ptree()))->second;
+                c.stack.push_back(child);
+            }
+        };
+
+        struct a_key_e
+        {
+            context &c;
+            a_key_e(context &c): c(c) { }
+            void operator()(It b, It e) const
+            {
+                if (c.stack.size() <= 1)
+                    throw xml_parser_error("xml parse error", 
+                                           b.get_position().file, 
+                                           b.get_position().line);
+                c.stack.pop_back();
+            }
+        };
+
+        struct a_content
+        {
+            context &c;
+            a_content(context &c): c(c) { }
+            void operator()(It b, It e) const
+            {
+                Str s = decode_char_entities(detail::trim(condense(Str(b, e))));
+                if (!s.empty())
+                {
+                    if (c.flags & no_concat_text)
+                        c.stack.back()->push_back(std::make_pair(xmltext<Ch>(), Ptree(s)));
+                    else
+                        c.stack.back()->put_own(c.stack.back()->template get_own<std::basic_string<Ch> >() + s);
+                }
+            }
+        };
+
+        struct a_attr_key
+        {
+            context &c;
+            a_attr_key(context &c): c(c) { }
+            void operator()(It b, It e) const
+            {
+                c.stack.back()->put_child(Ch('/'), xmlattr<Ch>() + Ch('/') + Str(b, e), empty_ptree<Ptree>());
+            }
+        };
+
+        struct a_attr_data
+        {
+            context &c;
+            a_attr_data(context &c): c(c) { }
+            void operator()(It b, It e) const
+            {
+                Ptree &attr = c.stack.back()->get_child(xmlattr<Ch>());
+                attr.back().second.put_own(Str(b + 1, e - 1));
+            }
+        };
+
+        struct a_comment
+        {
+            context &c;
+            a_comment(context &c): c(c) { }
+            void operator()(It b, It e) const
+            {
+                c.stack.back()->push_back(std::make_pair(xmlcomment<Ch>(), Ptree(Str(b, e))));
+            }
+        };
+
+    };
+
+    ///////////////////////////////////////////////////////////////////////
+    // Grammar
+        
+    template<class Ptree>
+    struct xml_grammar: public boost::spirit::grammar<xml_grammar<Ptree> >
+    {
+        
+        typedef context<Ptree> context_t;
+        
+        mutable context_t c;
+        
+        template<class ScannerT>
+        struct definition
+        {
+            
+            typedef typename ScannerT::value_t char_t;
+            typedef boost::spirit::chset<char_t> chset_t;
+
+            boost::spirit::rule<ScannerT>
+                prolog, element, Misc, PEReference, Reference, PITarget, CData,
+                doctypedecl, XMLDecl, SDDecl, VersionInfo, EncodingDecl, VersionNum,
+                Eq, DeclSep, ExternalID, markupdecl, NotationDecl, EntityDecl,
+                AttlistDecl, elementdecl, TextDecl, extSubsetDecl, conditionalSect,
+                EmptyElemTag, STag, content, ETag, Attribute, contentspec, Mixed,
+                children, choice, seq, cp, AttDef, AttType, DefaultDecl, StringType,
+                TokenizedType, EnumeratedType, NotationType, Enumeration, EntityValue,
+                AttValue, SystemLiteral, PubidLiteral, CharDataChar, CharData, Comment,
+                PI, CDSect, extSubset, includeSect, ignoreSect, ignoreSectContents,
+                Ignore, CharRef, EntityRef, GEDecl, PEDecl, EntityDef, PEDef,
+                NDataDecl, extParsedEnt, EncName, PublicID, document, S, Name, Names,
+                Nmtoken, Nmtokens, STagB, STagE1, STagE2;
+
+            definition(const xml_grammar &self)
+            {
+                
+                using namespace boost::spirit;
+                
+                // XML Char sets
+                chset_t Char("\x9\xA\xD\x20-\x7F");
+                chset_t Sch("\x20\x9\xD\xA");
+                chset_t Letter("\x41-\x5A\x61-\x7A");
+                chset_t Digit("0-9");
+                chset_t XDigit("0-9A-Fa-f");
+                chset_t Extender("\xB7");
+                chset_t NameChar =
+                    Letter 
+                    | Digit 
+                    | (char_t)'.'
+                    | (char_t)'-'
+                    | (char_t)'_'
+                    | (char_t)':'
+                    | Extender;
+
+                document =
+                    prolog >> element >> *Misc
+                ;
+
+                S = 
+                    +(Sch)
+                ;
+
+                Name =
+                    (Letter | '_' | ':') 
+                    >> *(NameChar)
+                ;
+
+                Names =
+                    Name >> *(S >> Name)
+                ;
+
+                Nmtoken =
+                    +NameChar
+                ;
+
+                Nmtokens =
+                    Nmtoken >> *(S >> Nmtoken)
+                ;
+
+                EntityValue =
+                    '"'  >> *(  (anychar_p - (chset_t(detail::widen<char_t>("%&\"").c_str()))) 
+                                | PEReference
+                                | Reference) 
+                        >> '"'
+                    | '\'' >> *(  (anychar_p - (chset_t("%&'"))) 
+                                | PEReference
+                                | Reference) 
+                            >> '\''
+                ;
+
+                AttValue = 
+                    '"' >> *(  (anychar_p - (chset_t("<&\""))) 
+                                | Reference) 
+                        >> '"'
+                    | '\'' >> *(  (anychar_p - (chset_t("<&'"))) 
+                                | Reference) 
+                            >> '\''
+                ;
+
+                SystemLiteral= 
+                    ('"' >> *(anychar_p - '"') >> '"')
+                    | ('\'' >> *(anychar_p - '\'') >> '\'')
+                ;
+
+                chset_t PubidChar("\x20\xD\xA'a-zA-Z0-9()+,./:=?;!*#@$_%-");
+
+                PubidLiteral = 
+                    '"' >> *PubidChar >> '"' 
+                    | '\'' >> *(PubidChar - '\'') >> '\''
+                ;
+
+                CharDataChar = 
+                    //anychar_p - (chset_t("<&"))
+                    anychar_p - (chset_t("<"))
+                ;
+
+                CharData =
+                    *(CharDataChar - "]]>")
+                ;
+
+                Comment = 
+                    "<!--" >> 
+                    (
+                        *(
+                            (Char - '-')
+                            | ('-' >> (Char - '-'))
+                        )
+                    )[typename context_t::a_comment(self.c)] 
+                    >> "-->"
+                ;
+
+                PI = 
+                    "<?" >> PITarget >> !(S >> (*(Char - "?>"))) >> "?>"
+                ;
+
+                PITarget =
+                    Name - (as_lower_d["xml"])
+                ;
+
+                CDSect =
+                    "<![CDATA[" >> CData >> "]]>"
+                ;
+
+                CData =
+                    *(Char - "]]>")
+                ;
+
+                prolog =
+                    !XMLDecl >> *Misc >> !(doctypedecl >> *Misc)
+                ;
+
+                XMLDecl =
+                    "<?xml" >> VersionInfo >> !EncodingDecl >> !SDDecl 
+                    >> !S >> "?>"
+                ;
+
+                VersionInfo = 
+                    S >> "version" >> Eq >> 
+                    (
+                    '\'' >> VersionNum >> '\''
+                    | '"' >> VersionNum >> '"'
+                    )
+                ;
+
+                Eq =
+                    !S >> '=' >> !S
+                ;
+
+                chset_t VersionNumCh("a-zA-Z0-9_.:-");
+
+                VersionNum =
+                    +(VersionNumCh)
+                ;
+
+                Misc =
+                    Comment 
+                    | PI 
+                    | S
+                ;
+
+                doctypedecl =
+                    "<!DOCTYPE" >> S >> Name >> !(S >> ExternalID) >> !S >> 
+                    !(
+                    '[' >> *(markupdecl | DeclSep) >> ']' >> !S
+                    ) 
+                    >> '>'
+                ;
+
+                DeclSep =
+                    PEReference 
+                    | S
+                ;
+
+                markupdecl =
+                    elementdecl 
+                    | AttlistDecl 
+                    | EntityDecl 
+                    | NotationDecl 
+                    | PI 
+                    | Comment
+                ;
+
+                extSubset =
+                    !TextDecl >> extSubsetDecl
+                ;
+
+                extSubsetDecl =
+                    *(
+                        markupdecl 
+                    | conditionalSect 
+                    | DeclSep
+                    )
+                ;
+
+                SDDecl = 
+                    S >> "standalone" >> Eq >> 
+                    (
+                    ('\'' >> (str_p("yes") | "no") >> '\'')
+                    | ('"' >> (str_p("yes") | "no") >> '"')
+                    )
+                ;
+
+                /*
+                element =
+                    EmptyElemTag
+                    | STag >> content >> ETag
+                ;
+                */
+                element =
+                    STagB >> (STagE2 | (STagE1 >> content >> ETag))[typename context_t::a_key_e(self.c)]
+                ;
+
+                STag =
+                    '<' >> Name >> *(S >> Attribute) >> !S >> '>'
+                ;
+
+                STagB =
+                    '<'
+                    >> Name[typename context_t::a_key_s(self.c)]
+                    >> *(S >> Attribute)
+                    >> !S
+                ;
+
+                STagE1 = 
+                    ch_p(">")
+                ;
+
+                STagE2 = 
+                    str_p("/>")
+                ;
+
+                Attribute =
+                    Name[typename context_t::a_attr_key(self.c)]
+                    >> Eq
+                    >> AttValue[typename context_t::a_attr_data(self.c)]
+                ;
+
+                ETag =
+                    "</" >> Name >> !S >> '>'
+                ;
+
+                content =
+                   !(CharData[typename context_t::a_content(self.c)]) >> 
+                   *(
+                     (
+                          element 
+                        // | Reference
+                        | CDSect 
+                        | PI 
+                        | Comment
+                     ) >> 
+                     !(CharData[typename context_t::a_content(self.c)])
+                    )
+                ;
+
+                EmptyElemTag =
+                    '<' >> Name >> *(S >> Attribute) >> !S >> "/>"
+                ;
+
+                elementdecl = 
+                    "<!ELEMENT" >> S >> Name >> S >> contentspec >> !S >> '>'
+                ;
+
+                contentspec = 
+                    str_p("EMPTY") 
+                    | "ANY" 
+                    | Mixed 
+                    | children
+                ;
+
+                children =
+                    (choice | seq) >> !(ch_p('?') | '*' | '+')
+                ;
+
+                cp = 
+                    (Name | choice | seq) >> !(ch_p('?') | '*' | '+')
+                ;
+
+                choice = 
+                    '(' >> !S >> cp 
+                    >> +(!S >> '|' >> !S >> cp) 
+                    >> !S >> ')'
+                ;
+
+                seq =
+                    '(' >> !S >> cp >> 
+                    *(!S >> ',' >> !S >> cp) 
+                    >> !S >> ')'
+                ;
+
+                Mixed =
+                    '(' >> !S >> "#PCDATA" 
+                        >> *(!S >> '|' >> !S >> Name) 
+                        >> !S >> ")*"
+                    | '(' >> !S >> "#PCDATA" >> !S >> ')'
+                ;
+
+                AttlistDecl =
+                    "<!ATTLIST" >> S >> Name >> *AttDef >> !S >> '>'
+                ;
+
+                AttDef =
+                    S >> Name >> S >> AttType >> S >> DefaultDecl
+                ;
+
+                AttType =
+                    StringType 
+                    | TokenizedType 
+                    | EnumeratedType
+                ;
+
+                StringType =
+                    str_p("CDATA")
+                ;
+
+                TokenizedType =
+                    longest_d[ 
+                        str_p("ID") 
+                        | "IDREF" 
+                        | "IDREFS" 
+                        | "ENTITY" 
+                        | "ENTITIES" 
+                        | "NMTOKEN"
+                        | "NMTOKENS" 
+                    ]
+                ;
+
+                EnumeratedType =
+                    NotationType 
+                    | Enumeration
+                ;
+
+                NotationType =
+                    "NOTATION" >> S >> '(' >> !S >> Name 
+                    >> *(!S >> '|' >> !S >> Name) 
+                    >> !S >> ')'
+                ;
+
+                Enumeration = 
+                    '(' >> !S >> Nmtoken 
+                    >> *(!S >> '|' >> !S >> Nmtoken) 
+                    >> !S >> ')'
+                ;
+
+                DefaultDecl =
+                    str_p("#REQUIRED") 
+                    | "#IMPLIED" 
+                    | !("#FIXED" >> S) >> AttValue
+                ;
+
+                conditionalSect =
+                    includeSect 
+                    | ignoreSect
+                ;
+
+                includeSect =
+                    "<![" >> !S >> "INCLUDE" >> !S 
+                    >> '[' >> extSubsetDecl >> "]]>"
+                ;
+
+                ignoreSect = 
+                    "<![" >> !S >> "IGNORE"  >> !S 
+                    >> '[' >> *ignoreSectContents >> "]]>"
+                ;
+
+                ignoreSectContents = 
+                    Ignore >> *("<![" >> ignoreSectContents >> "]]>" >> Ignore)
+                ;
+
+                Ignore = 
+                    *(Char - (str_p("<![") | "]]>"))
+                ;
+
+                CharRef = 
+                    "&#"  >> +Digit  >> ';'
+                    | "&#x" >> +XDigit >> ';'
+                ;
+
+                Reference =
+                    EntityRef 
+                    | CharRef
+                ;
+
+                EntityRef =
+                    '&' >> Name >> ';'
+                ;
+
+                PEReference =
+                    '%' >> Name >> ';'
+                ;
+
+                EntityDecl =
+                    GEDecl 
+                    | PEDecl
+                ;
+
+                GEDecl =
+                    "<!ENTITY" >> S >> Name >> S >> EntityDef >> !S >> '>'
+                ;
+
+                PEDecl =
+                    "<!ENTITY" >> S >> '%' >> S >> Name >> S >> PEDef 
+                    >> !S >> '>'
+                ;
+
+                EntityDef =
+                    EntityValue
+                    | ExternalID >> !NDataDecl
+                ;
+
+                PEDef =
+                    EntityValue 
+                    | ExternalID
+                ;
+
+                ExternalID =
+                    "SYSTEM" >> S >> SystemLiteral
+                    | "PUBLIC" >> S >> PubidLiteral >> S >> SystemLiteral
+                ;
+
+                NDataDecl =
+                    S >> "NDATA" >> S >> Name
+                ;
+
+                TextDecl =
+                    "<?xml" >> !VersionInfo >> EncodingDecl >> !S >> "?>"
+                ;
+
+                extParsedEnt =
+                    !TextDecl >> content
+                ;
+
+                EncodingDecl =
+                    S >> "encoding" >> Eq 
+                    >> (  '"' >> EncName >> '"' 
+                        | '\'' >> EncName >> '\''
+                    )
+                ;
+
+                EncName =
+                    Letter >> *(Letter | Digit | '.' | '_' | '-')
+                ;
+
+                NotationDecl =
+                    "<!NOTATION" >> S >> Name >> S 
+                    >> (ExternalID | PublicID) >> !S >> '>'
+                ;
+
+                PublicID =
+                    "PUBLIC" >> S >> PubidLiteral
+                ;
+
+                BOOST_SPIRIT_DEBUG_RULE(document);
+                BOOST_SPIRIT_DEBUG_RULE(prolog);
+                BOOST_SPIRIT_DEBUG_RULE(element);
+                BOOST_SPIRIT_DEBUG_RULE(Misc);
+                BOOST_SPIRIT_DEBUG_RULE(PEReference);
+                BOOST_SPIRIT_DEBUG_RULE(Reference);
+                BOOST_SPIRIT_DEBUG_RULE(PITarget);
+                BOOST_SPIRIT_DEBUG_RULE(CData);
+                BOOST_SPIRIT_DEBUG_RULE(doctypedecl);
+                BOOST_SPIRIT_DEBUG_RULE(XMLDecl);
+                BOOST_SPIRIT_DEBUG_RULE(SDDecl);
+                BOOST_SPIRIT_DEBUG_RULE(VersionInfo);
+                BOOST_SPIRIT_DEBUG_RULE(EncodingDecl);
+                BOOST_SPIRIT_DEBUG_RULE(VersionNum);
+                BOOST_SPIRIT_DEBUG_RULE(Eq);
+                BOOST_SPIRIT_DEBUG_RULE(DeclSep);
+                BOOST_SPIRIT_DEBUG_RULE(ExternalID);
+                BOOST_SPIRIT_DEBUG_RULE(markupdecl);
+                BOOST_SPIRIT_DEBUG_RULE(NotationDecl);
+                BOOST_SPIRIT_DEBUG_RULE(EntityDecl);
+                BOOST_SPIRIT_DEBUG_RULE(AttlistDecl);
+                BOOST_SPIRIT_DEBUG_RULE(elementdecl);
+                BOOST_SPIRIT_DEBUG_RULE(TextDecl);
+                BOOST_SPIRIT_DEBUG_RULE(extSubsetDecl);
+                BOOST_SPIRIT_DEBUG_RULE(conditionalSect);
+                BOOST_SPIRIT_DEBUG_RULE(EmptyElemTag);
+                BOOST_SPIRIT_DEBUG_RULE(STag);
+                BOOST_SPIRIT_DEBUG_RULE(content);
+                BOOST_SPIRIT_DEBUG_RULE(ETag);
+                BOOST_SPIRIT_DEBUG_RULE(Attribute);
+                BOOST_SPIRIT_DEBUG_RULE(contentspec);
+                BOOST_SPIRIT_DEBUG_RULE(Mixed);
+                BOOST_SPIRIT_DEBUG_RULE(children);
+                BOOST_SPIRIT_DEBUG_RULE(choice);
+                BOOST_SPIRIT_DEBUG_RULE(seq);
+                BOOST_SPIRIT_DEBUG_RULE(cp);
+                BOOST_SPIRIT_DEBUG_RULE(AttDef);
+                BOOST_SPIRIT_DEBUG_RULE(AttType);
+                BOOST_SPIRIT_DEBUG_RULE(DefaultDecl);
+                BOOST_SPIRIT_DEBUG_RULE(StringType);
+                BOOST_SPIRIT_DEBUG_RULE(TokenizedType);
+                BOOST_SPIRIT_DEBUG_RULE(EnumeratedType);
+                BOOST_SPIRIT_DEBUG_RULE(NotationType);
+                BOOST_SPIRIT_DEBUG_RULE(Enumeration);
+                BOOST_SPIRIT_DEBUG_RULE(EntityValue);
+                BOOST_SPIRIT_DEBUG_RULE(AttValue);
+                BOOST_SPIRIT_DEBUG_RULE(SystemLiteral);
+                BOOST_SPIRIT_DEBUG_RULE(PubidLiteral);
+                BOOST_SPIRIT_DEBUG_RULE(CharDataChar);
+                BOOST_SPIRIT_DEBUG_RULE(CharData);
+                BOOST_SPIRIT_DEBUG_RULE(Comment);
+                BOOST_SPIRIT_DEBUG_RULE(PI);
+                BOOST_SPIRIT_DEBUG_RULE(CDSect);
+                BOOST_SPIRIT_DEBUG_RULE(extSubset);
+                BOOST_SPIRIT_DEBUG_RULE(includeSect);
+                BOOST_SPIRIT_DEBUG_RULE(ignoreSect);
+                BOOST_SPIRIT_DEBUG_RULE(ignoreSectContents);
+                BOOST_SPIRIT_DEBUG_RULE(Ignore);
+                BOOST_SPIRIT_DEBUG_RULE(CharRef);
+                BOOST_SPIRIT_DEBUG_RULE(EntityRef);
+                BOOST_SPIRIT_DEBUG_RULE(GEDecl);
+                BOOST_SPIRIT_DEBUG_RULE(PEDecl);
+                BOOST_SPIRIT_DEBUG_RULE(EntityDef);
+                BOOST_SPIRIT_DEBUG_RULE(PEDef);
+                BOOST_SPIRIT_DEBUG_RULE(NDataDecl);
+                BOOST_SPIRIT_DEBUG_RULE(extParsedEnt);
+                BOOST_SPIRIT_DEBUG_RULE(EncName);
+                BOOST_SPIRIT_DEBUG_RULE(PublicID);
+                BOOST_SPIRIT_DEBUG_RULE(document);
+                BOOST_SPIRIT_DEBUG_RULE(S);
+                BOOST_SPIRIT_DEBUG_RULE(Name);
+                BOOST_SPIRIT_DEBUG_RULE(Names);
+                BOOST_SPIRIT_DEBUG_RULE(Nmtoken);
+                BOOST_SPIRIT_DEBUG_RULE(Nmtokens);
+                BOOST_SPIRIT_DEBUG_RULE(STagB);
+                BOOST_SPIRIT_DEBUG_RULE(STagE1);
+                BOOST_SPIRIT_DEBUG_RULE(STagE2);
+
+            }
+
+            const boost::spirit::rule<ScannerT> &start() const
+            {
+                return document;
+            }
+
+        };
+
+    };
+
+    template<class Ptree>
+    void read_xml_internal(std::basic_istream<typename Ptree::char_type> &stream,
+                           Ptree &pt,
+                           int flags,
+                           const std::string &filename)
+    {
+
+        typedef typename Ptree::char_type Ch;
+        typedef boost::spirit::position_iterator<typename std::vector<Ch>::const_iterator> It;
+
+        BOOST_ASSERT(validate_flags(flags));
+
+        // Load data into vector
+        std::vector<Ch> v(std::istreambuf_iterator<Ch>(stream.rdbuf()),
+                          std::istreambuf_iterator<Ch>());
+        if (!stream.good())
+            throw xml_parser_error("read error", filename, 0);
+        
+        // Initialize iterators
+        It begin(v.begin(), v.end());
+        It end;
+        begin.set_position(filename);
+        
+        // Prepare grammar
+        Ptree local;
+        xml_grammar<Ptree> g;
+        g.c.stack.push_back(&local);       // Push root ptree on context stack
+        g.c.flags = flags;
+
+        // Parse into local
+        boost::spirit::parse_info<It> result = boost::spirit::parse(begin, end, g);
+        if (!result.full || g.c.stack.size() != 1)
+            throw xml_parser_error("xml parse error", 
+                                   result.stop.get_position().file, 
+                                   result.stop.get_position().line);
+
+        // Swap local and pt
+        pt.swap(local);
+    }
+
+} } }
+
+#endif

Added: trunk/boost/property_tree/detail/xml_parser_read_tinyxml.hpp
===================================================================
--- trunk/boost/property_tree/detail/xml_parser_read_tinyxml.hpp	2006-10-03 08:44:04 UTC (rev 304)
+++ trunk/boost/property_tree/detail/xml_parser_read_tinyxml.hpp	2006-10-03 08:49:51 UTC (rev 305)
@@ -0,0 +1,79 @@
+// ----------------------------------------------------------------------------
+// Copyright (C) 2002-2005 Marcin Kalicinski
+//
+// Distributed under the Boost Software License, Version 1.0. 
+// (See accompanying file LICENSE_1_0.txt or copy at 
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// For more information, see www.boost.org
+// ----------------------------------------------------------------------------
+#ifndef BOOST_PROPERTY_TREE_DETAIL_XML_PARSER_READ_TINYXML_HPP_INCLUDED
+#define BOOST_PROPERTY_TREE_DETAIL_XML_PARSER_READ_TINYXML_HPP_INCLUDED
+
+#include <boost/property_tree/ptree.hpp>
+#include <boost/property_tree/detail/xml_parser_error.hpp>
+#include <boost/property_tree/detail/xml_parser_flags.hpp>
+#include <boost/property_tree/detail/xml_parser_utils.hpp>
+
+#define TIXML_USE_STL
+#include <tinyxml.h>
+
+namespace boost { namespace property_tree { namespace xml_parser
+{
+
+    template<class Ptree>
+    void read_xml_node(TiXmlNode *node, Ptree &pt, int flags)
+    {
+
+        typedef typename Ptree::char_type Ch;
+
+        if (TiXmlElement *elem = node->ToElement())
+        {
+            Ptree &tmp = pt.push_back(std::make_pair(elem->Value(), Ptree()))->second;
+            for (TiXmlAttribute *attr = elem->FirstAttribute(); attr; attr = attr->Next())
+                tmp.put(Ch('/'), xmlattr<Ch>() + "/" + attr->Name(), attr->Value());
+            for (TiXmlNode *child = node->FirstChild(); child; child = child->NextSibling())
+                read_xml_node(child, tmp, flags);
+        }
+        else if (TiXmlText *text = node->ToText())
+        {
+            if (flags & no_concat_text)
+                pt.push_back(std::make_pair(xmltext<Ch>(), Ptree(text->Value())));
+            else
+                pt.data() += text->Value();
+        }
+        else if (TiXmlComment *comment = node->ToComment())
+        {
+            if (!(flags & no_comments))
+                pt.push_back(std::make_pair(xmlcomment<Ch>(), Ptree(comment->Value())));
+        }
+    }
+
+    template<class Ptree>
+    void read_xml_internal(std::basic_istream<typename Ptree::char_type> &stream,
+                           Ptree &pt,
+                           int flags,
+                           const std::string &filename)
+    {
+
+        // Create and load document from stream
+        TiXmlDocument doc;
+        stream >> doc;
+        if (!stream.good())
+            throw xml_parser_error("read error", filename, 0);
+        if (doc.Error())
+            throw xml_parser_error(doc.ErrorDesc(), filename, doc.ErrorRow());
+
+        // Create ptree from nodes
+        Ptree local;
+        for (TiXmlNode *child = doc.FirstChild(); child; child = child->NextSibling())
+            read_xml_node(child, local, flags);
+
+        // Swap local and result ptrees
+        pt.swap(local);
+
+    }
+
+} } }
+
+#endif

Added: trunk/boost/property_tree/detail/xml_parser_utils.hpp
===================================================================
--- trunk/boost/property_tree/detail/xml_parser_utils.hpp	2006-10-03 08:44:04 UTC (rev 304)
+++ trunk/boost/property_tree/detail/xml_parser_utils.hpp	2006-10-03 08:49:51 UTC (rev 305)
@@ -0,0 +1,119 @@
+// ----------------------------------------------------------------------------
+// Copyright (C) 2002-2005 Marcin Kalicinski
+//
+// Distributed under the Boost Software License, Version 1.0. 
+// (See accompanying file LICENSE_1_0.txt or copy at 
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// For more information, see www.boost.org
+// ----------------------------------------------------------------------------
+#ifndef BOOST_PROPERTY_TREE_DETAIL_XML_PARSER_UTILS_HPP_INCLUDED
+#define BOOST_PROPERTY_TREE_DETAIL_XML_PARSER_UTILS_HPP_INCLUDED
+
+#include <boost/property_tree/detail/ptree_utils.hpp>
+#include <boost/property_tree/detail/xml_parser_error.hpp>
+#include <string>
+#include <algorithm>
+#include <locale>
+
+namespace boost { namespace property_tree { namespace xml_parser
+{
+
+    template<class Ch>
+    std::basic_string<Ch> condense(const std::basic_string<Ch> &s)
+    {
+        std::basic_string<Ch> r;
+        std::locale loc;
+        bool space = false;
+        typename std::basic_string<Ch>::const_iterator end = s.end();
+        for (typename std::basic_string<Ch>::const_iterator it = s.begin();
+             it != end; ++it)
+        {
+            if (isspace(*it, loc) || *it == Ch('\n'))
+            {
+                if (!space)
+                    r += Ch(' '), space = true;
+            }
+            else
+                r += *it, space = false;
+        }
+        return r;
+    }
+
+    template<class Ch>
+    std::basic_string<Ch> encode_char_entities(const std::basic_string<Ch> &s)
+    {
+        typedef typename std::basic_string<Ch> Str;
+        Str r;
+        typename Str::const_iterator end = s.end();
+        for (typename Str::const_iterator it = s.begin(); it != end; ++it)
+        {
+            switch (*it)
+            {
+                case Ch('<'): r += detail::widen<Ch>("&lt;"); break;
+                case Ch('>'): r += detail::widen<Ch>("&gt;"); break;
+                case Ch('&'): r += detail::widen<Ch>("&amp;"); break;
+                default: r += *it; break;
+            }
+        }
+        return r;
+    }
+    
+    template<class Ch>
+    std::basic_string<Ch> decode_char_entities(const std::basic_string<Ch> &s)
+    {
+        typedef typename std::basic_string<Ch> Str;
+        Str r;
+        typename Str::const_iterator end = s.end();
+        for (typename Str::const_iterator it = s.begin(); it != end; ++it)
+        {
+            if (*it == Ch('&'))
+            {
+                typename Str::const_iterator semicolon = std::find(it + 1, end, Ch(';'));
+                if (semicolon == end)
+                    throw xml_parser_error("invalid character entity", "", 0);
+                Str ent(it + 1, semicolon);
+                if (ent == detail::widen<Ch>("lt")) r += Ch('<');
+                else if (ent == detail::widen<Ch>("gt")) r += Ch('>');
+                else if (ent == detail::widen<Ch>("amp")) r += Ch('&');
+                else
+                    throw xml_parser_error("invalid character entity", "", 0);
+                it = semicolon;
+            }
+            else
+                r += *it;
+        }
+        return r;
+    }
+    
+    template<class Ch>
+    const std::basic_string<Ch> &xmldecl()
+    {
+        static std::basic_string<Ch> s = detail::widen<Ch>("<?xml>");
+        return s;
+    }
+
+    template<class Ch>
+    const std::basic_string<Ch> &xmlattr()
+    {
+        static std::basic_string<Ch> s = detail::widen<Ch>("<xmlattr>");
+        return s;
+    }
+
+    template<class Ch>
+    const std::basic_string<Ch> &xmlcomment()
+    {
+        static std::basic_string<Ch> s = detail::widen<Ch>("<xmlcomment>");
+        return s;
+    }
+
+    template<class Ch>
+    const std::basic_string<Ch> &xmltext()
+    {
+        static std::basic_string<Ch> s = detail::widen<Ch>("<xmltext>");
+        return s;
+    }
+
+} } }
+
+#endif

Added: trunk/boost/property_tree/detail/xml_parser_write.hpp
===================================================================
--- trunk/boost/property_tree/detail/xml_parser_write.hpp	2006-10-03 08:44:04 UTC (rev 304)
+++ trunk/boost/property_tree/detail/xml_parser_write.hpp	2006-10-03 08:49:51 UTC (rev 305)
@@ -0,0 +1,145 @@
+// ----------------------------------------------------------------------------
+// Copyright (C) 2002-2005 Marcin Kalicinski
+//
+// Distributed under the Boost Software License, Version 1.0. 
+// (See accompanying file LICENSE_1_0.txt or copy at 
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// For more information, see www.boost.org
+// ----------------------------------------------------------------------------
+#ifndef BOOST_PROPERTY_TREE_DETAIL_XML_PARSER_WRITE_HPP_INCLUDED
+#define BOOST_PROPERTY_TREE_DETAIL_XML_PARSER_WRITE_HPP_INCLUDED
+
+#include <boost/property_tree/ptree.hpp>
+#include <boost/property_tree/detail/xml_parser_utils.hpp>
+#include <string>
+#include <ostream>
+#include <iomanip>
+
+namespace boost { namespace property_tree { namespace xml_parser
+{
+
+    template<class Ch>
+    void write_xml_comment(std::basic_ostream<Ch> &stream,
+                           const std::basic_string<Ch> &s, 
+                           int indent)
+    {
+        typedef typename std::basic_string<Ch> Str;
+        stream << Str(4 * indent, Ch(' '));
+        stream << Ch('<') << Ch('!') << Ch('-') << Ch('-');
+        stream << s;
+        stream << Ch('-') << Ch('-') << Ch('>') << std::endl;
+    }
+    
+    template<class Ch>
+    void write_xml_text(std::basic_ostream<Ch> &stream,
+                        const std::basic_string<Ch> &s, 
+                        int indent, 
+                        bool separate_line)
+    {
+        typedef typename std::basic_string<Ch> Str;
+        if (separate_line)    
+            stream << Str(4 * indent, Ch(' '));
+        stream << encode_char_entities(s);
+        if (separate_line)    
+            stream << Ch('\n');
+    }
+
+    template<class Ptree>
+    void write_xml_element(std::basic_ostream<typename Ptree::char_type> &stream, 
+                           const std::basic_string<typename Ptree::char_type> &key,
+                           const Ptree &pt, 
+                           int indent)
+    {
+
+        typedef typename Ptree::char_type Ch;
+        typedef typename std::basic_string<Ch> Str;
+        typedef typename Ptree::const_iterator It;
+
+        // Find if elements present
+        bool has_elements = false;
+        for (It it = pt.begin(), end = pt.end(); it != end; ++it)
+            if (it->first != xmlattr<Ch>() &&
+                it->first != xmltext<Ch>())
+            {
+                has_elements = true;
+                break;
+            }
+        
+        // Write element
+        if (pt.data().empty() && pt.empty())    // Empty key
+        {
+            if (indent >= 0)
+                stream << Str(4 * indent, Ch(' ')) << Ch('<') << key << 
+                          Ch('/') << Ch('>') << std::endl;
+        }
+        else    // Nonempty key
+        {
+        
+            // Write opening tag, attributes and data
+            if (indent >= 0)
+            {
+            
+                // Write opening brace and key
+                stream << Str(4 * indent, Ch(' '));
+                stream << Ch('<') << key;
+
+                // Write attributes
+                if (optional<const Ptree &> attribs = pt.get_child_optional(xmlattr<Ch>()))
+                    for (It it = attribs.get().begin(); it != attribs.get().end(); ++it)
+                        stream << Ch(' ') << it->first << Ch('=') << 
+                                  Ch('"') << it->second.template get_own<std::basic_string<Ch> >() << Ch('"');
+
+                // Write closing brace
+                stream << Ch('>');
+
+                // Break line if needed
+                if (has_elements)
+                    stream << Ch('\n');
+
+            }
+            
+            // Write data text, if present
+            if (!pt.data().empty())
+                write_xml_text(stream, pt.template get_own<std::basic_string<Ch> >(), indent + 1, has_elements);
+            
+            // Write elements, comments and texts
+            for (It it = pt.begin(); it != pt.end(); ++it)
+            {
+                if (it->first == xmlattr<Ch>())
+                    continue;
+                else if (it->first == xmlcomment<Ch>())
+                    write_xml_comment(stream, it->second.template get_own<std::basic_string<Ch> >(), indent + 1);
+                else if (it->first == xmltext<Ch>())
+                    write_xml_text(stream, it->second.template get_own<std::basic_string<Ch> >(), indent + 1, has_elements);
+                else
+                    write_xml_element(stream, it->first, it->second, indent + 1);
+            }
+            
+            // Write closing tag
+            if (indent >= 0)
+            {
+                if (has_elements)
+                    stream << Str(4 * indent, Ch(' '));
+                stream << Ch('<') << Ch('/') << key << Ch('>') << std::endl;
+            }
+
+        }
+    }
+
+    template<class Ptree>
+    void write_xml_internal(std::basic_ostream<typename Ptree::char_type> &stream, 
+                            const Ptree &pt,
+                            const std::string &filename)
+    {
+        typedef typename Ptree::char_type Ch;
+        typedef typename std::basic_string<Ch> Str;
+        stream << detail::widen<Ch>("<?xml version=\"1.0\" encoding=\"utf-8\"?>\n");
+        write_xml_element(stream, Str(), pt, -1);
+        if (!stream)
+            throw xml_parser_error("write error", filename, 0);
+    }
+
+} } }
+
+#endif

Added: trunk/boost/property_tree/info_parser.hpp
===================================================================
--- trunk/boost/property_tree/info_parser.hpp	2006-10-03 08:44:04 UTC (rev 304)
+++ trunk/boost/property_tree/info_parser.hpp	2006-10-03 08:49:51 UTC (rev 305)
@@ -0,0 +1,77 @@
+// ----------------------------------------------------------------------------
+// Copyright (C) 2002-2005 Marcin Kalicinski
+//
+// Distributed under the Boost Software License, Version 1.0. 
+// (See accompanying file LICENSE_1_0.txt or copy at 
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// For more information, see www.boost.org
+// ----------------------------------------------------------------------------
+#ifndef BOOST_PROPERTY_TREE_INFO_PARSER_HPP_INCLUDED
+#define BOOST_PROPERTY_TREE_INFO_PARSER_HPP_INCLUDED
+
+#include <boost/property_tree/ptree.hpp>
+#include <boost/property_tree/detail/info_parser_error.hpp>
+#include <boost/property_tree/detail/info_parser_read.hpp>
+#include <boost/property_tree/detail/info_parser_write.hpp>
+#include <istream>
+
+namespace boost { namespace property_tree { namespace info_parser
+{
+
+    // Read info from stream
+    template<class Ptree>
+    void read_info(std::basic_istream<typename Ptree::char_type> &stream, 
+                   Ptree &pt)
+    {
+        Ptree local;
+        read_info_internal(stream, local, std::string(), 0);
+        pt.swap(local);
+    }
+
+    // Read info from file
+    template<class Ptree>
+    void read_info(const std::string &filename,
+                   Ptree &pt,
+                   const std::locale &loc = std::locale())
+    {
+        std::basic_ifstream<typename Ptree::char_type> stream(filename.c_str());
+        if (!stream)
+            throw info_parser_error("cannot open file for reading", filename, 0);
+        stream.imbue(loc);
+        Ptree local;
+        read_info_internal(stream, local, filename, 0);
+        pt.swap(local);
+    }
+
+    // Write info to stream
+    template<class Ptree>
+    void write_info(std::basic_ostream<typename Ptree::char_type> &stream, 
+                    const Ptree &pt)
+    {
+        write_info_internal(stream, pt, std::string());
+    }
+
+    // Write info to file
+    template<class Ptree>
+    void write_info(const std::string &filename,
+                    const Ptree &pt,
+                    const std::locale &loc = std::locale())
+    {
+        std::basic_ofstream<typename Ptree::char_type> stream(filename.c_str());
+        if (!stream)
+            throw info_parser_error("cannot open file for writing", filename, 0);
+        stream.imbue(loc);
+        write_info_internal(stream, pt, filename);
+    }
+
+} } }
+
+namespace boost { namespace property_tree
+{
+    using info_parser::info_parser_error;
+    using info_parser::read_info;
+    using info_parser::write_info;
+} }
+
+#endif

Added: trunk/boost/property_tree/ini_parser.hpp
===================================================================
--- trunk/boost/property_tree/ini_parser.hpp	2006-10-03 08:44:04 UTC (rev 304)
+++ trunk/boost/property_tree/ini_parser.hpp	2006-10-03 08:49:51 UTC (rev 305)
@@ -0,0 +1,196 @@
+// ----------------------------------------------------------------------------
+// Copyright (C) 2002-2005 Marcin Kalicinski
+//
+// Distributed under the Boost Software License, Version 1.0. 
+// (See accompanying file LICENSE_1_0.txt or copy at 
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// For more information, see www.boost.org
+// ----------------------------------------------------------------------------
+#ifndef BOOST_PROPERTY_TREE_INI_PARSER_HPP_INCLUDED
+#define BOOST_PROPERTY_TREE_INI_PARSER_HPP_INCLUDED
+
+#include <boost/property_tree/ptree.hpp>
+#include <boost/property_tree/detail/ptree_utils.hpp>
+#include <boost/property_tree/detail/file_parser_error.hpp>
+#include <istream>
+#include <string>
+#include <sstream>
+#include <stdexcept>
+#include <locale>
+
+namespace boost { namespace property_tree { namespace ini_parser
+{
+
+    static const int skip_ini_validity_check = 1;     // Skip check if ptree is a valid ini
+
+    inline bool validate_flags(int flags)
+    {
+        return (flags & ~skip_ini_validity_check) == 0;
+    }
+
+    //! Ini parser error
+    class ini_parser_error: public file_parser_error
+    {
+    public:
+        ini_parser_error(const std::string &message, 
+                         const std::string &filename, 
+                         unsigned long line): 
+            file_parser_error(message, filename, line)
+        { 
+        }
+    };
+
+    //! Read ini from stream
+    template<class Ptree>
+    void read_ini(std::basic_istream<typename Ptree::char_type> &stream, 
+                  Ptree &pt)
+    {
+
+        typedef typename Ptree::char_type Ch;
+        typedef std::basic_string<Ch> Str;
+
+        Ptree local;
+        unsigned long line_no = 0;
+        Ptree *section = 0;
+        Str line;
+
+        // For all lines
+        while (stream.good())
+        {
+
+            // Get line from stream
+            ++line_no;
+            std::getline(stream, line);
+            if (!stream.good() && !stream.eof())
+                throw ini_parser_error("read error", "", line_no);
+
+            // If line is non-empty
+            line = detail::trim(line, stream.getloc());
+            if (!line.empty())
+            {
+            
+                // Comment, section or key?
+                if (line[0] == Ch(';'))
+                {
+                    // Ignore comments
+                }
+                else if (line[0] == Ch('['))
+                {
+                    typename Str::size_type end = line.find(Ch(']'));
+                    if (end == Str::npos)
+                        throw ini_parser_error("unmatched '['", "", line_no);
+                    Str key = detail::trim(line.substr(1, end - 1), stream.getloc());
+                    if (local.find(key) != local.end())
+                        throw ini_parser_error("duplicate section name", "", line_no);
+                    section = &local.push_back(std::make_pair(key, Ptree()))->second;
+                }
+                else
+                {
+                    if (!section)
+                        throw ini_parser_error("section expected", "", line_no);
+                    typename Str::size_type eqpos = line.find(Ch('='));
+                    if (eqpos == Str::npos)
+                        throw ini_parser_error("'=' character not found in line", "", line_no);
+                    if (eqpos == 0)
+                        throw ini_parser_error("key expected", "", line_no);
+                    Str key = detail::trim(line.substr(0, eqpos), stream.getloc());
+                    Str data = detail::trim(line.substr(eqpos + 1, Str::npos), stream.getloc());
+                    if (section->find(key) != section->end())
+                        throw ini_parser_error("duplicate key name", "", line_no);
+                    section->push_back(std::make_pair(key, Ptree(data)));
+                }
+            }
+        }
+
+        // Swap local ptree with result ptree
+        pt.swap(local);
+
+    }
+
+    //! Read ini from file
+    template<class Ptree>
+    void read_ini(const std::string &filename, 
+                  Ptree &pt,
+                  const std::locale &loc = std::locale())
+    {
+        std::basic_ifstream<typename Ptree::char_type> stream(filename.c_str());
+        if (!stream)
+            throw ini_parser_error("cannot open file", filename, 0);
+        stream.imbue(loc);
+        try {
+            read_ini(stream, pt);
+        }
+        catch (ini_parser_error &e) {
+            throw ini_parser_error(e.message(), filename, e.line());
+        }
+    }
+
+    //! Write ini to stream
+    template<class Ptree>
+    void write_ini(std::basic_ostream<typename Ptree::char_type> &stream, 
+                   const Ptree &pt,
+                   int flags = 0)
+    {
+
+        typedef typename Ptree::char_type Ch;
+        typedef std::basic_string<Ch> Str;
+
+        BOOST_ASSERT(validate_flags(flags));
+        
+        // Verify if ptree is not too rich to be saved as ini
+        if (!(flags & skip_ini_validity_check))
+            for (typename Ptree::const_iterator it = pt.begin(), end = pt.end(); it != end; ++it)
+            {
+                if (!it->second.data().empty())
+                    throw ini_parser_error("ptree has data on root level keys", "", 0);
+                if (pt.count(it->first) > 1)
+                    throw ini_parser_error("duplicate section name", "", 0);
+                for (typename Ptree::const_iterator it2 = it->second.begin(), end2 = it->second.end(); it2 != end2; ++it2)
+                {
+                    if (!it2->second.empty())
+                        throw ini_parser_error("ptree is too deep", "", 0);
+                    if (it->second.count(it2->first) > 1)
+                        throw ini_parser_error("duplicate key name", "", 0);
+                }
+            }
+
+        // Write ini
+        for (typename Ptree::const_iterator it = pt.begin(), end = pt.end(); it != end; ++it)
+        {
+            stream << Ch('[') << it->first << Ch(']') << Ch('\n');
+            for (typename Ptree::const_iterator it2 = it->second.begin(), end2 = it->second.end(); it2 != end2; ++it2)
+                stream << it2->first << Ch('=') << it2->second.template get_own<std::basic_string<Ch> >() << Ch('\n');
+        }
+
+    }
+
+    // Write ini to file
+    template<class Ptree>
+    void write_ini(const std::string &filename,
+                   const Ptree &pt,
+                   int flags = 0,
+                   const std::locale &loc = std::locale())
+    {
+        std::basic_ofstream<typename Ptree::char_type> stream(filename.c_str());
+        if (!stream)
+            throw ini_parser_error("cannot open file", filename, 0);
+        stream.imbue(loc);
+        try {
+            write_ini(stream, pt, flags);
+        }
+        catch (ini_parser_error &e) {
+            throw ini_parser_error(e.message(), filename, e.line());
+        }
+    }
+
+} } }
+
+namespace boost { namespace property_tree
+{
+    using ini_parser::ini_parser_error;
+    using ini_parser::read_ini;
+    using ini_parser::write_ini;
+} }
+
+#endif

Added: trunk/boost/property_tree/json_parser.hpp
===================================================================
--- trunk/boost/property_tree/json_parser.hpp	2006-10-03 08:44:04 UTC (rev 304)
+++ trunk/boost/property_tree/json_parser.hpp	2006-10-03 08:49:51 UTC (rev 305)
@@ -0,0 +1,76 @@
+// ----------------------------------------------------------------------------
+// Copyright (C) 2002-2005 Marcin Kalicinski
+//
+// Distributed under the Boost Software License, Version 1.0. 
+// (See accompanying file LICENSE_1_0.txt or copy at 
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// For more information, see www.boost.org
+// ----------------------------------------------------------------------------
+#ifndef BOOST_PROPERTY_TREE_JSON_PARSER_HPP_INCLUDED
+#define BOOST_PROPERTY_TREE_JSON_PARSER_HPP_INCLUDED
+
+#include <boost/property_tree/ptree.hpp>
+#include <boost/property_tree/detail/json_parser_read.hpp>
+#include <boost/property_tree/detail/json_parser_write.hpp>
+#include <boost/property_tree/detail/json_parser_error.hpp>
+
+#include <fstream>
+#include <string>
+#include <locale>
+
+namespace boost { namespace property_tree { namespace json_parser
+{
+
+    // Read json from stream
+    template<class Ptree>
+    void read_json(std::basic_istream<typename Ptree::char_type> &stream,
+                   Ptree &pt)
+    {
+        read_json_internal(stream, pt, std::string());
+    }
+
+    // Read json from file
+    template<class Ptree>
+    void read_json(const std::string &filename,
+                   Ptree &pt,
+                   const std::locale &loc = std::locale())
+    {
+        std::basic_ifstream<typename Ptree::char_type> stream(filename.c_str());
+        if (!stream)
+            throw json_parser_error("cannot open file", filename, 0);
+        stream.imbue(loc);
+        read_json_internal(stream, pt, filename);
+    }
+
+    // Write json to stream
+    template<class Ptree>
+    void write_json(std::basic_ostream<typename Ptree::char_type> &stream, 
+                    const Ptree &pt)
+    {
+        write_json_internal(stream, pt, std::string());
+    }
+
+    // Write json to file
+    template<class Ptree>
+    void write_json(const std::string &filename,
+                    const Ptree &pt,
+                    const std::locale &loc = std::locale())
+    {
+        std::basic_ofstream<typename Ptree::char_type> stream(filename.c_str());
+        if (!stream)
+            throw json_parser_error("cannot open file", filename, 0);
+        stream.imbue(loc);
+        write_json_internal(stream, pt, filename);
+    }
+
+} } }
+
+namespace boost { namespace property_tree
+{
+    using json_parser::read_json;
+    using json_parser::write_json;
+    using json_parser::json_parser_error;
+} }
+
+#endif

Added: trunk/boost/property_tree/ptree.hpp
===================================================================
--- trunk/boost/property_tree/ptree.hpp	2006-10-03 08:44:04 UTC (rev 304)
+++ trunk/boost/property_tree/ptree.hpp	2006-10-03 08:49:51 UTC (rev 305)
@@ -0,0 +1,16 @@
+// ----------------------------------------------------------------------------
+// Copyright (C) 2002-2005 Marcin Kalicinski
+//
+// Distributed under the Boost Software License, Version 1.0. 
+// (See accompanying file LICENSE_1_0.txt or copy at 
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// For more information, see www.boost.org
+// ----------------------------------------------------------------------------
+#ifndef BOOST_PROPERTY_TREE_PTREE_HPP_INCLUDED
+#define BOOST_PROPERTY_TREE_PTREE_HPP_INCLUDED
+
+#include <boost/property_tree/detail/ptree_interface.hpp>
+#include <boost/property_tree/detail/ptree_implementation.hpp>
+
+#endif                                                

Added: trunk/boost/property_tree/ptree_fwd.hpp
===================================================================
--- trunk/boost/property_tree/ptree_fwd.hpp	2006-10-03 08:44:04 UTC (rev 304)
+++ trunk/boost/property_tree/ptree_fwd.hpp	2006-10-03 08:49:51 UTC (rev 305)
@@ -0,0 +1,54 @@
+// ----------------------------------------------------------------------------
+// Copyright (C) 2002-2005 Marcin Kalicinski
+//
+// Distributed under the Boost Software License, Version 1.0. 
+// (See accompanying file LICENSE_1_0.txt or copy at 
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// For more information, see www.boost.org
+// ----------------------------------------------------------------------------
+#ifndef BOOST_PROPERTY_TREE_PTREE_FWD_HPP_INCLUDED
+#define BOOST_PROPERTY_TREE_PTREE_FWD_HPP_INCLUDED
+
+#include <boost/config.hpp>
+
+namespace boost { namespace property_tree
+{
+
+    ////////////////////////////////////////////////////////////////////////////
+    // Traits
+
+    template<class Ch> struct ptree_traits;
+    template<class Ch> struct iptree_traits;
+
+    ///////////////////////////////////////////////////////////////////////////
+    // Exceptions
+
+    class ptree_error;
+    class bad_ptree_data;
+    class bad_ptree_path;
+
+    ///////////////////////////////////////////////////////////////////////////
+    // basic_ptree class template
+
+    template<class Tr> class basic_ptree;
+
+    ////////////////////////////////////////////////////////////////////////////
+    // Typedefs
+
+    typedef basic_ptree<ptree_traits<char> > ptree;       // case sensitive, narrow char
+    typedef basic_ptree<iptree_traits<char> > iptree;     // case insensitive, narrow char
+#ifndef BOOST_NO_CWCHAR
+    typedef basic_ptree<ptree_traits<wchar_t> > wptree;    // case sensitive, wide char
+    typedef basic_ptree<iptree_traits<wchar_t> > wiptree;  // case insensitive, wide char
+#endif
+
+    ///////////////////////////////////////////////////////////////////////////
+    // Free functions
+
+    template<class Tr> void swap(basic_ptree<Tr> &pt1, basic_ptree<Tr> &pt2);
+    template<class Ptree> const Ptree &empty_ptree();
+
+} }
+
+#endif

Added: trunk/boost/property_tree/registry_parser.hpp
===================================================================
--- trunk/boost/property_tree/registry_parser.hpp	2006-10-03 08:44:04 UTC (rev 304)
+++ trunk/boost/property_tree/registry_parser.hpp	2006-10-03 08:49:51 UTC (rev 305)
@@ -0,0 +1,520 @@
+// ----------------------------------------------------------------------------
+// Copyright (C) 2002-2005 Marcin Kalicinski
+//
+// Distributed under the Boost Software License, Version 1.0. 
+// (See accompanying file LICENSE_1_0.txt or copy at 
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// For more information, see www.boost.org
+// ----------------------------------------------------------------------------
+#ifndef BOOST_PROPERTY_TREE_REGISTRY_PARSER_HPP_INCLUDED
+#define BOOST_PROPERTY_TREE_REGISTRY_PARSER_HPP_INCLUDED
+
+// Include minimal version of windows.h if not included yet
+#ifndef _WINDOWS_
+#ifndef NOMINMAX
+    #define NOMINMAX
+#endif
+#define STRICT
+#define WIN32_LEAN_AND_MEAN
+#define VC_EXTRALEAN
+#define NOGDICAPMASKS
+#define NOVIRTUALKEYCODES
+#define NOWINMESSAGES
+#define NOWINSTYLES
+#define NOSYSMETRICS
+#define NOMENUS
+#define NOICONS
+#define NOKEYSTATES
+#define NOSYSCOMMANDS
+#define NORASTEROPS
+#define NOSHOWWINDOW
+#define OEMRESOURCE
+#define NOATOM
+#define NOCLIPBOARD
+#define NOCOLOR
+#define NOCTLMGR
+#define NODRAWTEXT
+#define NOGDI
+#define NOKERNEL
+#define NOUSER
+#define NONLS
+#define NOMB 
+#define NOMEMMGR
+#define NOMETAFILE
+#define NOMSG
+#define NOOPENFILE
+#define NOSCROLL
+#define NOSERVICE
+#define NOSOUND
+#define NOTEXTMETRIC
+#define NOWH
+#define NOWINOFFSETS
+#define NOCOMM
+#define NOKANJI
+#define NOHELP
+#define NOPROFILER
+#define NODEFERWINDOWPOS
+#define NOMCX
+#include <windows.h>
+#endif
+
+#include <boost/property_tree/ptree.hpp>
+#include <boost/property_tree/detail/ptree_utils.hpp>
+#include <boost/cstdint.hpp>                // for 64 bit int
+#include <sstream>
+#include <iomanip>
+#include <string>
+#include <vector>
+#include <stdexcept>
+
+namespace boost { namespace property_tree { namespace registry_parser
+{
+
+    //! Registry parser error
+    class registry_parser_error: public ptree_error
+    {
+    public:
+    
+        // Construct error 
+        registry_parser_error(const std::string &message, DWORD windows_error): 
+            ptree_error(format_what(message, windows_error)), 
+            m_windows_error(windows_error)
+        { 
+        }
+    
+        // Get windows error
+        DWORD windows_error()
+        {
+            return m_windows_error;
+        }
+    
+    private:
+
+        DWORD m_windows_error;
+
+        // Format error message to be returned by std::runtime_error::what()
+        std::string format_what(const std::string &message,
+                                DWORD windows_error)
+        {
+            std::stringstream stream;
+            if (windows_error)
+                stream << message << " (windows error 0x" << std::hex << windows_error << ")";
+            else
+                stream << message;
+            return stream.str();
+        }
+
+    };
+
+    // Translate from binary buffer to string
+    template<class Ch>
+    std::basic_string<Ch> translate(DWORD type, const std::vector<BYTE> &data)
+    {
+
+        typedef std::basic_string<Ch> Str;
+        typedef std::basic_stringstream<Ch> Stream;
+
+        Str value;
+        switch (type)
+        {
+        
+            // No data
+            case REG_NONE:
+                break;
+            
+            // Binary data
+            case REG_BINARY: 
+                if (!data.empty())
+                {
+                    Stream stream;
+                    stream << std::hex << std::setfill(Ch('0'));
+                    for (std::vector<BYTE>::const_iterator it = data.begin(), end = data.end(); 
+                         it != end; ++it)
+                        stream << std::setw(2) << static_cast<int>(*it) << Ch(' ');
+                    value = stream.str();
+                    value.resize(value.size() - 1); // remove final space
+                }
+                break;
+            
+            // DWORD value
+            case REG_DWORD: 
+                if (!data.empty())
+                {
+                    Stream stream;
+                    stream << *reinterpret_cast<const DWORD *>(&data.front());
+                    value = stream.str();
+                }
+                break;
+
+            // QWORD value
+            case REG_QWORD: 
+                if (!data.empty())
+                {
+                    Stream stream;
+                    stream << *reinterpret_cast<const boost::uint64_t *>(&data.front());
+                    value = stream.str();
+                }
+                break;
+            
+            // Zero terminated string
+            case REG_SZ: case REG_EXPAND_SZ: 
+                if (!data.empty())
+                    value.assign(reinterpret_cast<const Ch *>(&data.front()));
+                break;
+            
+            // Unknown data type
+            default:
+                throw registry_parser_error("unsupported data type", 0);
+
+        };
+        return value;
+    }
+
+    // Translate from string to binary buffer
+    template<class Ch>
+    std::vector<BYTE> translate(DWORD type, const std::basic_string<Ch> &s)
+    {
+
+        typedef std::basic_string<Ch> Str;
+        typedef std::basic_stringstream<Ch> Stream;
+
+        std::vector<BYTE> data;
+        switch (type)
+        {
+        
+            // No data
+            case REG_NONE:
+                break;
+            
+            // Binary data
+            case REG_BINARY:
+                {
+                    int v;
+                    Stream stream(s);
+                    stream >> std::hex;
+                    while (1)
+                    {
+                        stream >> v >> std::ws;
+                        if (stream.fail() || stream.bad())
+                            throw registry_parser_error("bad REG_BINARY value", 0);
+                        data.push_back(v);
+                        if (stream.eof())
+                            break;
+                    }
+                }
+                break;
+            
+            // DWORD value
+            case REG_DWORD: 
+                {
+                    DWORD v;
+                    Stream stream(s);
+                    stream >> v >> std::ws;
+                    if (!stream.eof() || stream.fail() || stream.bad())
+                        throw registry_parser_error("bad REG_DWORD value", 0);
+                    for (size_t i = 0; i < sizeof(v); ++i)
+                        data.push_back(*(reinterpret_cast<BYTE *>(&v) + i));
+                }
+                break;
+
+            // QWORD value
+            case REG_QWORD: 
+                {
+                    boost::uint64_t v;
+                    Stream stream(s);
+                    stream >> v;
+                    if (!stream.eof() || stream.fail() || stream.bad())
+                        throw registry_parser_error("bad REG_QWORD value", 0);
+                    for (size_t i = 0; i < sizeof(v); ++i)
+                        data.push_back(*(reinterpret_cast<BYTE *>(&v) + i));
+                }
+                break;
+            
+            // Zero terminated string
+            case REG_SZ: case REG_EXPAND_SZ:
+                {
+                    const Ch *sz = s.c_str();
+                    size_t len = (s.size() + 1) * sizeof(Ch);
+                    for (size_t i = 0; i < len; ++i)
+                        data.push_back(*(reinterpret_cast<const BYTE *>(sz) + i));
+                }
+                break;
+            
+            // Unknown data type
+            default:
+                throw registry_parser_error("unsupported data type", 0);
+
+        };
+        return data;
+    }
+
+    /////////////////////////////////////////////////////////////////////////////
+    // Registry functions wrappers
+    
+    template<class Ch> 
+    inline LONG reg_create_key_ex(HKEY hkey, const Ch *subkey, REGSAM sam, HKEY *result);
+
+    template<> 
+    inline LONG reg_create_key_ex<char>(HKEY hkey, const char *subkey, REGSAM sam, HKEY *result)
+    {
+        return RegCreateKeyExA(hkey, subkey, 0, NULL, REG_OPTION_NON_VOLATILE, sam, NULL, result, NULL);
+    }
+    
+    template<> 
+    inline LONG reg_create_key_ex<wchar_t>(HKEY hkey, const wchar_t *subkey, REGSAM sam, HKEY *result)
+    {
+        return RegCreateKeyExW(hkey, subkey, 0, NULL, REG_OPTION_NON_VOLATILE, sam, NULL, result, NULL);
+    }
+
+    template<class Ch> 
+    inline LONG reg_set_value_ex(HKEY hkey, const Ch *name, DWORD type, const BYTE *data, DWORD size);
+
+    template<> 
+    inline LONG reg_set_value_ex<char>(HKEY hkey, const char *name, DWORD type, const BYTE *data, DWORD size)
+    {
+        return RegSetValueExA(hkey, name, 0, type, data, size);
+    }
+
+    template<> 
+    inline LONG reg_set_value_ex<wchar_t>(HKEY hkey, const wchar_t *name, DWORD type, const BYTE *data, DWORD size)
+    {
+        return RegSetValueExW(hkey, name, 0, type, data, size);
+    }
+
+    template<class Ch> 
+    inline LONG reg_open_key_ex(HKEY hkey, const Ch *subkey, REGSAM sam, HKEY *result);
+
+    template<> 
+    inline LONG reg_open_key_ex<char>(HKEY hkey, const char *subkey, REGSAM sam, HKEY *result)
+    {
+        return RegOpenKeyExA(hkey, subkey, 0, sam, result);
+    }
+    
+    template<> 
+    inline LONG reg_open_key_ex<wchar_t>(HKEY hkey, const wchar_t *subkey, REGSAM sam, HKEY *result)
+    {
+        return RegOpenKeyExW(hkey, subkey, 0, sam, result);
+    }
+
+    template<class Ch> 
+    inline LONG reg_enum_key_ex(HKEY hkey, DWORD index, Ch *name, DWORD *size);
+
+    template<> 
+    inline LONG reg_enum_key_ex<char>(HKEY hkey, DWORD index, char *name, DWORD *size)
+    {
+        FILETIME ft;
+        return RegEnumKeyExA(hkey, index, name, size, 0, NULL, NULL, &ft);
+    }
+
+    template<> 
+    inline LONG reg_enum_key_ex<wchar_t>(HKEY hkey, DWORD index, wchar_t *name, DWORD *size)
+    {
+        FILETIME ft;
+        return RegEnumKeyExW(hkey, index, name, size, 0, NULL, NULL, &ft);
+    }
+
+    template<class Ch> 
+    inline LONG reg_enum_value(HKEY hkey, DWORD index, Ch *name, DWORD *name_size, DWORD *type, BYTE *data, DWORD *data_size);
+
+    template<> 
+    inline LONG reg_enum_value<char>(HKEY hkey, DWORD index, char *name, DWORD *name_size, DWORD *type, BYTE *data, DWORD *data_size)
+    {
+        return RegEnumValueA(hkey, index, name, name_size, NULL, type, data, data_size);
+    }
+
+    template<> 
+    inline LONG reg_enum_value<wchar_t>(HKEY hkey, DWORD index, wchar_t *name, DWORD *name_size, DWORD *type, BYTE *data, DWORD *data_size)
+    {
+        return RegEnumValueW(hkey, index, name, name_size, NULL, type, data, data_size);
+    }
+
+    template<class Ch> 
+    inline LONG reg_query_info_key(HKEY hkey, DWORD *max_subkey_len, DWORD *max_name_len, DWORD *max_value_len);
+
+    template<> 
+    inline LONG reg_query_info_key<char>(HKEY hkey, DWORD *max_subkey_len, DWORD *max_name_len, DWORD *max_value_len)
+    {
+        return RegQueryInfoKeyA(hkey, NULL, NULL, NULL, NULL, max_subkey_len, NULL, NULL, max_name_len, max_value_len, NULL, NULL);
+    }
+
+    template<> 
+    inline LONG reg_query_info_key<wchar_t>(HKEY hkey, DWORD *max_subkey_len, DWORD *max_name_len, DWORD *max_value_len)
+    {
+        return RegQueryInfoKeyW(hkey, NULL, NULL, NULL, NULL, max_subkey_len, NULL, NULL, max_name_len, max_value_len, NULL, NULL);
+    }
+
+    /////////////////////////////////////////////////////////////////////////////
+    // Registry key handle wrapper
+    
+    template<class Ch>
+    class reg_key
+    {
+    public:
+        typedef std::basic_string<Ch> Str;
+        reg_key(HKEY root, const std::basic_string<Ch> &key, bool create):
+            hkey(0)
+        {
+            if (create)
+            {
+                LONG result = reg_create_key_ex(root, key.c_str(), KEY_WRITE, &hkey);
+                if (result != ERROR_SUCCESS)
+                    throw registry_parser_error("RegCreateKeyEx failed", result);
+            }
+            else
+            {
+                LONG result = reg_open_key_ex(root, key.c_str(), KEY_READ, &hkey);
+                if (result != ERROR_SUCCESS)
+                    throw registry_parser_error("RegOpenKeyEx failed", result);
+            }
+            BOOST_ASSERT(hkey);
+        }
+        ~reg_key()
+        {
+            BOOST_ASSERT(hkey);
+            RegCloseKey(hkey);
+        }
+        HKEY handle()
+        {
+            BOOST_ASSERT(hkey);
+            return hkey;
+        }
+    private:
+        HKEY hkey;
+    };
+    
+    /////////////////////////////////////////////////////////////////////////////
+    // Registry parser
+    
+    //! Read registry
+    template<class Ptree>
+    void read_registry(HKEY root, 
+                       const std::basic_string<typename Ptree::char_type> &key, 
+                       Ptree &pt)
+    {
+
+        typedef typename Ptree::char_type Ch;
+        typedef std::basic_string<Ch> Str;
+        typedef std::basic_stringstream<Ch> Stream;
+        
+        Ptree local;
+        
+        // Open key
+        reg_key<Ch> rk(root, key, false);
+        
+        // Query key info
+        DWORD max_subkey_len, max_name_len, max_value_len;
+        LONG result = reg_query_info_key<Ch>(rk.handle(), &max_subkey_len, &max_name_len, &max_value_len);
+        if (result != ERROR_SUCCESS)
+            throw registry_parser_error("RegQueryInfoKey failed", result);
+
+        // For all subkeys
+        std::vector<Ch> subkey(max_subkey_len + 1);
+        for (DWORD index = 0; true; ++index)
+        {
+            
+            // Get subkey name
+            DWORD size = static_cast<DWORD>(subkey.size());
+            LONG result = reg_enum_key_ex(rk.handle(), index, &subkey.front(), &size);
+            if (result == ERROR_NO_MORE_ITEMS)
+                break;
+            if (result != ERROR_SUCCESS)
+                throw registry_parser_error("RegEnumKeyEx failed", result);
+            
+            // Parse recursively
+            Ptree &child = local.push_back(typename Ptree::value_type(&subkey.front(), Ptree()))->second;
+            read_registry<Ptree>(rk.handle(), &subkey.front(), child);
+
+        }
+
+        // For all values
+        for (DWORD index = 0; true; ++index)
+        {
+
+            // Resize data to max size
+            std::vector<Ch> name(max_name_len + 1);
+            std::vector<BYTE> data(max_value_len + 1);
+            
+            // Get name and value from registry
+            DWORD name_size = static_cast<DWORD>(name.size());
+            DWORD data_size = static_cast<DWORD>(data.size());
+            DWORD type;
+            result = reg_enum_value<Ch>(rk.handle(), index, &name.front(), &name_size, &type, &data.front(), &data_size);
+            if (result == ERROR_NO_MORE_ITEMS)
+                break;
+            if (result != ERROR_SUCCESS)
+                throw registry_parser_error("RegEnumValue failed", result);
+
+            // Truncate data to actual size
+            name.resize(name_size + 1);
+            data.resize(data_size);
+
+            // Translate and put value in tree
+            Str value = translate<Ch>(type, data);
+            if (name_size > 0)
+            {
+                local.put(Str(detail::widen<Ch>("\\values.") + &name.front()), value);
+                local.put(Str(detail::widen<Ch>("\\types.") + &name.front()), type);
+            }
+            else
+                local.data() = value;
+
+        }
+
+        // Swap pt and local
+        pt.swap(local);
+
+    }
+
+    //! Write registry
+    template<class Ptree>
+    void write_registry(HKEY root, 
+                        const std::basic_string<typename Ptree::char_type> &key, 
+                        const Ptree &pt)
+    {
+
+        typedef typename Ptree::char_type Ch;
+        typedef std::basic_string<Ch> Str;
+        typedef std::basic_stringstream<Ch> Stream;
+        
+        // Create key
+        reg_key<Ch> rk(root, key, true);
+
+        // Set default key value
+        if (!pt.data().empty())
+        {
+            std::vector<BYTE> data = translate<Ch>(REG_SZ, pt.data());
+            reg_set_value_ex<Ch>(rk.handle(), NULL, REG_SZ, 
+                                 data.empty() ? NULL : &data.front(), 
+                                 static_cast<DWORD>(data.size()));
+        }
+
+        // Create values
+        const Ptree &values = pt.get_child(detail::widen<Ch>("\\values"), empty_ptree<Ptree>());
+        const Ptree &types = pt.get_child(detail::widen<Ch>("\\types"), empty_ptree<Ptree>());
+        for (typename Ptree::const_iterator it = values.begin(), end = values.end(); it != end; ++it)
+        {
+            DWORD type = types.get(it->first, REG_SZ);
+            std::vector<BYTE> data = translate<Ch>(type, it->second.data());
+            reg_set_value_ex<Ch>(rk.handle(), it->first.c_str(), type, 
+                                 data.empty() ? NULL : &data.front(), 
+                                 static_cast<DWORD>(data.size()));
+        }
+
+        // Create subkeys
+        for (typename Ptree::const_iterator it = pt.begin(), end = pt.end(); it != end; ++it)
+            if (&it->second != &values && &it->second != &types)
+                write_registry(rk.handle(), it->first, it->second);
+
+    }
+
+} } }
+
+namespace boost { namespace property_tree
+{
+    using registry_parser::read_registry;
+    using registry_parser::write_registry;
+    using registry_parser::registry_parser_error;
+} }
+
+#endif

Added: trunk/boost/property_tree/xml_parser.hpp
===================================================================
--- trunk/boost/property_tree/xml_parser.hpp	2006-10-03 08:44:04 UTC (rev 304)
+++ trunk/boost/property_tree/xml_parser.hpp	2006-10-03 08:49:51 UTC (rev 305)
@@ -0,0 +1,86 @@
+// ----------------------------------------------------------------------------
+// Copyright (C) 2002-2005 Marcin Kalicinski
+//
+// Distributed under the Boost Software License, Version 1.0. 
+// (See accompanying file LICENSE_1_0.txt or copy at 
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// For more information, see www.boost.org
+// ----------------------------------------------------------------------------
+#ifndef BOOST_PROPERTY_TREE_XML_PARSER_HPP_INCLUDED
+#define BOOST_PROPERTY_TREE_XML_PARSER_HPP_INCLUDED
+
+#include <boost/property_tree/ptree.hpp>
+#include <boost/property_tree/detail/xml_parser_write.hpp>
+#include <boost/property_tree/detail/xml_parser_error.hpp>
+#include <boost/property_tree/detail/xml_parser_flags.hpp>
+
+// Include proper parser
+#ifdef BOOST_PROPERTY_TREE_XML_PARSER_TINYXML
+#include <boost/property_tree/detail/xml_parser_read_tinyxml.hpp>
+#else
+#include <boost/property_tree/detail/xml_parser_read_spirit.hpp>
+#endif
+
+#include <fstream>
+#include <string>
+#include <locale>
+
+namespace boost { namespace property_tree { namespace xml_parser
+{
+
+    // Read XML from stream
+    template<class Ptree>
+    void read_xml(std::basic_istream<typename Ptree::char_type> &stream,
+                  Ptree &pt,
+                  int flags = 0)
+    {
+        read_xml_internal(stream, pt, flags, std::string());
+    }
+
+    // Read XML from file
+    template<class Ptree>
+    void read_xml(const std::string &filename,
+                  Ptree &pt,
+                  int flags = 0,
+                  const std::locale &loc = std::locale())
+    {
+        BOOST_ASSERT(validate_flags(flags));
+        std::basic_ifstream<typename Ptree::char_type> stream(filename.c_str());
+        if (!stream)
+            throw xml_parser_error("cannot open file", filename, 0);
+        stream.imbue(loc);
+        read_xml_internal(stream, pt, flags, filename);
+    }
+
+    // Write XML to stream
+    template<class Ptree>
+    void write_xml(std::basic_ostream<typename Ptree::char_type> &stream, 
+                   const Ptree &pt)
+    {
+        write_xml_internal(stream, pt, std::string());
+    }
+
+    // Write XML to file
+    template<class Ptree>
+    void write_xml(const std::string &filename,
+                   const Ptree &pt,
+                   const std::locale &loc = std::locale())
+    {
+        std::basic_ofstream<typename Ptree::char_type> stream(filename.c_str());
+        if (!stream)
+            throw xml_parser_error("cannot open file", filename, 0);
+        stream.imbue(loc);
+        write_xml_internal(stream, pt, filename);
+    }
+
+} } }
+
+namespace boost { namespace property_tree
+{
+    using xml_parser::read_xml;
+    using xml_parser::write_xml;
+    using xml_parser::xml_parser_error;
+} }
+
+#endif



From pavlenko at mail.berlios.de  Tue Oct  3 10:52:08 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Tue, 3 Oct 2006 10:52:08 +0200
Subject: [Mapnik-svn] r306 - trunk/boost
Message-ID: <200610030852.k938q8Ew020387@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-03 10:52:07 +0200 (Tue, 03 Oct 2006)
New Revision: 306

Removed:
   trunk/boost/property_tree/
Log:
move property tree one level up



From pavlenko at mail.berlios.de  Tue Oct  3 10:52:26 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Tue, 3 Oct 2006 10:52:26 +0200
Subject: [Mapnik-svn] r307 - trunk
Message-ID: <200610030852.k938qQcN020401@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-03 10:52:24 +0200 (Tue, 03 Oct 2006)
New Revision: 307

Added:
   trunk/property_tree/
Log:
move property tree one level up

Copied: trunk/property_tree (from rev 305, trunk/boost/property_tree)



From pavlenko at mail.berlios.de  Tue Oct  3 11:06:42 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Tue, 3 Oct 2006 11:06:42 +0200
Subject: [Mapnik-svn] r308 - in trunk: . boost boost/property_tree
	boost/property_tree/detail
Message-ID: <200610030906.k9396gfn023616@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-03 11:06:13 +0200 (Tue, 03 Oct 2006)
New Revision: 308

Added:
   trunk/boost/property_tree/
   trunk/boost/property_tree/cmdline_parser.hpp
   trunk/boost/property_tree/detail/
   trunk/boost/property_tree/detail/file_parser_error.hpp
   trunk/boost/property_tree/detail/info_parser_error.hpp
   trunk/boost/property_tree/detail/info_parser_read.hpp
   trunk/boost/property_tree/detail/info_parser_utils.hpp
   trunk/boost/property_tree/detail/info_parser_write.hpp
   trunk/boost/property_tree/detail/json_parser_error.hpp
   trunk/boost/property_tree/detail/json_parser_read.hpp
   trunk/boost/property_tree/detail/json_parser_write.hpp
   trunk/boost/property_tree/detail/ptree_implementation.hpp
   trunk/boost/property_tree/detail/ptree_interface.hpp
   trunk/boost/property_tree/detail/ptree_utils.hpp
   trunk/boost/property_tree/detail/xml_parser_error.hpp
   trunk/boost/property_tree/detail/xml_parser_flags.hpp
   trunk/boost/property_tree/detail/xml_parser_read_spirit.hpp
   trunk/boost/property_tree/detail/xml_parser_read_tinyxml.hpp
   trunk/boost/property_tree/detail/xml_parser_utils.hpp
   trunk/boost/property_tree/detail/xml_parser_write.hpp
   trunk/boost/property_tree/info_parser.hpp
   trunk/boost/property_tree/ini_parser.hpp
   trunk/boost/property_tree/json_parser.hpp
   trunk/boost/property_tree/ptree.hpp
   trunk/boost/property_tree/ptree_fwd.hpp
   trunk/boost/property_tree/registry_parser.hpp
   trunk/boost/property_tree/xml_parser.hpp
Removed:
   trunk/boost/property_tree/cmdline_parser.hpp
   trunk/boost/property_tree/detail/
   trunk/boost/property_tree/detail/file_parser_error.hpp
   trunk/boost/property_tree/detail/info_parser_error.hpp
   trunk/boost/property_tree/detail/info_parser_read.hpp
   trunk/boost/property_tree/detail/info_parser_utils.hpp
   trunk/boost/property_tree/detail/info_parser_write.hpp
   trunk/boost/property_tree/detail/json_parser_error.hpp
   trunk/boost/property_tree/detail/json_parser_read.hpp
   trunk/boost/property_tree/detail/json_parser_write.hpp
   trunk/boost/property_tree/detail/ptree_implementation.hpp
   trunk/boost/property_tree/detail/ptree_interface.hpp
   trunk/boost/property_tree/detail/ptree_utils.hpp
   trunk/boost/property_tree/detail/xml_parser_error.hpp
   trunk/boost/property_tree/detail/xml_parser_flags.hpp
   trunk/boost/property_tree/detail/xml_parser_read_spirit.hpp
   trunk/boost/property_tree/detail/xml_parser_read_tinyxml.hpp
   trunk/boost/property_tree/detail/xml_parser_utils.hpp
   trunk/boost/property_tree/detail/xml_parser_write.hpp
   trunk/boost/property_tree/info_parser.hpp
   trunk/boost/property_tree/ini_parser.hpp
   trunk/boost/property_tree/json_parser.hpp
   trunk/boost/property_tree/ptree.hpp
   trunk/boost/property_tree/ptree_fwd.hpp
   trunk/boost/property_tree/registry_parser.hpp
   trunk/boost/property_tree/xml_parser.hpp
   trunk/property_tree/
Log:
opps, may be not. merging back to -r305
 


Copied: trunk/boost/property_tree (from rev 305, trunk/boost/property_tree)

Deleted: trunk/boost/property_tree/cmdline_parser.hpp
===================================================================
--- trunk/boost/property_tree/cmdline_parser.hpp	2006-10-03 08:49:51 UTC (rev 305)
+++ trunk/boost/property_tree/cmdline_parser.hpp	2006-10-03 09:06:13 UTC (rev 308)
@@ -1,85 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2005 Marcin Kalicinski
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_CMDLINE_PARSER_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_CMDLINE_PARSER_HPP_INCLUDED
-
-#include <boost/property_tree/ptree.hpp>
-#include <boost/property_tree/detail/ptree_utils.hpp>
-
-namespace boost { namespace property_tree { namespace cmdline_parser
-{
-
-    template<class Ptree>
-    void read_cmdline(int argc, 
-                      typename Ptree::char_type *argv[], 
-                      const std::basic_string<typename Ptree::char_type> &metachars,
-                      Ptree &pt)
-    {
-
-        typedef typename Ptree::char_type Ch;
-        typedef std::basic_string<Ch> Str;
-
-        Ptree local;
-        
-        // For all arguments
-        for (int i = 0; i < argc; ++i)
-        {
-            Str text = detail::trim<Ch>(argv[i]);
-            if (!text.empty())
-                if (metachars.find(text[0]) != Str::npos)
-                {
-                    if (text.size() == 1)
-                    {
-                        Ptree &child = local.put(text, Str());
-                        Str key; 
-                        if (child.size() < 10) 
-                            key.push_back(typename Ptree::char_type('0' + child.size()));
-                        child.push_back(std::make_pair(key, Ptree(child.data())));
-                    }
-                    else if (text.size() == 2)
-                    {
-                        Ptree &child = local.put(text.substr(1, 1), Str());
-                        Str key; 
-                        if (child.size() < 10) 
-                            key.push_back(typename Ptree::char_type('0' + child.size()));
-                        child.push_back(std::make_pair(key, Ptree(child.data())));
-                    }
-                    else
-                    {
-                        Ptree &child = local.put(text.substr(1, 1), detail::trim<Ch>(text.substr(2, Str::npos)));
-                        Str key; 
-                        if (child.size() < 10) 
-                            key.push_back(typename Ptree::char_type('0' + child.size()));
-                        child.push_back(std::make_pair(key, Ptree(child.data())));
-                    }
-                }
-                else
-                {
-                    Ptree &child = local.put(Str(), detail::trim<Ch>(text));
-                    Str key; 
-                    if (child.size() < 10) 
-                        key.push_back(typename Ptree::char_type('0' + child.size()));
-                    child.push_back(std::make_pair(key, Ptree(child.data())));
-                }
-        }
-
-        // Swap local and pt
-        pt.swap(local);
-
-    }
-
-} } }
-
-namespace boost { namespace property_tree
-{
-    using cmdline_parser::read_cmdline;
-} }
-
-#endif

Copied: trunk/boost/property_tree/cmdline_parser.hpp (from rev 305, trunk/boost/property_tree/cmdline_parser.hpp)

Copied: trunk/boost/property_tree/detail (from rev 305, trunk/boost/property_tree/detail)

Deleted: trunk/boost/property_tree/detail/file_parser_error.hpp
===================================================================
--- trunk/boost/property_tree/detail/file_parser_error.hpp	2006-10-03 08:49:51 UTC (rev 305)
+++ trunk/boost/property_tree/detail/file_parser_error.hpp	2006-10-03 09:06:13 UTC (rev 308)
@@ -1,88 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2005 Marcin Kalicinski
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_DETAIL_FILE_PARSER_ERROR_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_DETAIL_FILE_PARSER_ERROR_HPP_INCLUDED
-
-#include <boost/property_tree/ptree.hpp>
-#include <string>
-
-namespace boost { namespace property_tree
-{
-
-    //! File parse error
-    class file_parser_error: public ptree_error
-    {
-
-    public:
-
-        ///////////////////////////////////////////////////////////////////////
-        // Construction & destruction
-        
-        // Construct error
-        file_parser_error(const std::string &message, 
-                          const std::string &filename, 
-                          unsigned long line): 
-            ptree_error(format_what(message, filename, line)), 
-            m_message(message), m_filename(filename), m_line(line)
-        { 
-        }
-
-        ~file_parser_error() throw()    
-            // gcc 3.4.2 complains about lack of throw specifier on compiler generated dtor
-        {
-        }
-
-        ///////////////////////////////////////////////////////////////////////
-        // Data access
-        
-        // Get error message (without line and file - use what() to get full message)
-        std::string message()
-        {
-            return m_message;
-        }
-        
-        // Get error filename
-        std::string filename()
-        {
-            return m_filename;
-        }
-
-        // Get error line number
-        unsigned long line() 
-        { 
-            return m_line; 
-        }
-
-    private:
-        
-        std::string m_message;
-        std::string m_filename;
-        unsigned long m_line;
-
-        // Format error message to be returned by std::runtime_error::what()
-        std::string format_what(const std::string &message,
-                                const std::string &filename, 
-                                unsigned long line)
-        {
-            std::stringstream stream;
-            if (line > 0)
-                stream << (filename.empty() ? "<unspecified file>" : filename.c_str()) << 
-                          '(' << line << "): " << message;
-            else
-                stream << (filename.empty() ? "<unspecified file>" : filename.c_str()) << 
-                          ": " << message;
-            return stream.str();
-        }
-
-    };
-
-} }
-
-#endif

Copied: trunk/boost/property_tree/detail/file_parser_error.hpp (from rev 305, trunk/boost/property_tree/detail/file_parser_error.hpp)

Deleted: trunk/boost/property_tree/detail/info_parser_error.hpp
===================================================================
--- trunk/boost/property_tree/detail/info_parser_error.hpp	2006-10-03 08:49:51 UTC (rev 305)
+++ trunk/boost/property_tree/detail/info_parser_error.hpp	2006-10-03 09:06:13 UTC (rev 308)
@@ -1,32 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2005 Marcin Kalicinski
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_DETAIL_INFO_PARSER_ERROR_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_DETAIL_INFO_PARSER_ERROR_HPP_INCLUDED
-
-#include <boost/property_tree/detail/file_parser_error.hpp>
-#include <string>
-
-namespace boost { namespace property_tree { namespace info_parser
-{
-
-    class info_parser_error: public file_parser_error
-    {
-    public:
-        info_parser_error(const std::string &message, 
-                          const std::string &filename, 
-                          unsigned long line): 
-            file_parser_error(message, filename, line)
-        { 
-        }
-    };
-
-} } }
-
-#endif

Copied: trunk/boost/property_tree/detail/info_parser_error.hpp (from rev 305, trunk/boost/property_tree/detail/info_parser_error.hpp)

Deleted: trunk/boost/property_tree/detail/info_parser_read.hpp
===================================================================
--- trunk/boost/property_tree/detail/info_parser_read.hpp	2006-10-03 08:49:51 UTC (rev 305)
+++ trunk/boost/property_tree/detail/info_parser_read.hpp	2006-10-03 09:06:13 UTC (rev 308)
@@ -1,369 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2005 Marcin Kalicinski
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_DETAIL_INFO_PARSER_READ_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_DETAIL_INFO_PARSER_READ_HPP_INCLUDED
-
-#include "boost/property_tree/ptree.hpp"
-#include "boost/property_tree/detail/info_parser_error.hpp"
-#include "boost/property_tree/detail/info_parser_utils.hpp"
-#include <iterator>
-#include <string>
-#include <stack>
-#include <fstream>
-#include <cctype>
-
-namespace boost { namespace property_tree { namespace info_parser
-{
-    
-    // Expand known escape sequences
-    template<class It>
-    std::basic_string<typename std::iterator_traits<It>::value_type> 
-        expand_escapes(It b, It e)
-    {
-        typedef typename std::iterator_traits<It>::value_type Ch;
-        std::basic_string<Ch> result;
-        while (b != e)
-        {
-            if (*b == Ch('\\'))
-            {
-                ++b;
-                if (b == e)
-                    throw info_parser_error("character expected after backslash", "", 0);
-                else if (*b == Ch('0')) result += Ch('\0');
-                else if (*b == Ch('a')) result += Ch('\a');
-                else if (*b == Ch('b')) result += Ch('\b');
-                else if (*b == Ch('f')) result += Ch('\f');
-                else if (*b == Ch('n')) result += Ch('\n');
-                else if (*b == Ch('r')) result += Ch('\r');
-                else if (*b == Ch('t')) result += Ch('\t');
-                else if (*b == Ch('v')) result += Ch('\v');
-                else if (*b == Ch('"')) result += Ch('"');
-                else if (*b == Ch('\'')) result += Ch('\'');
-                else if (*b == Ch('\\')) result += Ch('\\');
-                else
-                    throw info_parser_error("unknown escape sequence", "", 0);
-            }
-            else
-                result += *b;
-            ++b;
-        }
-        return result;
-    }
-    
-    // Advance pointer past whitespace
-    template<class Ch>
-    void skip_whitespace(const Ch *&text)
-    {
-        using namespace std;
-        while (isspace(*text))
-            ++text;
-    }
-    
-    // Extract word (whitespace delimited) and advance pointer accordingly
-    template<class Ch>
-    std::basic_string<Ch> read_word(const Ch *&text)
-    {
-        using namespace std;
-        skip_whitespace(text);
-        const Ch *start = text;
-        while (!isspace(*text) && *text != Ch(';') && *text != Ch('\0'))
-            ++text;
-        return expand_escapes(start, text);
-    }
-
-    // Extract line (eol delimited) and advance pointer accordingly
-    template<class Ch>
-    std::basic_string<Ch> read_line(const Ch *&text)
-    {
-        using namespace std;
-        skip_whitespace(text);
-        const Ch *start = text;
-        while (*text != Ch('\0') && *text != Ch(';'))
-            ++text;
-        while (text > start && isspace(*(text - 1)))
-            --text;
-        return expand_escapes(start, text);
-    }
-
-    // Extract string (inside ""), and advance pointer accordingly
-    // Set need_more_lines to true if \ continuator found
-    template<class Ch>
-    std::basic_string<Ch> read_string(const Ch *&text, bool *need_more_lines)
-    {
-        skip_whitespace(text);
-        if (*text == Ch('\"'))
-        {
-            
-            // Skip "
-            ++text;
-            
-            // Find end of string, but skip escaped "
-            bool escaped = false;
-            const Ch *start = text;
-            while ((escaped || *text != Ch('\"')) && *text != Ch('\0'))
-            {
-                escaped = (!escaped && *text == Ch('\\'));
-                ++text;
-            }
-            
-            // If end of string found
-            if (*text == Ch('\"'))
-            {
-                std::basic_string<Ch> result = expand_escapes(start, text++);
-                skip_whitespace(text);
-                if (*text == Ch('\\'))
-                {
-                    if (!need_more_lines)
-                        throw info_parser_error("unexpected \\", "", 0);
-                    ++text;
-                    skip_whitespace(text);
-                    if (*text == Ch('\0') || *text == Ch(';'))
-                        *need_more_lines = true;
-                    else
-                        throw info_parser_error("expected end of line after \\", "", 0);
-                }
-                else
-                    if (need_more_lines)
-                        *need_more_lines = false;
-                return result;
-            }
-            else
-                throw info_parser_error("unexpected end of line", "", 0);
-
-        }
-        else
-            throw info_parser_error("expected \"", "", 0);
-    }
-    
-    // Extract key
-    template<class Ch>
-    std::basic_string<Ch> read_key(const Ch *&text)
-    {
-        skip_whitespace(text);
-        if (*text == Ch('\"'))
-            return read_string(text, NULL);
-        else
-            return read_word(text);
-    }
-
-    // Extract data
-    template<class Ch>
-    std::basic_string<Ch> read_data(const Ch *&text, bool *need_more_lines)
-    {
-        skip_whitespace(text);
-        if (*text == Ch('\"'))
-            return read_string(text, need_more_lines);
-        else
-        {
-            *need_more_lines = false;
-            return read_word(text);
-        }
-    }
-
-    // Build ptree from info stream
-    template<class Ptree>
-    void read_info_internal(std::basic_istream<typename Ptree::char_type> &stream, 
-                            Ptree &pt, 
-                            const std::string &filename,
-                            int include_depth)
-    {
-        
-        // Character type
-        typedef typename Ptree::char_type Ch;
-        
-        // Possible parser states
-        enum state_t { 
-            s_key,              // Parser expects key
-            s_data,             // Parser expects data
-            s_data_cont         // Parser expects data continuation
-        };
-        
-        unsigned long line_no = 0;
-        state_t state = s_key;          // Parser state
-        Ptree *last = NULL;             // Pointer to last created ptree
-        std::basic_string<Ch> line;     // Define line here to minimize reallocations
-            
-        // Initialize ptree stack (used to handle nesting)
-        std::stack<Ptree *> stack;
-        stack.push(&pt);                // Push root ptree on stack initially
-        
-        try
-        {
-        
-            // While there are characters in the stream
-            while (stream.good())
-            {
-            
-                // Read one line from stream
-                ++line_no;
-                std::getline(stream, line);
-                if (!stream.good() && !stream.eof())
-                    throw info_parser_error("read error", "", 0);
-                const Ch *text = line.c_str();
-
-                // If directive found
-                skip_whitespace(text);
-                if (*text == Ch('#'))
-                {
-                    
-                    // Determine directive type
-                    ++text;     // skip #
-                    std::basic_string<Ch> directive = read_word(text);
-                    if (directive == convert_chtype<Ch, char>("include"))     // #include
-                    {
-                        if (include_depth > 100)
-                            throw info_parser_error("include depth too large, probably recursive include", "", 0);
-                        std::basic_string<Ch> s = read_string(text, NULL);
-                        std::string inc_name = convert_chtype<char, Ch>(s.c_str());
-                        std::basic_ifstream<Ch> inc_stream(inc_name.c_str());
-                        if (!inc_stream.good())
-                            throw info_parser_error("cannot open include file " + inc_name, "", 0);
-                        read_info_internal(inc_stream, *stack.top(), inc_name, include_depth + 1);
-                    }
-                    else    // Unknown directive
-                        throw info_parser_error("unknown directive", "", 0);
-
-                    // Directive must be followed by end of line
-                    skip_whitespace(text);
-                    if (*text != Ch('\0'))
-                        throw info_parser_error("expected end of line", "", 0);
-
-                    // Go to next line
-                    continue;
-
-                }
-
-                // While there are characters left in line
-                while (1)
-                {
-
-                    // Stop parsing on end of line or comment
-                    skip_whitespace(text);
-                    if (*text == Ch('\0') || *text == Ch(';'))
-                    {
-                        if (state == s_data)    // If there was no data set state to s_key
-                            state = s_key;
-                        break; 
-                    }
-
-                    // Process according to current parser state
-                    switch (state)
-                    {
-
-                        // Parser expects key
-                        case s_key:
-                        {
-
-                            if (*text == Ch('{'))   // Brace opening found
-                            {
-                                if (!last)
-                                    throw info_parser_error("unexpected {", "", 0);
-                                stack.push(last);
-                                last = NULL;
-                                ++text;
-                            }
-                            else if (*text == Ch('}'))  // Brace closing found
-                            {
-                                if (stack.size() <= 1)
-                                    throw info_parser_error("unmatched }", "", 0);
-                                stack.pop();
-                                last = NULL;
-                                ++text;
-                            }
-                            else    // Key text found
-                            {
-                                std::basic_string<Ch> key = read_key(text);
-                                last = &stack.top()->push_back(std::make_pair(key, Ptree()))->second;
-                                state = s_data;
-                            }
-
-                        }; break;
-
-                        // Parser expects data
-                        case s_data:
-                        {
-                            
-                            // Last ptree must be defined because we are going to add data to it
-                            BOOST_ASSERT(last);
-                            
-                            if (*text == Ch('{'))   // Brace opening found
-                            {
-                                stack.push(last);
-                                last = NULL;
-                                ++text;
-                                state = s_key;
-                            }
-                            else if (*text == Ch('}'))  // Brace closing found
-                            {
-                                if (stack.size() <= 1)
-                                    throw info_parser_error("unmatched }", "", 0);
-                                stack.pop();
-                                last = NULL;
-                                ++text;
-                                state = s_key;
-                            }
-                            else    // Data text found
-                            {
-                                bool need_more_lines;
-                                std::basic_string<Ch> data = read_data(text, &need_more_lines);
-                                last->data() = data;
-                                state = need_more_lines ? s_data_cont : s_key;
-                            }
-
-
-                        }; break;
-
-                        // Parser expects continuation of data after \ on previous line
-                        case s_data_cont:
-                        {
-                            
-                            // Last ptree must be defined because we are going to update its data
-                            BOOST_ASSERT(last);
-                            
-                            if (*text == Ch('\"'))  // Continuation must start with "
-                            {
-                                bool need_more_lines;
-                                std::basic_string<Ch> data = read_string(text, &need_more_lines);
-                                last->put_own(last->template get_own<std::basic_string<Ch> >() + data);
-                                state = need_more_lines ? s_data_cont : s_key;
-                            }
-                            else
-                                throw info_parser_error("expected \" after \\ in previous line", "", 0);
-
-                        }; break;
-
-                        // Should never happen
-                        default:
-                            BOOST_ASSERT(0);
-
-                    }
-                }
-            }
-
-            // Check if stack has initial size, otherwise some {'s have not been closed
-            if (stack.size() != 1)
-                throw info_parser_error("unmatched {", "", 0);
-
-        }
-        catch (info_parser_error &e)
-        {
-            // If line undefined rethrow error with correct filename and line
-            if (e.line() == 0)
-                throw info_parser_error(e.message(), filename, line_no);
-            else
-                throw e;
-
-        }
-
-    }
-    
-} } }
-
-#endif

Copied: trunk/boost/property_tree/detail/info_parser_read.hpp (from rev 305, trunk/boost/property_tree/detail/info_parser_read.hpp)

Deleted: trunk/boost/property_tree/detail/info_parser_utils.hpp
===================================================================
--- trunk/boost/property_tree/detail/info_parser_utils.hpp	2006-10-03 08:49:51 UTC (rev 305)
+++ trunk/boost/property_tree/detail/info_parser_utils.hpp	2006-10-03 09:06:13 UTC (rev 308)
@@ -1,32 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2005 Marcin Kalicinski
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_DETAIL_INFO_PARSER_CHCONV_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_DETAIL_INFO_PARSER_CHCONV_HPP_INCLUDED
-
-#include <string>
-
-namespace boost { namespace property_tree { namespace info_parser
-{
-
-    template<class ChDest, class ChSrc>
-    std::basic_string<ChDest> convert_chtype(const ChSrc *text)
-    {
-        std::basic_string<ChDest> result;
-        while (*text)
-        {
-            result += ChDest(*text);
-            ++text;
-        }
-        return result;
-    }
-
-} } }
-
-#endif

Copied: trunk/boost/property_tree/detail/info_parser_utils.hpp (from rev 305, trunk/boost/property_tree/detail/info_parser_utils.hpp)

Deleted: trunk/boost/property_tree/detail/info_parser_write.hpp
===================================================================
--- trunk/boost/property_tree/detail/info_parser_write.hpp	2006-10-03 08:49:51 UTC (rev 305)
+++ trunk/boost/property_tree/detail/info_parser_write.hpp	2006-10-03 09:06:13 UTC (rev 308)
@@ -1,131 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2005 Marcin Kalicinski
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_DETAIL_INFO_PARSER_WRITE_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_DETAIL_INFO_PARSER_WRITE_HPP_INCLUDED
-
-#include "boost/property_tree/ptree.hpp"
-#include "boost/property_tree/detail/info_parser_utils.hpp"
-#include <string>
-
-namespace boost { namespace property_tree { namespace info_parser
-{
-    
-    // Create necessary escape sequences from illegal characters
-    template<class Ch>
-    std::basic_string<Ch> create_escapes(const std::basic_string<Ch> &s)
-    {
-        std::basic_string<Ch> result;
-        typename std::basic_string<Ch>::const_iterator b = s.begin();
-        typename std::basic_string<Ch>::const_iterator e = s.end();
-        while (b != e)
-        {
-            if (*b == Ch('\0')) result += Ch('\\'), result += Ch('0');
-            else if (*b == Ch('\a')) result += Ch('\\'), result += Ch('a');
-            else if (*b == Ch('\b')) result += Ch('\\'), result += Ch('b');
-            else if (*b == Ch('\f')) result += Ch('\\'), result += Ch('f');
-            else if (*b == Ch('\n')) result += Ch('\\'), result += Ch('n');
-            else if (*b == Ch('\r')) result += Ch('\\'), result += Ch('r');
-            else if (*b == Ch('\v')) result += Ch('\\'), result += Ch('v');
-            else if (*b == Ch('"')) result += Ch('\\'), result += Ch('"');
-            else if (*b == Ch('\\')) result += Ch('\\'), result += Ch('\\');
-            else
-                result += *b;
-            ++b;
-        }
-        return result;
-    }
-
-    template<class Ch>
-    bool is_simple_key(const std::basic_string<Ch> &key)
-    {
-        const static std::basic_string<Ch> chars = convert_chtype<Ch, char>(" \t{};\n\"");
-        return !key.empty() && key.find_first_of(chars) == key.npos;
-    }
-    
-    template<class Ch>
-    bool is_simple_data(const std::basic_string<Ch> &data)
-    {
-        const static std::basic_string<Ch> chars = convert_chtype<Ch, char>(" \t{};\n\"");
-        return !data.empty() && data.find_first_of(chars) == data.npos;
-    }
-
-    template<class Ptree>
-    void write_info_helper(std::basic_ostream<typename Ptree::char_type> &stream, 
-                           const Ptree &pt, 
-                           int indent)
-    {
-
-        // Character type
-        typedef typename Ptree::char_type Ch;
-        
-        // Write data
-        if (indent >= 0)
-        {
-            if (!pt.data().empty())
-            {
-                std::basic_string<Ch> data = create_escapes(pt.template get_own<std::basic_string<Ch> >());
-                if (is_simple_data(data))
-                    stream << Ch(' ') << data << Ch('\n');
-                else
-                    stream << Ch(' ') << Ch('\"') << data << Ch('\"') << Ch('\n');
-            }
-            else if (pt.empty())
-                stream << Ch(' ') << Ch('\"') << Ch('\"') << Ch('\n');
-            else
-                stream << Ch('\n');
-        }
-        
-        // Write keys
-        if (!pt.empty())
-        {
-            
-            // Open brace
-            if (indent >= 0) 
-                stream << std::basic_string<Ch>(4 * indent, Ch(' ')) << Ch('{') << Ch('\n');
-            
-            // Write keys
-            typename Ptree::const_iterator it = pt.begin();
-            for (; it != pt.end(); ++it)
-            {
-
-                // Output key
-                std::basic_string<Ch> key = create_escapes(it->first);
-                stream << std::basic_string<Ch>(4 * (indent + 1), Ch(' '));
-                if (is_simple_key(key))
-                    stream << key;
-                else
-                    stream << Ch('\"') << key << Ch('\"');
-
-                // Output data and children  
-                write_info_helper(stream, it->second, indent + 1);
-
-            }
-            
-            // Close brace
-            if (indent >= 0) 
-                stream << std::basic_string<Ch>(4 * indent, Ch(' ')) << Ch('}') << Ch('\n');
-
-        }
-    }
-
-    // Write ptree to info stream
-    template<class Ptree>
-    void write_info_internal(std::basic_ostream<typename Ptree::char_type> &stream, 
-                             const Ptree &pt,
-                             const std::string &filename)
-    {
-        write_info_helper(stream, pt, -1);
-        if (!stream.good())
-            throw info_parser_error("write error", filename, 0);
-    }
-
-} } }
-
-#endif

Copied: trunk/boost/property_tree/detail/info_parser_write.hpp (from rev 305, trunk/boost/property_tree/detail/info_parser_write.hpp)

Deleted: trunk/boost/property_tree/detail/json_parser_error.hpp
===================================================================
--- trunk/boost/property_tree/detail/json_parser_error.hpp	2006-10-03 08:49:51 UTC (rev 305)
+++ trunk/boost/property_tree/detail/json_parser_error.hpp	2006-10-03 09:06:13 UTC (rev 308)
@@ -1,33 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2005 Marcin Kalicinski
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_DETAIL_JSON_PARSER_ERROR_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_DETAIL_JSON_PARSER_ERROR_HPP_INCLUDED
-
-#include <boost/property_tree/detail/file_parser_error.hpp>
-#include <string>
-
-namespace boost { namespace property_tree { namespace json_parser
-{
-
-    //! Json parser error
-    class json_parser_error: public file_parser_error
-    {
-    public:
-        json_parser_error(const std::string &message, 
-                          const std::string &filename, 
-                          unsigned long line): 
-            file_parser_error(message, filename, line)
-        { 
-        }
-    };
-
-} } }
-
-#endif

Copied: trunk/boost/property_tree/detail/json_parser_error.hpp (from rev 305, trunk/boost/property_tree/detail/json_parser_error.hpp)

Deleted: trunk/boost/property_tree/detail/json_parser_read.hpp
===================================================================
--- trunk/boost/property_tree/detail/json_parser_read.hpp	2006-10-03 08:49:51 UTC (rev 305)
+++ trunk/boost/property_tree/detail/json_parser_read.hpp	2006-10-03 09:06:13 UTC (rev 308)
@@ -1,316 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2005 Marcin Kalicinski
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_DETAIL_JSON_PARSER_READ_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_DETAIL_JSON_PARSER_READ_HPP_INCLUDED
-
-//#define BOOST_SPIRIT_DEBUG
-
-#include <boost/property_tree/ptree.hpp>
-#include <boost/property_tree/detail/ptree_utils.hpp>
-#include <boost/property_tree/detail/json_parser_error.hpp>
-#include <boost/spirit.hpp>
-#include <string>
-#include <locale>
-#include <istream>
-#include <vector>
-#include <algorithm>
-
-namespace boost { namespace property_tree { namespace json_parser
-{
-
-    ///////////////////////////////////////////////////////////////////////
-    // Json parser context
-        
-    template<class Ptree>
-    struct context
-    {
-
-        typedef typename Ptree::char_type Ch;
-        typedef std::basic_string<Ch> Str;
-        typedef typename std::vector<Ch>::iterator It;
-        
-        Str string;
-        Str name;
-        Ptree root;
-        std::vector<Ptree *> stack;
-
-        struct a_object_s
-        {
-            context &c;
-            a_object_s(context &c): c(c) { }
-            void operator()(Ch) const
-            {
-                if (c.stack.empty())
-                    c.stack.push_back(&c.root);
-                else
-                {
-                    Ptree *parent = c.stack.back();
-                    Ptree *child = &parent->push_back(std::make_pair(c.name, Ptree()))->second;
-                    c.stack.push_back(child);
-                    c.name.clear();
-                }
-            }
-        };
-        
-        struct a_object_e
-        {
-            context &c;
-            a_object_e(context &c): c(c) { }
-            void operator()(Ch) const
-            {
-                BOOST_ASSERT(c.stack.size() >= 1);
-                c.stack.pop_back();
-            }
-        };
-
-        struct a_name
-        {
-            context &c;
-            a_name(context &c): c(c) { }
-            void operator()(It, It) const
-            {
-                c.name.swap(c.string);
-                c.string.clear();
-            }
-        };
-
-        struct a_string_val
-        {
-            context &c;
-            a_string_val(context &c): c(c) { }
-            void operator()(It, It) const
-            {
-                BOOST_ASSERT(c.stack.size() >= 1);
-                c.stack.back()->push_back(std::make_pair(c.name, Ptree(c.string)));
-                c.name.clear();
-                c.string.clear();
-            }
-        };
-
-        struct a_literal_val
-        {
-            context &c;
-            a_literal_val(context &c): c(c) { }
-            void operator()(It b, It e) const
-            {
-                BOOST_ASSERT(c.stack.size() >= 1);
-                c.stack.back()->push_back(std::make_pair(c.name, Str(b, e)));
-                c.name.clear();
-                c.string.clear();
-            }
-        };
-
-        struct a_char
-        {
-            context &c;
-            a_char(context &c): c(c) { }
-            void operator()(It b, It e) const
-            {
-                c.string += *b;
-            }
-        };
-
-        struct a_escape
-        {
-            context &c;
-            a_escape(context &c): c(c) { }
-            void operator()(Ch ch) const
-            {
-                switch (ch)
-                {
-                    case Ch('\"'): c.string += Ch('\"'); break;
-                    case Ch('\\'): c.string += Ch('\\'); break;
-                    case Ch('0'): c.string += Ch('\0'); break;
-                    case Ch('b'): c.string += Ch('\b'); break;
-                    case Ch('f'): c.string += Ch('\f'); break;
-                    case Ch('n'): c.string += Ch('\n'); break;
-                    case Ch('r'): c.string += Ch('\r'); break;
-                    case Ch('t'): c.string += Ch('\t'); break;
-                    default: BOOST_ASSERT(0);
-                }
-            }
-        };
-
-        struct a_unicode
-        {
-            context &c;
-            a_unicode(context &c): c(c) { }
-            void operator()(unsigned long u) const
-            {
-                u = (std::min)(u, static_cast<unsigned long>((std::numeric_limits<Ch>::max)()));
-                c.string += Ch(u);
-            }
-        };
-
-    };
-
-    ///////////////////////////////////////////////////////////////////////
-    // Json grammar
-        
-    template<class Ptree>
-    struct json_grammar: public boost::spirit::grammar<json_grammar<Ptree> >
-    {
-        
-        typedef context<Ptree> Context;
-        typedef typename Ptree::char_type Ch;
-
-        mutable Context c;
-        
-        template<class Scanner>
-        struct definition
-        {
-            
-            boost::spirit::rule<Scanner> root, object, member, array, item, value, string, number;
-            boost::spirit::rule<typename boost::spirit::lexeme_scanner<Scanner>::type> character, escape;
-
-            definition(const json_grammar &self)
-            {
-                
-                using namespace boost::spirit;
-
-                // Assertions
-                assertion<std::string> expect_object("expected object");
-                assertion<std::string> expect_eoi("expected end of input");
-                assertion<std::string> expect_objclose("expected ',' or '}'");
-                assertion<std::string> expect_arrclose("expected ',' or ']'");
-                assertion<std::string> expect_name("expected object name");
-                assertion<std::string> expect_colon("expected ':'");
-                assertion<std::string> expect_value("expected value");
-                assertion<std::string> expect_escape("invalid escape sequence");
-
-                // JSON grammar rules
-                root 
-                    =   expect_object(object) 
-                        >> expect_eoi(end_p)
-                        ;
-                
-                object 
-                    =   ch_p('{')[typename Context::a_object_s(self.c)]
-                        >> (ch_p('}')[typename Context::a_object_e(self.c)] 
-                           | (list_p(member, ch_p(','))
-                              >> expect_objclose(ch_p('}')[typename Context::a_object_e(self.c)])
-                             )
-                           )
-                        ;
-                
-                member 
-                    =   expect_name(string[typename Context::a_name(self.c)]) 
-                        >> expect_colon(ch_p(':')) 
-                        >> expect_value(value)
-                        ;
-                
-                array 
-                    =   ch_p('[')[typename Context::a_object_s(self.c)]
-                        >> (ch_p(']')[typename Context::a_object_e(self.c)] 
-                            | (list_p(item, ch_p(','))
-                               >> expect_arrclose(ch_p(']')[typename Context::a_object_e(self.c)])
-                              )
-                           )
-                    ;
-
-                item 
-                    =   expect_value(value)
-                        ;
-
-                value 
-                    =   string[typename Context::a_string_val(self.c)] 
-                        | (number | str_p("true") | "false" | "null")[typename Context::a_literal_val(self.c)]
-                        | object 
-                        | array
-                        ;
-                
-                number 
-                    =   strict_real_p 
-                        | int_p
-                        ;
-                
-                string 
-                    =   +(lexeme_d[confix_p('\"', *character, '\"')])
-                        ;
-                
-                character 
-                    =   (anychar_p - "\\" - "\"")[typename Context::a_char(self.c)] 
-                        | ch_p("\\") >> expect_escape(escape)
-                        ;
-                
-                escape 
-                    =   chset_p(detail::widen<Ch>("\"\\0bfnrt").c_str())[typename Context::a_escape(self.c)] 
-                        | 'u' >> uint_parser<unsigned long, 16, 4, 4>()[typename Context::a_unicode(self.c)]
-                        ;
-                
-                // Debug
-                BOOST_SPIRIT_DEBUG_RULE(root);
-                BOOST_SPIRIT_DEBUG_RULE(object);
-                BOOST_SPIRIT_DEBUG_RULE(member);
-                BOOST_SPIRIT_DEBUG_RULE(array);
-                BOOST_SPIRIT_DEBUG_RULE(item);
-                BOOST_SPIRIT_DEBUG_RULE(value);
-                BOOST_SPIRIT_DEBUG_RULE(string);
-                BOOST_SPIRIT_DEBUG_RULE(number);
-                BOOST_SPIRIT_DEBUG_RULE(escape);
-                BOOST_SPIRIT_DEBUG_RULE(character);
-
-            }
-
-            const boost::spirit::rule<Scanner> &start() const
-            {
-                return root;
-            }
-
-        };
-
-    };
-
-    template<class It, class Ch>
-    unsigned long count_lines(It begin, It end)
-    {
-        return static_cast<unsigned long>(std::count(begin, end, Ch('\n')) + 1);
-    }
-
-    template<class Ptree>
-    void read_json_internal(std::basic_istream<typename Ptree::char_type> &stream,
-                            Ptree &pt,
-                            const std::string &filename)
-    {
-
-        using namespace boost::spirit;
-        typedef typename Ptree::char_type Ch;
-        typedef typename std::vector<Ch>::iterator It;
-
-        // Load data into vector
-        std::vector<Ch> v(std::istreambuf_iterator<Ch>(stream.rdbuf()),
-                          std::istreambuf_iterator<Ch>());
-        if (!stream.good())
-            throw json_parser_error("read error", filename, 0);
-        
-        // Prepare grammar
-        json_grammar<Ptree> g;
-
-        // Parse
-        try
-        {
-            parse_info<It> pi = parse(v.begin(), v.end(), g, 
-                                      space_p | comment_p("//") | comment_p("/*", "*/"));
-            if (!pi.hit || !pi.full)
-                throw parser_error<std::string, It>(v.begin(), "syntax error");
-        }
-        catch (parser_error<std::string, It> &e)
-        {
-            throw json_parser_error(e.descriptor, filename, count_lines<It, Ch>(v.begin(), e.where));
-        }
-
-        // Swap grammar context root and pt
-        pt.swap(g.c.root);
-
-    }
-
-} } }
-
-#endif

Copied: trunk/boost/property_tree/detail/json_parser_read.hpp (from rev 305, trunk/boost/property_tree/detail/json_parser_read.hpp)

Deleted: trunk/boost/property_tree/detail/json_parser_write.hpp
===================================================================
--- trunk/boost/property_tree/detail/json_parser_write.hpp	2006-10-03 08:49:51 UTC (rev 305)
+++ trunk/boost/property_tree/detail/json_parser_write.hpp	2006-10-03 09:06:13 UTC (rev 308)
@@ -1,163 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2005 Marcin Kalicinski
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_DETAIL_JSON_PARSER_WRITE_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_DETAIL_JSON_PARSER_WRITE_HPP_INCLUDED
-
-#include <boost/property_tree/ptree.hpp>
-#include <string>
-#include <ostream>
-#include <iomanip>
-
-namespace boost { namespace property_tree { namespace json_parser
-{
-
-    // Create necessary escape sequences from illegal characters
-    template<class Ch>
-    std::basic_string<Ch> create_escapes(const std::basic_string<Ch> &s,
-                                         const std::locale &loc)
-    {
-        std::basic_string<Ch> result;
-        typename std::basic_string<Ch>::const_iterator b = s.begin();
-        typename std::basic_string<Ch>::const_iterator e = s.end();
-        while (b != e)
-        {
-            if (*b == Ch('\0')) result += Ch('\\'), result += Ch('0');
-            else if (*b == Ch('\b')) result += Ch('\\'), result += Ch('b');
-            else if (*b == Ch('\f')) result += Ch('\\'), result += Ch('f');
-            else if (*b == Ch('\n')) result += Ch('\\'), result += Ch('n');
-            else if (*b == Ch('\r')) result += Ch('\\'), result += Ch('r');
-            else if (*b == Ch('"')) result += Ch('\\'), result += Ch('"');
-            else if (*b == Ch('\\')) result += Ch('\\'), result += Ch('\\');
-            else
-            {
-                if (std::isprint(*b, loc))
-                    result += *b;
-                else
-                {   
-                    const char *hexdigits = "0123456789ABCDEF";
-                    unsigned long u = (std::min)(static_cast<unsigned long>(*b), 0xFFFFul);
-                    int d1 = u / 4096; u -= d1 * 4096;
-                    int d2 = u / 256; u -= d2 * 256;
-                    int d3 = u / 16; u -= d3 * 16;
-                    int d4 = u;
-                    result += Ch('\\'); result += Ch('u');
-                    result += Ch(hexdigits[d1]); result += Ch(hexdigits[d2]);
-                    result += Ch(hexdigits[d3]); result += Ch(hexdigits[d4]);
-                }
-            }
-            ++b;
-        }
-        return result;
-    }
-
-    template<class Ptree>
-    void write_json_helper(std::basic_ostream<typename Ptree::char_type> &stream, 
-                           const Ptree &pt, 
-                           int indent)
-    {
-
-        typedef typename Ptree::char_type Ch;
-        typedef typename std::basic_string<Ch> Str;
-        
-        // Value or object or array
-        if (indent > 0 && pt.empty())
-        {
-            
-            // Write value
-            Str data = create_escapes(pt.template get_own<Str>(), stream.getloc());
-            stream << Ch('"') << data << Ch('"');
-
-        }
-        else if (indent > 0 && pt.count(Str()) == pt.size())
-        {
-                
-            // Write array
-            stream << Ch('[') << Ch('\n');
-            typename Ptree::const_iterator it = pt.begin();
-            for (; it != pt.end(); ++it)
-            {
-                stream << Str(4 * (indent + 1), Ch(' '));
-                write_json_helper(stream, it->second, indent + 1);
-                if (boost::next(it) != pt.end())
-                    stream << Ch(',');
-                stream << Ch('\n');
-            }
-            stream << Str(4 * indent, Ch(' ')) << Ch(']');
-
-        }
-        else
-        {
-        
-            // Write object
-            stream << Ch('{') << Ch('\n');
-            typename Ptree::const_iterator it = pt.begin();
-            for (; it != pt.end(); ++it)
-            {
-                stream << Str(4 * (indent + 1), Ch(' '));
-                stream << Ch('"') << create_escapes(it->first, stream.getloc()) << Ch('"') << Ch(':');
-                if (it->second.empty())
-                    stream << Ch(' ');
-                else
-                    stream << Ch('\n') << Str(4 * (indent + 1), Ch(' '));
-                write_json_helper(stream, it->second, indent + 1);
-                if (boost::next(it) != pt.end())
-                    stream << Ch(',');
-                stream << Ch('\n');
-            }
-            stream << Str(4 * indent, Ch(' ')) << Ch('}');
-
-        }
-
-    }
-
-    // Verify if ptree does not contain information that cannot be written to json
-    template<class Ptree>
-    bool verify_json(const Ptree &pt, int depth)
-    {
-
-        typedef typename Ptree::char_type Ch;
-        typedef typename std::basic_string<Ch> Str;
-
-        // Root ptree cannot have data
-        if (depth == 0 && !pt.template get_own<Str>().empty())
-            return false;
-        
-        // Ptree cannot have both children and data
-        if (!pt.template get_own<Str>().empty() && !pt.empty())
-            return false;
-
-        // Check children
-        typename Ptree::const_iterator it = pt.begin();
-        for (; it != pt.end(); ++it)
-            if (!verify_json(it->second, depth + 1))
-                return false;
-
-        // Success
-        return true;
-
-    }
-    
-    // Write ptree to json stream
-    template<class Ptree>
-    void write_json_internal(std::basic_ostream<typename Ptree::char_type> &stream, 
-                             const Ptree &pt,
-                             const std::string &filename)
-    {
-        if (!verify_json(pt, 0))
-            throw json_parser_error("ptree contains data that cannot be represented in JSON format", filename, 0);
-        write_json_helper(stream, pt, 0);
-        stream << std::endl;
-        if (!stream.good())
-            throw json_parser_error("write error", filename, 0);
-    }
-
-} } }
-
-#endif

Copied: trunk/boost/property_tree/detail/json_parser_write.hpp (from rev 305, trunk/boost/property_tree/detail/json_parser_write.hpp)

Deleted: trunk/boost/property_tree/detail/ptree_implementation.hpp
===================================================================
--- trunk/boost/property_tree/detail/ptree_implementation.hpp	2006-10-03 08:49:51 UTC (rev 305)
+++ trunk/boost/property_tree/detail/ptree_implementation.hpp	2006-10-03 09:06:13 UTC (rev 308)
@@ -1,996 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2005 Marcin Kalicinski
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_DETAIL_PTREE_IMPLEMENTATION_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_DETAIL_PTREE_IMPLEMENTATION_HPP_INCLUDED
-
-#include <sstream>
-#include <locale>
-#include <algorithm>
-#include <limits>
-#include <stdexcept>
-#include <functional>               // for std::less
-#include <memory>                   // for std::auto_ptr
-#include <boost/assert.hpp>
-#include <boost/static_assert.hpp>
-#include <boost/type_traits.hpp>
-#include <boost/utility.hpp>        // for boost::prior
-#include <boost/property_tree/detail/ptree_utils.hpp>
-
-//////////////////////////////////////////////////////////////////////////////
-// Debug macros
-
-#ifdef BOOST_PROPERTY_TREE_DEBUG
-
-    // Increment instances counter
-    #define BOOST_PROPERTY_TREE_DEBUG_INCREMENT_INSTANCES_COUNT()       \
-        {                                                               \
-            typedef boost::detail::lightweight_mutex::scoped_lock lock; \
-            lock l(debug_mutex);                                        \
-            ++debug_instances_count;                                    \
-        }
-
-    // Decrement instances counter
-    #define BOOST_PROPERTY_TREE_DEBUG_DECREMENT_INSTANCES_COUNT()       \
-        {                                                               \
-            typedef boost::detail::lightweight_mutex::scoped_lock lock; \
-            lock l(debug_mutex);                                        \
-            BOOST_ASSERT(debug_instances_count > 0);                    \
-            --debug_instances_count;                                    \
-        }
-
-#else // BOOST_PROPERTY_TREE_DEBUG
-
-    #define BOOST_PROPERTY_TREE_DEBUG_INCREMENT_INSTANCES_COUNT() static_cast<void>(0)
-    #define BOOST_PROPERTY_TREE_DEBUG_DECREMENT_INSTANCES_COUNT() static_cast<void>(0)
-
-#endif // BOOST_PROPERTY_TREE_DEBUG
-
-namespace boost { namespace property_tree
-{
-
-    namespace detail
-    {
-        
-        template<class T>
-        struct array_to_pointer_decay
-        {
-            typedef T type;
-        };
-
-        template<class T, std::size_t N>
-        struct array_to_pointer_decay<T[N]>
-        {
-            typedef const T *type;
-        };
-
-        ////////////////////////////////////////////////////////////////////////////
-        // Extractor and inserter
-
-        template<class Ch, class Type>
-        struct extractor
-        {
-            inline bool operator()(const std::basic_string<Ch> &data, 
-                                   Type &extracted,
-                                   const std::locale &loc) const
-            {
-                std::basic_istringstream<Ch> stream(data);
-                stream.imbue(loc);
-                stream >> extracted >> std::ws;
-                return stream.eof() && !stream.fail() && !stream.bad();
-            }
-        };
-
-        template<class Ch>
-        struct extractor<Ch, std::basic_string<Ch> >
-        {
-            inline bool operator()(const std::basic_string<Ch> &data, 
-                                   std::basic_string<Ch> &extracted,
-                                   const std::locale &loc) const
-            {
-                extracted = data;
-                return true;
-            }
-        };
-
-        template<class Ch, class Type>
-        struct inserter
-        {
-            inline bool operator()(std::basic_string<Ch> &data, 
-                                   const Type &to_insert,
-                                   const std::locale &loc) const
-            {
-                typedef typename detail::array_to_pointer_decay<Type>::type Type2;
-                std::basic_ostringstream<Ch> stream;
-                stream.imbue(loc);
-                if (std::numeric_limits<Type2>::is_specialized)
-                    stream.precision(std::numeric_limits<Type2>::digits10 + 1);
-                stream << to_insert;
-                data = stream.str();
-                return !stream.fail() && !stream.bad();
-            }
-        };
-
-        template<class Ch>
-        struct inserter<Ch, std::basic_string<Ch> >
-        {
-            inline bool operator()(std::basic_string<Ch> &data, 
-                                   const std::basic_string<Ch> &to_insert,
-                                   const std::locale &loc) const
-            {
-                data = to_insert;
-                return true;
-            }
-        };
-
-    }
-
-    ///////////////////////////////////////////////////////////////////////////
-    // Impl
-
-    template<class Tr>
-    struct basic_ptree<Tr>::impl
-    {
-        data_type m_data;
-        container_type m_container;
-        index_type m_index;
-    };
-
-    ////////////////////////////////////////////////////////////////////////////
-    // Traits
-
-    template<class Ch>
-    struct ptree_traits
-    {
-        typedef Ch char_type;
-        typedef std::basic_string<Ch> key_type;
-        typedef std::basic_string<Ch> data_type;
-        template<class Type>
-        struct extractor: public detail::extractor<Ch, Type> { };
-        template<class Type>
-        struct inserter: public detail::inserter<Ch, Type> { };
-        inline bool operator()(const key_type &key1, 
-                               const key_type &key2) const
-        {
-            return key1 < key2;
-        }
-    };
-
-    template<class Ch>
-    struct iptree_traits
-    {
-        std::locale loc;
-        typedef Ch char_type;
-        typedef std::basic_string<Ch> key_type;
-        typedef std::basic_string<Ch> data_type;
-        template<class Type>
-        struct extractor: public detail::extractor<Ch, Type> { };
-        template<class Type>
-        struct inserter: public detail::inserter<Ch, Type> { };
-        inline bool operator()(Ch c1, Ch c2) const      // Helper for comparing characters
-        {
-            return std::toupper(c1, loc) < std::toupper(c2, loc);
-        }
-        inline bool operator()(const key_type &key1, 
-                               const key_type &key2) const
-        {
-            return std::lexicographical_compare(key1.begin(), key1.end(), key2.begin(), key2.end(), *this);
-        }
-    };
-
-    ///////////////////////////////////////////////////////////////////////////
-    // Exceptions
-
-    class ptree_error: public std::runtime_error
-    {
-    public:
-        ptree_error(const std::string &what): std::runtime_error(what) { }
-        ~ptree_error() throw() { }
-    };
-
-    class ptree_bad_data: public ptree_error
-    {
-    public:
-        ptree_bad_data(const std::string &what): ptree_error(what) { }
-        ~ptree_bad_data() throw() { }
-    };
-    
-    class ptree_bad_path: public ptree_error
-    {
-    public:
-        ptree_bad_path(const std::string &what): ptree_error(what) { }
-        ~ptree_bad_path() throw() { }
-    };
-
-    ///////////////////////////////////////////////////////////////////////////
-    // Construction & destruction
-
-    template<class Tr>
-    basic_ptree<Tr>::basic_ptree()
-    {
-        m_impl = new impl;
-        BOOST_PROPERTY_TREE_DEBUG_INCREMENT_INSTANCES_COUNT();
-    }
-
-    template<class Tr>
-    basic_ptree<Tr>::basic_ptree(const data_type &rhs)
-    {
-        std::auto_ptr<impl> tmp(new impl);
-        tmp->m_data = rhs;
-        m_impl = tmp.release();
-        BOOST_PROPERTY_TREE_DEBUG_INCREMENT_INSTANCES_COUNT();
-    }
-
-    template<class Tr>
-    basic_ptree<Tr>::basic_ptree(const basic_ptree<Tr> &rhs)
-    {
-        std::auto_ptr<impl> tmp(new impl);
-        tmp->m_data = rhs.data();
-        m_impl = tmp.get();
-        insert(end(), rhs.begin(), rhs.end());
-        tmp.release();
-        BOOST_PROPERTY_TREE_DEBUG_INCREMENT_INSTANCES_COUNT();
-    }
-
-    template<class Tr>
-    basic_ptree<Tr>::~basic_ptree()
-    {
-        BOOST_PROPERTY_TREE_DEBUG_DECREMENT_INSTANCES_COUNT();
-        delete m_impl;
-    }
-
-    ///////////////////////////////////////////////////////////////////////////
-    // Iterator access
-
-    template<class Tr>
-    typename basic_ptree<Tr>::iterator 
-        basic_ptree<Tr>::begin()
-    {
-        return m_impl->m_container.begin();
-    }
-
-    template<class Tr>
-    typename basic_ptree<Tr>::const_iterator 
-        basic_ptree<Tr>::begin() const
-    {
-        return m_impl->m_container.begin();
-    }
-
-    template<class Tr>
-    typename basic_ptree<Tr>::iterator 
-        basic_ptree<Tr>::end()
-    {
-        return m_impl->m_container.end();
-    }
-
-    template<class Tr>
-    typename basic_ptree<Tr>::const_iterator 
-        basic_ptree<Tr>::end() const
-    {
-        return m_impl->m_container.end();
-    }
-
-    template<class Tr>
-    typename basic_ptree<Tr>::reverse_iterator 
-        basic_ptree<Tr>::rbegin()
-    {
-        return m_impl->m_container.rbegin();
-    }
-
-    template<class Tr>
-    typename basic_ptree<Tr>::const_reverse_iterator 
-        basic_ptree<Tr>::rbegin() const
-    {
-        return m_impl->m_container.rbegin();
-    }
-
-    template<class Tr>
-    typename basic_ptree<Tr>::reverse_iterator 
-        basic_ptree<Tr>::rend()
-    {
-        return m_impl->m_container.rend();
-    }
-
-    template<class Tr>
-    typename basic_ptree<Tr>::const_reverse_iterator 
-        basic_ptree<Tr>::rend() const
-    {
-        return m_impl->m_container.rend();
-    }
-
-    ///////////////////////////////////////////////////////////////////////////
-    // Data access
-
-    template<class Tr>
-    typename basic_ptree<Tr>::size_type 
-        basic_ptree<Tr>::size() const
-    {
-        return m_impl->m_index.size();
-    }
-
-    template<class Tr>
-    bool basic_ptree<Tr>::empty() const
-    {
-        return m_impl->m_index.empty();
-    }
-
-    template<class Tr>
-    typename basic_ptree<Tr>::data_type &
-        basic_ptree<Tr>::data()
-    {
-        return m_impl->m_data;
-    }
-
-    template<class Tr>
-    const typename basic_ptree<Tr>::data_type &
-        basic_ptree<Tr>::data() const
-    {
-        return m_impl->m_data;
-    }
-
-    template<class Tr>
-    typename basic_ptree<Tr>::value_type &
-        basic_ptree<Tr>::front()
-    {
-        return m_impl->m_container.front();
-    }
-    
-    template<class Tr>
-    const typename basic_ptree<Tr>::value_type &
-        basic_ptree<Tr>::front() const
-    {
-        return m_impl->m_container.front();
-    }
-
-    template<class Tr>
-    typename basic_ptree<Tr>::value_type &
-        basic_ptree<Tr>::back()
-    {
-        return m_impl->m_container.back();
-    }
-
-    template<class Tr>
-    const typename basic_ptree<Tr>::value_type &
-        basic_ptree<Tr>::back() const
-    {
-        return m_impl->m_container.back();
-    }
-
-    ///////////////////////////////////////////////////////////////////////////
-    // Operators
-
-    template<class Tr>
-    basic_ptree<Tr> &
-        basic_ptree<Tr>::operator =(const basic_ptree<Tr> &rhs)
-    {
-        if (&rhs != this)
-        {
-            clear();
-            data() = rhs.data();
-            insert(end(), rhs.begin(), rhs.end());
-        }
-        return *this;
-    }
-
-    template<class Tr>
-    bool basic_ptree<Tr>::operator ==(const basic_ptree<Tr> &rhs) const
-    {
-        
-        // Data and sizes must be equal
-        if (size() != rhs.size() || data() != rhs.data())
-            return false;
-
-        // Keys and children must be equal
-        Tr tr;
-        const_iterator it = begin();
-        const_iterator it_rhs = rhs.begin();
-        const_iterator it_end = end();
-        for (; it != it_end; ++it, ++it_rhs)
-            if (tr(it->first, it_rhs->first) || 
-                tr(it_rhs->first, it->first) || 
-                it->second != it_rhs->second)
-                return false;
-
-        // Equal
-        return true;
-
-    }
-
-    template<class Tr>
-    bool basic_ptree<Tr>::operator !=(const basic_ptree<Tr> &rhs) const
-    {
-        return !operator ==(rhs);
-    }
-
-    ///////////////////////////////////////////////////////////////////////////
-    // Container operations
-
-    template<class Tr>
-    typename basic_ptree<Tr>::iterator 
-        basic_ptree<Tr>::find(const key_type &key)
-    {
-        typename index_type::iterator it = m_impl->m_index.find(key);
-        return it == m_impl->m_index.end() ? end() : it->second;
-    }
-
-    template<class Tr>
-    typename basic_ptree<Tr>::const_iterator 
-        basic_ptree<Tr>::find(const key_type &key) const
-    {
-        typename index_type::const_iterator it = m_impl->m_index.find(key);
-        return it == m_impl->m_index.end() ? end() : it->second;
-    }
-
-    template<class Tr>
-    typename basic_ptree<Tr>::size_type 
-        basic_ptree<Tr>::count(const key_type &key) const
-    {
-        return m_impl->m_index.count(key);
-    }
-
-    template<class Tr>
-    void basic_ptree<Tr>::clear()
-    {
-        m_impl->m_data = data_type();
-        m_impl->m_container.clear();
-        m_impl->m_index.clear();
-    }
-
-    template<class Tr>
-    typename basic_ptree<Tr>::iterator 
-    basic_ptree<Tr>::insert(iterator where, 
-                                const value_type &value)
-    {
-
-        // Insert new value into container. If that throws nothing needs to be rolled back
-        where = m_impl->m_container.insert(where, value);
-
-        // Update index. If that throws we need to rollback the insert
-        try {
-            m_impl->m_index.insert(typename index_type::value_type(where->first, where));
-        } 
-        catch (...) {
-            m_impl->m_container.erase(where);   // rollback the insert
-            throw;
-        }
-
-        return where;
-    }
-
-    template<class Tr>
-    template<class It>
-    void basic_ptree<Tr>::insert(iterator where, 
-                                     It first, 
-                                     It last)
-    {
-        for (; first != last; ++first, ++where)
-            where = insert(where, value_type(first->first, first->second));
-    }
-
-    template<class Tr>
-    typename basic_ptree<Tr>::iterator 
-        basic_ptree<Tr>::erase(iterator where)
-    {
-
-        // Remove from index
-        typename index_type::iterator lo = m_impl->m_index.lower_bound(where->first);
-        typename index_type::iterator hi = m_impl->m_index.upper_bound(where->first);
-        for (; lo != hi; ++lo)
-            if (lo->second == where)
-            {
-                m_impl->m_index.erase(lo);
-                break;
-            }
-        
-        // Remove from container    
-        return m_impl->m_container.erase(where);
-
-    }
-
-    template<class Tr>
-    typename basic_ptree<Tr>::size_type 
-        basic_ptree<Tr>::erase(const key_type &key)
-    {
-        size_type count = 0;
-        typename index_type::iterator lo = m_impl->m_index.lower_bound(key);
-        if (lo != m_impl->m_index.end())
-        {
-            typename index_type::iterator hi = m_impl->m_index.upper_bound(key);
-            while (lo != hi)
-            {
-                typename index_type::iterator it = lo++;
-                erase(it->second);
-                ++count;
-            }
-        }
-        return count;
-    }
-
-    template<class Tr>
-    template<class It> 
-    typename basic_ptree<Tr>::iterator 
-        basic_ptree<Tr>::erase(It first, 
-                                   It last)
-    {
-        while (first != last)
-            first = erase(first);
-        return first;
-    }
-
-    template<class Tr>
-    typename basic_ptree<Tr>::iterator
-        basic_ptree<Tr>::push_front(const value_type &value)
-    {
-        return insert(begin(), value);
-    }
-
-    template<class Tr>
-    typename basic_ptree<Tr>::iterator
-        basic_ptree<Tr>::push_back(const value_type &value)
-    {
-        return insert(end(), value);
-    }
-
-    template<class Tr>
-    void basic_ptree<Tr>::pop_front()
-    {
-        erase(begin());
-    }
-
-    template<class Tr>
-    void basic_ptree<Tr>::pop_back()
-    {
-        erase(boost::prior(end()));
-    }
-        
-    template<class Tr>
-    void basic_ptree<Tr>::swap(basic_ptree<Tr> &rhs)
-    {
-        std::swap(m_impl, rhs.m_impl);
-    }
-
-    template<class Tr>
-    void basic_ptree<Tr>::reverse()
-    {
-        m_impl->m_container.reverse();
-    }
-    
-    template<class Tr>
-    template<class SortTr> 
-    void basic_ptree<Tr>::sort(SortTr tr)
-    {
-        m_impl->m_container.sort(tr);
-    }
-
-    ///////////////////////////////////////////////////////////////////////////
-    // ptree operations
-
-    // Get child ptree with custom separator
-    template<class Tr>
-    basic_ptree<Tr> &
-        basic_ptree<Tr>::get_child(char_type separator, 
-                                       const key_type &path)
-    {
-        if (optional<basic_ptree<Tr> &> result = get_child_optional(separator, path))
-            return result.get();
-        else
-            throw ptree_bad_path("key \"" + detail::narrow(path.c_str()) + "\" does not exist");
-    }
-
-    // Get child ptree with custom separator
-    template<class Tr>
-    const basic_ptree<Tr> &
-        basic_ptree<Tr>::get_child(char_type separator, 
-                                       const key_type &path) const
-    {
-        basic_ptree<Tr> *nc_this = const_cast<basic_ptree<Tr> *>(this);
-        return nc_this->get_child(separator, path);
-    }
-
-    // Get child ptree with custom separator
-    template<class Tr>
-    basic_ptree<Tr> &
-        basic_ptree<Tr>::get_child(char_type separator, 
-                                       const key_type &path, 
-                                       basic_ptree<Tr> &default_value)
-    {
-        if (optional<basic_ptree<Tr> &> result = get_child_optional(separator, path))
-            return result.get();
-        else
-            return default_value;
-    }
-
-    // Get child ptree with custom separator
-    template<class Tr>
-    const basic_ptree<Tr> &
-        basic_ptree<Tr>::get_child(char_type separator, 
-                                       const key_type &path, 
-                                       const basic_ptree<Tr> &default_value) const
-    {
-        basic_ptree<Tr> *nc_this = const_cast<basic_ptree<Tr> *>(this);
-        basic_ptree<Tr> &nc_default_value = const_cast<basic_ptree<Tr> &>(default_value);
-        return nc_this->get_child(separator, path, nc_default_value);
-    }
-
-
-    // Get child ptree with custom separator
-    template<class Tr>
-    optional<basic_ptree<Tr> &> 
-        basic_ptree<Tr>::get_child_optional(char_type separator, 
-                                                const key_type &path)
-    {
-        typename key_type::size_type n = path.find(separator);
-        if (n != key_type::npos)
-        {
-            key_type head = path.substr(0, n);
-            key_type tail = path.substr(n + 1, key_type::npos);
-            iterator it = find(head);
-            if (it != end())
-                return it->second.get_child_optional(separator, tail);
-            else
-                return optional<basic_ptree<Tr> &>();
-        }
-        else
-        {
-            iterator it = find(path);
-            if (it != end())
-                return it->second;
-            else
-                return optional<basic_ptree<Tr> &>();
-        }
-    }
-
-    // Get child ptree with custom separator
-    template<class Tr>
-    optional<const basic_ptree<Tr> &> 
-        basic_ptree<Tr>::get_child_optional(char_type separator, const key_type &path) const
-    {
-        basic_ptree<Tr> *nc_this = const_cast<basic_ptree<Tr> *>(this);
-        optional<basic_ptree<Tr> &> tmp = nc_this->get_child_optional(separator, path);
-        if (tmp)
-            return optional<const basic_ptree<Tr> &>(tmp.get());
-        else
-            return optional<const basic_ptree<Tr> &>();
-    }
-
-    // Get child ptree with default separator
-    template<class Tr>
-    basic_ptree<Tr> &
-        basic_ptree<Tr>::get_child(const key_type &path)
-    {
-        return get_child(char_type('.'), path);
-    }
-
-    // Get child ptree with default separator
-    template<class Tr>
-    const basic_ptree<Tr> &
-        basic_ptree<Tr>::get_child(const key_type &path) const
-    {
-        return get_child(char_type('.'), path);
-    }
-
-    // Get child ptree with default separator
-    template<class Tr>
-    basic_ptree<Tr> &
-        basic_ptree<Tr>::get_child(const key_type &path, 
-                                       basic_ptree<Tr> &default_value)
-    {
-        return get_child(char_type('.'), path, default_value);
-    }
-    
-    // Get child ptree with default separator
-    template<class Tr>
-    const basic_ptree<Tr> &
-        basic_ptree<Tr>::get_child(const key_type &path, 
-                                       const basic_ptree<Tr> &default_value) const
-    {
-        return get_child(char_type('.'), path, default_value);
-    }
-    
-    // Get child ptree with default separator
-    template<class Tr>
-    optional<basic_ptree<Tr> &> 
-        basic_ptree<Tr>::get_child_optional(const key_type &path)
-    {
-        return get_child_optional(char_type('.'), path);
-    }
-
-    // Get child ptree with default separator
-    template<class Tr>
-    optional<const basic_ptree<Tr> &> 
-        basic_ptree<Tr>::get_child_optional(const key_type &path) const
-    {
-        return get_child_optional(char_type('.'), path);
-    }
-
-    // Put child ptree with custom separator
-    template<class Tr>
-    basic_ptree<Tr> &
-        basic_ptree<Tr>::put_child(char_type separator, 
-                                   const key_type &path, 
-                                   const basic_ptree<Tr> &value,
-                                   bool do_not_replace)
-    {
-        typename key_type::size_type n = path.find(separator);
-        if (n == key_type::npos)
-        {
-            if (do_not_replace)
-                return push_back(value_type(path, value))->second;
-            else
-            {
-                iterator it = find(path);
-                if (it == end())
-                    return push_back(value_type(path, value))->second;
-                else
-                {
-                    it->second = value;
-                    return it->second;
-                }
-            }
-        }
-        else
-        {
-            key_type head = path.substr(0, n);
-            key_type tail = path.substr(n + 1, key_type::npos);
-            iterator it = find(head);
-            if (it == end())
-                it = push_back(value_type(head, basic_ptree<Tr>()));
-            return it->second.put_child(separator, tail, value, do_not_replace);
-        }
-    }
-
-    // Put child ptree with default separator
-    template<class Tr>
-    basic_ptree<Tr> &
-        basic_ptree<Tr>::put_child(const key_type &path,
-                                   const basic_ptree<Tr> &value,
-                                   bool do_not_replace)
-    {
-        return put_child(char_type('.'), path, value, do_not_replace);
-    }
-
-    // Get value from data of ptree
-    template<class Tr>
-    template<class Type>
-    Type basic_ptree<Tr>::get_own(const std::locale &loc) const
-    {
-        if (optional<Type> result = get_own_optional<Type>(loc))
-            return result.get();
-        else
-            throw ptree_bad_data(std::string("conversion of data into type '") + 
-                                 typeid(Type).name() + "' failed");
-    }
-
-    // Get value from data of ptree
-    template<class Tr>
-    template<class Type>
-    Type basic_ptree<Tr>::get_own(const Type &default_value, 
-                                      const std::locale &loc) const
-    {
-        if (optional<Type> result = get_own_optional<Type>(loc))
-            return result.get();
-        else
-            return default_value;
-    }
-
-    // Get value from data of ptree
-    template<class Tr>
-    template<class CharType>
-    std::basic_string<CharType> 
-        basic_ptree<Tr>::get_own(const CharType *default_value, 
-                                     const std::locale &loc) const
-    {
-        BOOST_STATIC_ASSERT((boost::is_same<char_type, CharType>::value == true)); // Character types must match
-        return get_own(std::basic_string<CharType>(default_value), loc);
-    }
-
-    // Get value from data of ptree
-    template<class Tr>
-    template<class Type>
-    optional<Type> 
-        basic_ptree<Tr>::get_own_optional(const std::locale &loc) const
-    {
-        BOOST_STATIC_ASSERT(boost::is_pointer<Type>::value == false);   // Disallow pointer types, they are unsafe
-        Type tmp;
-        if (typename traits_type::template extractor<Type>()(m_impl->m_data, tmp, loc))
-        {
-            return optional<Type>(tmp);
-        }
-        else
-            return optional<Type>();
-    }
-
-    // Get value from data of child ptree (custom path separator)
-    template<class Tr>
-    template<class Type>
-    Type basic_ptree<Tr>::get(char_type separator,
-                                  const key_type &path,
-                                  const std::locale &loc) const
-    {
-        return get_child(separator, path).get_own<Type>(loc);
-    }
-
-    // Get value from data of child ptree (custom path separator)
-    template<class Tr>
-    template<class Type>
-    Type basic_ptree<Tr>::get(char_type separator,
-                                  const key_type &path, 
-                                  const Type &default_value, 
-                                  const std::locale &loc) const
-    {
-        if (optional<Type> result = get_optional<Type>(separator, path, loc))
-            return *result;
-        else
-            return default_value;
-    }
-
-    // Get value from data of child ptree (custom path separator)
-    template<class Tr>
-    template<class CharType>
-    std::basic_string<CharType> 
-        basic_ptree<Tr>::get(char_type separator,
-                                 const key_type &path, 
-                                 const CharType *default_value,
-                                 const std::locale &loc) const
-    {
-        BOOST_STATIC_ASSERT((boost::is_same<char_type, CharType>::value == true)); // Character types must match
-        return get(separator, path, std::basic_string<CharType>(default_value), loc);
-    }
-
-    // Get value from data of child ptree (custom path separator)
-    template<class Tr>
-    template<class Type>
-    optional<Type> 
-        basic_ptree<Tr>::get_optional(char_type separator,
-                                          const key_type &path, 
-                                          const std::locale &loc) const
-    {
-        if (optional<const basic_ptree<Tr> &> child = get_child_optional(separator, path))
-            return child.get().get_own_optional<Type>(loc);
-        else
-            return optional<Type>();
-    }
-
-    // Get value from data of child ptree (default path separator)
-    template<class Tr>
-    template<class Type>
-    Type basic_ptree<Tr>::get(const key_type &path,
-                                  const std::locale &loc) const
-    {
-        return get<Type>(char_type('.'), path, loc);
-    }
-
-    // Get value from data of child ptree (default path separator)
-    template<class Tr>
-    template<class Type>
-    Type basic_ptree<Tr>::get(const key_type &path, 
-                                  const Type &default_value,
-                                  const std::locale &loc) const
-    {
-        return get(char_type('.'), path, default_value, loc);
-    }
-
-    // Get value from data of child ptree (default path separator)
-    template<class Tr>
-    template<class CharType>
-    std::basic_string<CharType> 
-        basic_ptree<Tr>::get(const key_type &path, 
-                                 const CharType *default_value,
-                                 const std::locale &loc) const
-    {
-        return get(char_type('.'), path, default_value, loc);
-    }
-
-    // Get value from data of child ptree (default path separator)
-    template<class Tr>
-    template<class Type>
-    optional<Type> 
-        basic_ptree<Tr>::get_optional(const key_type &path, 
-                                          const std::locale &loc) const
-    {
-        return get_optional<Type>(char_type('.'), path, loc);
-    }
-
-    // Put value in data of ptree
-    template<class Tr>
-    template<class Type> 
-    void basic_ptree<Tr>::put_own(const Type &value, const std::locale &loc)
-    {
-        using namespace boost;
-        // Make sure that no pointer other than char_type * is allowed
-        BOOST_STATIC_ASSERT((is_pointer<Type>::value == false ||
-                             is_same<char_type, typename remove_const<typename remove_pointer<Type>::type>::type>::value == true));
-        typename traits_type::template inserter<Type>()(m_impl->m_data, value, loc);
-    }
-
-    // Put value in data of child ptree (custom path separator)
-    template<class Tr>
-    template<class Type> 
-    basic_ptree<Tr> &
-        basic_ptree<Tr>::put(char_type separator,
-                             const key_type &path, 
-                             const Type &value,
-                             bool do_not_replace,
-                             const std::locale &loc)
-    {
-        optional<basic_ptree<Tr> &> child;
-        if (!do_not_replace &&
-            (child = get_child_optional(separator, path)))
-        {
-            child.get().put_own(value, loc);
-            return *child;
-        }
-        else
-        {
-            basic_ptree<Tr> &child2 = put_child(separator, path, empty_ptree<basic_ptree<Tr> >(), do_not_replace);
-            child2.put_own(value, loc);
-            return child2;
-        }
-    }
-
-    // Put value in data of child ptree (default path separator)
-    template<class Tr>
-    template<class Type> 
-    basic_ptree<Tr> &
-        basic_ptree<Tr>::put(const key_type &path, 
-                             const Type &value,
-                             bool do_not_replace,
-                             const std::locale &loc)
-    {
-        return put(char_type('.'), path, value, do_not_replace, loc);
-    }
-
-    ////////////////////////////////////////////////////////////////////////////
-    // Debugging
-
-#ifdef BOOST_PROPERTY_TREE_DEBUG
-
-    template<class Tr>
-    typename basic_ptree<Tr>::size_type 
-        basic_ptree<Tr>::debug_get_instances_count() 
-    { 
-        empty_ptree<basic_ptree<Tr> >();    // Make sure empty ptree exists
-        return debug_instances_count - 1;       // Do not count empty ptree
-    }
-
-    template<class Tr>
-    typename basic_ptree<Tr>::size_type 
-        basic_ptree<Tr>::debug_instances_count;
-
-    template<class Tr>
-    boost::detail::lightweight_mutex 
-        basic_ptree<Tr>::debug_mutex;
-
-#endif
-
-    ///////////////////////////////////////////////////////////////////////////
-    // Free functions
-
-    template<class Ptree> 
-    inline const Ptree &empty_ptree()
-    {
-        static Ptree pt;
-        return pt;
-    }
-
-    template<class Tr>
-    inline void swap(basic_ptree<Tr> &pt1, basic_ptree<Tr> &pt2)
-    {
-        pt1.swap(pt2);
-    }
-
-} }
-
-// Undefine debug macros
-#ifdef BOOST_PROPERTY_TREE_DEBUG
-#   undef BOOST_PROPERTY_TREE_DEBUG_INCREMENT_INSTANCES_COUNT
-#   undef BOOST_PROPERTY_TREE_DEBUG_DECREMENT_INSTANCES_COUNT
-#endif
-
-#endif

Copied: trunk/boost/property_tree/detail/ptree_implementation.hpp (from rev 305, trunk/boost/property_tree/detail/ptree_implementation.hpp)

Deleted: trunk/boost/property_tree/detail/ptree_interface.hpp
===================================================================
--- trunk/boost/property_tree/detail/ptree_interface.hpp	2006-10-03 08:49:51 UTC (rev 305)
+++ trunk/boost/property_tree/detail/ptree_interface.hpp	2006-10-03 09:06:13 UTC (rev 308)
@@ -1,198 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2005 Marcin Kalicinski
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_DETAIL_PTREE_INTERFACE_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_DETAIL_PTREE_INTERFACE_HPP_INCLUDED
-
-#include <boost/config.hpp>
-#include <boost/optional.hpp>
-#include <string>
-#include <list>
-#include <map>
-#include <utility>          // For std::pair
-#include <locale>
-
-#include "boost/property_tree/ptree_fwd.hpp"
-
-#ifdef BOOST_PROPERTY_TREE_DEBUG
-#   include <boost/detail/lightweight_mutex.hpp>   // For syncing debug instances counter
-#endif
-
-namespace boost { namespace property_tree
-{
-
-    ///////////////////////////////////////////////////////////////////////////
-    // basic_ptree class template
-
-    template<class Tr>
-    class basic_ptree
-    {
-
-    public:
-
-        // Basic types
-        typedef Tr traits_type;
-        typedef typename traits_type::char_type char_type;
-        typedef typename traits_type::key_type key_type;
-        typedef typename traits_type::data_type data_type;
-        
-        // Container-related types
-        typedef std::pair<key_type, basic_ptree<Tr> > value_type;
-        typedef std::list<value_type> container_type;
-        typedef typename container_type::size_type size_type;
-        typedef typename container_type::iterator iterator;
-        typedef typename container_type::const_iterator const_iterator;
-        typedef typename container_type::reverse_iterator reverse_iterator;
-        typedef typename container_type::const_reverse_iterator const_reverse_iterator;
-        
-        ///////////////////////////////////////////////////////////////////////////
-        // Construction & destruction
-
-        basic_ptree();
-        explicit basic_ptree(const data_type &data);
-        basic_ptree(const basic_ptree<Tr> &rhs);
-        ~basic_ptree();
-
-        ///////////////////////////////////////////////////////////////////////////
-        // Iterator access
-
-        iterator begin();
-        const_iterator begin() const;
-        iterator end();
-        const_iterator end() const;
-        reverse_iterator rbegin();
-        const_reverse_iterator rbegin() const;
-        reverse_iterator rend();
-        const_reverse_iterator rend() const;
-        
-        ///////////////////////////////////////////////////////////////////////////
-        // Data access
-
-        size_type size() const;
-        bool empty() const;
-        
-        data_type &data();
-        const data_type &data() const;
-
-        value_type &front();
-        const value_type &front() const;
-        value_type &back();
-        const value_type &back() const;
-
-        ///////////////////////////////////////////////////////////////////////////
-        // Operators
-
-        basic_ptree<Tr> &operator =(const basic_ptree<Tr> &rhs);
-
-        bool operator ==(const basic_ptree<Tr> &rhs) const;
-        bool operator !=(const basic_ptree<Tr> &rhs) const;
-
-        ///////////////////////////////////////////////////////////////////////////
-        // Container operations
-
-        iterator find(const key_type &key);
-        const_iterator find(const key_type &key) const;
-
-        size_type count(const key_type &key) const;
-
-        void clear();
-
-        iterator insert(iterator where, const value_type &value);
-        template<class It> void insert(iterator where, It first, It last);
-
-        iterator erase(iterator where);
-        size_type erase(const key_type &key);
-        template<class It> iterator erase(It first, It last);
-
-        iterator push_front(const value_type &value);
-        iterator push_back(const value_type &value);
-
-        void pop_front();
-        void pop_back();
-
-        void swap(basic_ptree<Tr> &rhs);
-
-        void reverse();
-        template<class SortTr> void sort(SortTr tr);
-
-        ///////////////////////////////////////////////////////////////////////////
-        // ptree operations
-
-        // Get child ptree with custom separator
-        basic_ptree<Tr> &get_child(char_type separator, const key_type &path);
-        const basic_ptree<Tr> &get_child(char_type separator, const key_type &path) const;
-        basic_ptree<Tr> &get_child(char_type separator, const key_type &path, basic_ptree<Tr> &default_value);
-        const basic_ptree<Tr> &get_child(char_type separator, const key_type &path, const basic_ptree<Tr> &default_value) const;
-        optional<basic_ptree<Tr> &> get_child_optional(char_type separator, const key_type &path);
-        optional<const basic_ptree<Tr> &> get_child_optional(char_type separator, const key_type &path) const;
-
-        // Get child ptree with default separator
-        basic_ptree<Tr> &get_child(const key_type &path);
-        const basic_ptree<Tr> &get_child(const key_type &path) const;
-        basic_ptree<Tr> &get_child(const key_type &path, basic_ptree<Tr> &default_value);
-        const basic_ptree<Tr> &get_child(const key_type &path, const basic_ptree<Tr> &default_value) const;
-        optional<basic_ptree<Tr> &> get_child_optional(const key_type &path);
-        optional<const basic_ptree<Tr> &> get_child_optional(const key_type &path) const;
-
-        // Put child ptree with custom separator
-        basic_ptree<Tr> &put_child(char_type separator, const key_type &path, const basic_ptree<Tr> &value, bool do_not_replace = false);
-
-        // Put child ptree with default separator
-        basic_ptree<Tr> &put_child(const key_type &path, const basic_ptree<Tr> &value, bool do_not_replace = false);
-
-        // Get value from data of ptree
-        template<class Type> Type get_own(const std::locale &loc = std::locale()) const;
-        template<class Type> Type get_own(const Type &default_value, const std::locale &loc = std::locale()) const;
-        template<class CharType> std::basic_string<CharType> get_own(const CharType *default_value, const std::locale &loc = std::locale()) const;
-        template<class Type> optional<Type> get_own_optional(const std::locale &loc = std::locale()) const;
-
-        // Get value from data of child ptree (custom path separator)
-        template<class Type> Type get(char_type separator, const key_type &path, const std::locale &loc = std::locale()) const;
-        template<class Type> Type get(char_type separator, const key_type &path, const Type &default_value, const std::locale &loc = std::locale()) const;
-        template<class CharType> std::basic_string<CharType> get(char_type separator, const key_type &path, const CharType *default_value, const std::locale &loc = std::locale()) const;
-        template<class Type> optional<Type> get_optional(char_type separator, const key_type &path, const std::locale &loc = std::locale()) const;
-
-        // Get value from data of child ptree (default path separator)
-        template<class Type> Type get(const key_type &path, const std::locale &loc = std::locale()) const;
-        template<class Type> Type get(const key_type &path, const Type &default_value, const std::locale &loc = std::locale()) const;
-        template<class CharType> std::basic_string<CharType> get(const key_type &path, const CharType *default_value, const std::locale &loc = std::locale()) const;
-        template<class Type> optional<Type> get_optional(const key_type &path, const std::locale &loc = std::locale()) const;
-
-        // Put value in data of ptree
-        template<class Type> void put_own(const Type &value, const std::locale &loc = std::locale());
-
-        // Put value in data of child ptree (custom path separator)
-        template<class Type> basic_ptree<Tr> &put(char_type separator, const key_type &path, const Type &value, bool do_not_replace = false, const std::locale &loc = std::locale());
-
-        // Put value in data of child ptree (default path separator)
-        template<class Type> basic_ptree<Tr> &put(const key_type &path, const Type &value, bool do_not_replace = false, const std::locale &loc = std::locale());
-
-    private:
-
-        typedef std::multimap<key_type, iterator, Tr> index_type;
-        
-        struct impl;
-        impl *m_impl;
-
-        ////////////////////////////////////////////////////////////////////////////
-        // Debugging
-
-#ifdef BOOST_PROPERTY_TREE_DEBUG
-    private:
-        static boost::detail::lightweight_mutex debug_mutex;    // Mutex for syncing instances counter
-        static size_type debug_instances_count;                 // Total number of instances of this ptree class
-    public:
-        static size_type debug_get_instances_count();
-#endif
-
-    };
-
-} }
-
-#endif

Copied: trunk/boost/property_tree/detail/ptree_interface.hpp (from rev 305, trunk/boost/property_tree/detail/ptree_interface.hpp)

Deleted: trunk/boost/property_tree/detail/ptree_utils.hpp
===================================================================
--- trunk/boost/property_tree/detail/ptree_utils.hpp	2006-10-03 08:49:51 UTC (rev 305)
+++ trunk/boost/property_tree/detail/ptree_utils.hpp	2006-10-03 09:06:13 UTC (rev 308)
@@ -1,72 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2005 Marcin Kalicinski
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_DETAIL_PTREE_UTILS_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_DETAIL_PTREE_UTILS_HPP_INCLUDED
-
-#include <boost/property_tree/ptree.hpp>
-#include <string>
-#include <locale>
-
-namespace boost { namespace property_tree { namespace detail
-{
-
-    // Naively convert narrow string to another character type
-    template<class Ch>
-    std::basic_string<Ch> widen(const char *text)
-    {
-        std::locale loc;
-        std::basic_string<Ch> result;
-        while (*text)
-        {
-            result += Ch(*text);
-            ++text;
-        }
-        return result;
-    }
-
-    // Naively convert string to narrow character type
-    template<class Ch>
-    std::string narrow(const Ch *text)
-    {
-        std::locale loc;
-        std::string result;
-        while (*text)
-        {
-            if (*text < 0 || *text > (std::numeric_limits<char>::max)())
-                result += '*';
-            else
-                result += char(*text);
-            ++text;
-        }
-        return result;
-    }
-
-    // Remove trailing and leading spaces
-    template<class Ch>
-    std::basic_string<Ch> trim(const std::basic_string<Ch> &s, 
-                               const std::locale &loc = std::locale())
-    {
-        typename std::basic_string<Ch>::const_iterator first = s.begin();
-        typename std::basic_string<Ch>::const_iterator end = s.end();
-        while (first != end && std::isspace(*first, loc)) 
-            ++first;
-        if (first == end)
-            return std::basic_string<Ch>();
-        typename std::basic_string<Ch>::const_iterator last = end;
-        do --last; while (std::isspace(*last, loc)); 
-        if (first != s.begin() || last + 1 != end)
-            return std::basic_string<Ch>(first, last + 1);
-        else
-            return s;
-    }
-
-} } }
-
-#endif

Copied: trunk/boost/property_tree/detail/ptree_utils.hpp (from rev 305, trunk/boost/property_tree/detail/ptree_utils.hpp)

Deleted: trunk/boost/property_tree/detail/xml_parser_error.hpp
===================================================================
--- trunk/boost/property_tree/detail/xml_parser_error.hpp	2006-10-03 08:49:51 UTC (rev 305)
+++ trunk/boost/property_tree/detail/xml_parser_error.hpp	2006-10-03 09:06:13 UTC (rev 308)
@@ -1,33 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2005 Marcin Kalicinski
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_DETAIL_XML_PARSER_ERROR_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_DETAIL_XML_PARSER_ERROR_HPP_INCLUDED
-
-#include <boost/property_tree/detail/file_parser_error.hpp>
-#include <string>
-
-namespace boost { namespace property_tree { namespace xml_parser
-{
-
-    //! Xml parser error
-    class xml_parser_error: public file_parser_error
-    {
-    public:
-        xml_parser_error(const std::string &message, 
-                         const std::string &filename, 
-                         unsigned long line): 
-            file_parser_error(message, filename, line)
-        { 
-        }
-    };
-
-} } }
-
-#endif

Copied: trunk/boost/property_tree/detail/xml_parser_error.hpp (from rev 305, trunk/boost/property_tree/detail/xml_parser_error.hpp)

Deleted: trunk/boost/property_tree/detail/xml_parser_flags.hpp
===================================================================
--- trunk/boost/property_tree/detail/xml_parser_flags.hpp	2006-10-03 08:49:51 UTC (rev 305)
+++ trunk/boost/property_tree/detail/xml_parser_flags.hpp	2006-10-03 09:06:13 UTC (rev 308)
@@ -1,26 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2005 Marcin Kalicinski
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_DETAIL_XML_PARSER_FLAGS_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_DETAIL_XML_PARSER_FLAGS_HPP_INCLUDED
-
-namespace boost { namespace property_tree { namespace xml_parser
-{
-    
-    static const int no_concat_text = 1;     // Text elements should be put in separate keys, not concatenated in parent data
-    static const int no_comments = 2;        // Comments should be omitted
-
-    inline bool validate_flags(int flags)
-    {
-        return (flags & ~(no_concat_text | no_comments)) == 0;
-    }
-
-} } }
-
-#endif

Copied: trunk/boost/property_tree/detail/xml_parser_flags.hpp (from rev 305, trunk/boost/property_tree/detail/xml_parser_flags.hpp)

Deleted: trunk/boost/property_tree/detail/xml_parser_read_spirit.hpp
===================================================================
--- trunk/boost/property_tree/detail/xml_parser_read_spirit.hpp	2006-10-03 08:49:51 UTC (rev 305)
+++ trunk/boost/property_tree/detail/xml_parser_read_spirit.hpp	2006-10-03 09:06:13 UTC (rev 308)
@@ -1,729 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2005 Marcin Kalicinski
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// Based on XML grammar by Daniel C. Nuffer 
-// http://spirit.sourceforge.net/repository/applications/xml.zip
-// 
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_DETAIL_XML_PARSER_READ_SPIRIT_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_DETAIL_XML_PARSER_READ_SPIRIT_HPP_INCLUDED
-
-//#define BOOST_SPIRIT_DEBUG
-
-#include <boost/property_tree/ptree.hpp>
-#include <boost/property_tree/detail/xml_parser_error.hpp>
-#include <boost/property_tree/detail/xml_parser_flags.hpp>
-#include <boost/property_tree/detail/xml_parser_utils.hpp>
-#include <boost/spirit.hpp>
-#include <boost/spirit/iterator/position_iterator.hpp>
-#include <string>
-#include <locale>
-#include <istream>
-#include <vector>
-
-namespace boost { namespace property_tree { namespace xml_parser
-{
-
-    // XML parser context
-    template<class Ptree>
-    struct context
-    {
-        
-        typedef typename Ptree::char_type Ch;
-        typedef std::basic_string<Ch> Str;
-        typedef boost::spirit::position_iterator<typename std::vector<Ch>::const_iterator> It;
-
-        int flags;
-        std::vector<Ptree *> stack;
-
-        ///////////////////////////////////////////////////////////////////////
-        // Actions
-        
-        struct a_key_s
-        {
-            context &c;
-            a_key_s(context &c): c(c) { }
-            void operator()(It b, It e) const
-            {
-                if (c.stack.empty())
-                    throw xml_parser_error("xml parse error", 
-                                           b.get_position().file, 
-                                           b.get_position().line);
-                Str name(b, e);
-                Ptree *child = &c.stack.back()->push_back(std::make_pair(name, Ptree()))->second;
-                c.stack.push_back(child);
-            }
-        };
-
-        struct a_key_e
-        {
-            context &c;
-            a_key_e(context &c): c(c) { }
-            void operator()(It b, It e) const
-            {
-                if (c.stack.size() <= 1)
-                    throw xml_parser_error("xml parse error", 
-                                           b.get_position().file, 
-                                           b.get_position().line);
-                c.stack.pop_back();
-            }
-        };
-
-        struct a_content
-        {
-            context &c;
-            a_content(context &c): c(c) { }
-            void operator()(It b, It e) const
-            {
-                Str s = decode_char_entities(detail::trim(condense(Str(b, e))));
-                if (!s.empty())
-                {
-                    if (c.flags & no_concat_text)
-                        c.stack.back()->push_back(std::make_pair(xmltext<Ch>(), Ptree(s)));
-                    else
-                        c.stack.back()->put_own(c.stack.back()->template get_own<std::basic_string<Ch> >() + s);
-                }
-            }
-        };
-
-        struct a_attr_key
-        {
-            context &c;
-            a_attr_key(context &c): c(c) { }
-            void operator()(It b, It e) const
-            {
-                c.stack.back()->put_child(Ch('/'), xmlattr<Ch>() + Ch('/') + Str(b, e), empty_ptree<Ptree>());
-            }
-        };
-
-        struct a_attr_data
-        {
-            context &c;
-            a_attr_data(context &c): c(c) { }
-            void operator()(It b, It e) const
-            {
-                Ptree &attr = c.stack.back()->get_child(xmlattr<Ch>());
-                attr.back().second.put_own(Str(b + 1, e - 1));
-            }
-        };
-
-        struct a_comment
-        {
-            context &c;
-            a_comment(context &c): c(c) { }
-            void operator()(It b, It e) const
-            {
-                c.stack.back()->push_back(std::make_pair(xmlcomment<Ch>(), Ptree(Str(b, e))));
-            }
-        };
-
-    };
-
-    ///////////////////////////////////////////////////////////////////////
-    // Grammar
-        
-    template<class Ptree>
-    struct xml_grammar: public boost::spirit::grammar<xml_grammar<Ptree> >
-    {
-        
-        typedef context<Ptree> context_t;
-        
-        mutable context_t c;
-        
-        template<class ScannerT>
-        struct definition
-        {
-            
-            typedef typename ScannerT::value_t char_t;
-            typedef boost::spirit::chset<char_t> chset_t;
-
-            boost::spirit::rule<ScannerT>
-                prolog, element, Misc, PEReference, Reference, PITarget, CData,
-                doctypedecl, XMLDecl, SDDecl, VersionInfo, EncodingDecl, VersionNum,
-                Eq, DeclSep, ExternalID, markupdecl, NotationDecl, EntityDecl,
-                AttlistDecl, elementdecl, TextDecl, extSubsetDecl, conditionalSect,
-                EmptyElemTag, STag, content, ETag, Attribute, contentspec, Mixed,
-                children, choice, seq, cp, AttDef, AttType, DefaultDecl, StringType,
-                TokenizedType, EnumeratedType, NotationType, Enumeration, EntityValue,
-                AttValue, SystemLiteral, PubidLiteral, CharDataChar, CharData, Comment,
-                PI, CDSect, extSubset, includeSect, ignoreSect, ignoreSectContents,
-                Ignore, CharRef, EntityRef, GEDecl, PEDecl, EntityDef, PEDef,
-                NDataDecl, extParsedEnt, EncName, PublicID, document, S, Name, Names,
-                Nmtoken, Nmtokens, STagB, STagE1, STagE2;
-
-            definition(const xml_grammar &self)
-            {
-                
-                using namespace boost::spirit;
-                
-                // XML Char sets
-                chset_t Char("\x9\xA\xD\x20-\x7F");
-                chset_t Sch("\x20\x9\xD\xA");
-                chset_t Letter("\x41-\x5A\x61-\x7A");
-                chset_t Digit("0-9");
-                chset_t XDigit("0-9A-Fa-f");
-                chset_t Extender("\xB7");
-                chset_t NameChar =
-                    Letter 
-                    | Digit 
-                    | (char_t)'.'
-                    | (char_t)'-'
-                    | (char_t)'_'
-                    | (char_t)':'
-                    | Extender;
-
-                document =
-                    prolog >> element >> *Misc
-                ;
-
-                S = 
-                    +(Sch)
-                ;
-
-                Name =
-                    (Letter | '_' | ':') 
-                    >> *(NameChar)
-                ;
-
-                Names =
-                    Name >> *(S >> Name)
-                ;
-
-                Nmtoken =
-                    +NameChar
-                ;
-
-                Nmtokens =
-                    Nmtoken >> *(S >> Nmtoken)
-                ;
-
-                EntityValue =
-                    '"'  >> *(  (anychar_p - (chset_t(detail::widen<char_t>("%&\"").c_str()))) 
-                                | PEReference
-                                | Reference) 
-                        >> '"'
-                    | '\'' >> *(  (anychar_p - (chset_t("%&'"))) 
-                                | PEReference
-                                | Reference) 
-                            >> '\''
-                ;
-
-                AttValue = 
-                    '"' >> *(  (anychar_p - (chset_t("<&\""))) 
-                                | Reference) 
-                        >> '"'
-                    | '\'' >> *(  (anychar_p - (chset_t("<&'"))) 
-                                | Reference) 
-                            >> '\''
-                ;
-
-                SystemLiteral= 
-                    ('"' >> *(anychar_p - '"') >> '"')
-                    | ('\'' >> *(anychar_p - '\'') >> '\'')
-                ;
-
-                chset_t PubidChar("\x20\xD\xA'a-zA-Z0-9()+,./:=?;!*#@$_%-");
-
-                PubidLiteral = 
-                    '"' >> *PubidChar >> '"' 
-                    | '\'' >> *(PubidChar - '\'') >> '\''
-                ;
-
-                CharDataChar = 
-                    //anychar_p - (chset_t("<&"))
-                    anychar_p - (chset_t("<"))
-                ;
-
-                CharData =
-                    *(CharDataChar - "]]>")
-                ;
-
-                Comment = 
-                    "<!--" >> 
-                    (
-                        *(
-                            (Char - '-')
-                            | ('-' >> (Char - '-'))
-                        )
-                    )[typename context_t::a_comment(self.c)] 
-                    >> "-->"
-                ;
-
-                PI = 
-                    "<?" >> PITarget >> !(S >> (*(Char - "?>"))) >> "?>"
-                ;
-
-                PITarget =
-                    Name - (as_lower_d["xml"])
-                ;
-
-                CDSect =
-                    "<![CDATA[" >> CData >> "]]>"
-                ;
-
-                CData =
-                    *(Char - "]]>")
-                ;
-
-                prolog =
-                    !XMLDecl >> *Misc >> !(doctypedecl >> *Misc)
-                ;
-
-                XMLDecl =
-                    "<?xml" >> VersionInfo >> !EncodingDecl >> !SDDecl 
-                    >> !S >> "?>"
-                ;
-
-                VersionInfo = 
-                    S >> "version" >> Eq >> 
-                    (
-                    '\'' >> VersionNum >> '\''
-                    | '"' >> VersionNum >> '"'
-                    )
-                ;
-
-                Eq =
-                    !S >> '=' >> !S
-                ;
-
-                chset_t VersionNumCh("a-zA-Z0-9_.:-");
-
-                VersionNum =
-                    +(VersionNumCh)
-                ;
-
-                Misc =
-                    Comment 
-                    | PI 
-                    | S
-                ;
-
-                doctypedecl =
-                    "<!DOCTYPE" >> S >> Name >> !(S >> ExternalID) >> !S >> 
-                    !(
-                    '[' >> *(markupdecl | DeclSep) >> ']' >> !S
-                    ) 
-                    >> '>'
-                ;
-
-                DeclSep =
-                    PEReference 
-                    | S
-                ;
-
-                markupdecl =
-                    elementdecl 
-                    | AttlistDecl 
-                    | EntityDecl 
-                    | NotationDecl 
-                    | PI 
-                    | Comment
-                ;
-
-                extSubset =
-                    !TextDecl >> extSubsetDecl
-                ;
-
-                extSubsetDecl =
-                    *(
-                        markupdecl 
-                    | conditionalSect 
-                    | DeclSep
-                    )
-                ;
-
-                SDDecl = 
-                    S >> "standalone" >> Eq >> 
-                    (
-                    ('\'' >> (str_p("yes") | "no") >> '\'')
-                    | ('"' >> (str_p("yes") | "no") >> '"')
-                    )
-                ;
-
-                /*
-                element =
-                    EmptyElemTag
-                    | STag >> content >> ETag
-                ;
-                */
-                element =
-                    STagB >> (STagE2 | (STagE1 >> content >> ETag))[typename context_t::a_key_e(self.c)]
-                ;
-
-                STag =
-                    '<' >> Name >> *(S >> Attribute) >> !S >> '>'
-                ;
-
-                STagB =
-                    '<'
-                    >> Name[typename context_t::a_key_s(self.c)]
-                    >> *(S >> Attribute)
-                    >> !S
-                ;
-
-                STagE1 = 
-                    ch_p(">")
-                ;
-
-                STagE2 = 
-                    str_p("/>")
-                ;
-
-                Attribute =
-                    Name[typename context_t::a_attr_key(self.c)]
-                    >> Eq
-                    >> AttValue[typename context_t::a_attr_data(self.c)]
-                ;
-
-                ETag =
-                    "</" >> Name >> !S >> '>'
-                ;
-
-                content =
-                   !(CharData[typename context_t::a_content(self.c)]) >> 
-                   *(
-                     (
-                          element 
-                        // | Reference
-                        | CDSect 
-                        | PI 
-                        | Comment
-                     ) >> 
-                     !(CharData[typename context_t::a_content(self.c)])
-                    )
-                ;
-
-                EmptyElemTag =
-                    '<' >> Name >> *(S >> Attribute) >> !S >> "/>"
-                ;
-
-                elementdecl = 
-                    "<!ELEMENT" >> S >> Name >> S >> contentspec >> !S >> '>'
-                ;
-
-                contentspec = 
-                    str_p("EMPTY") 
-                    | "ANY" 
-                    | Mixed 
-                    | children
-                ;
-
-                children =
-                    (choice | seq) >> !(ch_p('?') | '*' | '+')
-                ;
-
-                cp = 
-                    (Name | choice | seq) >> !(ch_p('?') | '*' | '+')
-                ;
-
-                choice = 
-                    '(' >> !S >> cp 
-                    >> +(!S >> '|' >> !S >> cp) 
-                    >> !S >> ')'
-                ;
-
-                seq =
-                    '(' >> !S >> cp >> 
-                    *(!S >> ',' >> !S >> cp) 
-                    >> !S >> ')'
-                ;
-
-                Mixed =
-                    '(' >> !S >> "#PCDATA" 
-                        >> *(!S >> '|' >> !S >> Name) 
-                        >> !S >> ")*"
-                    | '(' >> !S >> "#PCDATA" >> !S >> ')'
-                ;
-
-                AttlistDecl =
-                    "<!ATTLIST" >> S >> Name >> *AttDef >> !S >> '>'
-                ;
-
-                AttDef =
-                    S >> Name >> S >> AttType >> S >> DefaultDecl
-                ;
-
-                AttType =
-                    StringType 
-                    | TokenizedType 
-                    | EnumeratedType
-                ;
-
-                StringType =
-                    str_p("CDATA")
-                ;
-
-                TokenizedType =
-                    longest_d[ 
-                        str_p("ID") 
-                        | "IDREF" 
-                        | "IDREFS" 
-                        | "ENTITY" 
-                        | "ENTITIES" 
-                        | "NMTOKEN"
-                        | "NMTOKENS" 
-                    ]
-                ;
-
-                EnumeratedType =
-                    NotationType 
-                    | Enumeration
-                ;
-
-                NotationType =
-                    "NOTATION" >> S >> '(' >> !S >> Name 
-                    >> *(!S >> '|' >> !S >> Name) 
-                    >> !S >> ')'
-                ;
-
-                Enumeration = 
-                    '(' >> !S >> Nmtoken 
-                    >> *(!S >> '|' >> !S >> Nmtoken) 
-                    >> !S >> ')'
-                ;
-
-                DefaultDecl =
-                    str_p("#REQUIRED") 
-                    | "#IMPLIED" 
-                    | !("#FIXED" >> S) >> AttValue
-                ;
-
-                conditionalSect =
-                    includeSect 
-                    | ignoreSect
-                ;
-
-                includeSect =
-                    "<![" >> !S >> "INCLUDE" >> !S 
-                    >> '[' >> extSubsetDecl >> "]]>"
-                ;
-
-                ignoreSect = 
-                    "<![" >> !S >> "IGNORE"  >> !S 
-                    >> '[' >> *ignoreSectContents >> "]]>"
-                ;
-
-                ignoreSectContents = 
-                    Ignore >> *("<![" >> ignoreSectContents >> "]]>" >> Ignore)
-                ;
-
-                Ignore = 
-                    *(Char - (str_p("<![") | "]]>"))
-                ;
-
-                CharRef = 
-                    "&#"  >> +Digit  >> ';'
-                    | "&#x" >> +XDigit >> ';'
-                ;
-
-                Reference =
-                    EntityRef 
-                    | CharRef
-                ;
-
-                EntityRef =
-                    '&' >> Name >> ';'
-                ;
-
-                PEReference =
-                    '%' >> Name >> ';'
-                ;
-
-                EntityDecl =
-                    GEDecl 
-                    | PEDecl
-                ;
-
-                GEDecl =
-                    "<!ENTITY" >> S >> Name >> S >> EntityDef >> !S >> '>'
-                ;
-
-                PEDecl =
-                    "<!ENTITY" >> S >> '%' >> S >> Name >> S >> PEDef 
-                    >> !S >> '>'
-                ;
-
-                EntityDef =
-                    EntityValue
-                    | ExternalID >> !NDataDecl
-                ;
-
-                PEDef =
-                    EntityValue 
-                    | ExternalID
-                ;
-
-                ExternalID =
-                    "SYSTEM" >> S >> SystemLiteral
-                    | "PUBLIC" >> S >> PubidLiteral >> S >> SystemLiteral
-                ;
-
-                NDataDecl =
-                    S >> "NDATA" >> S >> Name
-                ;
-
-                TextDecl =
-                    "<?xml" >> !VersionInfo >> EncodingDecl >> !S >> "?>"
-                ;
-
-                extParsedEnt =
-                    !TextDecl >> content
-                ;
-
-                EncodingDecl =
-                    S >> "encoding" >> Eq 
-                    >> (  '"' >> EncName >> '"' 
-                        | '\'' >> EncName >> '\''
-                    )
-                ;
-
-                EncName =
-                    Letter >> *(Letter | Digit | '.' | '_' | '-')
-                ;
-
-                NotationDecl =
-                    "<!NOTATION" >> S >> Name >> S 
-                    >> (ExternalID | PublicID) >> !S >> '>'
-                ;
-
-                PublicID =
-                    "PUBLIC" >> S >> PubidLiteral
-                ;
-
-                BOOST_SPIRIT_DEBUG_RULE(document);
-                BOOST_SPIRIT_DEBUG_RULE(prolog);
-                BOOST_SPIRIT_DEBUG_RULE(element);
-                BOOST_SPIRIT_DEBUG_RULE(Misc);
-                BOOST_SPIRIT_DEBUG_RULE(PEReference);
-                BOOST_SPIRIT_DEBUG_RULE(Reference);
-                BOOST_SPIRIT_DEBUG_RULE(PITarget);
-                BOOST_SPIRIT_DEBUG_RULE(CData);
-                BOOST_SPIRIT_DEBUG_RULE(doctypedecl);
-                BOOST_SPIRIT_DEBUG_RULE(XMLDecl);
-                BOOST_SPIRIT_DEBUG_RULE(SDDecl);
-                BOOST_SPIRIT_DEBUG_RULE(VersionInfo);
-                BOOST_SPIRIT_DEBUG_RULE(EncodingDecl);
-                BOOST_SPIRIT_DEBUG_RULE(VersionNum);
-                BOOST_SPIRIT_DEBUG_RULE(Eq);
-                BOOST_SPIRIT_DEBUG_RULE(DeclSep);
-                BOOST_SPIRIT_DEBUG_RULE(ExternalID);
-                BOOST_SPIRIT_DEBUG_RULE(markupdecl);
-                BOOST_SPIRIT_DEBUG_RULE(NotationDecl);
-                BOOST_SPIRIT_DEBUG_RULE(EntityDecl);
-                BOOST_SPIRIT_DEBUG_RULE(AttlistDecl);
-                BOOST_SPIRIT_DEBUG_RULE(elementdecl);
-                BOOST_SPIRIT_DEBUG_RULE(TextDecl);
-                BOOST_SPIRIT_DEBUG_RULE(extSubsetDecl);
-                BOOST_SPIRIT_DEBUG_RULE(conditionalSect);
-                BOOST_SPIRIT_DEBUG_RULE(EmptyElemTag);
-                BOOST_SPIRIT_DEBUG_RULE(STag);
-                BOOST_SPIRIT_DEBUG_RULE(content);
-                BOOST_SPIRIT_DEBUG_RULE(ETag);
-                BOOST_SPIRIT_DEBUG_RULE(Attribute);
-                BOOST_SPIRIT_DEBUG_RULE(contentspec);
-                BOOST_SPIRIT_DEBUG_RULE(Mixed);
-                BOOST_SPIRIT_DEBUG_RULE(children);
-                BOOST_SPIRIT_DEBUG_RULE(choice);
-                BOOST_SPIRIT_DEBUG_RULE(seq);
-                BOOST_SPIRIT_DEBUG_RULE(cp);
-                BOOST_SPIRIT_DEBUG_RULE(AttDef);
-                BOOST_SPIRIT_DEBUG_RULE(AttType);
-                BOOST_SPIRIT_DEBUG_RULE(DefaultDecl);
-                BOOST_SPIRIT_DEBUG_RULE(StringType);
-                BOOST_SPIRIT_DEBUG_RULE(TokenizedType);
-                BOOST_SPIRIT_DEBUG_RULE(EnumeratedType);
-                BOOST_SPIRIT_DEBUG_RULE(NotationType);
-                BOOST_SPIRIT_DEBUG_RULE(Enumeration);
-                BOOST_SPIRIT_DEBUG_RULE(EntityValue);
-                BOOST_SPIRIT_DEBUG_RULE(AttValue);
-                BOOST_SPIRIT_DEBUG_RULE(SystemLiteral);
-                BOOST_SPIRIT_DEBUG_RULE(PubidLiteral);
-                BOOST_SPIRIT_DEBUG_RULE(CharDataChar);
-                BOOST_SPIRIT_DEBUG_RULE(CharData);
-                BOOST_SPIRIT_DEBUG_RULE(Comment);
-                BOOST_SPIRIT_DEBUG_RULE(PI);
-                BOOST_SPIRIT_DEBUG_RULE(CDSect);
-                BOOST_SPIRIT_DEBUG_RULE(extSubset);
-                BOOST_SPIRIT_DEBUG_RULE(includeSect);
-                BOOST_SPIRIT_DEBUG_RULE(ignoreSect);
-                BOOST_SPIRIT_DEBUG_RULE(ignoreSectContents);
-                BOOST_SPIRIT_DEBUG_RULE(Ignore);
-                BOOST_SPIRIT_DEBUG_RULE(CharRef);
-                BOOST_SPIRIT_DEBUG_RULE(EntityRef);
-                BOOST_SPIRIT_DEBUG_RULE(GEDecl);
-                BOOST_SPIRIT_DEBUG_RULE(PEDecl);
-                BOOST_SPIRIT_DEBUG_RULE(EntityDef);
-                BOOST_SPIRIT_DEBUG_RULE(PEDef);
-                BOOST_SPIRIT_DEBUG_RULE(NDataDecl);
-                BOOST_SPIRIT_DEBUG_RULE(extParsedEnt);
-                BOOST_SPIRIT_DEBUG_RULE(EncName);
-                BOOST_SPIRIT_DEBUG_RULE(PublicID);
-                BOOST_SPIRIT_DEBUG_RULE(document);
-                BOOST_SPIRIT_DEBUG_RULE(S);
-                BOOST_SPIRIT_DEBUG_RULE(Name);
-                BOOST_SPIRIT_DEBUG_RULE(Names);
-                BOOST_SPIRIT_DEBUG_RULE(Nmtoken);
-                BOOST_SPIRIT_DEBUG_RULE(Nmtokens);
-                BOOST_SPIRIT_DEBUG_RULE(STagB);
-                BOOST_SPIRIT_DEBUG_RULE(STagE1);
-                BOOST_SPIRIT_DEBUG_RULE(STagE2);
-
-            }
-
-            const boost::spirit::rule<ScannerT> &start() const
-            {
-                return document;
-            }
-
-        };
-
-    };
-
-    template<class Ptree>
-    void read_xml_internal(std::basic_istream<typename Ptree::char_type> &stream,
-                           Ptree &pt,
-                           int flags,
-                           const std::string &filename)
-    {
-
-        typedef typename Ptree::char_type Ch;
-        typedef boost::spirit::position_iterator<typename std::vector<Ch>::const_iterator> It;
-
-        BOOST_ASSERT(validate_flags(flags));
-
-        // Load data into vector
-        std::vector<Ch> v(std::istreambuf_iterator<Ch>(stream.rdbuf()),
-                          std::istreambuf_iterator<Ch>());
-        if (!stream.good())
-            throw xml_parser_error("read error", filename, 0);
-        
-        // Initialize iterators
-        It begin(v.begin(), v.end());
-        It end;
-        begin.set_position(filename);
-        
-        // Prepare grammar
-        Ptree local;
-        xml_grammar<Ptree> g;
-        g.c.stack.push_back(&local);       // Push root ptree on context stack
-        g.c.flags = flags;
-
-        // Parse into local
-        boost::spirit::parse_info<It> result = boost::spirit::parse(begin, end, g);
-        if (!result.full || g.c.stack.size() != 1)
-            throw xml_parser_error("xml parse error", 
-                                   result.stop.get_position().file, 
-                                   result.stop.get_position().line);
-
-        // Swap local and pt
-        pt.swap(local);
-    }
-
-} } }
-
-#endif

Copied: trunk/boost/property_tree/detail/xml_parser_read_spirit.hpp (from rev 305, trunk/boost/property_tree/detail/xml_parser_read_spirit.hpp)

Deleted: trunk/boost/property_tree/detail/xml_parser_read_tinyxml.hpp
===================================================================
--- trunk/boost/property_tree/detail/xml_parser_read_tinyxml.hpp	2006-10-03 08:49:51 UTC (rev 305)
+++ trunk/boost/property_tree/detail/xml_parser_read_tinyxml.hpp	2006-10-03 09:06:13 UTC (rev 308)
@@ -1,79 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2005 Marcin Kalicinski
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_DETAIL_XML_PARSER_READ_TINYXML_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_DETAIL_XML_PARSER_READ_TINYXML_HPP_INCLUDED
-
-#include <boost/property_tree/ptree.hpp>
-#include <boost/property_tree/detail/xml_parser_error.hpp>
-#include <boost/property_tree/detail/xml_parser_flags.hpp>
-#include <boost/property_tree/detail/xml_parser_utils.hpp>
-
-#define TIXML_USE_STL
-#include <tinyxml.h>
-
-namespace boost { namespace property_tree { namespace xml_parser
-{
-
-    template<class Ptree>
-    void read_xml_node(TiXmlNode *node, Ptree &pt, int flags)
-    {
-
-        typedef typename Ptree::char_type Ch;
-
-        if (TiXmlElement *elem = node->ToElement())
-        {
-            Ptree &tmp = pt.push_back(std::make_pair(elem->Value(), Ptree()))->second;
-            for (TiXmlAttribute *attr = elem->FirstAttribute(); attr; attr = attr->Next())
-                tmp.put(Ch('/'), xmlattr<Ch>() + "/" + attr->Name(), attr->Value());
-            for (TiXmlNode *child = node->FirstChild(); child; child = child->NextSibling())
-                read_xml_node(child, tmp, flags);
-        }
-        else if (TiXmlText *text = node->ToText())
-        {
-            if (flags & no_concat_text)
-                pt.push_back(std::make_pair(xmltext<Ch>(), Ptree(text->Value())));
-            else
-                pt.data() += text->Value();
-        }
-        else if (TiXmlComment *comment = node->ToComment())
-        {
-            if (!(flags & no_comments))
-                pt.push_back(std::make_pair(xmlcomment<Ch>(), Ptree(comment->Value())));
-        }
-    }
-
-    template<class Ptree>
-    void read_xml_internal(std::basic_istream<typename Ptree::char_type> &stream,
-                           Ptree &pt,
-                           int flags,
-                           const std::string &filename)
-    {
-
-        // Create and load document from stream
-        TiXmlDocument doc;
-        stream >> doc;
-        if (!stream.good())
-            throw xml_parser_error("read error", filename, 0);
-        if (doc.Error())
-            throw xml_parser_error(doc.ErrorDesc(), filename, doc.ErrorRow());
-
-        // Create ptree from nodes
-        Ptree local;
-        for (TiXmlNode *child = doc.FirstChild(); child; child = child->NextSibling())
-            read_xml_node(child, local, flags);
-
-        // Swap local and result ptrees
-        pt.swap(local);
-
-    }
-
-} } }
-
-#endif

Copied: trunk/boost/property_tree/detail/xml_parser_read_tinyxml.hpp (from rev 305, trunk/boost/property_tree/detail/xml_parser_read_tinyxml.hpp)

Deleted: trunk/boost/property_tree/detail/xml_parser_utils.hpp
===================================================================
--- trunk/boost/property_tree/detail/xml_parser_utils.hpp	2006-10-03 08:49:51 UTC (rev 305)
+++ trunk/boost/property_tree/detail/xml_parser_utils.hpp	2006-10-03 09:06:13 UTC (rev 308)
@@ -1,119 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2005 Marcin Kalicinski
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_DETAIL_XML_PARSER_UTILS_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_DETAIL_XML_PARSER_UTILS_HPP_INCLUDED
-
-#include <boost/property_tree/detail/ptree_utils.hpp>
-#include <boost/property_tree/detail/xml_parser_error.hpp>
-#include <string>
-#include <algorithm>
-#include <locale>
-
-namespace boost { namespace property_tree { namespace xml_parser
-{
-
-    template<class Ch>
-    std::basic_string<Ch> condense(const std::basic_string<Ch> &s)
-    {
-        std::basic_string<Ch> r;
-        std::locale loc;
-        bool space = false;
-        typename std::basic_string<Ch>::const_iterator end = s.end();
-        for (typename std::basic_string<Ch>::const_iterator it = s.begin();
-             it != end; ++it)
-        {
-            if (isspace(*it, loc) || *it == Ch('\n'))
-            {
-                if (!space)
-                    r += Ch(' '), space = true;
-            }
-            else
-                r += *it, space = false;
-        }
-        return r;
-    }
-
-    template<class Ch>
-    std::basic_string<Ch> encode_char_entities(const std::basic_string<Ch> &s)
-    {
-        typedef typename std::basic_string<Ch> Str;
-        Str r;
-        typename Str::const_iterator end = s.end();
-        for (typename Str::const_iterator it = s.begin(); it != end; ++it)
-        {
-            switch (*it)
-            {
-                case Ch('<'): r += detail::widen<Ch>("&lt;"); break;
-                case Ch('>'): r += detail::widen<Ch>("&gt;"); break;
-                case Ch('&'): r += detail::widen<Ch>("&amp;"); break;
-                default: r += *it; break;
-            }
-        }
-        return r;
-    }
-    
-    template<class Ch>
-    std::basic_string<Ch> decode_char_entities(const std::basic_string<Ch> &s)
-    {
-        typedef typename std::basic_string<Ch> Str;
-        Str r;
-        typename Str::const_iterator end = s.end();
-        for (typename Str::const_iterator it = s.begin(); it != end; ++it)
-        {
-            if (*it == Ch('&'))
-            {
-                typename Str::const_iterator semicolon = std::find(it + 1, end, Ch(';'));
-                if (semicolon == end)
-                    throw xml_parser_error("invalid character entity", "", 0);
-                Str ent(it + 1, semicolon);
-                if (ent == detail::widen<Ch>("lt")) r += Ch('<');
-                else if (ent == detail::widen<Ch>("gt")) r += Ch('>');
-                else if (ent == detail::widen<Ch>("amp")) r += Ch('&');
-                else
-                    throw xml_parser_error("invalid character entity", "", 0);
-                it = semicolon;
-            }
-            else
-                r += *it;
-        }
-        return r;
-    }
-    
-    template<class Ch>
-    const std::basic_string<Ch> &xmldecl()
-    {
-        static std::basic_string<Ch> s = detail::widen<Ch>("<?xml>");
-        return s;
-    }
-
-    template<class Ch>
-    const std::basic_string<Ch> &xmlattr()
-    {
-        static std::basic_string<Ch> s = detail::widen<Ch>("<xmlattr>");
-        return s;
-    }
-
-    template<class Ch>
-    const std::basic_string<Ch> &xmlcomment()
-    {
-        static std::basic_string<Ch> s = detail::widen<Ch>("<xmlcomment>");
-        return s;
-    }
-
-    template<class Ch>
-    const std::basic_string<Ch> &xmltext()
-    {
-        static std::basic_string<Ch> s = detail::widen<Ch>("<xmltext>");
-        return s;
-    }
-
-} } }
-
-#endif

Copied: trunk/boost/property_tree/detail/xml_parser_utils.hpp (from rev 305, trunk/boost/property_tree/detail/xml_parser_utils.hpp)

Deleted: trunk/boost/property_tree/detail/xml_parser_write.hpp
===================================================================
--- trunk/boost/property_tree/detail/xml_parser_write.hpp	2006-10-03 08:49:51 UTC (rev 305)
+++ trunk/boost/property_tree/detail/xml_parser_write.hpp	2006-10-03 09:06:13 UTC (rev 308)
@@ -1,145 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2005 Marcin Kalicinski
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_DETAIL_XML_PARSER_WRITE_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_DETAIL_XML_PARSER_WRITE_HPP_INCLUDED
-
-#include <boost/property_tree/ptree.hpp>
-#include <boost/property_tree/detail/xml_parser_utils.hpp>
-#include <string>
-#include <ostream>
-#include <iomanip>
-
-namespace boost { namespace property_tree { namespace xml_parser
-{
-
-    template<class Ch>
-    void write_xml_comment(std::basic_ostream<Ch> &stream,
-                           const std::basic_string<Ch> &s, 
-                           int indent)
-    {
-        typedef typename std::basic_string<Ch> Str;
-        stream << Str(4 * indent, Ch(' '));
-        stream << Ch('<') << Ch('!') << Ch('-') << Ch('-');
-        stream << s;
-        stream << Ch('-') << Ch('-') << Ch('>') << std::endl;
-    }
-    
-    template<class Ch>
-    void write_xml_text(std::basic_ostream<Ch> &stream,
-                        const std::basic_string<Ch> &s, 
-                        int indent, 
-                        bool separate_line)
-    {
-        typedef typename std::basic_string<Ch> Str;
-        if (separate_line)    
-            stream << Str(4 * indent, Ch(' '));
-        stream << encode_char_entities(s);
-        if (separate_line)    
-            stream << Ch('\n');
-    }
-
-    template<class Ptree>
-    void write_xml_element(std::basic_ostream<typename Ptree::char_type> &stream, 
-                           const std::basic_string<typename Ptree::char_type> &key,
-                           const Ptree &pt, 
-                           int indent)
-    {
-
-        typedef typename Ptree::char_type Ch;
-        typedef typename std::basic_string<Ch> Str;
-        typedef typename Ptree::const_iterator It;
-
-        // Find if elements present
-        bool has_elements = false;
-        for (It it = pt.begin(), end = pt.end(); it != end; ++it)
-            if (it->first != xmlattr<Ch>() &&
-                it->first != xmltext<Ch>())
-            {
-                has_elements = true;
-                break;
-            }
-        
-        // Write element
-        if (pt.data().empty() && pt.empty())    // Empty key
-        {
-            if (indent >= 0)
-                stream << Str(4 * indent, Ch(' ')) << Ch('<') << key << 
-                          Ch('/') << Ch('>') << std::endl;
-        }
-        else    // Nonempty key
-        {
-        
-            // Write opening tag, attributes and data
-            if (indent >= 0)
-            {
-            
-                // Write opening brace and key
-                stream << Str(4 * indent, Ch(' '));
-                stream << Ch('<') << key;
-
-                // Write attributes
-                if (optional<const Ptree &> attribs = pt.get_child_optional(xmlattr<Ch>()))
-                    for (It it = attribs.get().begin(); it != attribs.get().end(); ++it)
-                        stream << Ch(' ') << it->first << Ch('=') << 
-                                  Ch('"') << it->second.template get_own<std::basic_string<Ch> >() << Ch('"');
-
-                // Write closing brace
-                stream << Ch('>');
-
-                // Break line if needed
-                if (has_elements)
-                    stream << Ch('\n');
-
-            }
-            
-            // Write data text, if present
-            if (!pt.data().empty())
-                write_xml_text(stream, pt.template get_own<std::basic_string<Ch> >(), indent + 1, has_elements);
-            
-            // Write elements, comments and texts
-            for (It it = pt.begin(); it != pt.end(); ++it)
-            {
-                if (it->first == xmlattr<Ch>())
-                    continue;
-                else if (it->first == xmlcomment<Ch>())
-                    write_xml_comment(stream, it->second.template get_own<std::basic_string<Ch> >(), indent + 1);
-                else if (it->first == xmltext<Ch>())
-                    write_xml_text(stream, it->second.template get_own<std::basic_string<Ch> >(), indent + 1, has_elements);
-                else
-                    write_xml_element(stream, it->first, it->second, indent + 1);
-            }
-            
-            // Write closing tag
-            if (indent >= 0)
-            {
-                if (has_elements)
-                    stream << Str(4 * indent, Ch(' '));
-                stream << Ch('<') << Ch('/') << key << Ch('>') << std::endl;
-            }
-
-        }
-    }
-
-    template<class Ptree>
-    void write_xml_internal(std::basic_ostream<typename Ptree::char_type> &stream, 
-                            const Ptree &pt,
-                            const std::string &filename)
-    {
-        typedef typename Ptree::char_type Ch;
-        typedef typename std::basic_string<Ch> Str;
-        stream << detail::widen<Ch>("<?xml version=\"1.0\" encoding=\"utf-8\"?>\n");
-        write_xml_element(stream, Str(), pt, -1);
-        if (!stream)
-            throw xml_parser_error("write error", filename, 0);
-    }
-
-} } }
-
-#endif

Copied: trunk/boost/property_tree/detail/xml_parser_write.hpp (from rev 305, trunk/boost/property_tree/detail/xml_parser_write.hpp)

Deleted: trunk/boost/property_tree/info_parser.hpp
===================================================================
--- trunk/boost/property_tree/info_parser.hpp	2006-10-03 08:49:51 UTC (rev 305)
+++ trunk/boost/property_tree/info_parser.hpp	2006-10-03 09:06:13 UTC (rev 308)
@@ -1,77 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2005 Marcin Kalicinski
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_INFO_PARSER_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_INFO_PARSER_HPP_INCLUDED
-
-#include <boost/property_tree/ptree.hpp>
-#include <boost/property_tree/detail/info_parser_error.hpp>
-#include <boost/property_tree/detail/info_parser_read.hpp>
-#include <boost/property_tree/detail/info_parser_write.hpp>
-#include <istream>
-
-namespace boost { namespace property_tree { namespace info_parser
-{
-
-    // Read info from stream
-    template<class Ptree>
-    void read_info(std::basic_istream<typename Ptree::char_type> &stream, 
-                   Ptree &pt)
-    {
-        Ptree local;
-        read_info_internal(stream, local, std::string(), 0);
-        pt.swap(local);
-    }
-
-    // Read info from file
-    template<class Ptree>
-    void read_info(const std::string &filename,
-                   Ptree &pt,
-                   const std::locale &loc = std::locale())
-    {
-        std::basic_ifstream<typename Ptree::char_type> stream(filename.c_str());
-        if (!stream)
-            throw info_parser_error("cannot open file for reading", filename, 0);
-        stream.imbue(loc);
-        Ptree local;
-        read_info_internal(stream, local, filename, 0);
-        pt.swap(local);
-    }
-
-    // Write info to stream
-    template<class Ptree>
-    void write_info(std::basic_ostream<typename Ptree::char_type> &stream, 
-                    const Ptree &pt)
-    {
-        write_info_internal(stream, pt, std::string());
-    }
-
-    // Write info to file
-    template<class Ptree>
-    void write_info(const std::string &filename,
-                    const Ptree &pt,
-                    const std::locale &loc = std::locale())
-    {
-        std::basic_ofstream<typename Ptree::char_type> stream(filename.c_str());
-        if (!stream)
-            throw info_parser_error("cannot open file for writing", filename, 0);
-        stream.imbue(loc);
-        write_info_internal(stream, pt, filename);
-    }
-
-} } }
-
-namespace boost { namespace property_tree
-{
-    using info_parser::info_parser_error;
-    using info_parser::read_info;
-    using info_parser::write_info;
-} }
-
-#endif

Copied: trunk/boost/property_tree/info_parser.hpp (from rev 305, trunk/boost/property_tree/info_parser.hpp)

Deleted: trunk/boost/property_tree/ini_parser.hpp
===================================================================
--- trunk/boost/property_tree/ini_parser.hpp	2006-10-03 08:49:51 UTC (rev 305)
+++ trunk/boost/property_tree/ini_parser.hpp	2006-10-03 09:06:13 UTC (rev 308)
@@ -1,196 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2005 Marcin Kalicinski
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_INI_PARSER_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_INI_PARSER_HPP_INCLUDED
-
-#include <boost/property_tree/ptree.hpp>
-#include <boost/property_tree/detail/ptree_utils.hpp>
-#include <boost/property_tree/detail/file_parser_error.hpp>
-#include <istream>
-#include <string>
-#include <sstream>
-#include <stdexcept>
-#include <locale>
-
-namespace boost { namespace property_tree { namespace ini_parser
-{
-
-    static const int skip_ini_validity_check = 1;     // Skip check if ptree is a valid ini
-
-    inline bool validate_flags(int flags)
-    {
-        return (flags & ~skip_ini_validity_check) == 0;
-    }
-
-    //! Ini parser error
-    class ini_parser_error: public file_parser_error
-    {
-    public:
-        ini_parser_error(const std::string &message, 
-                         const std::string &filename, 
-                         unsigned long line): 
-            file_parser_error(message, filename, line)
-        { 
-        }
-    };
-
-    //! Read ini from stream
-    template<class Ptree>
-    void read_ini(std::basic_istream<typename Ptree::char_type> &stream, 
-                  Ptree &pt)
-    {
-
-        typedef typename Ptree::char_type Ch;
-        typedef std::basic_string<Ch> Str;
-
-        Ptree local;
-        unsigned long line_no = 0;
-        Ptree *section = 0;
-        Str line;
-
-        // For all lines
-        while (stream.good())
-        {
-
-            // Get line from stream
-            ++line_no;
-            std::getline(stream, line);
-            if (!stream.good() && !stream.eof())
-                throw ini_parser_error("read error", "", line_no);
-
-            // If line is non-empty
-            line = detail::trim(line, stream.getloc());
-            if (!line.empty())
-            {
-            
-                // Comment, section or key?
-                if (line[0] == Ch(';'))
-                {
-                    // Ignore comments
-                }
-                else if (line[0] == Ch('['))
-                {
-                    typename Str::size_type end = line.find(Ch(']'));
-                    if (end == Str::npos)
-                        throw ini_parser_error("unmatched '['", "", line_no);
-                    Str key = detail::trim(line.substr(1, end - 1), stream.getloc());
-                    if (local.find(key) != local.end())
-                        throw ini_parser_error("duplicate section name", "", line_no);
-                    section = &local.push_back(std::make_pair(key, Ptree()))->second;
-                }
-                else
-                {
-                    if (!section)
-                        throw ini_parser_error("section expected", "", line_no);
-                    typename Str::size_type eqpos = line.find(Ch('='));
-                    if (eqpos == Str::npos)
-                        throw ini_parser_error("'=' character not found in line", "", line_no);
-                    if (eqpos == 0)
-                        throw ini_parser_error("key expected", "", line_no);
-                    Str key = detail::trim(line.substr(0, eqpos), stream.getloc());
-                    Str data = detail::trim(line.substr(eqpos + 1, Str::npos), stream.getloc());
-                    if (section->find(key) != section->end())
-                        throw ini_parser_error("duplicate key name", "", line_no);
-                    section->push_back(std::make_pair(key, Ptree(data)));
-                }
-            }
-        }
-
-        // Swap local ptree with result ptree
-        pt.swap(local);
-
-    }
-
-    //! Read ini from file
-    template<class Ptree>
-    void read_ini(const std::string &filename, 
-                  Ptree &pt,
-                  const std::locale &loc = std::locale())
-    {
-        std::basic_ifstream<typename Ptree::char_type> stream(filename.c_str());
-        if (!stream)
-            throw ini_parser_error("cannot open file", filename, 0);
-        stream.imbue(loc);
-        try {
-            read_ini(stream, pt);
-        }
-        catch (ini_parser_error &e) {
-            throw ini_parser_error(e.message(), filename, e.line());
-        }
-    }
-
-    //! Write ini to stream
-    template<class Ptree>
-    void write_ini(std::basic_ostream<typename Ptree::char_type> &stream, 
-                   const Ptree &pt,
-                   int flags = 0)
-    {
-
-        typedef typename Ptree::char_type Ch;
-        typedef std::basic_string<Ch> Str;
-
-        BOOST_ASSERT(validate_flags(flags));
-        
-        // Verify if ptree is not too rich to be saved as ini
-        if (!(flags & skip_ini_validity_check))
-            for (typename Ptree::const_iterator it = pt.begin(), end = pt.end(); it != end; ++it)
-            {
-                if (!it->second.data().empty())
-                    throw ini_parser_error("ptree has data on root level keys", "", 0);
-                if (pt.count(it->first) > 1)
-                    throw ini_parser_error("duplicate section name", "", 0);
-                for (typename Ptree::const_iterator it2 = it->second.begin(), end2 = it->second.end(); it2 != end2; ++it2)
-                {
-                    if (!it2->second.empty())
-                        throw ini_parser_error("ptree is too deep", "", 0);
-                    if (it->second.count(it2->first) > 1)
-                        throw ini_parser_error("duplicate key name", "", 0);
-                }
-            }
-
-        // Write ini
-        for (typename Ptree::const_iterator it = pt.begin(), end = pt.end(); it != end; ++it)
-        {
-            stream << Ch('[') << it->first << Ch(']') << Ch('\n');
-            for (typename Ptree::const_iterator it2 = it->second.begin(), end2 = it->second.end(); it2 != end2; ++it2)
-                stream << it2->first << Ch('=') << it2->second.template get_own<std::basic_string<Ch> >() << Ch('\n');
-        }
-
-    }
-
-    // Write ini to file
-    template<class Ptree>
-    void write_ini(const std::string &filename,
-                   const Ptree &pt,
-                   int flags = 0,
-                   const std::locale &loc = std::locale())
-    {
-        std::basic_ofstream<typename Ptree::char_type> stream(filename.c_str());
-        if (!stream)
-            throw ini_parser_error("cannot open file", filename, 0);
-        stream.imbue(loc);
-        try {
-            write_ini(stream, pt, flags);
-        }
-        catch (ini_parser_error &e) {
-            throw ini_parser_error(e.message(), filename, e.line());
-        }
-    }
-
-} } }
-
-namespace boost { namespace property_tree
-{
-    using ini_parser::ini_parser_error;
-    using ini_parser::read_ini;
-    using ini_parser::write_ini;
-} }
-
-#endif

Copied: trunk/boost/property_tree/ini_parser.hpp (from rev 305, trunk/boost/property_tree/ini_parser.hpp)

Deleted: trunk/boost/property_tree/json_parser.hpp
===================================================================
--- trunk/boost/property_tree/json_parser.hpp	2006-10-03 08:49:51 UTC (rev 305)
+++ trunk/boost/property_tree/json_parser.hpp	2006-10-03 09:06:13 UTC (rev 308)
@@ -1,76 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2005 Marcin Kalicinski
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_JSON_PARSER_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_JSON_PARSER_HPP_INCLUDED
-
-#include <boost/property_tree/ptree.hpp>
-#include <boost/property_tree/detail/json_parser_read.hpp>
-#include <boost/property_tree/detail/json_parser_write.hpp>
-#include <boost/property_tree/detail/json_parser_error.hpp>
-
-#include <fstream>
-#include <string>
-#include <locale>
-
-namespace boost { namespace property_tree { namespace json_parser
-{
-
-    // Read json from stream
-    template<class Ptree>
-    void read_json(std::basic_istream<typename Ptree::char_type> &stream,
-                   Ptree &pt)
-    {
-        read_json_internal(stream, pt, std::string());
-    }
-
-    // Read json from file
-    template<class Ptree>
-    void read_json(const std::string &filename,
-                   Ptree &pt,
-                   const std::locale &loc = std::locale())
-    {
-        std::basic_ifstream<typename Ptree::char_type> stream(filename.c_str());
-        if (!stream)
-            throw json_parser_error("cannot open file", filename, 0);
-        stream.imbue(loc);
-        read_json_internal(stream, pt, filename);
-    }
-
-    // Write json to stream
-    template<class Ptree>
-    void write_json(std::basic_ostream<typename Ptree::char_type> &stream, 
-                    const Ptree &pt)
-    {
-        write_json_internal(stream, pt, std::string());
-    }
-
-    // Write json to file
-    template<class Ptree>
-    void write_json(const std::string &filename,
-                    const Ptree &pt,
-                    const std::locale &loc = std::locale())
-    {
-        std::basic_ofstream<typename Ptree::char_type> stream(filename.c_str());
-        if (!stream)
-            throw json_parser_error("cannot open file", filename, 0);
-        stream.imbue(loc);
-        write_json_internal(stream, pt, filename);
-    }
-
-} } }
-
-namespace boost { namespace property_tree
-{
-    using json_parser::read_json;
-    using json_parser::write_json;
-    using json_parser::json_parser_error;
-} }
-
-#endif

Copied: trunk/boost/property_tree/json_parser.hpp (from rev 305, trunk/boost/property_tree/json_parser.hpp)

Deleted: trunk/boost/property_tree/ptree.hpp
===================================================================
--- trunk/boost/property_tree/ptree.hpp	2006-10-03 08:49:51 UTC (rev 305)
+++ trunk/boost/property_tree/ptree.hpp	2006-10-03 09:06:13 UTC (rev 308)
@@ -1,16 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2005 Marcin Kalicinski
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_PTREE_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_PTREE_HPP_INCLUDED
-
-#include <boost/property_tree/detail/ptree_interface.hpp>
-#include <boost/property_tree/detail/ptree_implementation.hpp>
-
-#endif                                                

Copied: trunk/boost/property_tree/ptree.hpp (from rev 305, trunk/boost/property_tree/ptree.hpp)

Deleted: trunk/boost/property_tree/ptree_fwd.hpp
===================================================================
--- trunk/boost/property_tree/ptree_fwd.hpp	2006-10-03 08:49:51 UTC (rev 305)
+++ trunk/boost/property_tree/ptree_fwd.hpp	2006-10-03 09:06:13 UTC (rev 308)
@@ -1,54 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2005 Marcin Kalicinski
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_PTREE_FWD_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_PTREE_FWD_HPP_INCLUDED
-
-#include <boost/config.hpp>
-
-namespace boost { namespace property_tree
-{
-
-    ////////////////////////////////////////////////////////////////////////////
-    // Traits
-
-    template<class Ch> struct ptree_traits;
-    template<class Ch> struct iptree_traits;
-
-    ///////////////////////////////////////////////////////////////////////////
-    // Exceptions
-
-    class ptree_error;
-    class bad_ptree_data;
-    class bad_ptree_path;
-
-    ///////////////////////////////////////////////////////////////////////////
-    // basic_ptree class template
-
-    template<class Tr> class basic_ptree;
-
-    ////////////////////////////////////////////////////////////////////////////
-    // Typedefs
-
-    typedef basic_ptree<ptree_traits<char> > ptree;       // case sensitive, narrow char
-    typedef basic_ptree<iptree_traits<char> > iptree;     // case insensitive, narrow char
-#ifndef BOOST_NO_CWCHAR
-    typedef basic_ptree<ptree_traits<wchar_t> > wptree;    // case sensitive, wide char
-    typedef basic_ptree<iptree_traits<wchar_t> > wiptree;  // case insensitive, wide char
-#endif
-
-    ///////////////////////////////////////////////////////////////////////////
-    // Free functions
-
-    template<class Tr> void swap(basic_ptree<Tr> &pt1, basic_ptree<Tr> &pt2);
-    template<class Ptree> const Ptree &empty_ptree();
-
-} }
-
-#endif

Copied: trunk/boost/property_tree/ptree_fwd.hpp (from rev 305, trunk/boost/property_tree/ptree_fwd.hpp)

Deleted: trunk/boost/property_tree/registry_parser.hpp
===================================================================
--- trunk/boost/property_tree/registry_parser.hpp	2006-10-03 08:49:51 UTC (rev 305)
+++ trunk/boost/property_tree/registry_parser.hpp	2006-10-03 09:06:13 UTC (rev 308)
@@ -1,520 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2005 Marcin Kalicinski
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_REGISTRY_PARSER_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_REGISTRY_PARSER_HPP_INCLUDED
-
-// Include minimal version of windows.h if not included yet
-#ifndef _WINDOWS_
-#ifndef NOMINMAX
-    #define NOMINMAX
-#endif
-#define STRICT
-#define WIN32_LEAN_AND_MEAN
-#define VC_EXTRALEAN
-#define NOGDICAPMASKS
-#define NOVIRTUALKEYCODES
-#define NOWINMESSAGES
-#define NOWINSTYLES
-#define NOSYSMETRICS
-#define NOMENUS
-#define NOICONS
-#define NOKEYSTATES
-#define NOSYSCOMMANDS
-#define NORASTEROPS
-#define NOSHOWWINDOW
-#define OEMRESOURCE
-#define NOATOM
-#define NOCLIPBOARD
-#define NOCOLOR
-#define NOCTLMGR
-#define NODRAWTEXT
-#define NOGDI
-#define NOKERNEL
-#define NOUSER
-#define NONLS
-#define NOMB 
-#define NOMEMMGR
-#define NOMETAFILE
-#define NOMSG
-#define NOOPENFILE
-#define NOSCROLL
-#define NOSERVICE
-#define NOSOUND
-#define NOTEXTMETRIC
-#define NOWH
-#define NOWINOFFSETS
-#define NOCOMM
-#define NOKANJI
-#define NOHELP
-#define NOPROFILER
-#define NODEFERWINDOWPOS
-#define NOMCX
-#include <windows.h>
-#endif
-
-#include <boost/property_tree/ptree.hpp>
-#include <boost/property_tree/detail/ptree_utils.hpp>
-#include <boost/cstdint.hpp>                // for 64 bit int
-#include <sstream>
-#include <iomanip>
-#include <string>
-#include <vector>
-#include <stdexcept>
-
-namespace boost { namespace property_tree { namespace registry_parser
-{
-
-    //! Registry parser error
-    class registry_parser_error: public ptree_error
-    {
-    public:
-    
-        // Construct error 
-        registry_parser_error(const std::string &message, DWORD windows_error): 
-            ptree_error(format_what(message, windows_error)), 
-            m_windows_error(windows_error)
-        { 
-        }
-    
-        // Get windows error
-        DWORD windows_error()
-        {
-            return m_windows_error;
-        }
-    
-    private:
-
-        DWORD m_windows_error;
-
-        // Format error message to be returned by std::runtime_error::what()
-        std::string format_what(const std::string &message,
-                                DWORD windows_error)
-        {
-            std::stringstream stream;
-            if (windows_error)
-                stream << message << " (windows error 0x" << std::hex << windows_error << ")";
-            else
-                stream << message;
-            return stream.str();
-        }
-
-    };
-
-    // Translate from binary buffer to string
-    template<class Ch>
-    std::basic_string<Ch> translate(DWORD type, const std::vector<BYTE> &data)
-    {
-
-        typedef std::basic_string<Ch> Str;
-        typedef std::basic_stringstream<Ch> Stream;
-
-        Str value;
-        switch (type)
-        {
-        
-            // No data
-            case REG_NONE:
-                break;
-            
-            // Binary data
-            case REG_BINARY: 
-                if (!data.empty())
-                {
-                    Stream stream;
-                    stream << std::hex << std::setfill(Ch('0'));
-                    for (std::vector<BYTE>::const_iterator it = data.begin(), end = data.end(); 
-                         it != end; ++it)
-                        stream << std::setw(2) << static_cast<int>(*it) << Ch(' ');
-                    value = stream.str();
-                    value.resize(value.size() - 1); // remove final space
-                }
-                break;
-            
-            // DWORD value
-            case REG_DWORD: 
-                if (!data.empty())
-                {
-                    Stream stream;
-                    stream << *reinterpret_cast<const DWORD *>(&data.front());
-                    value = stream.str();
-                }
-                break;
-
-            // QWORD value
-            case REG_QWORD: 
-                if (!data.empty())
-                {
-                    Stream stream;
-                    stream << *reinterpret_cast<const boost::uint64_t *>(&data.front());
-                    value = stream.str();
-                }
-                break;
-            
-            // Zero terminated string
-            case REG_SZ: case REG_EXPAND_SZ: 
-                if (!data.empty())
-                    value.assign(reinterpret_cast<const Ch *>(&data.front()));
-                break;
-            
-            // Unknown data type
-            default:
-                throw registry_parser_error("unsupported data type", 0);
-
-        };
-        return value;
-    }
-
-    // Translate from string to binary buffer
-    template<class Ch>
-    std::vector<BYTE> translate(DWORD type, const std::basic_string<Ch> &s)
-    {
-
-        typedef std::basic_string<Ch> Str;
-        typedef std::basic_stringstream<Ch> Stream;
-
-        std::vector<BYTE> data;
-        switch (type)
-        {
-        
-            // No data
-            case REG_NONE:
-                break;
-            
-            // Binary data
-            case REG_BINARY:
-                {
-                    int v;
-                    Stream stream(s);
-                    stream >> std::hex;
-                    while (1)
-                    {
-                        stream >> v >> std::ws;
-                        if (stream.fail() || stream.bad())
-                            throw registry_parser_error("bad REG_BINARY value", 0);
-                        data.push_back(v);
-                        if (stream.eof())
-                            break;
-                    }
-                }
-                break;
-            
-            // DWORD value
-            case REG_DWORD: 
-                {
-                    DWORD v;
-                    Stream stream(s);
-                    stream >> v >> std::ws;
-                    if (!stream.eof() || stream.fail() || stream.bad())
-                        throw registry_parser_error("bad REG_DWORD value", 0);
-                    for (size_t i = 0; i < sizeof(v); ++i)
-                        data.push_back(*(reinterpret_cast<BYTE *>(&v) + i));
-                }
-                break;
-
-            // QWORD value
-            case REG_QWORD: 
-                {
-                    boost::uint64_t v;
-                    Stream stream(s);
-                    stream >> v;
-                    if (!stream.eof() || stream.fail() || stream.bad())
-                        throw registry_parser_error("bad REG_QWORD value", 0);
-                    for (size_t i = 0; i < sizeof(v); ++i)
-                        data.push_back(*(reinterpret_cast<BYTE *>(&v) + i));
-                }
-                break;
-            
-            // Zero terminated string
-            case REG_SZ: case REG_EXPAND_SZ:
-                {
-                    const Ch *sz = s.c_str();
-                    size_t len = (s.size() + 1) * sizeof(Ch);
-                    for (size_t i = 0; i < len; ++i)
-                        data.push_back(*(reinterpret_cast<const BYTE *>(sz) + i));
-                }
-                break;
-            
-            // Unknown data type
-            default:
-                throw registry_parser_error("unsupported data type", 0);
-
-        };
-        return data;
-    }
-
-    /////////////////////////////////////////////////////////////////////////////
-    // Registry functions wrappers
-    
-    template<class Ch> 
-    inline LONG reg_create_key_ex(HKEY hkey, const Ch *subkey, REGSAM sam, HKEY *result);
-
-    template<> 
-    inline LONG reg_create_key_ex<char>(HKEY hkey, const char *subkey, REGSAM sam, HKEY *result)
-    {
-        return RegCreateKeyExA(hkey, subkey, 0, NULL, REG_OPTION_NON_VOLATILE, sam, NULL, result, NULL);
-    }
-    
-    template<> 
-    inline LONG reg_create_key_ex<wchar_t>(HKEY hkey, const wchar_t *subkey, REGSAM sam, HKEY *result)
-    {
-        return RegCreateKeyExW(hkey, subkey, 0, NULL, REG_OPTION_NON_VOLATILE, sam, NULL, result, NULL);
-    }
-
-    template<class Ch> 
-    inline LONG reg_set_value_ex(HKEY hkey, const Ch *name, DWORD type, const BYTE *data, DWORD size);
-
-    template<> 
-    inline LONG reg_set_value_ex<char>(HKEY hkey, const char *name, DWORD type, const BYTE *data, DWORD size)
-    {
-        return RegSetValueExA(hkey, name, 0, type, data, size);
-    }
-
-    template<> 
-    inline LONG reg_set_value_ex<wchar_t>(HKEY hkey, const wchar_t *name, DWORD type, const BYTE *data, DWORD size)
-    {
-        return RegSetValueExW(hkey, name, 0, type, data, size);
-    }
-
-    template<class Ch> 
-    inline LONG reg_open_key_ex(HKEY hkey, const Ch *subkey, REGSAM sam, HKEY *result);
-
-    template<> 
-    inline LONG reg_open_key_ex<char>(HKEY hkey, const char *subkey, REGSAM sam, HKEY *result)
-    {
-        return RegOpenKeyExA(hkey, subkey, 0, sam, result);
-    }
-    
-    template<> 
-    inline LONG reg_open_key_ex<wchar_t>(HKEY hkey, const wchar_t *subkey, REGSAM sam, HKEY *result)
-    {
-        return RegOpenKeyExW(hkey, subkey, 0, sam, result);
-    }
-
-    template<class Ch> 
-    inline LONG reg_enum_key_ex(HKEY hkey, DWORD index, Ch *name, DWORD *size);
-
-    template<> 
-    inline LONG reg_enum_key_ex<char>(HKEY hkey, DWORD index, char *name, DWORD *size)
-    {
-        FILETIME ft;
-        return RegEnumKeyExA(hkey, index, name, size, 0, NULL, NULL, &ft);
-    }
-
-    template<> 
-    inline LONG reg_enum_key_ex<wchar_t>(HKEY hkey, DWORD index, wchar_t *name, DWORD *size)
-    {
-        FILETIME ft;
-        return RegEnumKeyExW(hkey, index, name, size, 0, NULL, NULL, &ft);
-    }
-
-    template<class Ch> 
-    inline LONG reg_enum_value(HKEY hkey, DWORD index, Ch *name, DWORD *name_size, DWORD *type, BYTE *data, DWORD *data_size);
-
-    template<> 
-    inline LONG reg_enum_value<char>(HKEY hkey, DWORD index, char *name, DWORD *name_size, DWORD *type, BYTE *data, DWORD *data_size)
-    {
-        return RegEnumValueA(hkey, index, name, name_size, NULL, type, data, data_size);
-    }
-
-    template<> 
-    inline LONG reg_enum_value<wchar_t>(HKEY hkey, DWORD index, wchar_t *name, DWORD *name_size, DWORD *type, BYTE *data, DWORD *data_size)
-    {
-        return RegEnumValueW(hkey, index, name, name_size, NULL, type, data, data_size);
-    }
-
-    template<class Ch> 
-    inline LONG reg_query_info_key(HKEY hkey, DWORD *max_subkey_len, DWORD *max_name_len, DWORD *max_value_len);
-
-    template<> 
-    inline LONG reg_query_info_key<char>(HKEY hkey, DWORD *max_subkey_len, DWORD *max_name_len, DWORD *max_value_len)
-    {
-        return RegQueryInfoKeyA(hkey, NULL, NULL, NULL, NULL, max_subkey_len, NULL, NULL, max_name_len, max_value_len, NULL, NULL);
-    }
-
-    template<> 
-    inline LONG reg_query_info_key<wchar_t>(HKEY hkey, DWORD *max_subkey_len, DWORD *max_name_len, DWORD *max_value_len)
-    {
-        return RegQueryInfoKeyW(hkey, NULL, NULL, NULL, NULL, max_subkey_len, NULL, NULL, max_name_len, max_value_len, NULL, NULL);
-    }
-
-    /////////////////////////////////////////////////////////////////////////////
-    // Registry key handle wrapper
-    
-    template<class Ch>
-    class reg_key
-    {
-    public:
-        typedef std::basic_string<Ch> Str;
-        reg_key(HKEY root, const std::basic_string<Ch> &key, bool create):
-            hkey(0)
-        {
-            if (create)
-            {
-                LONG result = reg_create_key_ex(root, key.c_str(), KEY_WRITE, &hkey);
-                if (result != ERROR_SUCCESS)
-                    throw registry_parser_error("RegCreateKeyEx failed", result);
-            }
-            else
-            {
-                LONG result = reg_open_key_ex(root, key.c_str(), KEY_READ, &hkey);
-                if (result != ERROR_SUCCESS)
-                    throw registry_parser_error("RegOpenKeyEx failed", result);
-            }
-            BOOST_ASSERT(hkey);
-        }
-        ~reg_key()
-        {
-            BOOST_ASSERT(hkey);
-            RegCloseKey(hkey);
-        }
-        HKEY handle()
-        {
-            BOOST_ASSERT(hkey);
-            return hkey;
-        }
-    private:
-        HKEY hkey;
-    };
-    
-    /////////////////////////////////////////////////////////////////////////////
-    // Registry parser
-    
-    //! Read registry
-    template<class Ptree>
-    void read_registry(HKEY root, 
-                       const std::basic_string<typename Ptree::char_type> &key, 
-                       Ptree &pt)
-    {
-
-        typedef typename Ptree::char_type Ch;
-        typedef std::basic_string<Ch> Str;
-        typedef std::basic_stringstream<Ch> Stream;
-        
-        Ptree local;
-        
-        // Open key
-        reg_key<Ch> rk(root, key, false);
-        
-        // Query key info
-        DWORD max_subkey_len, max_name_len, max_value_len;
-        LONG result = reg_query_info_key<Ch>(rk.handle(), &max_subkey_len, &max_name_len, &max_value_len);
-        if (result != ERROR_SUCCESS)
-            throw registry_parser_error("RegQueryInfoKey failed", result);
-
-        // For all subkeys
-        std::vector<Ch> subkey(max_subkey_len + 1);
-        for (DWORD index = 0; true; ++index)
-        {
-            
-            // Get subkey name
-            DWORD size = static_cast<DWORD>(subkey.size());
-            LONG result = reg_enum_key_ex(rk.handle(), index, &subkey.front(), &size);
-            if (result == ERROR_NO_MORE_ITEMS)
-                break;
-            if (result != ERROR_SUCCESS)
-                throw registry_parser_error("RegEnumKeyEx failed", result);
-            
-            // Parse recursively
-            Ptree &child = local.push_back(typename Ptree::value_type(&subkey.front(), Ptree()))->second;
-            read_registry<Ptree>(rk.handle(), &subkey.front(), child);
-
-        }
-
-        // For all values
-        for (DWORD index = 0; true; ++index)
-        {
-
-            // Resize data to max size
-            std::vector<Ch> name(max_name_len + 1);
-            std::vector<BYTE> data(max_value_len + 1);
-            
-            // Get name and value from registry
-            DWORD name_size = static_cast<DWORD>(name.size());
-            DWORD data_size = static_cast<DWORD>(data.size());
-            DWORD type;
-            result = reg_enum_value<Ch>(rk.handle(), index, &name.front(), &name_size, &type, &data.front(), &data_size);
-            if (result == ERROR_NO_MORE_ITEMS)
-                break;
-            if (result != ERROR_SUCCESS)
-                throw registry_parser_error("RegEnumValue failed", result);
-
-            // Truncate data to actual size
-            name.resize(name_size + 1);
-            data.resize(data_size);
-
-            // Translate and put value in tree
-            Str value = translate<Ch>(type, data);
-            if (name_size > 0)
-            {
-                local.put(Str(detail::widen<Ch>("\\values.") + &name.front()), value);
-                local.put(Str(detail::widen<Ch>("\\types.") + &name.front()), type);
-            }
-            else
-                local.data() = value;
-
-        }
-
-        // Swap pt and local
-        pt.swap(local);
-
-    }
-
-    //! Write registry
-    template<class Ptree>
-    void write_registry(HKEY root, 
-                        const std::basic_string<typename Ptree::char_type> &key, 
-                        const Ptree &pt)
-    {
-
-        typedef typename Ptree::char_type Ch;
-        typedef std::basic_string<Ch> Str;
-        typedef std::basic_stringstream<Ch> Stream;
-        
-        // Create key
-        reg_key<Ch> rk(root, key, true);
-
-        // Set default key value
-        if (!pt.data().empty())
-        {
-            std::vector<BYTE> data = translate<Ch>(REG_SZ, pt.data());
-            reg_set_value_ex<Ch>(rk.handle(), NULL, REG_SZ, 
-                                 data.empty() ? NULL : &data.front(), 
-                                 static_cast<DWORD>(data.size()));
-        }
-
-        // Create values
-        const Ptree &values = pt.get_child(detail::widen<Ch>("\\values"), empty_ptree<Ptree>());
-        const Ptree &types = pt.get_child(detail::widen<Ch>("\\types"), empty_ptree<Ptree>());
-        for (typename Ptree::const_iterator it = values.begin(), end = values.end(); it != end; ++it)
-        {
-            DWORD type = types.get(it->first, REG_SZ);
-            std::vector<BYTE> data = translate<Ch>(type, it->second.data());
-            reg_set_value_ex<Ch>(rk.handle(), it->first.c_str(), type, 
-                                 data.empty() ? NULL : &data.front(), 
-                                 static_cast<DWORD>(data.size()));
-        }
-
-        // Create subkeys
-        for (typename Ptree::const_iterator it = pt.begin(), end = pt.end(); it != end; ++it)
-            if (&it->second != &values && &it->second != &types)
-                write_registry(rk.handle(), it->first, it->second);
-
-    }
-
-} } }
-
-namespace boost { namespace property_tree
-{
-    using registry_parser::read_registry;
-    using registry_parser::write_registry;
-    using registry_parser::registry_parser_error;
-} }
-
-#endif

Copied: trunk/boost/property_tree/registry_parser.hpp (from rev 305, trunk/boost/property_tree/registry_parser.hpp)

Deleted: trunk/boost/property_tree/xml_parser.hpp
===================================================================
--- trunk/boost/property_tree/xml_parser.hpp	2006-10-03 08:49:51 UTC (rev 305)
+++ trunk/boost/property_tree/xml_parser.hpp	2006-10-03 09:06:13 UTC (rev 308)
@@ -1,86 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2005 Marcin Kalicinski
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_XML_PARSER_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_XML_PARSER_HPP_INCLUDED
-
-#include <boost/property_tree/ptree.hpp>
-#include <boost/property_tree/detail/xml_parser_write.hpp>
-#include <boost/property_tree/detail/xml_parser_error.hpp>
-#include <boost/property_tree/detail/xml_parser_flags.hpp>
-
-// Include proper parser
-#ifdef BOOST_PROPERTY_TREE_XML_PARSER_TINYXML
-#include <boost/property_tree/detail/xml_parser_read_tinyxml.hpp>
-#else
-#include <boost/property_tree/detail/xml_parser_read_spirit.hpp>
-#endif
-
-#include <fstream>
-#include <string>
-#include <locale>
-
-namespace boost { namespace property_tree { namespace xml_parser
-{
-
-    // Read XML from stream
-    template<class Ptree>
-    void read_xml(std::basic_istream<typename Ptree::char_type> &stream,
-                  Ptree &pt,
-                  int flags = 0)
-    {
-        read_xml_internal(stream, pt, flags, std::string());
-    }
-
-    // Read XML from file
-    template<class Ptree>
-    void read_xml(const std::string &filename,
-                  Ptree &pt,
-                  int flags = 0,
-                  const std::locale &loc = std::locale())
-    {
-        BOOST_ASSERT(validate_flags(flags));
-        std::basic_ifstream<typename Ptree::char_type> stream(filename.c_str());
-        if (!stream)
-            throw xml_parser_error("cannot open file", filename, 0);
-        stream.imbue(loc);
-        read_xml_internal(stream, pt, flags, filename);
-    }
-
-    // Write XML to stream
-    template<class Ptree>
-    void write_xml(std::basic_ostream<typename Ptree::char_type> &stream, 
-                   const Ptree &pt)
-    {
-        write_xml_internal(stream, pt, std::string());
-    }
-
-    // Write XML to file
-    template<class Ptree>
-    void write_xml(const std::string &filename,
-                   const Ptree &pt,
-                   const std::locale &loc = std::locale())
-    {
-        std::basic_ofstream<typename Ptree::char_type> stream(filename.c_str());
-        if (!stream)
-            throw xml_parser_error("cannot open file", filename, 0);
-        stream.imbue(loc);
-        write_xml_internal(stream, pt, filename);
-    }
-
-} } }
-
-namespace boost { namespace property_tree
-{
-    using xml_parser::read_xml;
-    using xml_parser::write_xml;
-    using xml_parser::xml_parser_error;
-} }
-
-#endif

Copied: trunk/boost/property_tree/xml_parser.hpp (from rev 305, trunk/boost/property_tree/xml_parser.hpp)



From pavlenko at mail.berlios.de  Tue Oct  3 12:02:16 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Tue, 3 Oct 2006 12:02:16 +0200
Subject: [Mapnik-svn] r309 - trunk/bindings/python
Message-ID: <200610031002.k93A2GbM028907@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-03 12:02:14 +0200 (Tue, 03 Oct 2006)
New Revision: 309

Modified:
   trunk/bindings/python/mapnik_python.cpp
Log:
reflect load/save map methods in python



Modified: trunk/bindings/python/mapnik_python.cpp
===================================================================
--- trunk/bindings/python/mapnik_python.cpp	2006-10-03 09:06:13 UTC (rev 308)
+++ trunk/bindings/python/mapnik_python.cpp	2006-10-03 10:02:14 UTC (rev 309)
@@ -51,6 +51,8 @@
 #include <agg_renderer.hpp>
 #include <graphics.hpp>
 #include <datasource_cache.hpp>
+#include <load_map.hpp>
+#include <save_map.hpp>
 
 void render_to_file(const mapnik::Map& map,
                     const std::string& file,
@@ -95,6 +97,8 @@
     using mapnik::datasource;
     using mapnik::coord;
     using mapnik::filter_ptr;
+    using mapnik::load_map;
+    using mapnik::save_map;
     
     export_query();
     
@@ -141,5 +145,9 @@
     
     def("render_to_file",&render_to_file);
     def("render",&render);
+    
+    def("load_map",&load_map,"load Map object from XML");
+    def("save_map",&load_map,"sace Map object to XML");
+    
     register_ptr_to_python<filter_ptr>();
 }



From pavlenko at mail.berlios.de  Tue Oct  3 12:03:33 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Tue, 3 Oct 2006 12:03:33 +0200
Subject: [Mapnik-svn] r310 - in trunk: . src
Message-ID: <200610031003.k93A3XsA028999@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-03 12:03:31 +0200 (Tue, 03 Oct 2006)
New Revision: 310

Modified:
   trunk/SConstruct
   trunk/src/SConscript
Log:
update build system to include map_{load,save}

Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2006-10-03 10:02:14 UTC (rev 309)
+++ trunk/SConstruct	2006-10-03 10:03:31 UTC (rev 310)
@@ -60,7 +60,7 @@
 
 # Libraries and headers dependency checks
 
-env['CPPPATH'] = ['#agg/include', '#include']
+env['CPPPATH'] = ['#agg/include', '#include', '#']
 
 for path in [env['BOOST_INCLUDES'], env['PNG_INCLUDES'], env['JPEG_INCLUDES'], env['TIFF_INCLUDES'], env['PGSQL_INCLUDES'], env['PROJ_INCLUDES']]:
     if path not in env['CPPPATH']: env['CPPPATH'].append(path)

Modified: trunk/src/SConscript
===================================================================
--- trunk/src/SConscript	2006-10-03 10:02:14 UTC (rev 309)
+++ trunk/src/SConscript	2006-10-03 10:03:31 UTC (rev 310)
@@ -51,6 +51,8 @@
     line_pattern_symbolizer.cpp
     text_symbolizer.cpp
     font_engine_freetype.cpp
+    load_map.cpp
+    save_map.cpp
     """
     )
 



From pavlenko at mail.berlios.de  Tue Oct  3 12:04:30 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Tue, 3 Oct 2006 12:04:30 +0200
Subject: [Mapnik-svn] r311 - trunk/src
Message-ID: <200610031004.k93A4UUN029084@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-03 12:04:28 +0200 (Tue, 03 Oct 2006)
New Revision: 311

Modified:
   trunk/src/load_map.cpp
   trunk/src/save_map.cpp
Log:
added missing header

Modified: trunk/src/load_map.cpp
===================================================================
--- trunk/src/load_map.cpp	2006-10-03 10:03:31 UTC (rev 310)
+++ trunk/src/load_map.cpp	2006-10-03 10:04:28 UTC (rev 311)
@@ -20,7 +20,6 @@
  *
  *****************************************************************************/
 
-
 #include <iostream>
 
 #include <boost/foreach.hpp>

Modified: trunk/src/save_map.cpp
===================================================================
--- trunk/src/save_map.cpp	2006-10-03 10:03:31 UTC (rev 310)
+++ trunk/src/save_map.cpp	2006-10-03 10:04:28 UTC (rev 311)
@@ -36,7 +36,7 @@
 //#include "filter_factory.hpp"
 //#include "layer.hpp"
 //#include "datasource_cache.hpp"
-//#include "save_map.hpp"
+#include "save_map.hpp"
 
 namespace mapnik 
 {



From pavlenko at mail.berlios.de  Tue Oct  3 12:06:39 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Tue, 3 Oct 2006 12:06:39 +0200
Subject: [Mapnik-svn] r312 - trunk/demo/c++
Message-ID: <200610031006.k93A6dZf029726@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-03 12:06:38 +0200 (Tue, 03 Oct 2006)
New Revision: 312

Modified:
   trunk/demo/c++/rundemo.cpp
Log:
added copyleft header

Modified: trunk/demo/c++/rundemo.cpp
===================================================================
--- trunk/demo/c++/rundemo.cpp	2006-10-03 10:04:28 UTC (rev 311)
+++ trunk/demo/c++/rundemo.cpp	2006-10-03 10:06:38 UTC (rev 312)
@@ -1,3 +1,25 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+// $Id$
 
 #include <map.hpp>
 



From pavlenko at mail.berlios.de  Wed Oct  4 13:23:30 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Wed, 4 Oct 2006 13:23:30 +0200
Subject: [Mapnik-svn] r313 - in trunk: . bindings/python
	bindings/python/mapnik demo/c++ fonts include include/mapnik
	plugins/input/postgis plugins/input/raster
	plugins/input/shape src utils/shapeindex
Message-ID: <200610041123.k94BNUju012862@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-04 13:22:18 +0200 (Wed, 04 Oct 2006)
New Revision: 313

Added:
   trunk/include/mapnik/
   trunk/include/mapnik/agg_renderer.hpp
   trunk/include/mapnik/attribute.hpp
   trunk/include/mapnik/attribute_collector.hpp
   trunk/include/mapnik/attribute_descriptor.hpp
   trunk/include/mapnik/color.hpp
   trunk/include/mapnik/color_factory.hpp
   trunk/include/mapnik/comparison.hpp
   trunk/include/mapnik/config.hpp
   trunk/include/mapnik/coord.hpp
   trunk/include/mapnik/coord_array.hpp
   trunk/include/mapnik/css_color_parser.hpp
   trunk/include/mapnik/ctrans.hpp
   trunk/include/mapnik/datasource.hpp
   trunk/include/mapnik/datasource_cache.hpp
   trunk/include/mapnik/envelope.hpp
   trunk/include/mapnik/expression.hpp
   trunk/include/mapnik/factory.hpp
   trunk/include/mapnik/feature.hpp
   trunk/include/mapnik/feature_factory.hpp
   trunk/include/mapnik/feature_layer_desc.hpp
   trunk/include/mapnik/feature_style_processor.hpp
   trunk/include/mapnik/feature_type_style.hpp
   trunk/include/mapnik/fill.hpp
   trunk/include/mapnik/filter.hpp
   trunk/include/mapnik/filter_expression.hpp
   trunk/include/mapnik/filter_factory.hpp
   trunk/include/mapnik/filter_parser.hpp
   trunk/include/mapnik/filter_parser_ast.hpp
   trunk/include/mapnik/filter_visitor.hpp
   trunk/include/mapnik/font_engine_freetype.hpp
   trunk/include/mapnik/gamma.hpp
   trunk/include/mapnik/geom_util.hpp
   trunk/include/mapnik/geometry.hpp
   trunk/include/mapnik/global.hpp
   trunk/include/mapnik/graphics.hpp
   trunk/include/mapnik/image_data.hpp
   trunk/include/mapnik/image_reader.hpp
   trunk/include/mapnik/image_util.hpp
   trunk/include/mapnik/label_collision_detector.hpp
   trunk/include/mapnik/label_placement.hpp
   trunk/include/mapnik/layer.hpp
   trunk/include/mapnik/line_pattern_symbolizer.hpp
   trunk/include/mapnik/line_symbolizer.hpp
   trunk/include/mapnik/load_map.hpp
   trunk/include/mapnik/local_datasource.hpp
   trunk/include/mapnik/logical.hpp
   trunk/include/mapnik/map.hpp
   trunk/include/mapnik/math_expr.hpp
   trunk/include/mapnik/memory.hpp
   trunk/include/mapnik/params.hpp
   trunk/include/mapnik/plugin.hpp
   trunk/include/mapnik/point_symbolizer.hpp
   trunk/include/mapnik/polygon_pattern_symbolizer.hpp
   trunk/include/mapnik/polygon_symbolizer.hpp
   trunk/include/mapnik/pool.hpp
   trunk/include/mapnik/quad_tree.hpp
   trunk/include/mapnik/query.hpp
   trunk/include/mapnik/raster.hpp
   trunk/include/mapnik/raster_symbolizer.hpp
   trunk/include/mapnik/regex_filter.hpp
   trunk/include/mapnik/rule.hpp
   trunk/include/mapnik/save_map.hpp
   trunk/include/mapnik/spatial.hpp
   trunk/include/mapnik/stroke.hpp
   trunk/include/mapnik/style.hpp
   trunk/include/mapnik/style_factory.hpp
   trunk/include/mapnik/symbolizer.hpp
   trunk/include/mapnik/text_symbolizer.hpp
   trunk/include/mapnik/utils.hpp
   trunk/include/mapnik/value.hpp
   trunk/include/mapnik/vertex.hpp
   trunk/include/mapnik/vertex_transform.hpp
   trunk/include/mapnik/vertex_vector.hpp
   trunk/include/mapnik/wkb.hpp
Removed:
   trunk/include/agg_renderer.hpp
   trunk/include/attribute.hpp
   trunk/include/attribute_collector.hpp
   trunk/include/attribute_descriptor.hpp
   trunk/include/color.hpp
   trunk/include/color_factory.hpp
   trunk/include/comparison.hpp
   trunk/include/config.hpp
   trunk/include/coord.hpp
   trunk/include/coord_array.hpp
   trunk/include/css_color_parser.hpp
   trunk/include/ctrans.hpp
   trunk/include/datasource.hpp
   trunk/include/datasource_cache.hpp
   trunk/include/envelope.hpp
   trunk/include/expression.hpp
   trunk/include/factory.hpp
   trunk/include/feature.hpp
   trunk/include/feature_factory.hpp
   trunk/include/feature_layer_desc.hpp
   trunk/include/feature_style_processor.hpp
   trunk/include/feature_type_style.hpp
   trunk/include/fill.hpp
   trunk/include/filter.hpp
   trunk/include/filter_expression.hpp
   trunk/include/filter_factory.hpp
   trunk/include/filter_parser.hpp
   trunk/include/filter_parser_ast.hpp
   trunk/include/filter_visitor.hpp
   trunk/include/font_engine_freetype.hpp
   trunk/include/gamma.hpp
   trunk/include/geom_util.hpp
   trunk/include/geometry.hpp
   trunk/include/global.hpp
   trunk/include/graphics.hpp
   trunk/include/image_data.hpp
   trunk/include/image_reader.hpp
   trunk/include/image_util.hpp
   trunk/include/label_collision_detector.hpp
   trunk/include/label_placement.hpp
   trunk/include/layer.hpp
   trunk/include/line_pattern_symbolizer.hpp
   trunk/include/line_symbolizer.hpp
   trunk/include/load_map.hpp
   trunk/include/local_datasource.hpp
   trunk/include/logical.hpp
   trunk/include/map.hpp
   trunk/include/math_expr.hpp
   trunk/include/memory.hpp
   trunk/include/params.hpp
   trunk/include/plugin.hpp
   trunk/include/point_symbolizer.hpp
   trunk/include/polygon_pattern_symbolizer.hpp
   trunk/include/polygon_symbolizer.hpp
   trunk/include/pool.hpp
   trunk/include/quad_tree.hpp
   trunk/include/query.hpp
   trunk/include/raster.hpp
   trunk/include/raster_symbolizer.hpp
   trunk/include/regex_filter.hpp
   trunk/include/rule.hpp
   trunk/include/save_map.hpp
   trunk/include/spatial.hpp
   trunk/include/stroke.hpp
   trunk/include/style.hpp
   trunk/include/style_factory.hpp
   trunk/include/symbolizer.hpp
   trunk/include/text_symbolizer.hpp
   trunk/include/utils.hpp
   trunk/include/value.hpp
   trunk/include/vertex.hpp
   trunk/include/vertex_transform.hpp
   trunk/include/vertex_vector.hpp
   trunk/include/wkb.hpp
Modified:
   trunk/SConstruct
   trunk/bindings/python/SConscript
   trunk/bindings/python/mapnik/__init__.py
   trunk/bindings/python/mapnik_color.cpp
   trunk/bindings/python/mapnik_datasource_cache.cpp
   trunk/bindings/python/mapnik_envelope.cpp
   trunk/bindings/python/mapnik_filter.cpp
   trunk/bindings/python/mapnik_font_engine.cpp
   trunk/bindings/python/mapnik_image.cpp
   trunk/bindings/python/mapnik_layer.cpp
   trunk/bindings/python/mapnik_line_pattern_symbolizer.cpp
   trunk/bindings/python/mapnik_line_symbolizer.cpp
   trunk/bindings/python/mapnik_map.cpp
   trunk/bindings/python/mapnik_parameters.cpp
   trunk/bindings/python/mapnik_point_symbolizer.cpp
   trunk/bindings/python/mapnik_polygon_pattern_symbolizer.cpp
   trunk/bindings/python/mapnik_polygon_symbolizer.cpp
   trunk/bindings/python/mapnik_python.cpp
   trunk/bindings/python/mapnik_query.cpp
   trunk/bindings/python/mapnik_raster_symbolizer.cpp
   trunk/bindings/python/mapnik_rule.cpp
   trunk/bindings/python/mapnik_stroke.cpp
   trunk/bindings/python/mapnik_style.cpp
   trunk/bindings/python/mapnik_text_symbolizer.cpp
   trunk/demo/c++/rundemo.cpp
   trunk/fonts/SConscript
   trunk/plugins/input/postgis/SConscript
   trunk/plugins/input/raster/SConscript
   trunk/plugins/input/raster/raster_datasource.cpp
   trunk/plugins/input/raster/raster_datasource.hpp
   trunk/plugins/input/raster/raster_featureset.cpp
   trunk/plugins/input/raster/raster_featureset.hpp
   trunk/plugins/input/shape/SConscript
   trunk/plugins/input/shape/dbffile.cpp
   trunk/plugins/input/shape/dbffile.hpp
   trunk/plugins/input/shape/shape.cpp
   trunk/plugins/input/shape/shape.hpp
   trunk/plugins/input/shape/shape_featureset.cpp
   trunk/plugins/input/shape/shape_featureset.hpp
   trunk/plugins/input/shape/shape_index_featureset.cpp
   trunk/plugins/input/shape/shape_index_featureset.hpp
   trunk/plugins/input/shape/shapefile.cpp
   trunk/plugins/input/shape/shapefile.hpp
   trunk/plugins/input/shape/shp_index.cpp
   trunk/plugins/input/shape/shp_index.hpp
   trunk/src/SConscript
   trunk/src/agg_renderer.cpp
   trunk/src/datasource_cache.cpp
   trunk/src/envelope.cpp
   trunk/src/filter_factory.cpp
   trunk/src/font_engine_freetype.cpp
   trunk/src/graphics.cpp
   trunk/src/image_reader.cpp
   trunk/src/image_util.cpp
   trunk/src/layer.cpp
   trunk/src/line_pattern_symbolizer.cpp
   trunk/src/load_map.cpp
   trunk/src/map.cpp
   trunk/src/memory.cpp
   trunk/src/params.cpp
   trunk/src/plugin.cpp
   trunk/src/png_reader.cpp
   trunk/src/point_symbolizer.cpp
   trunk/src/polygon_pattern_symbolizer.cpp
   trunk/src/save_map.cpp
   trunk/src/text_symbolizer.cpp
   trunk/src/tiff_reader.cpp
   trunk/src/wkb.cpp
   trunk/utils/shapeindex/SConscript
   trunk/utils/shapeindex/quadtree.hpp
   trunk/utils/shapeindex/shapeindex.cpp
Log:
1. move include to mapnik/include
2. update demos,bibdibgs etc.



Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/SConstruct	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,37 +22,34 @@
 
 import os, sys, platform
 
-
-
 if platform.uname()[4] == 'x86_64':
-    LIB_PLATFORM = 'lib64'
-else :
-    LIB_PLATFORM = 'lib'
+    LIBDIR_SCHEMA='lib64' 
+else:
+    LIBDIR_SCHEMA='lib'
 
-    
 opts = Options()
-
 opts.Add('PREFIX', 'The install path "prefix"', '/usr/local')
 opts.Add(PathOption('BOOST_INCLUDES', 'Search path for boost include files', '/usr/include'))
-opts.Add(PathOption('BOOST_LIBS', 'Search path for boost library files', '/usr/' + LIB_PLATFORM))
+opts.Add(PathOption('BOOST_LIBS', 'Search path for boost library files', '/usr/' + LIBDIR_SCHEMA))
 opts.Add(PathOption('FREETYPE_CONFIG', 'The path to the freetype-config executable.', '/usr/bin/freetype-config'))
 opts.Add(PathOption('PNG_INCLUDES', 'Search path for libpng include files', '/usr/include'))
-opts.Add(PathOption('PNG_LIBS', 'Search path for libpng include files', '/usr/' + LIB_PLATFORM))
+opts.Add(PathOption('PNG_LIBS','Search path for libpng include files','/usr/' + LIBDIR_SCHEMA))
 opts.Add(PathOption('JPEG_INCLUDES', 'Search path for libjpeg include files', '/usr/include'))
-opts.Add(PathOption('JPEG_LIBS', 'Search path for libjpeg library files', '/usr/' + LIB_PLATFORM))
+opts.Add(PathOption('JPEG_LIBS', 'Search path for libjpeg library files', '/usr/' + LIBDIR_SCHEMA))
 opts.Add(PathOption('TIFF_INCLUDES', 'Search path for libtiff include files', '/usr/include'))
-opts.Add(PathOption('TIFF_LIBS', 'Search path for libtiff library files', '/usr/' + LIB_PLATFORM))
+opts.Add(PathOption('TIFF_LIBS', 'Search path for libtiff library files', '/usr/' + LIBDIR_SCHEMA))
 opts.Add(PathOption('PGSQL_INCLUDES', 'Search path for PostgreSQL include files', '/usr/include'))
-opts.Add(PathOption('PGSQL_LIBS', 'Search path for PostgreSQL library files', '/usr/' + LIB_PLATFORM))
+opts.Add(PathOption('PGSQL_LIBS', 'Search path for PostgreSQL library files', '/usr/' + LIBDIR_SCHEMA))
 opts.Add(PathOption('PROJ_INCLUDES', 'Search path for PROJ.4 include files', '/usr/local/include'))
-opts.Add(PathOption('PROJ_LIBS', 'Search path for PROJ.4 include files', '/usr/local/' + LIB_PLATFORM))
+opts.Add(PathOption('PROJ_LIBS', 'Search path for PROJ.4 include files', '/usr/local/' + LIBDIR_SCHEMA))
 opts.Add(PathOption('PYTHON','Python executable', sys.executable))
 opts.Add(ListOption('INPUT_PLUGINS','Input drivers to include','all',['postgis','shape','raster']))
 opts.Add(ListOption('BINDINGS','Language bindings to build','all',['python']))
+
 opts.Add('DEBUG', 'Compile a debug version of mapnik', '')
 
 env = Environment(ENV=os.environ, options=opts)
-env['LIB_PLATFORM'] = LIB_PLATFORM
+env['LIBDIR_SCHEMA'] = LIBDIR_SCHEMA
 
 Help(opts.GenerateHelpText(env))
 

Modified: trunk/bindings/python/SConscript
===================================================================
--- trunk/bindings/python/SConscript	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/SConscript	2006-10-04 11:22:18 UTC (rev 313)
@@ -23,7 +23,7 @@
 
 Import('env')
 
-prefix = env['PYTHON_PREFIX'] + '/'+env['LIB_PLATFORM']+ '/python' + env['PYTHON_VERSION'] + '/site-packages/'
+prefix = env['PYTHON_PREFIX'] + '/'+ 'lib' + '/python' + env['PYTHON_VERSION'] + '/site-packages/'
 
 libraries = ['mapnik', 'boost_python%s' % env['BOOST_APPEND']]
 headers = [env['PYTHON_PREFIX'] + '/include/python' + env['PYTHON_VERSION']] + env['CPPPATH']
@@ -36,7 +36,7 @@
 fontscollectionpath = mapniklibpath + '/fonts'
 """
 
-file('mapnik/paths.py','w').write(paths % (env['PREFIX'] + '/'+env['LIB_PLATFORM']+'/mapnik',))
+file('mapnik/paths.py','w').write(paths % (env['PREFIX'] + '/'+env['LIBDIR_SCHEMA']+'/mapnik',))
 
 pymapnik = glob.glob('mapnik/*.py')
 env.Alias(target='install', source=env.Install(prefix+'/mapnik', pymapnik))

Modified: trunk/bindings/python/mapnik/__init__.py
===================================================================
--- trunk/bindings/python/mapnik/__init__.py	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik/__init__.py	2006-10-04 11:22:18 UTC (rev 313)
@@ -59,10 +59,10 @@
         return 'Envelope(%s,%s,%s,%s)' % \
                (self.minx,self.miny,self.maxx,self.maxy)
 
-def Layer (**keywords):
-    return CreateLayer(keywords)
-    
-    
+def Datasource (**keywords):
+    return CreateDatasource(keywords)
+
+
 #register datasources
 from mapnik import DatasourceCache
 DatasourceCache.instance().register_datasources('%s' % inputpluginspath)

Modified: trunk/bindings/python/mapnik_color.cpp
===================================================================
--- trunk/bindings/python/mapnik_color.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_color.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -23,8 +23,8 @@
 
 
 #include <boost/python.hpp>
-#include <color.hpp>
-#include <color_factory.hpp>
+#include <mapnik/color.hpp>
+#include <mapnik/color_factory.hpp>
 
 using mapnik::Color;
 using mapnik::color_factory;

Modified: trunk/bindings/python/mapnik_datasource_cache.cpp
===================================================================
--- trunk/bindings/python/mapnik_datasource_cache.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_datasource_cache.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -23,7 +23,7 @@
 //$Id$
 
 #include <boost/python.hpp>
-#include "datasource_cache.hpp"
+#include <mapnik/datasource_cache.hpp>
 
 void export_datasource_cache()
 {

Modified: trunk/bindings/python/mapnik_envelope.cpp
===================================================================
--- trunk/bindings/python/mapnik_envelope.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_envelope.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,7 +22,7 @@
 //$Id: mapnik_envelope.cc 27 2005-03-30 21:45:40Z pavlenko $
 
 #include <boost/python.hpp>
-#include <envelope.hpp>
+#include <mapnik/envelope.hpp>
 
 using mapnik::coord;
 using mapnik::Envelope;

Modified: trunk/bindings/python/mapnik_filter.cpp
===================================================================
--- trunk/bindings/python/mapnik_filter.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_filter.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,13 +22,14 @@
 //$Id$
 
 #include <boost/python.hpp>
-#include <spatial.hpp>
-#include <logical.hpp>
-#include <comparison.hpp>
-#include <regex_filter.hpp>
-#include <filter.hpp>
-#include <filter_factory.hpp>
 
+#include <mapnik/spatial.hpp>
+#include <mapnik/logical.hpp>
+#include <mapnik/comparison.hpp>
+#include <mapnik/regex_filter.hpp>
+#include <mapnik/filter.hpp>
+#include <mapnik/filter_factory.hpp>
+
 using mapnik::filter;
 using mapnik::filter_ptr;
 using mapnik::filter_factory;

Modified: trunk/bindings/python/mapnik_font_engine.cpp
===================================================================
--- trunk/bindings/python/mapnik_font_engine.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_font_engine.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,7 +22,7 @@
 //$Id$
 
 #include <boost/python.hpp>
-#include <font_engine_freetype.hpp>
+#include <mapnik/font_engine_freetype.hpp>
 
 void export_font_engine()
 {

Modified: trunk/bindings/python/mapnik_image.cpp
===================================================================
--- trunk/bindings/python/mapnik_image.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_image.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -24,14 +24,11 @@
 #include <boost/python.hpp>
 #include <boost/python/module.hpp>
 #include <boost/python/def.hpp>
-#include <graphics.hpp>
+#include <mapnik/graphics.hpp>
 
 using mapnik::Image32;
-
-
 using namespace boost::python;
 
-
 PyObject* rawdata( Image32 const& im)
 {
     int size = im.width() * im.height() * 4;

Modified: trunk/bindings/python/mapnik_layer.cpp
===================================================================
--- trunk/bindings/python/mapnik_layer.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_layer.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -25,7 +25,7 @@
 #include <boost/python.hpp>
 #include <boost/python/detail/api_placeholder.hpp>
 #include <boost/python/suite/indexing/vector_indexing_suite.hpp>
-#include <layer.hpp>
+#include <mapnik/layer.hpp>
 
 using mapnik::Layer;
 using mapnik::parameters;

Modified: trunk/bindings/python/mapnik_line_pattern_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_line_pattern_symbolizer.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_line_pattern_symbolizer.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,7 +22,7 @@
 //$Id$
 
 #include <boost/python.hpp>
-#include <line_pattern_symbolizer.hpp>
+#include <mapnik/line_pattern_symbolizer.hpp>
 
 using mapnik::line_pattern_symbolizer;
 

Modified: trunk/bindings/python/mapnik_line_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_line_symbolizer.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_line_symbolizer.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,7 +22,7 @@
 //$Id$
 
 #include <boost/python.hpp>
-#include <line_symbolizer.hpp>
+#include <mapnik/line_symbolizer.hpp>
 
 using mapnik::line_symbolizer;
 using mapnik::stroke;

Modified: trunk/bindings/python/mapnik_map.cpp
===================================================================
--- trunk/bindings/python/mapnik_map.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_map.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -26,8 +26,8 @@
 #include <boost/python/detail/api_placeholder.hpp>
 #include <boost/python/suite/indexing/vector_indexing_suite.hpp>
 
-#include <layer.hpp>
-#include <map.hpp>
+#include <mapnik/layer.hpp>
+#include <mapnik/map.hpp>
 
 using mapnik::Color;
 using mapnik::coord;

Modified: trunk/bindings/python/mapnik_parameters.cpp
===================================================================
--- trunk/bindings/python/mapnik_parameters.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_parameters.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -23,7 +23,7 @@
 
 #include <boost/python.hpp>
 #include <boost/python/detail/api_placeholder.hpp>
-#include <params.hpp>
+#include <mapnik/params.hpp>
 
 using mapnik::parameter;
 using mapnik::parameters;

Modified: trunk/bindings/python/mapnik_point_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_point_symbolizer.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_point_symbolizer.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,7 +22,7 @@
 //$Id$
 
 #include <boost/python.hpp>
-#include <point_symbolizer.hpp>
+#include <mapnik/point_symbolizer.hpp>
 
 void export_point_symbolizer()
 {

Modified: trunk/bindings/python/mapnik_polygon_pattern_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_polygon_pattern_symbolizer.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_polygon_pattern_symbolizer.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,7 +22,7 @@
 //$Id$
 
 #include <boost/python.hpp>
-#include <polygon_pattern_symbolizer.hpp>
+#include <mapnik/polygon_pattern_symbolizer.hpp>
 
 void export_polygon_pattern_symbolizer()
 {

Modified: trunk/bindings/python/mapnik_polygon_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_polygon_symbolizer.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_polygon_symbolizer.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,7 +22,7 @@
 //$Id$
 
 #include <boost/python.hpp>
-#include <polygon_symbolizer.hpp>
+#include <mapnik/polygon_symbolizer.hpp>
 
 void export_polygon_symbolizer()
 {

Modified: trunk/bindings/python/mapnik_python.cpp
===================================================================
--- trunk/bindings/python/mapnik_python.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_python.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -47,12 +47,12 @@
 void export_text_symbolizer();
 void export_font_engine();
 
-#include <map.hpp>
-#include <agg_renderer.hpp>
-#include <graphics.hpp>
-#include <datasource_cache.hpp>
-#include <load_map.hpp>
-#include <save_map.hpp>
+#include <mapnik/map.hpp>
+#include <mapnik/agg_renderer.hpp>
+#include <mapnik/graphics.hpp>
+#include <mapnik/datasource_cache.hpp>
+#include <mapnik/load_map.hpp>
+#include <mapnik/save_map.hpp>
 
 void render_to_file(const mapnik::Map& map,
                     const std::string& file,

Modified: trunk/bindings/python/mapnik_query.cpp
===================================================================
--- trunk/bindings/python/mapnik_query.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_query.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,7 +22,7 @@
 //$Id$
 
 #include <boost/python.hpp>
-#include <query.hpp>
+#include <mapnik/query.hpp>
 
 void export_query()
 {

Modified: trunk/bindings/python/mapnik_raster_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_raster_symbolizer.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_raster_symbolizer.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,7 +22,7 @@
 //$Id$
 
 #include <boost/python.hpp>
-#include <raster_symbolizer.hpp>
+#include <mapnik/raster_symbolizer.hpp>
 
 void export_raster_symbolizer()
 {

Modified: trunk/bindings/python/mapnik_rule.cpp
===================================================================
--- trunk/bindings/python/mapnik_rule.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_rule.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -21,12 +21,11 @@
  *****************************************************************************/
 //$Id$
 
-
 #include <boost/python.hpp>
 #include <boost/python/implicit.hpp>
 #include <boost/python/suite/indexing/vector_indexing_suite.hpp>
-#include <rule.hpp>
 
+#include <mapnik/rule.hpp>
 
 void export_rule()
 {
@@ -45,8 +44,8 @@
     using mapnik::text_symbolizer;
     using mapnik::symbolizer;
     using mapnik::symbolizers;
-
     
+    
     implicitly_convertible<point_symbolizer,symbolizer>();
     implicitly_convertible<line_symbolizer,symbolizer>();
     implicitly_convertible<line_pattern_symbolizer,symbolizer>();

Modified: trunk/bindings/python/mapnik_stroke.cpp
===================================================================
--- trunk/bindings/python/mapnik_stroke.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_stroke.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,8 +22,9 @@
 //$Id$
 
 #include <boost/python.hpp>
-#include <stroke.hpp>
 
+#include <mapnik/stroke.hpp>
+
 void export_stroke ()
 {
     using namespace mapnik;

Modified: trunk/bindings/python/mapnik_style.cpp
===================================================================
--- trunk/bindings/python/mapnik_style.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_style.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -23,8 +23,9 @@
 
 #include <boost/python.hpp>
 #include <boost/python/suite/indexing/vector_indexing_suite.hpp>
-#include <feature_type_style.hpp>
 
+#include <mapnik/feature_type_style.hpp>
+
 void export_style()
 {
     using namespace boost::python;

Modified: trunk/bindings/python/mapnik_text_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_text_symbolizer.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_text_symbolizer.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,8 +22,9 @@
 //$Id$
 
 #include <boost/python.hpp>
-#include <text_symbolizer.hpp>
 
+#include <mapnik/text_symbolizer.hpp>
+
 void export_text_symbolizer()
 {
     using namespace boost::python;

Modified: trunk/demo/c++/rundemo.cpp
===================================================================
--- trunk/demo/c++/rundemo.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/demo/c++/rundemo.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -21,15 +21,14 @@
  *****************************************************************************/
 // $Id$
 
-#include <map.hpp>
+#include <mapnik/map.hpp>
+#include <mapnik/datasource_cache.hpp>
+#include <mapnik/font_engine_freetype.hpp>
+#include <mapnik/agg_renderer.hpp>
+#include <mapnik/filter_factory.hpp>
+#include <mapnik/color_factory.hpp>
+#include <mapnik/image_util.hpp>
 
-#include <datasource_cache.hpp>
-#include <font_engine_freetype.hpp>
-#include <agg_renderer.hpp>
-#include <filter_factory.hpp>
-#include <color_factory.hpp>
-#include <image_util.hpp>
-
 #include <iostream>
 
 using namespace mapnik;
@@ -231,7 +230,8 @@
         m.addLayer(lyr);
     }
     
-    m.zoomToBox(Envelope<double>(1405120.04127408,-247003.813399447,1706357.31328276,-25098.593149577));
+    m.zoomToBox(Envelope<double>(1405120.04127408,-247003.813399447,
+                                 1706357.31328276,-25098.593149577));
     
     Image32 buf(m.getWidth(),m.getHeight());
     agg_renderer<Image32> ren(m,buf);

Modified: trunk/fonts/SConscript
===================================================================
--- trunk/fonts/SConscript	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/fonts/SConscript	2006-10-04 11:22:18 UTC (rev 313)
@@ -24,4 +24,4 @@
 prefix = env['PREFIX']
 
 includes = glob.glob('*/*.ttf')
-env.Alias(target='install', source=env.Install(prefix+'/' + env['LIB_PLATFORM'] + '/mapnik/fonts', includes))
+env.Alias(target='install', source=env.Install(prefix+'/' + env['LIBDIR_SCHEMA'] + '/mapnik/fonts', includes))

Deleted: trunk/include/agg_renderer.hpp
===================================================================
--- trunk/include/agg_renderer.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/agg_renderer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,60 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef AGG_RENDERER_HPP
-#define AGG_RENDERER_HPP
-
-#include "feature_style_processor.hpp"
-#include <boost/utility.hpp>
-#include "font_engine_freetype.hpp"
-#include "label_collision_detector.hpp"
-
-namespace mapnik
-{
-    template <typename T>
-    class MAPNIK_DECL agg_renderer : public feature_style_processor<agg_renderer<T> >,
-                                     private boost::noncopyable
-    {
-    public:
-        agg_renderer(Map const& m, T & pixmap);
-        void start_map_processing(Map const& map);
-        void end_map_processing(Map const& map);
-        void start_layer_processing(Layer const& lay);
-        void end_layer_processing(Layer const& lay);
-        void process(point_symbolizer const& sym,Feature const& feature);
-        void process(line_symbolizer const& sym,Feature const& feature);
-        void process(line_pattern_symbolizer const& sym,Feature const& feature);
-        void process(polygon_symbolizer const& sym,Feature const& feature);
-        void process(polygon_pattern_symbolizer const& sym,Feature const& feature);
-        void process(raster_symbolizer const& sym,Feature const& feature);
-        void process(text_symbolizer const& sym,Feature const& feature);
-    private:
-        T & pixmap_;
-        CoordTransform t_;
-        face_manager<freetype_engine> font_manager_;
-        label_collision_detector2 detector_;
-    };
-}
-
-#endif //AGG_RENDERER_HPP

Deleted: trunk/include/attribute.hpp
===================================================================
--- trunk/include/attribute.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/attribute.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,222 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: attribute.hpp 41 2005-04-13 20:21:56Z pavlenko $
-
-#ifndef ATTRIBUTE_HPP
-#define ATTRIBUTE_HPP
-
-#include <typeinfo>
-#include <sstream>
-#include <map>
-#include <boost/any.hpp>
-
-
-namespace mapnik
-{
-    template <typename T>
-    struct attribute_traits
-    {
-	static std::string to_string(const T& value)
-	{
-	    std::stringstream ss;
-	    ss << value;
-	    return ss.str();
-	}
-    };
-
-    template <>
-    struct attribute_traits<std::string>
-    {
-	static std::string to_string(const std::string& value)
-	{
-	    return value;
-	}
-    };
-    
-    class MAPNIK_DECL attribute
-    {	
-    public:
-	attribute()
-	    : base_(0) {}
-
-	template <typename T>
-	attribute(const T& value)
-	    : base_(new attribute_impl<T>(value)) 
-	{}
-
-	attribute(const attribute& rhs)
-	    : base_(rhs.base_ ? rhs.base_->clone() : 0)
-	{}
-
-	~attribute() 
-	{
-	    delete base_;
-	}
-
-	template<typename T>
-	attribute& operator=(const T& rhs)
-	{
-	    attribute(rhs).swap(*this);
-	    return *this;
-	}
-
-	attribute& operator=(const attribute& rhs)
-	{
-	    attribute(rhs).swap(*this);
-	    return *this;
-	}
-
-	bool empty() const
-	{
-	    return !base_;
-	}
-
-	const std::type_info & type() const
-        {
-            return base_ ? base_->type() : typeid(void);
-        }
-
-	const std::string to_string() const
-	{
-	    return base_ ? base_->to_string() : "";
-	}
-    private:
-	attribute& swap(attribute& rhs)
-	{
-	    std::swap(base_,rhs.base_);
-	    return *this;
-	}
-	
-	class attribute_base
-	{
-	public:
-	    virtual ~attribute_base() {}
-	    virtual attribute_base* clone() const=0;
-	    virtual std::string to_string() const=0;
-	    virtual const std::type_info& type()  const=0;
-	};
-
-	template <typename T,typename ATraits=attribute_traits<T> >
-	class attribute_impl : public attribute_base
-	{	    
-	public:
-	    typedef T value_type;
-	    attribute_impl(const value_type& value)
-		: value_(value) {}
-	    
-	    virtual std::string to_string() const
-	    {
-		return  ATraits::to_string(value_);
-	    }
-	    
-	    virtual attribute_base* clone() const
-	    {
-		return new attribute_impl(value_);
-	    }
-	    virtual const std::type_info& type() const 
-	    {
-		return typeid(value_);
-	    }
-	    value_type value_;
-	};
-    private:
-	template<typename value_type>
-	friend value_type* attribute_cast(attribute*);
-	attribute_base* base_;
-    };
-    
-    
-    template<typename T>
-    struct bad_attribute_cast : public std::bad_cast
-    {
-	virtual const char* what() const throw()
-	{
-	    return "attribute::failed conversion";
-	}
-    };
-    
-    template <typename T> 
-    bool is_type(const attribute& attr)
-    {
-	return attr.type()==typeid(T);
-    }
-    
-    template <typename T>
-    T* attribute_cast(attribute* attr)
-    {
-	return attr && attr->type() == typeid(T)
-	    ? &static_cast<attribute::attribute_impl<T>*>(attr->base_)->value_
-	    : 0;
-    }
-
-    template <typename T>
-    const T* attribute_cast(const attribute* attr)
-    {
-	return attribute_cast<T>(const_cast<attribute*>(attr));
-    }
-    
-    template <typename T>
-    T attribute_cast(const attribute& attr)
-    {
-	using namespace boost;
-	typedef BOOST_DEDUCED_TYPENAME remove_reference<T>::type nonref;
-	const nonref * result=attribute_cast<nonref>(&attr);
-	if (!result)
-	{
-	    throw bad_attribute_cast<T>();
-	}
-	return *result;
-    }
-    
-    template <typename T>
-    T attribute_cast(attribute& attr)
-    {
-	using namespace boost;
-	typedef BOOST_DEDUCED_TYPENAME remove_reference<T>::type nonref;
-	nonref * result=attribute_cast<nonref>(&attr);
-	if (!result)
-	    throw bad_attribute_cast<T>();
-	return *result;
-    }
-    
-       
-    template <typename T>
-    attribute attribute_from_string(const std::string& val)
-    {
-	std::istringstream is(val);
-	T t;
-	is >> t;
-	return attribute(t);
-    }
-
-    template <typename charT, typename traits>
-    inline std::basic_ostream<charT,traits>& 
-    operator << (std::basic_ostream<charT,traits>& out,
-		 const attribute& attr)
-    {
-	out << attr.to_string();
-	return out; 
-    }
-}
-
-#endif                                            //ATTRIBUTE_HPP

Deleted: trunk/include/attribute_collector.hpp
===================================================================
--- trunk/include/attribute_collector.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/attribute_collector.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,98 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef ATTRIBUTE_COLLECTOR_HPP
-#define ATTRIBUTE_COLLECTOR_HPP
-
-#include "filter.hpp"
-#include "expression.hpp"
-#include "feature_layer_desc.hpp"
-#include "rule.hpp"
-#include <set>
-#include <iostream>
-
-namespace mapnik
-{
-    
-    struct symbolizer_attributes : public boost::static_visitor<>
-    {
-	symbolizer_attributes(std::set<std::string>& names)
-	    : names_(names) {}
-	
-	template <typename T>
-	void operator () (T const&) const {}
-	void operator () (text_symbolizer const& sym)
-	{
-	    names_.insert(sym.get_name());
-	}
-    private:
-	std::set<std::string>& names_;
-    };
-
-    template <typename FeatureT>
-    class attribute_collector : public filter_visitor<FeatureT>
-    {
-    private:
-	std::set<std::string>& names_;
-    public:
-	
-	attribute_collector(std::set<std::string>& names)
-	    : names_(names) {}
-	
-	void visit(filter<FeatureT>& /*filter*/) 
-	{ 
-	    //not interested
-	}
-	
-	void visit(expression<FeatureT>& exp)
-	{
-	    property<FeatureT>* pf;
-	    if ((pf = dynamic_cast<property<FeatureT>*>(&exp)))
-	    {
-		names_.insert(pf->name());
-	    }
-	}
-	void visit(rule_type const& r)
-	{	    
-	    const symbolizers& symbols = r.get_symbolizers();
-	    symbolizers::const_iterator symIter=symbols.begin();
-	    symbolizer_attributes attr(names_);
-	    while (symIter != symbols.end())
-	    {
-		boost::apply_visitor(attr,*symIter++);
-	    }
-	    filter_ptr const& filter = r.get_filter();
-	    filter->accept(*this);
-	}
-
-	virtual ~attribute_collector() {}
-    private:
-	
-	// no copying 
-	attribute_collector(attribute_collector const&);
-	attribute_collector& operator=(attribute_collector const&);
-    };   
-}
-
-#endif //ATTRIBUTE_COLLECTOR_HPP

Deleted: trunk/include/attribute_descriptor.hpp
===================================================================
--- trunk/include/attribute_descriptor.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/attribute_descriptor.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,39 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef ATTRIBUTE_DESCRIPTOR
-#define ATTRIBUTE_DESCRIPTOR
-
-#include <string>
-
-namespace mapnik
-{
-    struct attribute_desc
-    {
-	std::string name;
-	eType type;
-    };
-}
-
-#endif

Deleted: trunk/include/color.hpp
===================================================================
--- trunk/include/color.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/color.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,127 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: color.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef COLOR_HPP
-#define COLOR_HPP
-
-#include <boost/format.hpp>
-#include "config.hpp"
-#include <sstream>
-
-namespace mapnik {
-
-    class MAPNIK_DECL Color
-    {
-    private:
-        unsigned int abgr_;
-    public:
-        Color()
-            :abgr_(0xffffffff) {}
-
-        Color(int red,int green,int blue,int alpha=0xff)
-            : abgr_((alpha&0xff) << 24 | 
-                    (blue&0xff) << 16  | 
-                    (green&0xff) << 8  | 
-                    red&0xff) {}
-        
-        explicit Color(int rgba)
-            : abgr_(rgba) {}
-
-        Color(const Color& rhs)
-            : abgr_(rhs.abgr_) {}
-
-        Color& operator=(const Color& rhs)
-        {
-            if (this==&rhs) return *this;
-            abgr_=rhs.abgr_;
-            return *this;
-        }
-        inline unsigned int red() const
-        {
-            return abgr_&0xff;
-        }
-        inline unsigned int green() const
-        {
-            return (abgr_>>8)&0xff;
-        }
-        inline unsigned int blue() const
-        {
-            return (abgr_>>16)&0xff;
-        }
-        inline unsigned int alpha() const
-        {
-            return (abgr_>>24)&0xff;
-        }
-	
-        inline void set_red(unsigned int r)
-        {
-            abgr_ = (abgr_ & 0xffffff00) | (r&0xff);
-        }
-        inline void set_green(unsigned int g)
-        {
-            abgr_ = (abgr_ & 0xffff00ff) | ((g&0xff) << 8);
-        }
-        inline void set_blue(unsigned int b)
-        {
-            abgr_ = (abgr_ & 0xff00ffff) | ((b&0xff) << 16);
-        }
-        inline void set_alpha(unsigned int a)
-        {
-            abgr_ = (abgr_ & 0x00ffffff | (a&0xff) << 24);
-        }
-
-        inline unsigned int rgba() const
-        {
-            return abgr_;
-        }
-        inline void set_bgr(unsigned bgr)
-        {
-            abgr_ = (abgr_ & 0xff000000) | (bgr & 0xffffff);
-        }
-        inline bool operator==(Color const& other) const
-        {
-            return abgr_ == other.abgr_;
-        }
-        
-        inline std::string to_string() const
-        {
-            std::stringstream ss;
-            ss << "rgb (" 
-               << red()   << ","  
-               << green() << ","  
-               << blue()  << ","
-               << alpha() << ")";
-            return ss.str();
-        }
-        
-        inline std::string to_hex_string() const
-        {
-            std::stringstream ss;
-            ss << boost::format("#%1$02x%2$02x%3$02x") % red() % green() % blue();
-            return ss.str();
-        }
-    };    
-}
-
-#endif //COLOR_HPP

Deleted: trunk/include/color_factory.hpp
===================================================================
--- trunk/include/color_factory.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/color_factory.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,53 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef COLOR_FACTORY_HPP
-#define COLOR_FACTORY_HPP
-
-#include "config.hpp"
-#include "css_color_parser.hpp"
-
-namespace mapnik
-{
-    using namespace boost::spirit;
-    class MAPNIK_DECL color_factory
-    {
-    public:
-        static Color from_string(char const* css_color)
-        {   
-            Color color;
-            actions<Color> a(color);
-            css_color_grammar<actions<Color> > grammar(a);
-            parse_info<> info = parse(css_color, grammar, space_p);
-            if (info.full) return color;
-            return Color(0,0,0);	
-        }    
-    private:
-        color_factory();
-        color_factory(color_factory const&);
-        color_factory& operator=(color_factory const&);
-    };
-}
-
-#endif //COLOR_FACTORY_HPP

Deleted: trunk/include/comparison.hpp
===================================================================
--- trunk/include/comparison.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/comparison.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,153 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id$
-
-#ifndef COMPARISON_HPP
-#define COMPARISON_HPP
-
-
-#include "filter.hpp"
-#include "expression.hpp"
-#include "attribute.hpp"
-
-#include <iostream>
-
-namespace mapnik
-{   
-    template <typename T>  
-    struct greater_than
-    {
-	bool operator() (T const& left, T const& right) const
-	{
-	    return left > right;
-	}
-	static std::string to_string()
-	{
-	    return ">";
-	}
-    };
-
-    template <typename T>  
-    struct greater_than_or_equal
-    {
-	bool operator() (T const& left, T const& right) const
-	{
-	    return left >= right;
-	}
-	static std::string to_string()
-	{
-	    return ">=";
-	}
-    };
-    template <typename T>  
-    struct less_than
-    {
-	bool operator() (T const& left, T const& right) const
-	{
-	    return left < right;
-	}
-	static std::string to_string()
-	{
-	    return "<";
-	}
-    };
-    template <typename T>  
-    struct less_than_or_equal
-    {
-	bool operator() (T const& left, T const& right) const
-	{
-	    return left <= right;
-	}
-	static std::string to_string()
-	{
-	    return "<=";
-	}
-    };
-    template <typename T>  
-    struct equals
-    {
-	bool operator() (T const& left, T const& right) const
-	{
-	    return left == right;
-	}
-	static std::string to_string()
-	{
-	    return "=";
-	}
-    };
-    
-    template <typename T>  
-    struct not_equals
-    {
-	bool operator() (T const& left, T const& right) const
-	{
-	    return left != right;
-	}
-	static std::string to_string()
-	{
-	    return "<>";
-	}
-    };
-    
-    template <typename FeatureT,typename Op>
-    struct compare_filter : public filter<FeatureT>
-    {
-	compare_filter(expression<FeatureT> const& left,
-		       expression<FeatureT> const& right)
-	    : filter<FeatureT>(),
-	      left_(left.clone()), right_(right.clone()) {}
-
-	compare_filter(compare_filter const& other)
-	    : filter<FeatureT>(),
-	      left_(other.left_->clone()),right_(other.right_->clone()) {}
-	
-	bool pass(const FeatureT& feature) const
-	{   
-	    return Op()(left_->get_value(feature),right_->get_value(feature));     
-	}
-	void accept(filter_visitor<FeatureT>& v)
-	{
-	    left_->accept(v);
-	    right_->accept(v);
-	    v.visit(*this);
-	}
-	std::string to_string() const
-	{
-	    return "("+left_->to_string()+Op::to_string()+right_->to_string()+")";
-	}
-
-	filter<FeatureT>* clone() const
-	{
-	    return new compare_filter<FeatureT,Op>(*this);
-	}
-	virtual ~compare_filter() 
-	{
-	    delete left_;
-	    delete right_;
-	}
-    private:
-	expression<FeatureT>* left_;
-	expression<FeatureT>* right_;
-    };
-}
-
-#endif //COMPARISON_HPP

Deleted: trunk/include/config.hpp
===================================================================
--- trunk/include/config.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/config.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,39 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-#ifndef CONFIG_HPP
-#define CONFIG_HPP
-
-// Window DLL support
-
-#ifdef _WINDOWS
-# define MAPNIK_DECL __declspec (dllexport)
-# pragma warning( disable: 4251 )
-# pragma warning( disable: 4275 )
-# if (_MSC_VER >= 1400) // vc8
-#   pragma warning(disable : 4996) //_CRT_SECURE_NO_DEPRECATE
-# endif
-#else
-# define MAPNIK_DECL 
-#endif
-
-#endif

Deleted: trunk/include/coord.hpp
===================================================================
--- trunk/include/coord.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/coord.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,138 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: coord.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef COORD_HPP
-#define COORD_HPP
-
-#include <iostream>
-#include <iomanip>
-#include <sstream>
-
-namespace mapnik 
-{   
-    template <typename T,int dim>
-    struct coord {
-        typedef T type;
-    };
-    
-    template <typename T>
-    struct coord<T,2> 
-    {
-        typedef T type;
-        T x;
-        T y;
-    public:
-        coord()
-            : x(),y() {}
-        coord(T x,T y)
-            : x(x),y(y) {}
-        template <typename T2>
-        coord (const coord<T2,2>& rhs)
-            : x(type(rhs.x)),
-              y(type(rhs.y)) {}
-
-        template <typename T2>
-        coord<T,2>& operator=(const coord<T2,2>& rhs)
-        {
-            if ((void*)this==(void*)&rhs)
-            {
-                return *this;
-            }
-            x=type(rhs.x);
-            y=type(rhs.y);
-            return *this;
-        }
-    };
-
-    template <typename T>
-    struct coord<T,3> 
-    {
-        typedef T type;
-        T x;
-        T y;
-        T z;
-    public:
-        coord()
-            : x(),y(),z() {}
-        coord(T x,T y,T z)
-            : x(x),y(y),z(z) {}
-        template <typename T2>
-        coord (const coord<T2,3>& rhs)
-            : x(type(rhs.x)),
-              y(type(rhs.y)),
-              z(type(rhs.z)) {}
-
-        template <typename T2>
-        coord<T,3>& operator=(const coord<T2,3>& rhs)
-        {
-            if ((void*)this==(void*)&rhs)
-            {
-                return *this;
-            }
-            x=type(rhs.x);
-            y=type(rhs.y);
-            z=type(rhs.z);
-            return *this;
-        }
-    };
-
-    typedef coord<double,2> coord2d;
-    typedef coord<int,2> coord2i;
-
-     
-    template <typename charT,typename traits,typename T ,int dim>
-    inline std::basic_ostream<charT,traits>&
-    operator << (std::basic_ostream<charT,traits>& out,
-                 const coord<T,dim>& c);
-    
-    template <typename charT,typename traits,typename T>
-    inline std::basic_ostream<charT,traits>&
-    operator << (std::basic_ostream<charT,traits>& out,
-                 const coord<T,2>& c)
-    {
-        std::basic_ostringstream<charT,traits> s;
-        s.copyfmt(out);
-        s.width(0);
-        s << "coord2(" << std::setprecision(16) 
-          << c.x << "," << c.y<< ")";
-        out << s.str();
-        return out;
-    }
-
-    template <typename charT,typename traits,typename T>
-    inline std::basic_ostream<charT,traits>&
-    operator << (std::basic_ostream<charT,traits>& out,
-                 const coord<T,3>& c)
-    {
-        std::basic_ostringstream<charT,traits> s;
-        s.copyfmt(out);
-        s.width(0);
-        s << "coord3(" << std::setprecision(16) 
-          << c.x << "," << c.y<< "," << c.z<<")";
-        out << s.str();
-        return out;
-    } 
-}
-
-#endif // COORD_HPP

Deleted: trunk/include/coord_array.hpp
===================================================================
--- trunk/include/coord_array.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/coord_array.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,92 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: coord_array.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef COORD_ARRAY_HPP
-#define COORD_ARRAY_HPP
-
-#include "coord.hpp"
-#include <cassert>
-
-namespace mapnik
-{
-
-    template <typename T>
-    class coord_array 
-    {   
-	typedef T coord_type;
-	coord_type* pt_;
-	const unsigned size_;
-    public:	
-	coord_array(unsigned size=0)
-	    : pt_(static_cast<coord_type*>(size==0?0: ::operator new (sizeof(coord_type)*size))),
-	      size_(size) {}
-	
-	coord_array(const coord_array& rhs)
-	    : pt_(static_cast<coord_type*>(rhs.size_==0?0: ::operator new (sizeof(coord_type)*rhs.size_))),
-	      size_(rhs.size_) {
-	    memcpy(pt_,rhs.pt_,sizeof(coord_type)*rhs.size_);
-	}
-	
-	~coord_array() 
-	{
-	    ::operator delete (pt_);
-	}
-	
-	unsigned size() const 
-	{
-	    return size_;
-	}
-	
-	void set(unsigned index,double x,double y)
-	{
-	    assert(index<size_);
-	    pt_[index].x=x;
-	    pt_[index].y=y;
-	}
-	
-	const coord_type& at(unsigned index) const 
-	{
-	    assert(index<size_);
-	    return pt_[index];
-	}
-	
-	const coord_type& operator[] (unsigned index) const
-	{
-	    assert (index<size_);
-	    return pt_[index];
-	}
-	
-	coord_type& operator[] (unsigned index)
-	{
-	    assert (index<size_);
-	    return pt_[index];
-	}
-	
-    private:
-	coord_array& operator=(const coord_array&);
-    };
-}
-
-
-#endif //COORD_ARRAY_HPP

Deleted: trunk/include/css_color_parser.hpp
===================================================================
--- trunk/include/css_color_parser.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/css_color_parser.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,388 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef CSS_COLOR_PARSER_HPP
-#define CSS_COLOR_PARSER_HPP
-
-#include <boost/spirit/core.hpp>
-#include <boost/spirit/symbols.hpp>
-
-using namespace boost::spirit;
-
-namespace mapnik
-{
-    template <typename ColorT>
-    struct named_colors : public symbols<ColorT>
-    {
-	named_colors()
-	{
-	    symbols<ColorT>::add
-		("aliceblue", ColorT(240, 248, 255))
-		("antiquewhite", ColorT(250, 235, 215))
-		("aqua", ColorT(0, 255, 255))
-		("aquamarine", ColorT(127, 255, 212))
-		("azure", ColorT(240, 255, 255))
-		("beige", ColorT(245, 245, 220))
-		("bisque", ColorT(255, 228, 196))
-		("black", ColorT(0, 0, 0))
-		("blanchedalmond", ColorT(255,235,205))
-		("blue", ColorT(0, 0, 255))
-		("blueviolet", ColorT(138, 43, 226))
-		("brown", ColorT(165, 42, 42))
-		("burlywood", ColorT(222, 184, 135))
-		("cadetblue", ColorT(95, 158, 160))
-		("chartreuse", ColorT(127, 255, 0))
-		("chocolate", ColorT(210, 105, 30))
-		("coral", ColorT(255, 127, 80))
-		("cornflowerblue", ColorT(100, 149, 237))
-		("cornsilk", ColorT(255, 248, 220))
-		("crimson", ColorT(220, 20, 60))
-		("cyan", ColorT(0, 255, 255))
-		("darkblue", ColorT(0, 0, 139))
-		("darkcyan", ColorT(0, 139, 139))
-		("darkgoldenrod", ColorT(184, 134, 11))
-		("darkgray", ColorT(169, 169, 169))
-		("darkgreen", ColorT(0, 100, 0))
-		("darkgrey", ColorT(169, 169, 169))
-		("darkkhaki", ColorT(189, 183, 107))
-		("darkmagenta", ColorT(139, 0, 139))
-		("darkolivegreen", ColorT(85, 107, 47))
-		("darkorange", ColorT(255, 140, 0))
-		("darkorchid", ColorT(153, 50, 204))
-		("darkred", ColorT(139, 0, 0))
-		("darksalmon", ColorT(233, 150, 122))
-		("darkseagreen", ColorT(143, 188, 143))
-		("darkslateblue", ColorT(72, 61, 139))
-		("darkslategrey", ColorT(47, 79, 79))
-		("darkturquoise", ColorT(0, 206, 209))
-		("darkviolet", ColorT(148, 0, 211))
-		("deeppink", ColorT(255, 20, 147))
-		("deepskyblue", ColorT(0, 191, 255))
-		("dimgray", ColorT(105, 105, 105))
-		("dimgrey", ColorT(105, 105, 105))
-		("dodgerblue", ColorT(30, 144, 255))
-		("firebrick", ColorT(178, 34, 34))
-		("floralwhite", ColorT(255, 250, 240))
-		("forestgreen", ColorT(34, 139, 34))
-		("fuchsia", ColorT(255, 0, 255))
-		("gainsboro", ColorT(220, 220, 220))
-		("ghostwhite", ColorT(248, 248, 255))
-		("gold", ColorT(255, 215, 0))
-		("goldenrod", ColorT(218, 165, 32))
-		("gray", ColorT(128, 128, 128))
-		("grey", ColorT(128, 128, 128))
-		("green", ColorT(0, 128, 0))
-		("greenyellow", ColorT(173, 255, 47))
-		("honeydew", ColorT(240, 255, 240))
-		("hotpink", ColorT(255, 105, 180))
-		("indianred", ColorT(205, 92, 92))
-		("indigo", ColorT(75, 0, 130))
-		("ivory", ColorT(255, 255, 240))
-		("khaki", ColorT(240, 230, 140))
-		("lavender", ColorT(230, 230, 250))
-		("lavenderblush", ColorT(255, 240, 245))
-		("lawngreen", ColorT(124, 252, 0))
-		("lemonchiffon", ColorT(255, 250, 205))
-		("lightblue", ColorT(173, 216, 230))
-		("lightcoral", ColorT(240, 128, 128))
-		("lightcyan", ColorT(224, 255, 255))
-		("lightgoldenrodyellow", ColorT(250, 250, 210))
-		("lightgray", ColorT(211, 211, 211))
-		("lightgreen", ColorT(144, 238, 144))
-		("lightgrey", ColorT(211, 211, 211))
-		("lightpink", ColorT(255, 182, 193))
-		("lightsalmon", ColorT(255, 160, 122))
-		("lightseagreen", ColorT(32, 178, 170))
-		("lightskyblue", ColorT(135, 206, 250))
-		("lightslategray", ColorT(119, 136, 153))
-		("lightslategrey", ColorT(119, 136, 153))
-		("lightsteelblue", ColorT(176, 196, 222))
-		("lightyellow", ColorT(255, 255, 224))
-		("lime", ColorT(0, 255, 0))
-		("limegreen", ColorT(50, 205, 50))
-		("linen", ColorT(250, 240, 230))
-		("magenta", ColorT(255, 0, 255))
-		("maroon", ColorT(128, 0, 0))
-		("mediumaquamarine", ColorT(102, 205, 170))
-		("mediumblue", ColorT(0, 0, 205))
-		("mediumorchid", ColorT(186, 85, 211))
-		("mediumpurple", ColorT(147, 112, 219))
-		("mediumseagreen", ColorT(60, 179, 113))
-		("mediumslateblue", ColorT(123, 104, 238))
-		("mediumspringgreen", ColorT(0, 250, 154))
-		("mediumturquoise", ColorT(72, 209, 204))
-		("mediumvioletred", ColorT(199, 21, 133))
-		("midnightblue", ColorT(25, 25, 112))
-		("mintcream", ColorT(245, 255, 250))
-		("mistyrose", ColorT(255, 228, 225))
-		("moccasin", ColorT(255, 228, 181))
-		("navajowhite", ColorT(255, 222, 173))
-		("navy", ColorT(0, 0, 128))
-		("oldlace", ColorT(253, 245, 230))
-		("olive", ColorT(128, 128, 0))
-		("olivedrab", ColorT(107, 142, 35))
-		("orange", ColorT(255, 165, 0))
-		("orangered", ColorT(255, 69, 0))
-		("orchid", ColorT(218, 112, 214))
-		("palegoldenrod", ColorT(238, 232, 170))
-		("palegreen", ColorT(152, 251, 152))
-		("paleturquoise", ColorT(175, 238, 238))
-		("palevioletred", ColorT(219, 112, 147))
-		("papayawhip", ColorT(255, 239, 213))
-		("peachpuff", ColorT(255, 218, 185))
-		("peru", ColorT(205, 133, 63))
-		("pink", ColorT(255, 192, 203))
-		("plum", ColorT(221, 160, 221))
-		("powderblue", ColorT(176, 224, 230))
-		("purple", ColorT(128, 0, 128))
-		("red", ColorT(255, 0, 0))
-		("rosybrown", ColorT(188, 143, 143))
-		("royalblue", ColorT(65, 105, 225))
-		("saddlebrown", ColorT(139, 69, 19))
-		("salmon", ColorT(250, 128, 114))
-		("sandybrown", ColorT(244, 164, 96))
-		("seagreen", ColorT(46, 139, 87))
-		("seashell", ColorT(255, 245, 238))
-		("sienna", ColorT(160, 82, 45))
-		("silver", ColorT(192, 192, 192))
-		("skyblue", ColorT(135, 206, 235))
-		("slateblue", ColorT(106, 90, 205))
-		("slategray", ColorT(112, 128, 144))
-		("slategrey", ColorT(112, 128, 144))
-		("snow", ColorT(255, 250, 250))
-		("springgreen", ColorT(0, 255, 127))
-		("steelblue", ColorT(70, 130, 180))
-		("tan", ColorT(210, 180, 140))
-		("teal", ColorT(0, 128, 128))
-		("thistle", ColorT(216, 191, 216))
-		("tomato", ColorT(255, 99, 71))
-		("turquoise", ColorT(64, 224, 208))
-		("violet", ColorT(238, 130, 238))
-		("wheat", ColorT(245, 222, 179))
-		("white", ColorT(255, 255, 255))
-		("whitesmoke", ColorT(245, 245, 245))
-		("yellow", ColorT(255, 255, 0))
-		("yellowgreen", ColorT(154, 205, 50))
-		;
-	}
-    };
-    
-    template <typename ActionsT>
-    struct css_color_grammar : public grammar<css_color_grammar<ActionsT> >
-    {
-	css_color_grammar(ActionsT& actions_)
-	    : actions(actions_) {}
-    
-	template <typename ScannerT>
-	struct definition
-	{
-	    definition(css_color_grammar const& self)
-	    {
-		hex6 = ch_p('#') >> uint6x_p[self.actions.hex6_];
-		hex3 = ch_p('#') >> uint3x_p[self.actions.hex3_];
-		rgb = str_p("rgb") >> '(' >> uint3_p[self.actions.red_] 
-			     >> ',' >> uint3_p[self.actions.green_] 
-			     >> ',' >> uint3_p[self.actions.blue_] 
-			     >> ')';
-		rgb_percent = str_p("rgb") >> '(' >> ureal_p[self.actions.red_p_] >> '%' 
-					   >> ',' >> ureal_p[self.actions.green_p_] >> '%'
-					   >> ',' >> ureal_p[self.actions.blue_p_] >> '%'
-					   >> ')';
-		css_color = named_colors_p[self.actions.named_] | hex6 | hex3 | rgb_percent | rgb; 
-	    }
-	    boost::spirit::rule<ScannerT> rgb;
-	    boost::spirit::rule<ScannerT> rgb_percent;
-	    boost::spirit::rule<ScannerT> hex6;
-	    boost::spirit::rule<ScannerT> hex3;
-            boost::spirit::rule<ScannerT> css_color;
-	    boost::spirit::rule<ScannerT> const& start() const
-	    {
-		return css_color;
-	    }
-	    uint_parser<unsigned, 10, 1, 3> uint3_p;
-	    uint_parser<unsigned, 16, 6, 6> uint6x_p;
-	    uint_parser<unsigned, 16, 3, 3> uint3x_p;
-	    named_colors<typename ActionsT::color_type> named_colors_p;
-	    
-	};
-	ActionsT& actions;	
-    };
-    
-    template <typename ColorT>
-    struct named_color_action
-    {
-	named_color_action(ColorT& c)
-	    : c_(c) {}
-	
-	void operator() (ColorT const&c) const
-	{
-	    c_=c;
-	}
-	ColorT& c_;
-    };
-
-    template <typename ColorT>
-    struct hex6_action
-    {
-	hex6_action(ColorT& c)
-	    : c_(c) {}
-	
-	void operator () (unsigned int hex) const
-	{
-	    unsigned r = (hex >> 16) & 0xff;
-	    unsigned g = (hex >> 8) & 0xff;
-	    unsigned b = hex & 0xff;
-	    c_.set_red(r);
-	    c_.set_green(g);
-	    c_.set_blue(b);
-	}
-	ColorT& c_;
-    };
-    
-    template <typename ColorT>
-    struct hex3_action
-    {
-	hex3_action(ColorT& c)
-	    : c_(c) {}
-	
-	void operator () (unsigned int hex) const
-	{
-	    unsigned int r = (hex >> 8) & 0xf;
-	    unsigned int g = (hex >> 4) & 0xf;
-	    unsigned int b = hex & 0xf;
-	    c_.set_red( r | r << 4);
-	    c_.set_green(g | g << 4);
-	    c_.set_blue(b | b << 4);
-	}
-	ColorT& c_;
-    };
-
-    template <typename ColorT>
-    struct red_action
-    {
-	red_action(ColorT& c)
-	    : c_(c) {}
-	
-	void operator () (unsigned int r) const
-	{
-	    c_.set_red(r);
-	}
-	ColorT& c_;
-    };
-
-    template <typename ColorT>
-    struct green_action
-    {
-	green_action(ColorT& c)
-	    : c_(c) {}
-	
-	void operator () (unsigned int g) const
-	{
-	    c_.set_green(g);
-	}
-	ColorT& c_;
-    };
-	
-    template <typename ColorT>
-    struct blue_action
-    {
-	blue_action(ColorT& c)
-	    : c_(c) {}
-	
-	void operator () (unsigned int b) const
-	{
-	    c_.set_blue(b);
-	}
-	ColorT& c_;
-    };
-    
-
-    template <typename ColorT>
-    struct red_action_p
-    {
-	red_action_p(ColorT& c)
-	    : c_(c) {}
-	
-	void operator () (double r) const
-	{
-	    c_.set_red(unsigned((255.0 * r)/100.0 + 0.5));
-	}
-	ColorT& c_;
-    };
-
-    template <typename ColorT>
-    struct green_action_p
-    {
-	green_action_p(ColorT& c)
-	    : c_(c) {}
-	
-	void operator () (double g) const
-	{
-	    c_.set_green(unsigned((255.0 * g)/100.0 + 0.5));
-	}
-	ColorT& c_;
-    };
-
-    template <typename ColorT>
-    struct blue_action_p
-    {
-	blue_action_p(ColorT& c)
-	    : c_(c) {}
-	
-	void operator () (double b) const
-	{
-	    c_.set_blue(unsigned((255.0 * b)/100.0 + 0.5));
-	}
-	ColorT& c_;
-    };
-
-
-    template <typename ColorT>
-    struct actions
-    {
-	typedef ColorT color_type;
-	actions(ColorT& c)
-	    : named_(c),
-	      hex6_(c),
-	      hex3_(c),
-	      red_(c),
-	      green_(c),
-	      blue_(c),
-	      red_p_(c),
-	      green_p_(c),
-	      blue_p_(c) {}
-        
-	named_color_action<ColorT> named_;
-	hex6_action<ColorT> hex6_;
-	hex3_action<ColorT> hex3_;
-	red_action<ColorT> red_;
-	green_action<ColorT> green_;
-	blue_action<ColorT> blue_;
-	red_action_p<ColorT> red_p_;
-	green_action_p<ColorT> green_p_;
-	blue_action_p<ColorT> blue_p_;
-    };
-}
-
-#endif //CSS_COLOR_PARSER_HPP

Deleted: trunk/include/ctrans.hpp
===================================================================
--- trunk/include/ctrans.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/ctrans.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,169 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: ctrans.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef CTRANS_HPP
-#define CTRANS_HPP
-
-#include "envelope.hpp"
-#include "coord_array.hpp"
-
-namespace mapnik
-{
-    typedef coord_array<coord2d> CoordinateArray;
-    
-    template <typename Transform,typename Geometry>
-    struct MAPNIK_DECL coord_transform
-    {
-	coord_transform(Transform const& t,Geometry& geom)
-	    : t_(t), geom_(geom) {}
-	
-	unsigned  vertex(double *x , double *y) const
-	{
-	    unsigned command = geom_.vertex(x,y);
-	    *x = t_.forward_x_(x);
-	    *y = t_.forward_y_(y);
-	    return command;
-	}
-	void rewind (unsigned pos)
-	{
-	    geom_.rewind(pos);
-	}
-	
-    private:
-	Transform const& t_;
-	Geometry& geom_;
-    };
-    
-    class CoordTransform
-    {
-    private:
-	    int width;
-	    int height;
-	    double scale_;
-	    Envelope<double> extent;
-    public:
-	CoordTransform(int width,int height,const Envelope<double>& extent)
-            :width(width),height(height),extent(extent)
-	{
-	    double sx=((double)width)/extent.width();
-	    double sy=((double)height)/extent.height();
-	    scale_=std::min(sx,sy);
-	}
-	
-	inline double scale() const
-	{
-	    return scale_;
-	}
-	
-	inline void forward_x(double* x) const 
-	{
-	    *x = (*x - extent.minx() ) * scale_;   
-	}
-	
-	inline void forward_y(double* y) const 
-	{
-	    *y = (extent.maxy() - *y) * scale_;
-	}
-
-	inline double forward_x_(double* x) const 
-	{
-	    return (*x - extent.minx() ) * scale_;   
-	}
-	
-	inline double forward_y_(double* y) const 
-	{
-	    return (extent.maxy() - *y) * scale_;
-	}
-
-	inline void backward_x(double* x) const
-	{
-	    *x = extent.minx() + *x/scale_;
-	}
-	
-	inline void backward_y(double* y) const
-	{
-	    *y = extent.maxy() - *y/scale_;
-	}
-	
-	inline coord2d& forward(coord2d& c) const
-	{
-	    forward_x(&c.x);
-	    forward_y(&c.y);
-	    return c;
-	}
-
-	inline coord2d& backward(coord2d& c) const
-	{
-	    backward_x(&c.x);
-	    backward_y(&c.y);
-	    return c;
-	}
-
-	inline Envelope<double> forward(const Envelope<double>& e) const
-	{
-	    double x0 = e.minx();
-	    double y0 = e.miny();
-	    double x1 = e.maxx();
-	    double y1 = e.maxy();
-	    forward_x(&x0);
-	    forward_y(&y0);
-	    forward_x(&x1);
-	    forward_y(&y1);
-	    return Envelope<double>(x0,y0,x1,y1);
-	}
-
-	inline Envelope<double> backward(const Envelope<double>& e) const
-	{
-	    double x0 = e.minx();
-	    double y0 = e.miny();
-	    double x1 = e.maxx();
-	    double y1 = e.maxy();
-	    backward_x(&x0);
-	    backward_y(&y0);
-	    backward_x(&x1);
-	    backward_y(&y1);
-	    
-	    return Envelope<double>(x0,y0,x1,y1);
-	}
-
-	inline CoordinateArray& forward(CoordinateArray& coords) const
-	{
-	    for (unsigned i=0;i<coords.size();++i)
-	    {
-		forward(coords[i]);
-	    }
-	    return coords;
-	}
-	
-	inline CoordinateArray& backward(CoordinateArray& coords) const
-	{
-	    for (unsigned i=0;i<coords.size();++i)
-	    {
-		backward(coords[i]);
-	    }
-	    return coords;
-	}
-    };
-}
-#endif                                            //CTRANS_HPP

Deleted: trunk/include/datasource.hpp
===================================================================
--- trunk/include/datasource.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/datasource.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,119 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: datasource.hpp 43 2005-04-22 18:52:47Z pavlenko $
-
-#ifndef DATASOURCE_HPP
-#define DATASOURCE_HPP
-
-#include <map>
-#include <string>
-#include "ctrans.hpp"
-#include "params.hpp"
-#include "feature.hpp"
-#include "query.hpp"
-#include "feature_layer_desc.hpp"
-
-#include <boost/shared_ptr.hpp>
-
-namespace mapnik
-{    
-    typedef MAPNIK_DECL shared_ptr<Feature> feature_ptr;
-    struct MAPNIK_DECL Featureset
-    {
-        virtual feature_ptr next()=0;
-        virtual ~Featureset() {};
-    };
-    
-    typedef shared_ptr<Featureset> featureset_ptr;    
-    class MAPNIK_DECL datasource_exception : public std::exception
-    {
-    private:
-        const std::string message_;
-    public:
-        datasource_exception(const std::string& message=std::string())
-            :message_(message) {}
-
-        ~datasource_exception() throw() {}
-        virtual const char* what() const throw()
-        {
-            return message_.c_str();
-        }
-    };
-    
-    class MAPNIK_DECL datasource : private boost::noncopyable
-    {
-        parameters params_;
-    public:        
-        enum {
-            Vector,
-            Raster
-        };
-        
-        datasource (parameters const& params)
-            : params_(params) {}
-
-        parameters const& params() const
-        {
-            return params_;
-        }
-        
-        virtual int type() const=0;
-        virtual featureset_ptr features(const query& q) const=0;
-        virtual Envelope<double> const& envelope() const=0;
-        virtual layer_descriptor const& get_descriptor() const=0;
-        virtual ~datasource() {};
-    };
-    
-    typedef std::string datasource_name();
-    typedef datasource* create_ds(const parameters& params);
-    typedef void destroy_ds(datasource *ds);
-
-    
-    class datasource_deleter
-    {
-    public:
-        void operator() (datasource* ds)
-        {
-            delete ds;
-        }
-    };
-
-    typedef boost::shared_ptr<datasource> datasource_p;
-    
-    ///////////////////////////////////////////
-#define DATASOURCE_PLUGIN(classname)                                    \
-    extern "C" MAPNIK_DECL std::string datasource_name()                \
-    {                                                                   \
-        return classname::name();                                       \
-    }                                                                   \
-        extern "C"  MAPNIK_DECL datasource* create(const parameters &params) \
-        {                                                               \
-            return new classname(params);                               \
-        }                                                               \
-        extern "C" MAPNIK_DECL void destroy(datasource *ds)             \
-        {                                                               \
-            delete ds;                                                  \
-        }                                                               \
-        ///////////////////////////////////////////
-}
-#endif                                            //DATASOURCE_HPP

Deleted: trunk/include/datasource_cache.hpp
===================================================================
--- trunk/include/datasource_cache.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/datasource_cache.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,54 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: datasource_cache.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef DATASOURCE_CACHE_HPP
-#define DATASOURCE_CACHE_HPP
-
-#include <map>
-#include <boost/shared_ptr.hpp>
-
-#include "utils.hpp"
-#include "params.hpp"
-#include "plugin.hpp"
-#include "datasource.hpp"
-
-namespace mapnik
-{
-    class MAPNIK_DECL datasource_cache : public singleton <datasource_cache,CreateStatic>
-    {
-        friend class CreateStatic<datasource_cache>;
-    private:
-        datasource_cache();
-        ~datasource_cache();
-        datasource_cache(const datasource_cache&);
-        datasource_cache& operator=(const datasource_cache&);
-        static std::map<std::string,boost::shared_ptr<PluginInfo> > plugins_;
-        static bool registered_;
-        static bool insert(const std::string&  name,const lt_dlhandle module);
-    public:
-        static void register_datasources(const std::string& path);
-        static boost::shared_ptr<datasource> create(parameters const& params);
-    };
-}
-#endif   //DATASOURCE_CACHE_HPP

Deleted: trunk/include/envelope.hpp
===================================================================
--- trunk/include/envelope.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/envelope.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,88 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: envelope.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef ENVELOPE_HPP
-#define ENVELOPE_HPP
-
-#include "config.hpp"
-#include <iomanip>
-#include "coord.hpp"
-
-namespace mapnik
-{
-
-	template <class T> class MAPNIK_DECL Envelope
-    {
-    public:
-        typedef Envelope<T> EnvelopeType;
-    private:
-        T minx_;
-        T miny_;
-        T maxx_;
-        T maxy_;
-    public:
-        Envelope();
-        Envelope(T minx,T miny,T maxx,T maxy);
-        Envelope(const coord<T,2>& c0,const coord<T,2>& c1);
-        Envelope(const EnvelopeType& rhs);
-        T minx() const;
-        T miny() const;
-        T maxx() const;
-        T maxy() const;
-        T width() const;
-        T height() const;
-        void width(T w);
-        void height(T h);
-        coord<T,2> center() const;
-        void expand_to_include(T x,T y);
-        void expand_to_include(const coord<T,2>& c);
-        void expand_to_include(const EnvelopeType& other);
-        bool contains(const coord<T,2> &c) const;
-        bool contains(T x,T y) const;
-        bool contains(const EnvelopeType &other) const;
-        bool intersects(const coord<T,2> &c) const;
-        bool intersects(T x,T y) const;
-        bool intersects(const EnvelopeType &other) const;
-        EnvelopeType intersect(const EnvelopeType& other) const;
-        bool operator==(const EnvelopeType &other) const;
-        void re_center(T cx,T cy);
-        void init(T x0,T y0,T x1,T y1);
-    };
-    
-    template <class charT,class traits,class T>
-    inline std::basic_ostream<charT,traits>&
-    operator << (std::basic_ostream<charT,traits>& out,
-                 const Envelope<T>& e)
-    {
-        std::basic_ostringstream<charT,traits> s;
-        s.copyfmt(out);
-        s.width(0);
-        s <<"Envelope(" << std::setprecision(16) 
-          << e.minx() << "," << e.miny() <<"," 
-          << e.maxx() << "," << e.maxy() <<")";
-        out << s.str();
-        return out;
-    }
-}
-#endif // ENVELOPE_HPP

Deleted: trunk/include/expression.hpp
===================================================================
--- trunk/include/expression.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/expression.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,127 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef EXPRESSION_HPP
-#define EXPRESSION_HPP
-
-#include "value.hpp"
-#include "filter_visitor.hpp"
-
-namespace mapnik
-{
-    template <typename FeatureT> class filter_visitor;
-    template <typename FeatureT>
-    class expression
-    {
-    public:
-	virtual value get_value(FeatureT const& feature) const=0;
-	virtual void accept(filter_visitor<FeatureT>& v)=0;
-	virtual expression<FeatureT>* clone() const=0;
-	virtual std::string to_string() const=0;
-	virtual ~expression() {}
-    };
-
-    template <typename FeatureT> 
-    class literal : public expression<FeatureT>
-    {
-    public:
-	literal(int val)
-	    : expression<FeatureT>(),
-	      value_(val) {}
-	literal(double val)
-	    : expression<FeatureT>(),
-	      value_(val) {}
-	literal(std::string const& val)
-	    : expression<FeatureT>(),
-	      value_(val) {}
-	literal(literal const& other)
-	    : expression<FeatureT>(),
-	      value_(other.value_) {}
-	
-	value get_value(FeatureT const& /*feature*/) const
-	{
-	    return value_;
-	}
-	void accept(filter_visitor<FeatureT>& v)
-	{
-	    v.visit(*this);
-	}
-	expression<FeatureT>* clone() const
-	{
-	    return new literal(*this); 
-	}
-	std::string to_string() const
-	{
-	    return value_.to_expression_string();
-	}
-        ~literal() {}
-    private:
-	value value_;
-    };
-  
-
-    template <typename FeatureT> 
-    class property : public expression<FeatureT>
-    {
-    public:
-	property(std::string const& name)
-        : expression<FeatureT>(),
-	    name_(name)
-	    {}
-	
-	property(property const& other)
-	    : expression<FeatureT>(),
-	     name_(other.name_)
-	    {}
-
-	value get_value(FeatureT const& feature) const
-	{
-	    return feature[name_];
-	}
-	void accept(filter_visitor<FeatureT>& v)
-	{
-	    v.visit(*this);
-	}
-	expression<FeatureT>* clone() const
-	{
-	    return new property(*this); 
-	}
-	std::string const& name() const
-	{
-	    return name_;
-	}
-
-	std::string to_string() const
-	{
-	    return "["+name_+"]";
-	}
-
-    ~property() {}
-
-    private:
-	    std::string name_;
-    };
-}
-
-#endif //EXPRESSION_HPP

Deleted: trunk/include/factory.hpp
===================================================================
--- trunk/include/factory.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/factory.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,88 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: factory.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef FACTORY_HPP
-#define FACTORY_HPP
-
-#include <stdexcept>
-#include <map>
-#include "utils.hpp"
-
-namespace mapnik
-{
-    template <typename key_type,
-              typename product_type>
-    class default_factory_error
-    {
-    public:
-        struct factory_exception : public std::exception
-        {
-            const char* what() const throw()
-            {
-                return "uknown object type";
-            }
-        };
-        static product_type* on_unknown_type(const key_type&)
-        {
-            return 0;
-        }
-    };
-
-    template
-    <
-        typename product_type,
-        typename key_type,
-        typename product_creator=product_type* (*)(),
-        template <typename,typename> class factory_error_policy=default_factory_error
-        >
-    class factory : public singleton<factory <product_type,key_type,product_creator,factory_error_policy> >,
-        factory_error_policy <key_type,product_type>
-    {
-    private:
-        typedef std::map<key_type,product_creator> product_map;
-        product_map map_;
-    public:
-
-        bool register_product(const key_type& key,product_creator creator)
-        {
-            return map_.insert(typename product_map::value_type(key,creator)).second;
-        }
-
-        bool unregister_product(const key_type& key)
-        {
-            return map_.erase(key)==1;
-        }
-
-        product_type* create_object(const key_type& key,const std::string& file)
-        {
-            typename product_map::const_iterator pos=map_.find(key);
-            if (pos!=map_.end())
-            {
-                return (pos->second)(file);
-            }
-            return on_unknown_type(key);
-        }
-    };
-}
-#endif                                            //FACTORY_HPP

Deleted: trunk/include/feature.hpp
===================================================================
--- trunk/include/feature.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/feature.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,118 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: feature.hpp 40 2005-04-13 20:20:46Z pavlenko $
-
-#ifndef FEATURE_HPP
-#define FEATURE_HPP
-
-#include "geometry.hpp"
-#include "raster.hpp"
-#include "value.hpp"
-#include <map>
-
-#include <boost/property_map.hpp>
-#include <boost/utility.hpp>
-
-namespace mapnik
-{
-    typedef boost::shared_ptr<raster> raster_ptr;    
-    //typedef std::vector<value> properties;
-    typedef boost::associative_property_map<std::map<std::string,value> > properties;
-    
-    template <typename T1,typename T2>
-    struct feature : public properties,
-		     private boost::noncopyable
-    {
-    public:
-	typedef T1 geometry_type;
-	typedef T2 raster_type;
-    private:
-	int id_;
-	geometry_type geom_;
-	raster_type   raster_;
-	std::map<std::string,value> props_;
-    public:
-	explicit feature(int id)
-	    : properties(props_),
-	      id_(id),
-	      geom_(),
-	      raster_() {}
-
-	feature(int id,const geometry_type& geom)
-	    : properties(props_),
-	      id_(id),
-	      geom_(geom),
-	      raster_() {}
-
-	int id() const 
-	{
-	    return id_;
-	}
-	
-	void set_geometry(geometry_type& geom)
-	{
-	    geom_=geom;
-	}
-	
-	geometry_type const& get_geometry() const
-	{
-	    return geom_;
-	}
-        
-	const raster_type& get_raster() const
-	{
-	    return raster_;
-	}
-	void set_raster(raster_type const& raster)
-	{
-	    raster_=raster;
-	}
-	
-	const properties& get_properties() const 
-	{
-	    return props_;
-	}
-	
-	std::string to_string() const
-	{
-	    std::stringstream ss;
-	    ss << "feature (" << std::endl;
-	    for (std::map<std::string,value>::const_iterator itr=props_.begin();
-		 itr != props_.end();++itr)
-	    {
-		ss << "  " << itr->first  << ":" <<  itr->second << std::endl;
-	    }
-	    ss << ")" << std::endl;
-	    return ss.str();
-	}
-    };
-
-    typedef feature<geometry_ptr,raster_ptr> Feature;
-    
-    inline std::ostream& operator<< (std::ostream & out,Feature const& f)
-    {
-	out << f.to_string();
-    	return out;
-    }
-}
-#endif                                            //FEATURE_HPP

Deleted: trunk/include/feature_factory.hpp
===================================================================
--- trunk/include/feature_factory.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/feature_factory.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,41 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef FEATURE_FACTORY_HPP
-#define FEATURE_FACTORY_HPP
-
-#include "feature.hpp"
-namespace mapnik
-{
-    struct feature_factory
-    {
-	static Feature* create (int fid)
-	{
-	    return new Feature(fid);
-	}
-    }; 
-}
-
-
-#endif //FEATURE_FACTORY_HPP

Deleted: trunk/include/feature_layer_desc.hpp
===================================================================
--- trunk/include/feature_layer_desc.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/feature_layer_desc.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,250 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef FEATURE_LAYER_DESC_HPP
-#define FEATURE_LAYER_DESC_HPP
-
-#include <string>
-#include <vector>
-#include <iostream>
-
-namespace mapnik
-{
-    
-    using std::string;
-    using std::vector;
-    using std::clog;
-    using std::endl;
-    
-    enum {
-	Integer=1,
-	Float  =2,
-	Double =3,
-	String =4,
-	Geometry=5,
-	Object=6 
-    };
-    
-    class attribute_descriptor
-    {
-    public:
-	attribute_descriptor(string const& name,unsigned type,
-		       bool primary_key=false,
-		       int size=-1,
-		       int precision=-1)
-	    : name_(name),
-	      type_(type),
-	      primary_key_(primary_key),
-	      size_(size),
-	      precision_(precision) {}
-	      
-	attribute_descriptor(attribute_descriptor const& other)
-	    : name_(other.name_),
-	      type_(other.type_),
-	      primary_key_(other.primary_key_),
-	      size_(other.size_),
-	      precision_(other.precision_) {}
-
-	attribute_descriptor& operator=(attribute_descriptor const& other)
-	{
-	    if (this == &other)
-		return *this;	    
-	    name_=other.name_;
-	    type_=other.type_;
-	    primary_key_=other.primary_key_;
-	    size_=other.size_;
-	    precision_=other.precision_;
-	    return *this;
-	}
-	string const& get_name() const
-	{
-	    return name_;
-	}
-	unsigned  get_type() const
-	{
-	    return type_;
-	}
-	bool is_primary_key() const
-	{
-	    return primary_key_;
-	}
-	int get_size() const
-	{
-	    return size_;
-	} 
-	
-	int get_precision() const
-	{
-	    return precision_;
-	}
-    private:
-	string name_;
-	int type_;
-	bool primary_key_;
-	int size_;
-	int precision_;
-    };
-     
-    template <typename charT,typename traits>
-    inline std::basic_ostream<charT,traits>&
-    operator << (std::basic_ostream<charT,traits>& out,
-		 attribute_descriptor const& ad)
-    {
-	out << "name=" << ad.get_name() << endl;
-	out << "type=" << ad.get_type() << endl;
-	out << "size=" << ad.get_size() << endl;
-	return out;
-    }
-
-    class layer_descriptor 
-    {
-    public:
-	layer_descriptor(string const& name,int srid=-1)
-	    : name_(name),
-	      srid_(srid) {}
-
-	layer_descriptor(layer_descriptor const& other)
-	    : name_(other.name_),
-	      srid_(other.srid_),
-	      desc_ar_(other.desc_ar_) {}
-	
-	void set_name(string const& name)
-	{
-	    name_=name;
-	}
-	string const& get_name() const
-	{
-	    return name_;
-	}
-	
-	void set_srid(int srid) 
-	{
-	    srid_=srid;
-	}
-	
-	int get_srid() const
-	{
-	    return srid_;
-	}
-
-	void add_descriptor(attribute_descriptor const& desc)
-	{
-	    desc_ar_.push_back(desc);
-	}
-	
-	vector<attribute_descriptor> const& get_descriptors() const
-	{
-	    return desc_ar_;
-	}	
-	vector<attribute_descriptor>& get_descriptors()
-	{
-	    return desc_ar_;
-	}
-    private:
-	string name_;
-	int srid_;
-	vector<attribute_descriptor> desc_ar_;
-    };
-    
-    template <typename charT,typename traits>
-    inline std::basic_ostream<charT,traits>&
-    operator << (std::basic_ostream<charT,traits>& out,
-		 layer_descriptor const& ld)
-    {
-	out << "name=" << ld.get_name() << endl;
-	out << "srid=" << ld.get_srid() << endl;
-	vector<attribute_descriptor> const& desc_ar=ld.get_descriptors();
-	vector<attribute_descriptor>::const_iterator pos=desc_ar.begin();
-	while (pos != desc_ar.end())
-	{
-	    out << *pos++ << endl;
-	    
-	}
-	return out;
-    }
-    /*    
-    bool layer_descriptor_to_wkb(layer_descriptor const& desc,array<>& wkb)
-    {
-	//srid	
-	int srid = desc.get_srid();
-	wkb.write(&srid,sizeof(int));
-
-	//attribute descriptors
-	vector<attribute_descriptor> const& desc_ar = desc.get_descriptors();
-	vector<attribute_descriptor>::const_iterator itr=desc_ar.begin();
-	size_t num_desc = desc_ar.size();
-	wkb.write(&num_desc,sizeof(int));
-	
-	while (itr != desc_ar.end())
-	{
-	    string name = itr->get_name();
-	    wkb.write(name.c_str(),name.size()+1);
-	       
-	    unsigned type = static_cast<int>(itr->get_type());
-	    wkb.write(&type,sizeof(unsigned));
-
-	    bool prim_key = itr->is_primary_key();
-	    wkb.write(&prim_key,sizeof(bool));
-
-	    int size = itr->get_size();
-	    wkb.write(&size,sizeof(int));
-            
-	    ++itr;
-	}	
-	return true;
-    }
-    
-    bool layer_descriptor_from_wkb(const char* wkb, layer_descriptor &desc)
-    {
-	unsigned pos=0;
-	int srid;
-	
-	memcpy(&srid,wkb+pos,sizeof(int));
-	desc.set_srid(srid);
-	pos+=sizeof(int);
-	
-	int num_desc;
-	memcpy(&num_desc,wkb+pos,sizeof(int));
-	pos+=sizeof(int);
-	
-	for (int i=0;i<num_desc;++i)
-	{
-	    string name = wkb+pos;
-	    pos += name.size()+1;
-	    //std::clog<<"name="<<name<<"\n";
-	    
-	    int type;
-	    memcpy(&type,wkb+pos,sizeof(int));
-	    pos += sizeof(int);
-	    attribute_descriptor ad(name,type);
-	    desc.add_descriptor(ad);
-	    //todo!!!
-	    pos += 4+1;
-	}
-	return true;
-    }
-    */    
-}
-
-#endif //FEATURE_LAYER_DESC_HPP

Deleted: trunk/include/feature_style_processor.hpp
===================================================================
--- trunk/include/feature_style_processor.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/feature_style_processor.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,184 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef FEATURE_STYLE_PROCESSOR_HPP
-#define FEATURE_STYLE_PROCESSOR_HPP
-
-#include <vector>
-#include <iostream>
-#include <boost/progress.hpp>
-#include "envelope.hpp"
-#include "datasource.hpp"
-#include "layer.hpp"
-#include "map.hpp"
-#include "attribute_collector.hpp"
-#include "utils.hpp"
-
-namespace mapnik
-{       
-    template <typename Processor>
-    class feature_style_processor 
-    {
-        struct symbol_dispatch : public boost::static_visitor<>
-        {
-            symbol_dispatch (Processor & output,Feature const& f)
-                : output_(output),f_(f) {}
-	    
-            template <typename T>
-            void operator () (T const& sym) const
-            {
-                output_.process(sym,f_);
-            }
-
-            Processor & output_;
-            Feature const& f_;
-        };
-    public:
-        feature_style_processor(Map const& m)
-            : m_(m) {}
-	
-        void apply()
-        {
-            boost::progress_timer t;
-            Processor & p = static_cast<Processor&>(*this);
-
-            p.start_map_processing(m_);
-	    
-            std::vector<Layer>::const_iterator itr = m_.layers().begin();
-            while (itr != m_.layers().end())
-            {
-                if (itr->isVisible(m_.scale()) && 
-                    itr->envelope().intersects(m_.getCurrentExtent()))
-                {
-                    apply_to_layer(*itr,p);
-                }
-                ++itr;
-            }
-            p.end_map_processing(m_);
-        }	
-    private:
-        void apply_to_layer(Layer const& lay,Processor & p)
-        {
-            p.start_layer_processing(lay);
-            datasource *ds=lay.datasource().get();
-            if (ds)
-            {
-                Envelope<double> const& bbox=m_.getCurrentExtent();
-                double scale = m_.scale();
-	
-                std::vector<std::string> const& style_names = lay.styles();
-                std::vector<std::string>::const_iterator stylesIter = style_names.begin();
-                while (stylesIter != style_names.end())
-                {
-                    std::set<std::string> names;
-                    attribute_collector<Feature> collector(names);
-                    std::vector<rule_type*> if_rules;
-                    std::vector<rule_type*> else_rules;
-		
-                    bool active_rules=false;
-		    
-                    feature_type_style const& style=m_.find_style(*stylesIter++);
-		    
-                    const std::vector<rule_type>& rules=style.get_rules();
-                    std::vector<rule_type>::const_iterator ruleIter=rules.begin();
-		    
-                    query q(bbox); //BBOX query
-                    while (ruleIter!=rules.end())
-                    {
-                        if (ruleIter->active(scale))
-                        {
-                            active_rules=true;
-                            ruleIter->accept(collector);
-
-                            if (ruleIter->has_else_filter())
-                            {
-                                else_rules.push_back(const_cast<rule_type*>(&(*ruleIter)));
-                            }
-                            else
-                            {
-                                if_rules.push_back(const_cast<rule_type*>(&(*ruleIter))); 		    
-                            }
-                        }
-                        ++ruleIter;
-                    }
-                    std::set<std::string>::const_iterator namesIter=names.begin();
-                    // push all property names
-                    while (namesIter!=names.end())
-                    {
-                        q.add_property_name(*namesIter);
-                        ++namesIter;
-                    }
-                    if (active_rules)
-                    {
-                        featureset_ptr fs=ds->features(q);
-                        if (fs)
-                        {   	    
-                            feature_ptr feature;
-                            while ((feature = fs->next()))
-                            {		   
-                                bool do_else=true;		    
-                                std::vector<rule_type*>::const_iterator itr=if_rules.begin();
-                                while (itr!=if_rules.end())
-                                {
-                                    filter_ptr const& filter=(*itr)->get_filter();    
-                                    if (filter->pass(*feature))
-                                    {   
-                                        do_else=false;
-                                        const symbolizers& symbols = (*itr)->get_symbolizers();
-                                        symbolizers::const_iterator symIter=symbols.begin();
-                                        while (symIter!=symbols.end())
-                                        {   
-                                            boost::apply_visitor(symbol_dispatch(p,*feature),*symIter++);
-                                        }
-                                    }			    
-                                    ++itr;
-                                }
-                                if (do_else)
-                                {
-                                    //else filter
-                                    std::vector<rule_type*>::const_iterator itr=else_rules.begin();
-                                    while (itr != else_rules.end())
-                                    {
-                                        const symbolizers& symbols = (*itr)->get_symbolizers();
-                                        symbolizers::const_iterator symIter=symbols.begin();
-                                        while (symIter!=symbols.end())
-                                        {
-                                            boost::apply_visitor(symbol_dispatch(p,*feature),*symIter++);
-                                        }
-                                        ++itr;
-                                    }
-                                }	  
-                            }
-                        }
-                    }
-                }
-            }
-            p.end_layer_processing(lay);
-        }
-	
-        Map const& m_;
-    };
-}
-
-#endif //FEATURE_STYLE_PROCESSOR_HPP

Deleted: trunk/include/feature_type_style.hpp
===================================================================
--- trunk/include/feature_type_style.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/feature_type_style.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,67 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef FEATURE_TYPE_STYLE
-#define FEATURE_TYPE_STYLE
-
-#include "rule.hpp"
-#include "feature.hpp"
-#include <vector>
-
-
-namespace mapnik
-{
-    typedef std::vector<rule_type> rules;
-    class feature_type_style
-    {
-    private:
-        rules  rules_;
-    public:
-        feature_type_style() {}
-
-        feature_type_style(feature_type_style const& rhs)
-            : rules_(rhs.rules_) {}
-	
-        feature_type_style& operator=(feature_type_style const& rhs)
-        {
-            if (this == &rhs) return *this;
-            rules_=rhs.rules_;
-            return *this;
-        }
-	
-        void add_rule(rule_type const& rule)
-        {
-            rules_.push_back(rule);
-        } 
-	
-        rules const& get_rules() const
-        {
-            return rules_;
-        }
-	
-        ~feature_type_style() {}
-    };
-}
-
-#endif //FEATURE_TYPE_STYLE

Deleted: trunk/include/fill.hpp
===================================================================
--- trunk/include/fill.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/fill.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,36 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef FILL_HPP
-#define FILL_HPP
-
-namespace mapnik
-{
-    class fill 
-    {
-        
-    };
-}
-
-#endif //FILL_HPP

Deleted: trunk/include/filter.hpp
===================================================================
--- trunk/include/filter.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/filter.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,89 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef FILTER_HPP
-#define FILTER_HPP
-
-#include "feature.hpp"
-
-namespace mapnik
-{
-    template <typename FeatureT> class filter_visitor;
-    template <typename FeatureT>
-    class MAPNIK_DECL filter
-    {
-	public:
-		virtual bool pass(const FeatureT& feature) const=0; 
-		virtual filter<FeatureT>* clone() const=0;
-		virtual void accept(filter_visitor<FeatureT>& v) = 0;
-        virtual std::string to_string() const=0;
-		virtual ~filter() {}
-    };
-    
-    typedef boost::shared_ptr<filter<Feature> > filter_ptr;
-    
-    template <typename FeatureT>
-    class all_filter : public filter<FeatureT>
-    {
-	public:
-		bool pass (const FeatureT&) const
-		{
-			return true;
-		}
-	
-		filter<FeatureT>* clone() const
-		{
-			return new all_filter<FeatureT>;
-		}
-		std::string to_string() const
-		{
-			return "true";
-		}  
-        void accept(filter_visitor<FeatureT>&) {}
-		virtual ~all_filter() {}
-    };
-      
-    template <typename FeatureT>
-    class none_filter : public filter<FeatureT>
-    {
-	public:
-		bool pass (const FeatureT&) const
-		{
-			return false;
-		}
-	
-		filter<FeatureT>* clone() const
-		{
-			return new none_filter<FeatureT>;
-		}
-		std::string to_string() const
-		{
-			return "false";
-		}  
-	    void accept(filter_visitor<FeatureT>&) {}
-		virtual ~none_filter() {}
-	};
-}
-
-#endif //FILTER_HPP

Deleted: trunk/include/filter_expression.hpp
===================================================================
--- trunk/include/filter_expression.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/filter_expression.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,65 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef FILTER_TO_STRING_HPP
-#define FILTER_TO_STRING_HPP
-
-#include "filter.hpp"
-#include "expression.hpp"
-#include <set>
-
-namespace mapnik
-{
-    template <typename FeatureT>
-    class filter_to_string : public filter_visitor<FeatureT>
-    {
-    private:
-        std::string text_;
-    public:
-        filter_to_string() {}
-        void visit(filter<FeatureT>& /*filter*/) 
-        { 
-            //not interested
-        }
-        void visit(expression<FeatureT>& exp)
-        {
-            property<FeatureT>* pf;
-            if ((pf = dynamic_cast<property<FeatureT>*>(&exp)))
-            {
-                names_.insert(pf->name());
-            }
-        }
-        std::string const& text() const
-        {
-            return text_;
-        }
-	
-        virtual ~filter_to_string() {}
-    private:
-        filter_to_string(filter_to_string const&);
-        filter_to_string& operator=(filter_to_string const&);
-    };
-}
-
-#endif //FILTER_TO_STRING

Deleted: trunk/include/filter_factory.hpp
===================================================================
--- trunk/include/filter_factory.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/filter_factory.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,60 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef FILTER_FACTORY_HPP
-#define FILTER_FACTORY_HPP
-
-#include "filter_parser.hpp"
-
-using std::string;
-
-namespace mapnik
-{
-    template<typename FeatureT>
-    class MAPNIK_DECL filter_factory
-    {
-    public:
-        static filter_ptr compile(string const& str)
-        {
-            stack<shared_ptr<filter<FeatureT> > > filters;
-            stack<shared_ptr<expression<FeatureT> > > exps;
-            filter_grammar<FeatureT> grammar(filters,exps);
-            char const *text = str.c_str();
-            parse_info<> info = parse(text,text+strlen(text),grammar,space_p);
-            if (info.full && !filters.empty())
-            {
-                return filters.top();	
-            }
-            else 
-            {
-                clog << "failed at :" << info.stop << "\n";
-                return filter_ptr(new none_filter<FeatureT>());
-            }  
-        }
-    };
-
-    MAPNIK_DECL filter_ptr create_filter (std::string const& wkt);
-}
-
-#endif //FILTER_FACTORY_HPP

Deleted: trunk/include/filter_parser.hpp
===================================================================
--- trunk/include/filter_parser.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/filter_parser.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,447 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-
-//$Id$
-
-#ifndef FILTER_PARSER_HPP
-#define FILTER_PARSER_HPP
-
-#include <stack>
-#include <iostream>
-
-#include <boost/shared_ptr.hpp>
-#include <boost/spirit/core.hpp>
-#include <boost/spirit/symbols.hpp>
-#include <boost/spirit/utility/confix.hpp>
-#include <boost/spirit/utility/escape_char.hpp>
-#include <boost/spirit/utility/chset.hpp> 
-
-#include "value.hpp"
-#include "comparison.hpp"
-#include "math_expr.hpp"
-#include "expression.hpp"
-#include "filter.hpp"
-#include "regex_filter.hpp"
-#include "logical.hpp"
-
-using namespace boost::spirit;
-using std::string;
-using std::clog;
-using std::stack;
-
-namespace mapnik
-{    
-    template <typename FeatureT>
-    struct push_integer
-    {
-        push_integer(stack<shared_ptr<expression<FeatureT> > >& exprs)
-            : exprs_(exprs) {}
-	
-        void operator() (int val) const
-        {
-            exprs_.push(shared_ptr<expression<FeatureT> >(new literal<FeatureT>(val)));
-        }
-        stack<shared_ptr<expression<FeatureT> > >& exprs_;
-    };
-   
-    template <typename FeatureT>
-    struct push_real
-    {
-        push_real(stack<shared_ptr<expression<FeatureT> > >& exprs)
-            : exprs_(exprs) {}
-        void operator() (double val) const
-        {
-            exprs_.push(shared_ptr<expression<FeatureT> >(new literal<FeatureT>(val)));
-        }
-        stack<shared_ptr<expression<FeatureT> > >& exprs_;
-    };
-    
-    template <typename FeatureT>
-    struct push_string
-    {
-        push_string(stack<shared_ptr<expression<FeatureT> > >& exprs)
-            : exprs_(exprs) {}
-	
-        template <typename Iter>
-        void operator() (Iter start,Iter end) const
-        {
-            string str(start,end);
-            char quote='\\';
-            string::size_type idx;
-            idx = str.find(quote);
-            while (idx != string::npos)
-            {	    		
-                str.erase(idx,1);
-                idx = str.find(quote);
-            }
-            exprs_.push(shared_ptr<expression<FeatureT> >(new literal<FeatureT>(str)));
-        }
-        stack<shared_ptr<expression<FeatureT> > >& exprs_;
-    };
-    
-    template <typename FeatureT>
-    struct push_property
-    {
-        push_property(stack<shared_ptr<expression<FeatureT> > >& exprs)
-            : exprs_(exprs) {}
-	
-        template <typename Iter>
-        void operator() (Iter start,Iter end) const
-        {
-            string str(start,end);
-            exprs_.push(shared_ptr<expression<FeatureT> >(new property<FeatureT>(str)));
-        }
-        stack<shared_ptr<expression<FeatureT> > >& exprs_;
-    };
-
-    template <typename FeatureT,typename Op>
-    struct compose_expression
-    {
-        compose_expression(stack<shared_ptr<expression<FeatureT> > >& exprs)
-            : exprs_(exprs) {}
-
-        template <typename Iter>
-        void operator() (Iter,Iter) const
-        {
-            if (exprs_.size()>=2)
-            {
-                shared_ptr<expression<FeatureT> > right = exprs_.top();
-                exprs_.pop();
-                shared_ptr<expression<FeatureT> > left = exprs_.top();
-                exprs_.pop();
-                if (left && right)
-                {
-                    exprs_.push(shared_ptr<expression<FeatureT> >
-                                (new mapnik::math_expr_b<FeatureT,Op>(*left,*right)));
-                }
-            }
-        }
-        stack<shared_ptr<expression<FeatureT> > >& exprs_;
-    };
-    
-    template <typename FeatureT>
-    struct compose_regex
-    {
-        compose_regex(stack<shared_ptr<filter<FeatureT> > >& filters,
-                      stack<shared_ptr<expression<FeatureT> > >& exprs)
-            : filters_(filters),exprs_(exprs) {}
-
-        template <typename Iter>
-        void operator() (Iter start,Iter end) const
-        {
-            if (exprs_.size()>=1)
-            {
-                shared_ptr<expression<FeatureT> > exp = exprs_.top();
-                exprs_.pop();
-                if (exp)
-                {		    
-                    std::string pattern(start,end);
-                    try 
-                    {
-                        filters_.push(shared_ptr<filter<FeatureT> >(new regex_filter<FeatureT>(*exp,pattern)));
-                    }
-                    catch (...)//boost::regex_error& ex)
-                    {
-                        clog<<"error\n";//ex.what()<<"\n";
-                    }
-		    
-                }
-            }
-        }
-        stack<shared_ptr<filter<FeatureT> > >& filters_;
-        stack<shared_ptr<expression<FeatureT> > >& exprs_;
-    };
-
-  
-    template <typename FeatureT,typename Op>
-    struct compose_filter
-    {
-        compose_filter(stack<shared_ptr<filter<FeatureT> > >& filters,
-                       stack<shared_ptr<expression<FeatureT> > >& exprs)
-            : filters_(filters),exprs_(exprs) {}
-
-        template <typename Iter>
-        void operator() (Iter,Iter) const
-        {
-            if (exprs_.size()>=2)
-            {
-                shared_ptr<expression<FeatureT> > right = exprs_.top();
-                exprs_.pop();
-                shared_ptr<expression<FeatureT> > left = exprs_.top();
-                exprs_.pop();
-                if (left && right)
-                {
-                    filters_.push(shared_ptr<filter<FeatureT> >(new compare_filter<FeatureT,Op>(*left,*right)));
-                }
-            }
-        }
-        stack<shared_ptr<filter<FeatureT> > >& filters_;
-        stack<shared_ptr<expression<FeatureT> > >& exprs_;
-    };
-    
-    template <typename FeatureT>
-    struct compose_and_filter
-    {
-        compose_and_filter(stack<shared_ptr<filter<FeatureT> > >& filters)
-            : filters_(filters) {}
-
-        template <typename Iter>
-        void operator() (Iter,Iter) const
-        {
-            if (filters_.size()>=2)
-            {
-                shared_ptr<filter<FeatureT> > right = filters_.top();
-                filters_.pop();
-                shared_ptr<filter<FeatureT> > left = filters_.top();
-                filters_.pop();
-                if (left && right)
-                {
-                    filters_.push(shared_ptr<filter<FeatureT> >(new logical_and<FeatureT>(*left,*right)));
-                }
-            }
-        }
-        stack<shared_ptr<filter<FeatureT> > >& filters_;
-    };
-    
-    template <typename FeatureT>
-    struct compose_or_filter
-    {
-        compose_or_filter(stack<shared_ptr<filter<FeatureT> > >& filters)
-            : filters_(filters) {}
-
-        template <typename Iter>
-        void operator() (Iter,Iter) const
-        {
-            if (filters_.size()>=2)
-            {
-                shared_ptr<filter<FeatureT> > right = filters_.top();
-                filters_.pop();
-                shared_ptr<filter<FeatureT> > left = filters_.top();
-                filters_.pop();
-                if (left && right)
-                {
-                    filters_.push(shared_ptr<filter<FeatureT> >(new logical_or<FeatureT>(*left,*right)));
-                }
-            }
-        }
-        stack<shared_ptr<filter<FeatureT> > >& filters_;
-    };
-    
-    template <typename FeatureT>
-    struct compose_not_filter
-    {
-        compose_not_filter(stack<shared_ptr<filter<FeatureT> > >& filters)
-            : filters_(filters) {}
-
-        template <typename Iter>
-        void operator() (Iter,Iter) const
-        {
-            if (filters_.size()>=1)
-            {
-                shared_ptr<filter<FeatureT> > filter_ = filters_.top();
-                filters_.pop();
-                if (filter_)
-                {
-                    filters_.push(shared_ptr<filter<FeatureT> >(new logical_not<FeatureT>(*filter_)));
-                }
-            }
-        }
-        stack<shared_ptr<filter<FeatureT> > >& filters_;
-    };
-    
-    template <typename FeatureT>
-    struct filter_grammar : public grammar<filter_grammar<FeatureT> >
-    {
-        filter_grammar(stack<shared_ptr<filter<FeatureT> > >& filters_,
-                       stack<shared_ptr<expression<FeatureT> > >& exprs_)
-            : filters(filters_),exprs(exprs_) {}
-	
-        template <typename ScannerT>
-        struct definition
-        {
-            definition(filter_grammar const& self)
-            {	
-                typedef boost::spirit::chset<wchar_t> chset_t;
-
-                func1_op = "sqrt","sin","cos";
-                func2_op = "min","max";
-                spatial_op = "Equals","Disjoint","Touches","Within","Overlaps",
-                    "Crosses","Intersects","Contains","DWithin","Beyond","BBOX";
-		
-                chset_t BaseChar (L"\x41-\x5A\x61-\x7A\xC0-\xD6\xD8-\xF6\xF8-\xFF\x100-\x131\x134-\x13E"
-                                  L"\x141-\x148\x14A-\x17E\x180-\x1C3\x1CD-\x1F0\x1F4-\x1F5\x1FA-\x217"
-                                  L"\x250-\x2A8\x2BB-\x2C1\x386\x388-\x38A\x38C\x38E-\x3A1\x3A3-\x3CE"
-                                  L"\x3D0-\x3D6\x3DA\x3DC\x3DE\x3E0\x3E2-\x3F3\x401-\x40C\x40E-\x44F"
-                                  L"\x451-\x45C\x45E-\x481\x490-\x4C4\x4C7-\x4C8\x4CB-\x4CC\x4D0-\x4EB"
-                                  L"\x4EE-\x4F5\x4F8-\x4F9\x531-\x556\x559\x561-\x586\x5D0-\x5EA"
-                                  L"\x5F0-\x5F2\x621-\x63A\x641-\x64A\x671-\x6B7\x6BA-\x6BE\x6C0-\x6CE"
-                                  L"\x6D0-\x6D3\x6D5\x6E5-\x6E6\x905-\x939\x93D\x958-\x961\x985-\x98C"
-                                  L"\x98F-\x990\x993-\x9A8\x9AA-\x9B0\x9B2\x9B6-\x9B9\x9DC-\x9DD"
-                                  L"\x9DF-\x9E1\x9F0-\x9F1\xA05-\xA0A\xA0F-\xA10\xA13-\xA28\xA2A-\xA30"
-                                  L"\xA32-\xA33\xA35-\xA36\xA38-\xA39\xA59-\xA5C\xA5E\xA72-\xA74"
-                                  L"\xA85-\xA8B\xA8D\xA8F-\xA91\xA93-\xAA8\xAAA-\xAB0\xAB2-\xAB3"
-                                  L"\xAB5-\xAB9\xABD\xAE0\xB05-\xB0C\xB0F-\xB10\xB13-\xB28\xB2A-\xB30"
-                                  L"\xB32-\xB33\xB36-\xB39\xB3D\xB5C-\xB5D\xB5F-\xB61\xB85-\xB8A"
-                                  L"\xB8E-\xB90\xB92-\xB95\xB99-\xB9A\xB9C\xB9E-\xB9F\xBA3-\xBA4"
-                                  L"\xBA8-\xBAA\xBAE-\xBB5\xBB7-\xBB9\xC05-\xC0C\xC0E-\xC10\xC12-\xC28"
-                                  L"\xC2A-\xC33\xC35-\xC39\xC60-\xC61\xC85-\xC8C\xC8E-\xC90\xC92-\xCA8"
-                                  L"\xCAA-\xCB3\xCB5-\xCB9\xCDE\xCE0-\xCE1\xD05-\xD0C\xD0E-\xD10"
-                                  L"\xD12-\xD28\xD2A-\xD39\xD60-\xD61\xE01-\xE2E\xE30\xE32-\xE33"
-                                  L"\xE40-\xE45\xE81-\xE82\xE84\xE87-\xE88\xE8A\xE8D\xE94-\xE97"
-                                  L"\xE99-\xE9F\xEA1-\xEA3\xEA5\xEA7\xEAA-\xEAB\xEAD-\xEAE\xEB0"
-                                  L"\xEB2-\xEB3\xEBD\xEC0-\xEC4\xF40-\xF47\xF49-\xF69\x10A0-\x10C5"
-                                  L"\x10D0-\x10F6\x1100\x1102-\x1103\x1105-\x1107\x1109\x110B-\x110C"
-                                  L"\x110E-\x1112\x113C\x113E\x1140\x114C\x114E\x1150\x1154-\x1155"
-                                  L"\x1159\x115F-\x1161\x1163\x1165\x1167\x1169\x116D-\x116E"
-                                  L"\x1172-\x1173\x1175\x119E\x11A8\x11AB\x11AE-\x11AF\x11B7-\x11B8"
-                                  L"\x11BA\x11BC-\x11C2\x11EB\x11F0\x11F9\x1E00-\x1E9B\x1EA0-\x1EF9"
-                                  L"\x1F00-\x1F15\x1F18-\x1F1D\x1F20-\x1F45\x1F48-\x1F4D\x1F50-\x1F57"
-                                  L"\x1F59\x1F5B\x1F5D\x1F5F-\x1F7D\x1F80-\x1FB4\x1FB6-\x1FBC\x1FBE"
-                                  L"\x1FC2-\x1FC4\x1FC6-\x1FCC\x1FD0-\x1FD3\x1FD6-\x1FDB\x1FE0-\x1FEC"
-                                  L"\x1FF2-\x1FF4\x1FF6-\x1FFC\x2126\x212A-\x212B\x212E\x2180-\x2182"
-                                  L"\x3041-\x3094\x30A1-\x30FA\x3105-\x312C\xAC00-\xD7A3");
-            
-                chset_t Ideographic(L"\x4E00-\x9FA5\x3007\x3021-\x3029");
-                chset_t Letter = BaseChar | Ideographic;
-	    
-                chset_t CombiningChar(L"\x0300-\x0345\x0360-\x0361\x0483-\x0486\x0591-\x05A1\x05A3-\x05B9"
-                                      L"\x05BB-\x05BD\x05BF\x05C1-\x05C2\x05C4\x064B-\x0652\x0670"
-                                      L"\x06D6-\x06DC\x06DD-\x06DF\x06E0-\x06E4\x06E7-\x06E8\x06EA-\x06ED"
-                                      L"\x0901-\x0903\x093C\x093E-\x094C\x094D\x0951-\x0954\x0962-\x0963"
-                                      L"\x0981-\x0983\x09BC\x09BE\x09BF\x09C0-\x09C4\x09C7-\x09C8"
-                                      L"\x09CB-\x09CD\x09D7\x09E2-\x09E3\x0A02\x0A3C\x0A3E\x0A3F"
-                                      L"\x0A40-\x0A42\x0A47-\x0A48\x0A4B-\x0A4D\x0A70-\x0A71\x0A81-\x0A83"
-                                      L"\x0ABC\x0ABE-\x0AC5\x0AC7-\x0AC9\x0ACB-\x0ACD\x0B01-\x0B03\x0B3C"
-                                      L"\x0B3E-\x0B43\x0B47-\x0B48\x0B4B-\x0B4D\x0B56-\x0B57\x0B82-\x0B83"
-                                      L"\x0BBE-\x0BC2\x0BC6-\x0BC8\x0BCA-\x0BCD\x0BD7\x0C01-\x0C03"
-                                      L"\x0C3E-\x0C44\x0C46-\x0C48\x0C4A-\x0C4D\x0C55-\x0C56\x0C82-\x0C83"
-                                      L"\x0CBE-\x0CC4\x0CC6-\x0CC8\x0CCA-\x0CCD\x0CD5-\x0CD6\x0D02-\x0D03"
-                                      L"\x0D3E-\x0D43\x0D46-\x0D48\x0D4A-\x0D4D\x0D57\x0E31\x0E34-\x0E3A"
-                                      L"\x0E47-\x0E4E\x0EB1\x0EB4-\x0EB9\x0EBB-\x0EBC\x0EC8-\x0ECD"
-                                      L"\x0F18-\x0F19\x0F35\x0F37\x0F39\x0F3E\x0F3F\x0F71-\x0F84"
-                                      L"\x0F86-\x0F8B\x0F90-\x0F95\x0F97\x0F99-\x0FAD\x0FB1-\x0FB7\x0FB9"
-                                      L"\x20D0-\x20DC\x20E1\x302A-\x302F\x3099\x309A");
-	    
-                chset_t Digit(L"\x0030-\x0039\x0660-\x0669\x06F0-\x06F9\x0966-\x096F\x09E6-\x09EF"
-                              L"\x0A66-\x0A6F\x0AE6-\x0AEF\x0B66-\x0B6F\x0BE7-\x0BEF\x0C66-\x0C6F"
-                              L"\x0CE6-\x0CEF\x0D66-\x0D6F\x0E50-\x0E59\x0ED0-\x0ED9\x0F20-\x0F29");
-		
-                chset_t Extender(L"\x00B7\x02D0\x02D1\x0387\x0640\x0E46\x0EC6\x3005\x3031-\x3035"
-                                 L"\x309D-\x309E\x30FC-\x30FE");
-		
-                chset_t NameChar =
-                    Letter 
-                    | Digit 
-                    | L'.'
-                    | L'-'
-                    | L'_'
-                    | L':'
-                    | CombiningChar 
-                    | Extender;
-				
-                number = strict_real_p [push_real<FeatureT>(self.exprs)] 
-                    | int_p [push_integer<FeatureT>(self.exprs)];
-		
-                string_ = confix_p(L'\'',(*lex_escape_ch_p)
-                                   [push_string<FeatureT>(self.exprs)],
-                                   L'\'');
-		
-                property = L'[' >> ( (Letter | L'_' | L':') 
-                                     >> *NameChar )[push_property<FeatureT>(self.exprs)] >> L']';
-		
-                literal = number | string_ | property;
-		
-                function = literal | ( func1_op >> L'('>> literal >> L')') | 
-                    (func2_op >> L'(' >> literal >> L','>> literal >> L')');
-		
-                factor = function 
-                    | L'(' >> or_expr >> L')'
-                    | ( L'-' >> factor) 
-                    ;
-                term = factor
-                    >> *((L'*' >> factor) [compose_expression<FeatureT,mapnik::mult<value> >(self.exprs)] 
-                         | (L'/' >> factor) [compose_expression<FeatureT,mapnik::div<value> >(self.exprs)]);
-		
-                expression = term >> *((L'+' >> term) [compose_expression<FeatureT,mapnik::add<value> >(self.exprs)] 
-                                       | (L'-' >> term) [compose_expression<FeatureT,mapnik::sub<value> >(self.exprs)]);
-
-                regex = str_p(L".match")>>L'('>>confix_p(L'\'',(*lex_escape_ch_p)
-                                                         [compose_regex<FeatureT>(self.filters,self.exprs)],
-                                                         L'\'') >>L')';
-
-                relation   = expression 
-                    >> *((L">=" >> expression) 
-                         [compose_filter<FeatureT,greater_than_or_equal<value> >(self.filters,self.exprs)]
-                         | (L'>' >> expression)
-                         [compose_filter<FeatureT,mapnik::greater_than<value> >(self.filters,self.exprs)]
-                         | (L'<' >> expression)
-                         [compose_filter<FeatureT,mapnik::less_than<value> >(self.filters,self.exprs)]
-                         | (L"<=" >> expression)
-                         [compose_filter<FeatureT,less_than_or_equal<value> >(self.filters,self.exprs)]
-                         | regex );
-
-                equation = relation >> *( ( L'=' >> relation)
-                                          [compose_filter<FeatureT,mapnik::equals<value> >(self.filters,self.exprs)]
-                                          | ( L"<>" >> relation)
-                                          [compose_filter<FeatureT,not_equals<value> >(self.filters,self.exprs)]);
-
-                not_expr = equation | *(str_p(L"not") >> equation)[compose_not_filter<FeatureT>(self.filters)];
-
-                and_expr = not_expr >> *(L"and" >> not_expr)[compose_and_filter<FeatureT>(self.filters)];
-
-                or_expr  = and_expr >> *(L"or" >> and_expr)[compose_or_filter<FeatureT>(self.filters)];
-
-                filter_statement = or_expr;	
-            }
-	    
-            boost::spirit::rule<ScannerT> const& start() const
-            {
-                return filter_statement;
-            }
-	    	    
-            boost::spirit::rule<ScannerT> factor; 
-            boost::spirit::rule<ScannerT> term;
-            boost::spirit::rule<ScannerT> expression;
-            boost::spirit::rule<ScannerT> relation;
-            boost::spirit::rule<ScannerT> equation;
-            boost::spirit::rule<ScannerT> not_expr;
-            boost::spirit::rule<ScannerT> and_expr;
-            boost::spirit::rule<ScannerT> or_expr;
-	    
-            boost::spirit::rule<ScannerT> filter_statement;   
-            boost::spirit::rule<ScannerT> literal;
-            boost::spirit::rule<ScannerT> number;
-            boost::spirit::rule<ScannerT> string_;
-            boost::spirit::rule<ScannerT> property;
-            boost::spirit::rule<ScannerT> function;
-            boost::spirit::rule<ScannerT> regex;
-            symbols<string> func1_op;
-            symbols<string> func2_op;
-            symbols<string> spatial_op;
-        };
-        stack<shared_ptr<filter<FeatureT> > >& filters;
-        stack<shared_ptr<expression<FeatureT> > >& exprs;
-    };    
-}
-
-#endif //FILTER_PARSER_HPP 

Deleted: trunk/include/filter_parser_ast.hpp
===================================================================
--- trunk/include/filter_parser_ast.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/filter_parser_ast.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,265 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef FILTER_PARSER_AST_HPP
-#define FILTER_PARSER_AST_HPP
-
-#include <boost/spirit/core.hpp>
-#include <boost/spirit/tree/ast.hpp>
-
-#include <iostream>
-
-using namespace std;
-using namespace boost::spirit;
-
-namespace mapnik
-{
-    struct filter_grammar_ast : public grammar<filter_grammar_ast>
-    {
-	
-	static const int integerID = 1;
-	static const int realID = 2;
-	static const int stringID = 3;
-	static const int propertyID = 4;
-	static const int factorID = 5;
-	static const int termID = 6;
-	static const int expressionID = 7;
-	static const int relationID = 8;
-	static const int equationID = 9;
-	static const int and_exprID = 10;
-	static const int or_exprID = 11;
-	
-	template <typename ScannerT>
-	struct definition
-	{
-	    
-	    definition(filter_grammar_ast const& /*self*/)
-	    {			
-		real = leaf_node_d[strict_real_p];
-		integer    = leaf_node_d[int_p];
-		number = real | integer;
-		
-		string_ = inner_node_d['\''>> leaf_node_d[( (alpha_p | '_')  >> 
-					     * (alnum_p | '_' ))] >>  '\''];
-		
-		property = inner_node_d['[' >> leaf_node_d[ ( (alpha_p | '_') >> * (alnum_p | '_' )) ] >> ']'];
-		
-		literal = number | string_ | property;
-		
-		factor = literal 
-		    | (root_node_d[str_p("not")] >> literal) 
-		    | inner_node_d[ch_p('(') >> or_expr >> ch_p(')') ]
-		    | (root_node_d[ch_p('-')] >> factor)
-		    ;
-		
-		term = factor
-		    >> *((root_node_d[ch_p('*')] >> factor) | (root_node_d[ch_p('/')] >> factor));
-		
-		expression = term >> *((root_node_d[ch_p('+')] >> term) | (root_node_d[ch_p('-')] >> term));
-		relation   = expression >> *((root_node_d[str_p(">=")] >> expression) 
-					     | (root_node_d[ch_p('>')] >> expression)
-					     | (root_node_d[ch_p('<')] >> expression)
-					     | (root_node_d[str_p("<=")] >> expression));
-		
-		equation = relation >> *( (root_node_d[ch_p('=')] >> relation)
-					  | (root_node_d[str_p("<>")] >> relation));
-		and_expr = equation >> *(root_node_d[str_p("and")] >> equation);
-		or_expr  = and_expr >> *(root_node_d[str_p("or")] >> and_expr);
-		
-		//spatial_op = str_p("Equals") | "Disjoint" | "Touches" | "Within" 
-		//   | "Overlaps" | "Crosses" | "Intersects" | "Contains" | "DWithin" | "Beyond" | "BBOX";
-
-		filter_statement = or_expr;
-	    }
-	    
-	    rule<ScannerT> const& start() const
-	    {
-		return filter_statement;
-	    }
-	    	    
-	    rule<ScannerT,parser_context<>, parser_tag<factorID> > factor; 
-	    rule<ScannerT,parser_context<>, parser_tag<termID> > term;
-	    rule<ScannerT,parser_context<>, parser_tag<expressionID> > expression;
-	    rule<ScannerT,parser_context<>, parser_tag<relationID> > relation;
-	    rule<ScannerT,parser_context<>, parser_tag<equationID> > equation;
-	    
-	    rule<ScannerT,parser_context<>, parser_tag<and_exprID> > and_expr;
-	    rule<ScannerT,parser_context<>, parser_tag<or_exprID> > or_expr;
-	    
-	    rule<ScannerT> filter_statement;
-	    rule<ScannerT> literal,number;
-	    
-	    rule<ScannerT,parser_context<>, parser_tag<integerID> > integer;
-	    rule<ScannerT,parser_context<>, parser_tag<realID> > real;
-	    rule<ScannerT,parser_context<>, parser_tag<stringID> > string_;
-	    rule<ScannerT,parser_context<>, parser_tag<propertyID> > property;
-	    
-
-	    //rule<ScannerT> spatial_op;
-
-	};
-	
-    }; 
-
-    class node_data
-    {
-    public:
-	enum  {
-	    Unknown=0,
-	    Integer=1,
-	    Real   =2,
-	    String =3,
-	    Property=4
-	};
-	node_data()
-	    : type_(Unknown) {}
-
-	node_data(int type)
-	    : type_(type) {}
-    
-	node_data(node_data const& other)
-	    : type_(other.type_) {}
-    
-	node_data& operator=(node_data const& other)
-	{
-	    if (this==&other) 
-		return *this;
-	    type_=other.type_;
-	    return *this;
-	}
-	~node_data() {}
-    private:
-	int type_;    
-    };
-
-    typedef char const* iterator_t;
-    typedef node_val_data_factory<node_data> factory_t;
-    typedef tree_match<iterator_t,factory_t>::tree_iterator iter_t;
-
-    void process_node(iter_t const&,string&);
-    
-    void walk_ast_tree(tree_parse_info<iterator_t,factory_t> info,string& text)
-    {
-	process_node(info.trees.begin(),text);
-    }
-    
-    void process_node(iter_t const& i,string& text)
-    {
-	//clog << "In eval_expression. i->value = " <<
-	//   string(i->value.begin(), i->value.end()) <<
-	//   " i->children.size() = " << i->children.size() << endl;
-	//std::clog<<typeid(*i).name()<<"\n";
-
-	if (i->value.id() == filter_grammar_ast::integerID)
-	{	
-	    assert(i->children.size()==0);
-	    string integer(i->value.begin(), i->value.end());	
-	    text+= integer;
-	}
-	else if (i->value.id() == filter_grammar_ast::realID)
-	{	
-	    assert(i->children.size()==0);
-	    string real(i->value.begin(), i->value.end());
-	    text += real;
-	}
-	else if (i->value.id() == filter_grammar_ast::stringID)
-	{	
-	    assert(i->children.size()==0);
-	    string str(i->value.begin(), i->value.end());
-	    text += str;
-	}
-	else if (i->value.id() == filter_grammar_ast::propertyID)
-	{
-	    assert(i->children.size()==0);
-	    string property_name(i->value.begin(), i->value.end());
-	    text += property_name;
-	}
-	else if (i->value.id() == filter_grammar_ast::expressionID)
-	{
-	    assert(i->children.size() == 2);
-	    assert(!i->children.begin()->value.is_root());
-	    process_node(i->children.begin(),text);	     
-	    text += string(i->value.begin(), i->value.end());
-	    process_node(i->children.begin()+1,text);
-	    
-	    text +="\n";
-	}
-	else if (i->value.id() == filter_grammar_ast::termID)
-	{
-	    assert(i->children.size() == 2);
-	    assert(!i->children.begin()->value.is_root());
-	    process_node(i->children.begin(),text);
-	    text +=  string(i->value.begin(), i->value.end());
-	    process_node(i->children.begin()+1,text);
-	    
-	    text +="\n";
-	
-	}
-	else if (i->value.id() == filter_grammar_ast::relationID)
-	{
-	    assert(i->children.size() == 2);
-	    assert(!i->children.begin()->value.is_root());
-	    process_node(i->children.begin(),text);
-	    text += string(i->value.begin(), i->value.end());
-	    process_node(i->children.begin()+1,text);
-	    
-	    text +="\n";
-
-	}
-	else if (i->value.id() == filter_grammar_ast::equationID)
-	{
-	    assert(i->children.size() == 2);
-	    assert(!i->children.begin()->value.is_root());
-	    process_node(i->children.begin(),text);
-	    text += string(i->value.begin(), i->value.end());
-	    process_node(i->children.begin()+1,text);
-	    
-	    text +="\n";
-	}
-	else if (i->value.id() == filter_grammar_ast::and_exprID)
-	{
-	    assert(i->children.size() == 2);
-	    assert(!i->children.begin()->value.is_root());
-	    process_node(i->children.begin(),text);
-	    text += string(i->value.begin(), i->value.end());
-	    process_node(i->children.begin()+1,text);
-	    
-	    text +="\n";
-	}
-	else if (i->value.id() == filter_grammar_ast::or_exprID)
-	{
-	    assert(i->children.size() == 2);
-	    assert(!i->children.begin()->value.is_root());
-            
-	    process_node(i->children.begin(),text);
-	    text += string(i->value.begin(), i->value.end());
-	    process_node(i->children.begin()+1,text);
-	    
-	    text +="\n";
-
-	}
-    }   
-}
-
-#endif //FILTER_PARSER_AST_HPP 

Deleted: trunk/include/filter_visitor.hpp
===================================================================
--- trunk/include/filter_visitor.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/filter_visitor.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,48 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef FILTER_VISITOR_HPP
-#define FILTER_VISITOR_HPP
-
-#include "filter.hpp"
-#include "expression.hpp"
-
-namespace mapnik
-{
-    template <typename FeatureT> class filter;
-    template <typename FeatureT> class expression;
-    template <typename FeatureT> class expression;
-    template <typename Feature,template <typename> class Filter> class rule;
-    template <typename FeatureT>
-    class filter_visitor
-    {
-	public:
-		virtual void visit(filter<FeatureT>& filter)=0;
-		virtual void visit(expression<FeatureT>&)=0;
-		virtual void visit(rule<FeatureT,filter> const& r)=0;
-		virtual ~filter_visitor() {}
-    };    
-}
-
-#endif //FILTER_VISITOR_HPP

Deleted: trunk/include/font_engine_freetype.hpp
===================================================================
--- trunk/include/font_engine_freetype.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/font_engine_freetype.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,432 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#if !defined FONT_ENGINE_FREETYPE_HPP
-#define FONT_ENGINE_FREETYPE_HPP
-
-extern "C"
-{
-  #include <ft2build.h>
-  #include FT_FREETYPE_H
-  #include FT_GLYPH_H
-}
-
-#include <boost/shared_ptr.hpp>
-#include <boost/utility.hpp>
-#include <boost/ptr_container/ptr_vector.hpp>
-#include <boost/thread/mutex.hpp>
-
-#include <string>
-#include <vector>
-#include <map>
-#include <iostream>
-
-#include <color.hpp>
-#include <utils.hpp>
-
-namespace mapnik
-{
-
-  class font_face : boost::noncopyable
-    {
-    public:
-    	font_face(FT_Face face)
-	    : face_(face) {}
-	
-    	std::string  family_name() const
-    	{
-    	    return std::string(face_->family_name);
-    	}
-
-	std::string  style_name() const
-    	{
-    	    return std::string(face_->style_name);
-    	}
-	
-	unsigned num_glyphs() const
-	{
-	    return face_->num_glyphs;
-	}
-
-	FT_GlyphSlot glyph() const
-	{
-	    return face_->glyph;
-	}
-	
-	FT_Face get_face() const
-	{
-	    return face_;
-	}
-	
-	bool set_pixel_sizes(unsigned size)
-	{
-	    if (! FT_Set_Pixel_Sizes( face_, 0, size ))
-		return true;
-	    return false;
-	}
-        
-	
-    	~font_face()
-    	{
-    	    std::clog << "clean up face:" << family_name()<<":" << style_name() << std::endl;
-    	    FT_Done_Face(face_);
-    	}
-	
-    private:
-    	FT_Face face_;
-    };
-    
-    typedef boost::shared_ptr<font_face> face_ptr;
-    
-    class MAPNIK_DECL freetype_engine : public mapnik::singleton<freetype_engine,mapnik::CreateStatic>,
-        private boost::noncopyable
-    {
-        friend class mapnik::CreateStatic<freetype_engine>;
-    public:
-
-        static bool register_font(std::string const& file_name);
-        static std::vector<std::string> face_names ();
-        static face_ptr create_face(std::string const& family_name);
-
-    private:
-        freetype_engine();
-        virtual ~freetype_engine();
-        static FT_Library library_;
-        static std::map<std::string,std::string> name2file_;
-    }; 
-    
-    template <typename T>
-    class MAPNIK_DECL face_manager : private boost::noncopyable
-    {
-	typedef T font_engine_type;
-	typedef std::map<std::string,face_ptr> faces;
-	
-    public:
-        face_ptr get_face(std::string const& name)
-        {
-            typename faces::iterator itr;
-            itr = faces_.find(name);
-            if (itr != faces_.end())
-            {
-                return itr->second;
-            }
-            else
-            {
-                face_ptr face = font_engine_type::instance()->create_face(name);
-                if (face)
-                {
-                    faces_.insert(make_pair(name,face));
-                }
-                return face;	
-            }
-        }
-    private:
-	faces faces_;
-    };
-        
-    inline std::wstring to_unicode(std::string const& text)
-    {
-	std::wstring out;
-	unsigned long code = 0;
-	int expect = 0;
-	std::string::const_iterator itr=text.begin();
-	
-	while ( itr != text.end())
-	{
-	    unsigned p = (*itr++) & 0xff;
-	    if ( p >= 0xc0)
-	    {
-		if ( p < 0xe0)      // U+0080 - U+07ff
-		{
-		    expect = 1;
-		    code = p & 0x1f;
-		}
-		else if ( p < 0xf0)  // U+0800 - U+ffff
-		{
-		    expect = 2;
-		    code = p & 0x0f;
-		}
-		else if ( p  < 0xf8) // U+1000 - U+10ffff
-		{
-		    expect = 3;
-		    code = p & 0x07;
-		}
-		continue;
-	    }
-	    else if (p >= 0x80)
-	    {
-		--expect;
-		if (expect >= 0)
-		{
-		    code <<= 6;
-		    code += p & 0x3f;
-		}
-		if (expect > 0)
-		    continue;
-		expect = 0;
-	    }
-	    else 
-	    {
-		code = p;            // U+0000 - U+007f (ascii)
-	    }
-	    out.push_back(wchar_t(code));
-	}
-	return out;
-    }
-    
-    template <typename T>
-    struct text_renderer : private boost::noncopyable
-    {
-
-	struct glyph_t : boost::noncopyable
-	{
-	    FT_Glyph image;
-	    glyph_t(FT_Glyph image_) : image(image_) {}
-	    ~glyph_t ()	{ FT_Done_Glyph(image);}
-	};
-	
-	typedef boost::ptr_vector<glyph_t> glyphs_t;
-	typedef std::pair<unsigned,unsigned> dimension_t;
-	typedef T pixmap_type;
-	
-	text_renderer (pixmap_type & pixmap, face_ptr face)
-	    : pixmap_(pixmap),
-	      face_(face),
-	      fill_(0,0,0), 
-	      halo_fill_(255,255,255),
-	      halo_radius_(0),
-	      angle_(0.0) {}
-    
-	void set_pixel_size(unsigned size)
-	{
-	    face_->set_pixel_sizes(size);
-	}
-    
-	void set_angle(float angle)
-	{
-	    angle_=angle;
-	}
-
-	void set_fill(mapnik::Color const& fill)
-	{
-	    fill_=fill;
-	}
-    
-	void set_halo_fill(mapnik::Color const& halo)
-	{
-	    halo_fill_=halo;
-	}
-    
-	void set_halo_radius( int radius=1)
-	{
-	    halo_radius_=radius;
-	}
-
-	dimension_t prepare_glyphs(std::string const& text)
-	{
-	    //clear glyphs
-	    glyphs_.clear();
-	    
-	    FT_Matrix matrix;
-	    FT_Vector pen;
-	    FT_Error  error;
-	    
-	    FT_Face face = face_->get_face();
-	    FT_GlyphSlot slot = face->glyph;
-	    FT_Bool use_kerning;
-	    FT_UInt previous = 0;
-	    
-	    pen.x = 0;
-	    pen.y = 0;
-	    
-	    use_kerning = FT_HAS_KERNING(face)>0?true:false;
-	    
-	    FT_BBox bbox;   
-	    bbox.xMin = bbox.yMin = 32000; 
-	    bbox.xMax = bbox.yMax = -32000; //hmm?? 
-	    
-	    for (std::string::const_iterator i=text.begin();i!=text.end();++i)
-	    {
-		FT_BBox glyph_bbox; 
-		FT_Glyph image;
-		
-		matrix.xx = (FT_Fixed)( cos( angle_ ) * 0x10000L ); 
-		matrix.xy = (FT_Fixed)(-sin( angle_ ) * 0x10000L ); 
-		matrix.yx = (FT_Fixed)( sin( angle_ ) * 0x10000L ); 
-		matrix.yy = (FT_Fixed)( cos( angle_ ) * 0x10000L );
-	        	
-		FT_Set_Transform (face,&matrix,&pen);
-		
-		FT_UInt glyph_index = FT_Get_Char_Index( face, unsigned(*i) & 0xff );
-		
-		if ( use_kerning && previous && glyph_index)
-		{
-		    FT_Vector delta;
-		    FT_Get_Kerning(face,previous,glyph_index,
-				   FT_KERNING_DEFAULT,&delta);
-		    pen.x += delta.x;
-		    pen.y += delta.y;
-		}
-		
-		error = FT_Load_Glyph (face,glyph_index,FT_LOAD_DEFAULT); 
-		if ( error )
-		    continue;
-		
-		error = FT_Get_Glyph( face->glyph, &image);
-		if ( error )
-		    continue;
-		
-		FT_Glyph_Get_CBox(image,ft_glyph_bbox_pixels, &glyph_bbox); 
-		if (glyph_bbox.xMin < bbox.xMin) 
-		    bbox.xMin = glyph_bbox.xMin; 
-		if (glyph_bbox.yMin < bbox.yMin) 
-		    bbox.yMin = glyph_bbox.yMin; 
-		if (glyph_bbox.xMax > bbox.xMax) 
-		    bbox.xMax = glyph_bbox.xMax; 
-		if (glyph_bbox.yMax > bbox.yMax) 
-		    bbox.yMax = glyph_bbox.yMax;
-		
-		if ( bbox.xMin > bbox.xMax )
-		{
-		    bbox.xMin = 0; 
-		    bbox.yMin = 0; 
-		    bbox.xMax = 0; 
-		    bbox.yMax = 0; 
-		}
-		
-		pen.x += slot->advance.x;
-		pen.y += slot->advance.y;
-		
-		previous = glyph_index;
-		// take ownership of the glyph
-		glyphs_.push_back(new glyph_t(image));
-	    }
-	    
-	    unsigned string_width = (bbox.xMax - bbox.xMin); 
-	    unsigned string_height = (bbox.yMax - bbox.yMin);
-	    return dimension_t(string_width,string_height);
-	}
-	
-	void render(double x0, double y0)
-	{
-	    FT_Error  error;
-	    FT_Vector start;
-	    unsigned height = pixmap_.height();
-	    
-	    start.x = unsigned(x0 * (1 << 6)); 
-	    start.y = unsigned((height - y0) * (1 << 6));
-	    // now render transformed glyphs
-	    typename glyphs_t::iterator pos;
-
-	    if (halo_radius_ > 0)
-	    {
-		//render halo 
-		for ( pos = glyphs_.begin(); pos != glyphs_.end();++pos)
-		{
-	    
-		    FT_Glyph_Transform(pos->image,0,&start);
-	    
-		    error = FT_Glyph_To_Bitmap( &(pos->image),FT_RENDER_MODE_NORMAL,0,1);
-		    if ( ! error )
-		    {
-			
-			FT_BitmapGlyph bit = (FT_BitmapGlyph)pos->image;
-			render_halo(&bit->bitmap, halo_fill_.rgba(), 
-				    bit->left,
-				    height - bit->top,halo_radius_);
-		    }
-		}  
-	    }
-	    //render actual text
-	    for ( pos = glyphs_.begin(); pos != glyphs_.end();++pos)
-	    {
-	    
-		FT_Glyph_Transform(pos->image,0,&start);
-	    
-		error = FT_Glyph_To_Bitmap( &(pos->image),FT_RENDER_MODE_NORMAL,0,1);
-		if ( ! error )
-		{
-		   
-		    FT_BitmapGlyph bit = (FT_BitmapGlyph)pos->image;
-		    render_bitmap(&bit->bitmap, fill_.rgba(), 
-				  bit->left,
-				  height - bit->top);
-		}
-	    }  
-	}
-   	
-    private:
-    
-	void render_halo(FT_Bitmap *bitmap,unsigned rgba,int x,int y,int radius)
-	{
-	    int x_max=x+bitmap->width;
-	    int y_max=y+bitmap->rows;
-	    int i,p,j,q;
-	
-	    for (i=x,p=0;i<x_max;++i,++p)
-	    {
-		for (j=y,q=0;j<y_max;++j,++q)
-		{
-		    int gray = bitmap->buffer[q*bitmap->width+p];
-		    if (gray)
-		    {
-			for (int n=-halo_radius_; n <=halo_radius_; ++n)
-			    for (int m=-halo_radius_;m <= halo_radius_; ++m)
-				pixmap_.blendPixel(i+m,j+n,rgba,gray);		        
-		    }
-		}
-	    }
-	}
-    
-	void render_bitmap(FT_Bitmap *bitmap,unsigned rgba,int x,int y)
-	{
-	    int x_max=x+bitmap->width;
-	    int y_max=y+bitmap->rows;
-	    int i,p,j,q;
-	
-	    for (i=x,p=0;i<x_max;++i,++p)
-	    {
-		for (j=y,q=0;j<y_max;++j,++q)
-		{
-		    int gray=bitmap->buffer[q*bitmap->width+p];
-		    if (gray)
-		    {
-			pixmap_.blendPixel(i,j,rgba,gray);
-		    }
-		}
-	    }
-	}
-    
-	pixmap_type & pixmap_;
-	face_ptr face_;
-	mapnik::Color fill_;
-	mapnik::Color halo_fill_;
-	int halo_radius_;
-	float angle_;
-	glyphs_t glyphs_;
-    }; 
-}
-
-
-#endif // FONT_ENGINE_FREETYPE_HPP

Deleted: trunk/include/gamma.hpp
===================================================================
--- trunk/include/gamma.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/gamma.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,51 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: gamma.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef GAMMA_HPP
-#define GAMMA_HPP
-
-namespace mapnik 
-{
-    struct MAPNIK_DECL gamma
-    {
-	unsigned char g2l[256];
-	unsigned char l2g[256];
-	gamma(double gamma=2.0)
-	{
-	    int result;
-	    for (int i=0;i< 256;i++)
-	    {
-		result=(int)(pow(i/255.0,gamma) * 255.0 + 0.5);
-		g2l[i]=(unsigned char)result;
-	    }
-	    for (int i = 0; i < 256; i++)
-	    {
-		result = (int)(pow(i/255.0, 1/gamma) * 255.0 + 0.5);
-		l2g[i] = (unsigned char)result;
-	    }
-	}
-    };
-}
-
-#endif  //GAMMA_HPP

Deleted: trunk/include/geom_util.hpp
===================================================================
--- trunk/include/geom_util.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/geom_util.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,189 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: geom_util.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef GEOM_UTIL_HPP
-#define GEOM_UTIL_HPP
-
-#include <cmath>
-
-namespace mapnik
-{
-
-    template <typename T>
-    bool clip_test(T p,T q,double& tmin,double& tmax)
-    {
-        double r;
-        bool result=true;
-        if (p<0.0)
-        {
-            r=q/p;
-            if (r>tmax) result=false;
-            else if (r>tmin) tmin=r;
-        }
-        else if (p>0.0)
-        {
-            r=q/p;
-            if (r<tmin) result=false;
-            else if (r<tmax) tmax=r;
-        } else if (q<0.0) result=false;
-        return result;
-    }
-
-    template <typename T,typename Image>
-    bool clip_line(T& x0,T& y0,T& x1,T& y1,Envelope<T> const& box)
-    {
-        double tmin=0.0;
-        double tmax=1.0;
-        double dx=x1-x0;
-        if (clip_test<double>(-dx,x0,tmin,tmax))
-        {
-            if (clip_test<double>(dx,box.width()-x0,tmin,tmax))
-            {
-                double dy=y1-y0;
-                if (clip_test<double>(-dy,y0,tmin,tmax))
-                {
-                    if (clip_test<double>(dy,box.height()-y0,tmin,tmax))
-                    {
-                        if (tmax<1.0)
-                        {
-                            x1=static_cast<T>(x0+tmax*dx);
-                            y1=static_cast<T>(y0+tmax*dy);
-                        }
-                        if (tmin>0.0)
-                        {
-                            x0+=static_cast<T>(tmin*dx);
-                            y0+=static_cast<T>(tmin*dy);
-                        }
-                        return true;
-                    }
-                }
-            }
-        }
-        return false;
-    }
-    
-    template <typename Iter> 
-    inline bool point_inside_path(double x,double y,Iter start,Iter end)
-    {
-        bool inside=false;
-        double x0=boost::get<0>(*start);
-        double y0=boost::get<1>(*start);
-        
-        double x1,y1;
-        while (++start!=end) 
-        {
-            if ( boost::get<2>(*start) == SEG_MOVETO)
-            {
-                x0 = boost::get<0>(*start);
-                y0 = boost::get<1>(*start);
-                continue;
-            }		
-            x1=boost::get<0>(*start);
-            y1=boost::get<1>(*start);
-            
-            if ((((y1 <= y) && (y < y0)) ||
-                 ((y0 <= y) && (y < y1))) &&
-                ( x < (x0 - x1) * (y - y1)/ (y0 - y1) + x1))
-                inside=!inside;
-            x0=x1;
-            y0=y1;
-        }
-    	return inside;
-    }
-
-#define TOL 0.00001
-
-    /*
-      (Ay-Cy)(Bx-Ax)-(Ax-Cx)(By-Ay)
-      s = -----------------------------
-      L^2
-    */
-
-    inline bool point_in_circle(double x,double y,double cx,double cy,double r)
-    {
-        double dx = x - cx;
-        double dy = y - cy;
-        double d2 = dx * dx + dy * dy;
-        return (d2 <= r * r);
-    }
-    
-    inline bool point_on_segment(double x,double y,double x0,double y0,double x1,double y1)
-    {	
-        double dx = x1 - x0;
-        double dy = y1 - y0;
-        if ( fabs(dx) > TOL  ||  fabs(dy) > TOL )
-        {
-            double s = (y0 - y) * dx - (x0 - x) * dy;
-            return ( fabs (s) < TOL ) ;
-        } 
-        return false;
-    }
-
-    inline bool point_on_segment2(double x,double y,double x0,double y0,double x1,double y1)
-    {	 
-        double d  = sqrt ((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0));
-        double d0 = sqrt ((x0 - x) * (x0 - x) + (y0 - y) * (y0 - y));
-        double d1 = sqrt ((x1 - x) * (x1 - x) + (y1 - y) * (y1 - y));
-        double d2 = d0 + d1;
-        return ( d2 - d < 0.01);
-    }
-    
-#undef TOL
-    template <typename Iter> 
-    inline bool point_on_path(double x,double y,Iter start,Iter end)
-    {
-        return false;
-    }
-    
-    template <typename Iter> 
-    inline bool point_on_points (double x,double y,Iter start,Iter end) 
-    {
-        return false; 
-    }
-
-    struct filter_in_box
-    {
-        Envelope<double> box_;
-        explicit filter_in_box(const Envelope<double>& box)
-            : box_(box) {}
-
-        bool pass(const Envelope<double>& extent) const
-        {
-            return extent.intersects(box_);
-        }
-    };
-
-    struct filter_at_point
-    {
-        coord2d pt_;
-        explicit filter_at_point(const coord2d& pt)
-            : pt_(pt) {}
-        bool pass(const Envelope<double>& extent) const
-        {
-            return extent.contains(pt_);
-        }
-    };
-}
-
-#endif                                            //GEOM_UTIL_HPP

Deleted: trunk/include/geometry.hpp
===================================================================
--- trunk/include/geometry.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/geometry.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,386 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-
-//$Id: geometry.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef GEOMETRY_HPP
-#define GEOMETRY_HPP
-
-#include "vertex_vector.hpp"
-#include "vertex_transform.hpp"
-#include "ctrans.hpp"
-#include "geom_util.hpp"
-#include <boost/shared_ptr.hpp>
-#include <boost/utility.hpp>
-
-namespace mapnik
-{
-    enum {
-    	Point = 1,
-    	LineString = 2,
-    	Polygon = 3
-    };
-             
-    template <typename T>
-    class geometry : private boost::noncopyable
-    {   
-    public:
-        typedef T vertex_type;
-        typedef typename vertex_type::type value_type;
-    private:
-        int srid_;
-    public:
-        geometry (int srid=-1)
-            : srid_(srid) {}	
-
-        int srid() const
-        {
-            return srid_;
-        }
-	
-        Envelope<double> envelope()
-        {
-            Envelope<double> result;		
-            double x,y;
-            for (unsigned i=0;i<num_points();++i)
-            {
-                vertex(&x,&y);
-                if (i==0)
-                {
-                    result.init(x,y,x,y);
-                }
-                else
-                {
-                    result.expand_to_include(x,y);
-                }
-            }
-            return result;
-        }
-
-        virtual int type() const=0;
-        virtual bool hit_test(value_type x,value_type y) const=0;	
-        virtual void label_position(double *x, double *y) const=0;
-        virtual void move_to(value_type x,value_type y)=0;
-        virtual void line_to(value_type x,value_type y)=0;
-        virtual void transform(const mapnik::CoordTransform& t)=0;
-        virtual unsigned num_points() const = 0;
-        virtual unsigned vertex(double* x, double* y)=0;
-        virtual void rewind(unsigned )=0;
-        virtual void set_capacity(size_t size)=0;
-        virtual ~geometry() {}
-    };
-    
-    template <typename T>
-    class point : public geometry<T>
-    {
-        typedef geometry<T> geometry_base;
-        typedef typename geometry<T>::vertex_type vertex_type;
-        typedef typename geometry<T>::value_type value_type;
-    private:
-        vertex_type pt_;
-    public:
-        point(int srid)
-            : geometry<T>(srid)
-        {}
-	 
-        int type() const 
-        {
-            return Point;
-        }
-        void label_position(double *x, double *y) const
-        {
-            *x = pt_.x;
-            *y = pt_.y;
-        }
-	
-        void move_to(value_type x,value_type y)
-        {
-            pt_.x = x;
-            pt_.y = y;
-        }
-	
-        void line_to(value_type ,value_type ) {}
-	
-        void transform(const mapnik::CoordTransform& t)
-        {
-            t.forward_x(&pt_.x);
-            t.forward_y(&pt_.y);
-        }
-	
-        unsigned num_points() const
-        {
-            return 1;
-        }
-	
-        unsigned vertex(double* x, double* y)
-        {
-            *x = pt_.x;
-            *y = pt_.y;
-            return SEG_LINETO;
-        }
-	
-        void rewind(unsigned ) {}
-	
-        bool hit_test(value_type x,value_type y) const
-        {
-            return false;
-        }
-        void set_capacity(size_t) {}
-        virtual ~point() {}
-    };
-
-    template <typename T, template <typename> class Container=vertex_vector2>
-    class polygon : public geometry<T>
-    {
-        typedef geometry<T> geometry_base;
-        typedef typename geometry<T>::vertex_type vertex_type;
-        typedef typename geometry_base::value_type value_type;
-        typedef Container<vertex_type> container_type;
-    private:
-        container_type cont_;
-        mutable unsigned itr_;
-    public:
-        polygon(int srid)
-            : geometry_base(srid),
-              itr_(0)
-        {}
-        
-        int type() const 
-        {
-            return Polygon;
-        }
-	
-        void label_position(double *x, double *y) const
-        {
-	    
-            unsigned size = cont_.size();
-            if (size < 3) 
-            {
-                cont_.get_vertex(0,x,y);
-                return;
-            }
-	      
-            double ai;
-            double atmp = 0;
-            double xtmp = 0;
-            double ytmp = 0;
-            double x0 =0;
-            double y0 =0;
-            double x1 =0;
-            double y1 =0;
-	    
-            unsigned i,j;
-            for (i = size-1,j = 0; j < size; i = j, ++j)
-            {
-		
-                cont_.get_vertex(i,&x0,&y0);
-                cont_.get_vertex(j,&x1,&y1);
-                ai = x0 * y1 - x1 * y0;
-                atmp += ai;
-                xtmp += (x1 + x0) * ai;
-                ytmp += (y1 + y0) * ai;
-            }	  
-            if (atmp != 0)
-            {
-                *x = xtmp/(3*atmp);
-                *y = ytmp /(3*atmp);
-                return;
-            }
-            *x=x0;
-            *y=y0;	    	    
-        }
-
-        void line_to(value_type x,value_type y)
-        {
-            cont_.push_back(x,y,SEG_LINETO);
-        }
-
-        void move_to(value_type x,value_type y)
-        {
-            cont_.push_back(x,y,SEG_MOVETO);
-        }
-	
-        void transform(mapnik::CoordTransform const& t)
-        {
-            unsigned size = cont_.size();
-            for (unsigned pos=0; pos < size; ++pos)
-            {	
-                cont_.transform_at(pos,t);
-            }
-        }
-	
-        unsigned num_points() const
-        {
-            return cont_.size();
-        }
-	
-        unsigned vertex(double* x, double* y)
-        {
-            return cont_.get_vertex(itr_++,x,y);
-        }
-	
-        void rewind(unsigned )
-        {
-            itr_=0;
-        }
-	
-        bool hit_test(value_type x,value_type y) const
-        {	    
-            return point_inside_path(x,y,cont_.begin(),cont_.end());
-        } 
-        
-        void set_capacity(size_t size) 
-        {
-            cont_.set_capacity(size);
-        }
-        virtual ~polygon() {}
-    };
-    
-    template <typename T, template <typename> class Container=vertex_vector>
-    class line_string : public geometry<T>
-    {
-        typedef geometry<T> geometry_base;
-        typedef typename geometry_base::value_type value_type;
-        typedef typename geometry<T>::vertex_type vertex_type;
-        typedef Container<vertex_type> container_type;
-    private:
-        container_type cont_;
-        mutable unsigned itr_;
-    public:
-        line_string(int srid)
-            : geometry_base(srid),
-              itr_(0)
-        {}
-        
-        int type() const 
-        {
-            return LineString;
-        }
-        void label_position(double *x, double *y) const
-        {
-            // calculate mid point on line string
-            double x0=0;
-            double y0=0;
-            double x1=0;
-            double y1=0;
-	    
-            unsigned size = cont_.size();
-            if (size == 1)
-            {
-                cont_.get_vertex(0,x,y); 
-            }
-            else if (size == 2)
-            {
-
-                cont_.get_vertex(0,&x0,&y0);
-                cont_.get_vertex(1,&x1,&y1);
-                *x = 0.5 * (x1 + x0);
-                *y = 0.5 * (y1 + y0);		
-            }
-            else
-            {
-                double len=0.0;
-                for (unsigned pos = 1; pos < size; ++pos)
-                {
-                    cont_.get_vertex(pos-1,&x0,&y0);
-                    cont_.get_vertex(pos,&x1,&y1);
-                    double dx = x1 - x0;
-                    double dy = y1 - y0;
-                    len += sqrt(dx * dx + dy * dy);
-                }
-                double midlen = 0.5 * len;
-                double dist = 0.0;
-                for (unsigned pos = 1; pos < size;++pos)
-                {
-                    cont_.get_vertex(pos-1,&x0,&y0);
-                    cont_.get_vertex(pos,&x1,&y1);
-                    double dx = x1 - x0;
-                    double dy = y1 - y0; 
-                    double seg_len = sqrt(dx * dx + dy * dy);
-                    if (( dist + seg_len) >= midlen)
-                    {
-                        double r = (midlen - dist)/seg_len;
-                        *x = x0 + (x1 - x0) * r;
-                        *y = y0 + (y1 - y0) * r;
-                        break;
-                    }
-                    dist += seg_len;
-                }
-            }
-	    
-        }
-        void line_to(value_type x,value_type y)
-        {
-            cont_.push_back(x,y,SEG_LINETO);
-        }
-
-        void move_to(value_type x,value_type y)
-        {
-            cont_.push_back(x,y,SEG_MOVETO);
-        }
-	
-        void transform(mapnik::CoordTransform const& t)
-        {
-            unsigned size = cont_.size();
-            for (unsigned pos=0; pos < size; ++pos)
-            {	
-                cont_.transform_at(pos,t);
-            }
-        }
-	
-        unsigned num_points() const
-        {
-            return cont_.size();
-        }
-	
-        unsigned vertex(double* x, double* y)
-        {
-            return cont_.get_vertex(itr_++,x,y);
-        }
-	
-        void rewind(unsigned )
-        {
-            itr_=0;
-        }
-	
-        bool hit_test(value_type x,value_type y) const
-        {	    
-            return false;
-        } 
-	
-        void set_capacity(size_t size) 
-        {
-            cont_.set_capacity(size);
-        }
-        virtual ~line_string() {}
-    };
-
-    typedef point<vertex2d> point_impl;
-    typedef line_string<vertex2d,vertex_vector2> line_string_impl;
-    typedef polygon<vertex2d,vertex_vector2> polygon_impl;
-    
-    typedef geometry<vertex2d> geometry_type;
-    typedef boost::shared_ptr<geometry_type> geometry_ptr;
-}
-
-#endif //GEOMETRY_HPP

Deleted: trunk/include/global.hpp
===================================================================
--- trunk/include/global.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/global.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,61 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef GLOBAL_HPP
-#define GLOBAL_HPP
-
-#include <boost/cstdint.hpp>
-
-namespace mapnik
-{
-    using namespace boost;
-#define int2net(A)  (int32_t) (((uint32_t) ((uint8_t) (A)[1]))      |\
-			      (((uint32_t) ((uint8_t) (A)[0])) << 8))
-
-#define int4net(A)  (int32_t) (((uint32_t) ((uint8_t) (A)[3]))      |\
-			    (((uint32_t) ((uint8_t) (A)[2])) << 8)  |\
-			    (((uint32_t) ((uint8_t) (A)[1])) << 16) |\
-			    (((uint32_t) ((uint8_t) (A)[0])) << 24))
-
-
-    typedef char byte;
-#define float8net(V,M)   do { double def_temp;\
-                              ((byte*) &def_temp)[0]=(M)[7];\
-                              ((byte*) &def_temp)[1]=(M)[6];\
-                              ((byte*) &def_temp)[2]=(M)[5];\
-                              ((byte*) &def_temp)[3]=(M)[4];\
-                              ((byte*) &def_temp)[4]=(M)[3];\
-                              ((byte*) &def_temp)[5]=(M)[2];\
-                              ((byte*) &def_temp)[6]=(M)[1];\
-                              ((byte*) &def_temp)[7]=(M)[0];\
-                              (V) = def_temp; } while(0)
-#define float4net(V,M)   do { float def_temp;\
-                              ((byte*) &def_temp)[0]=(M)[3];\
-                              ((byte*) &def_temp)[1]=(M)[2];\
-                              ((byte*) &def_temp)[2]=(M)[1];\
-                              ((byte*) &def_temp)[3]=(M)[0];\
-                              (V)=def_temp; } while(0)
-}
-
-#endif //GLOBAL_HPP

Deleted: trunk/include/graphics.hpp
===================================================================
--- trunk/include/graphics.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/graphics.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,182 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: graphics.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef GRAPHICS_HPP
-#define GRAPHICS_HPP
-
-#include <cmath>
-#include <string>
-#include <cassert>
-#include "color.hpp"
-#include "gamma.hpp"
-#include "image_data.hpp"
-#include "envelope.hpp"
-
-namespace mapnik
-{
-    class MAPNIK_DECL Image32
-    {
-    private:
-        unsigned width_;
-        unsigned height_;
-        Color background_;
-        ImageData32 data_;
-    public:
-        Image32(int width,int height);
-        Image32(const Image32& rhs);
-        ~Image32();
-        void setBackground(const Color& background);
-        const Color& getBackground() const;     
-        const ImageData32& data() const;
-        
-        inline ImageData32& data() 
-        {
-            return data_;
-        }
-        
-        inline const unsigned char* raw_data() const
-        {
-            return data_.getBytes();
-        }
-	
-        inline unsigned char* raw_data()
-        {
-            return data_.getBytes();
-        }
-	
-        void saveToFile(const std::string& file,const std::string& format="auto"); 
-    private:
-
-        inline bool checkBounds(unsigned x, unsigned y) const
-        {
-            return (x < width_ && y < height_);
-        }
-
-    public:
-        inline void setPixel(int x,int y,unsigned int rgba)
-        {
-            if (checkBounds(x,y))
-            {
-                data_(x,y)=rgba;
-            }
-        }
-        inline void blendPixel(int x,int y,unsigned int rgba1,int t)
-        {
-            if (checkBounds(x,y))
-            {
-                unsigned rgba0 = data_(x,y);	
-                unsigned a1 = t;//(rgba1 >> 24) & 0xff;
-                if (a1 == 0) return;
-                unsigned r1 = rgba1 & 0xff;
-                unsigned g1 = (rgba1 >> 8 ) & 0xff;
-                unsigned b1 = (rgba1 >> 16) & 0xff;
-		
-                unsigned a0 = (rgba0 >> 24) & 0xff;
-                unsigned r0 = (rgba0 & 0xff) * a0;
-                unsigned g0 = ((rgba0 >> 8 ) & 0xff) * a0;
-                unsigned b0 = ((rgba0 >> 16) & 0xff) * a0;
-		
-		
-                a0 = ((a1 + a0) << 8) - a0*a1;
-		
-                r0 = ((((r1 << 8) - r0) * a1 + (r0 << 8)) / a0);
-                g0 = ((((g1 << 8) - g0) * a1 + (g0 << 8)) / a0);
-                b0 = ((((b1 << 8) - b0) * a1 + (b0 << 8)) / a0);
-                a0 = a0 >> 8;
-                data_(x,y)= (a0 << 24)| (b0 << 16) |  (g0 << 8) | (r0) ;
-            }
-        }
-
-        inline unsigned width() const
-        {
-            return width_;
-        }
-	
-        inline unsigned height() const
-        {
-            return height_;
-        }
-
-        inline void set_rectangle(int x0,int y0,ImageData32 const& data)
-        {
-            Envelope<int> ext0(0,0,width_,height_);   
-            Envelope<int> ext1(x0,y0,x0+data.width(),y0+data.height());
-	    
-            if (ext0.intersects(ext1))
-            {	
-                Envelope<int> box = ext0.intersect(ext1);
-                for (int y = box.miny(); y < box.maxy(); ++y)
-                {
-                    for (int x = box.minx(); x < box.maxx(); ++x)
-                    {
-                        if ((data(x-x0,y-y0) & 0xff000000)) 
-                        {
-                            data_(x,y)=data(x-x0,y-y0);
-                        }
-                    }
-                }   
-            }
-        }
-	
-        inline void set_rectangle_alpha(int x0,int y0,const ImageData32& data)
-        {
-            Envelope<int> ext0(0,0,width_,height_);   
-            Envelope<int> ext1(x0,y0,x0 + data.width(),y0 + data.height());
-	    
-            if (ext0.intersects(ext1))
-            {	                		
-                Envelope<int> box = ext0.intersect(ext1);		
-                for (int y = box.miny(); y < box.maxy(); ++y)
-                {
-                    for (int x = box.minx(); x < box.maxx(); ++x)
-                    {
-                        unsigned rgba0 = data_(x,y);
-                        unsigned rgba1 = data(x-x0,y-y0);
-		    
-                        unsigned a1 = (rgba1 >> 24) & 0xff;
-                        if (a1 == 0) continue;
-                        unsigned r1 = rgba1 & 0xff;
-                        unsigned g1 = (rgba1 >> 8 ) & 0xff;
-                        unsigned b1 = (rgba1 >> 16) & 0xff;
-		    
-                        unsigned a0 = (rgba0 >> 24) & 0xff;
-                        unsigned r0 = (rgba0 & 0xff) * a0;
-                        unsigned g0 = ((rgba0 >> 8 ) & 0xff) * a0;
-                        unsigned b0 = ((rgba0 >> 16) & 0xff) * a0;
-		    
-		    
-                        a0 = ((a1 + a0) << 8) - a0*a1;
-		    
-                        r0 = ((((r1 << 8) - r0) * a1 + (r0 << 8)) / a0);
-                        g0 = ((((g1 << 8) - g0) * a1 + (g0 << 8)) / a0);
-                        b0 = ((((b1 << 8) - b0) * a1 + (b0 << 8)) / a0);
-                        a0 = a0 >> 8;
-                        data_(x,y)= (a0 << 24)| (b0 << 16) |  (g0 << 8) | (r0) ;
-                    }
-                }
-            }
-        }
-    };
-}
-#endif //GRAPHICS_HPP

Deleted: trunk/include/image_data.hpp
===================================================================
--- trunk/include/image_data.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/image_data.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,128 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: image_data.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef IMAGE_DATA_HPP
-#define IMAGE_DATA_HPP
-
-#include <cassert>
-
-namespace mapnik 
-{
-    template <class T> class ImageData
-    {
-    private:
-        const unsigned width_;
-        const unsigned height_;
-        T *pData_;
-        ImageData& operator=(const ImageData&);
-    public:
-        ImageData(unsigned width,unsigned height)
-            : width_(width),
-              height_(height),
-              pData_((width!=0 && height!=0)? static_cast<T*>(::operator new(sizeof(T)*width*height)):0)
-        {
-            if (pData_) memset(pData_,0,sizeof(T)*width_*height_);
-        }
-
-        ImageData(const ImageData<T>& rhs)
-            :width_(rhs.width_),
-             height_(rhs.height_),
-             pData_((rhs.width_!=0 && rhs.height_!=0)? new T[rhs.width_*rhs.height_]:0)
-        {
-            if (pData_) memcpy(pData_,rhs.pData_,sizeof(T)*rhs.width_* rhs.height_);
-        }
-        inline T& operator() (unsigned i,unsigned j)
-        {
-            assert(i<width_ && j<height_);
-            return pData_[j*width_+i];
-        }
-        inline const T& operator() (unsigned i,unsigned j) const
-        {
-            assert(i<width_ && j<height_);
-            return pData_[j*width_+i];
-        }
-        inline unsigned width() const
-        {
-            return width_;
-        }
-        inline unsigned height() const
-        {
-            return height_;
-        }
-        inline void set(const T& t)
-        {
-            for (unsigned i=0;i<width_;++i)
-            {
-                for (unsigned j=0;j<height_;++j)
-                {
-                    (*this)(i,j)=t;
-                }
-            }
-        }
-        inline const T* getData() const
-        {
-            return pData_;
-        }
-
-        inline T* getData()
-        {
-            return pData_;
-        }
-
-        inline const unsigned char* getBytes() const
-        {
-            return (unsigned char*)pData_;
-        }
-	
-        inline unsigned char* getBytes()
-        {
-            return (unsigned char*)pData_;
-        }
-	
-        inline const T* getRow(unsigned row) const
-        {
-            return pData_+row*width_;
-        }
-        inline void setRow(unsigned row,const T* buf,unsigned size)
-        {
-            assert(row<height_);
-            assert(size<=(width_*sizeof(T)));
-            memcpy(pData_+row*width_,buf,size*sizeof(T));
-        }
-        inline void setRow(unsigned row,unsigned x0,unsigned x1,const T* buf)
-        {
-            memcpy(pData_+row*width_+x0,buf,(x1-x0)*sizeof(T));
-        }
-
-        inline ~ImageData()
-        {
-            ::operator delete(pData_),pData_=0;
-        }
-	
-    };
-
-    typedef ImageData<unsigned> ImageData32;
-}
-
-#endif //IMAGE_DATA_HPP

Deleted: trunk/include/image_reader.hpp
===================================================================
--- trunk/include/image_reader.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/image_reader.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,66 +0,0 @@
-/*****************************************************************************
-* 
-* This file is part of Mapnik (c++ mapping toolkit)
-*
-* Copyright (C) 2006 Artem Pavlenko
-*
-* This library is free software; you can redistribute it and/or
-* modify it under the terms of the GNU Lesser General Public
-* License as published by the Free Software Foundation; either
-* version 2.1 of the License, or (at your option) any later version.
-*
-* This library is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-* Lesser General Public License for more details.
-*
-* You should have received a copy of the GNU Lesser General Public
-* License along with this library; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*
-*****************************************************************************/
-
-//$Id: image_reader.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef IMAGE_READER_HPP
-#define IMAGE_READER_HPP
-
-#include <stdexcept>
-#include <string>
-
-#include "image_data.hpp"
-#include "config.hpp"
-
-
-namespace mapnik 
-{
-    class ImageReaderException : public std::exception
-    {
-    private:
-        std::string message_;
-    public:
-        ImageReaderException(const std::string& message) 
-            : message_(message) {}
-
-        ~ImageReaderException() throw() {}
-
-        virtual const char* what() const throw()
-        {
-            return message_.c_str();
-        }
-    };
-
-    struct MAPNIK_DECL ImageReader
-    {
-        virtual unsigned width() const=0;
-        virtual unsigned height() const=0;
-        virtual void read(unsigned x,unsigned y,ImageData32& image)=0;
-        virtual ~ImageReader() {}
-    };
-
-    bool register_image_reader(const std::string& type,ImageReader* (*)(const std::string&));
-    MAPNIK_DECL ImageReader* get_image_reader(const std::string& type,const std::string& file);
-
-}
-
-#endif                                            //IMAGE_READER_HPP

Deleted: trunk/include/image_util.hpp
===================================================================
--- trunk/include/image_util.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/image_util.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,212 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: image_util.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef IMAGE_UTIL_HPP
-#define IMAGE_UTIL_HPP
-
-namespace mapnik
-{
-    class MAPNIK_DECL ImageUtils
-    {
-    public:
-        static void save_to_file(const std::string& filename,const std::string& type,const Image32& image);
-    private:
-        static void save_as_png(const std::string& filename,const Image32& image);
-        static void save_as_jpeg(const std::string& filename,int quality, const Image32& image);
-    };
-
-    template <typename T>
-    double distance(T x0,T y0,T x1,T y1)
-    {
-        double dx = x1-x0;
-        double dy = y1-y0;
-        return sqrt(dx * dx + dy * dy);
-    }
-
-    template <typename Image>
-    inline void scale_down2(Image& target,const Image& source)
-    {
-        int source_width=source.width();
-        int source_height=source.height();
-
-        int target_width=target.width();
-        int target_height=target.height();
-        if (target_width<source_width/2 || target_height<source_height/2)
-            return;
-        int y1,x1;
-        for (int y=0;y<target_height;++y)
-        {
-            y1=2*y;
-            for(int x=0;x<target_width;++x)
-            {
-                x1=2*x;
-                //todo calculate average???
-                target(x,y)=source(x1,y1);
-            }
-        }
-    }
-
-    template <typename Image,int scale>
-    struct image_op
-    {
-        static void scale_up(Image& target,const Image& source)
-        {
-            if (scale<3) return;
-            int source_width=source.width();
-            int source_height=source.height();
-
-            int target_width=target.width();
-            int target_height=target.height();
-            if (target_width<scale*source_width || target_height<scale*source_height)
-                return;
-            for (int y=0;y<source_height;++y)
-            {
-                for(int x=0;x<source_width;++x)
-                {
-                    unsigned p=source(x,y);
-                    for (int i=0;i<scale;++i)
-                        for (int j=0;j<scale;++j)
-                            target(scale*x+i,scale*y+j)=p;
-                }
-            }
-        }
-    };
-
-    template <typename Image>
-    struct image_op<Image,2>
-    {
-        static void scale_up(Image& target,const Image& source)
-        {
-            int source_width=source.width();
-            int source_height=source.height();
-
-            int target_width=target.width();
-            int target_height=target.height();
-            if (target_width<2*source_width || target_height<2*source_height)
-                return;
-            for (int y=0;y<source_height;++y)
-            {
-                for(int x=0;x<source_width;++x)
-                {
-                    target(2*x,2*y)=source(x,y);
-                    target(2*x+1,2*y)=source(x,y);
-                    target(2*x+1,2*y+1)=source(x,y);
-                    target(2*x,2*y+1)=source(x,y);
-                }
-            }
-        }
-    };
-
-    namespace
-    {
-        template <typename Image>
-        inline void scale_up(Image& target,const Image& source,unsigned scale)
-        {
-            int source_width=source.width();
-            int source_height=source.height();
-
-            int target_width=target.width();
-            int target_height=target.height();
-            if (target_width<scale*source_width || target_height<scale*source_height)
-                return;
-            for (int y=0;y<source_height;++y)
-            {
-                for(int x=0;x<source_width;++x)
-                {
-                    unsigned p=source(x,y);
-                    for (int i=0;i<scale;++i)
-                        for (int j=0;j<scale;++j)
-                            target(scale*x+i,scale*y+j)=p;
-                }
-            }
-        }
-    }
-    
-    template <typename Image>
-    void scale_image(Image& target,const Image& source,unsigned scale)
-    {
-        if (scale==2)
-        {
-            image_op<Image,2>::scale_up(target,source);
-        }
-        else
-        {
-            scale_up<Image>(target,source,scale);
-        }
-    }
-
-    template <typename Image>
-    inline void scale_image (Image& target,const Image& source)
-    {
-
-        int source_width=source.width();
-        int source_height=source.height();
-
-        int target_width=target.width();
-        int target_height=target.height();
-
-        if (source_width<1 || source_height<1 ||
-            target_width<1 || target_height<1) return;
-        int int_part_y=source_height/target_height;
-        int fract_part_y=source_height%target_height;
-        int err_y=0;
-        int int_part_x=source_width/target_width;
-        int fract_part_x=source_width%target_width;
-        int err_x=0;
-        int x=0,y=0,xs=0,ys=0;
-        int prev_y=-1;
-        for (y=0;y<target_height;++y)
-        {
-            if (ys==prev_y)
-            {
-                target.setRow(y,target.getRow(y-1),target_width);
-            }
-            else
-            {
-                xs=0;
-                for (x=0;x<target_width;++x)
-                {
-                    target(x,y)=source(xs,ys);
-                    xs+=int_part_x;
-                    err_x+=fract_part_x;
-                    if (err_x>=target_width)
-                    {
-                        err_x-=target_width;
-                        ++xs;
-                    }
-                }
-                prev_y=ys;
-            }
-            ys+=int_part_y;
-            err_y+=fract_part_y;
-            if (err_y>=target_height)
-            {
-                err_y-=target_height;
-                ++ys;
-            }
-        }
-    }
-}
-
-#endif //IMAGE_UTIL_HPP

Deleted: trunk/include/label_collision_detector.hpp
===================================================================
--- trunk/include/label_collision_detector.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/label_collision_detector.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,87 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#if !defined LABEL_COLLISION_DETECTOR
-#define LABEL_COLLISION_DETECTOR
-
-#include "quad_tree.hpp"
-#include <vector>
-
-namespace mapnik
-{
-    //this needs to be tree structure 
-    //as a proof of a concept _only_ we use sequential scan 
-
-    struct label_collision_detector
-    {
-	typedef std::vector<Envelope<double> > label_placements;
-
-	bool has_plasement(Envelope<double> const& box)
-	{
-	    label_placements::const_iterator itr=labels_.begin();
-	    for( ; itr !=labels_.end();++itr)
-	    {
-		if (itr->intersects(box))
-		{
-		    return false;
-		}
-	    }
-	    labels_.push_back(box);
-	    return true;
-	}
-    private:
-
-	label_placements labels_;
-    };
-
-    // quad_tree based label collision detector
-    class label_collision_detector2 : boost::noncopyable
-    {
-	typedef quad_tree<Envelope<double> > tree_t;
-	tree_t tree_;
-    public:
-	
-	explicit label_collision_detector2(Envelope<double> const& extent)
-	    : tree_(extent) {}
-	
-	bool has_placement(Envelope<double> const& box)
-	{
-	    tree_t::query_iterator itr = tree_.query_in_box(box);
-	    tree_t::query_iterator end = tree_.query_end();
-	    
-	    for ( ;itr != end; ++itr)
-	    {
-		if (itr->intersects(box))
-		{
-		    return false;
-		}
-	    }
-	    
-	    tree_.insert(box,box);
-	    return true;
-	}	
-    };
-}
-
-#endif 

Deleted: trunk/include/label_placement.hpp
===================================================================
--- trunk/include/label_placement.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/label_placement.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,54 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id$
-
-#ifndef LABEL_PLACEMENT_HPP
-#define LABEL_PLACEMENT_HPP
-
-namespace mapnik
-{
-    struct point_
-    {
-        double x;
-        double y;
-        point_()
-            : x(0),y(0) {}
-        point_(double x_,double y_)
-            : x(x_),y(y_) {}	
-    };
-    
-    class label_placement
-    {
-    private:
-        point_ anchor_;
-        point_ displacement_;
-        double rotation_;
-    public:
-        label_placement() 
-            : anchor_(),
-              displacement_(),
-              rotation_(0.0) {}
-	
-    };
-}
- 
-#endif //LABEL_PLACEMENT_HPP

Deleted: trunk/include/layer.hpp
===================================================================
--- trunk/include/layer.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/layer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,86 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id: layer.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef LAYER_HPP
-#define LAYER_HPP
-
-#include <vector>
-#include "feature.hpp"
-#include "datasource.hpp"
-#include <boost/shared_ptr.hpp>
-
-namespace mapnik
-{
-    class MAPNIK_DECL Layer
-    {
-        std::string name_;
-        std::string title_;
-        std::string abstract_;
-        double minZoom_;
-        double maxZoom_;
-        bool active_;
-        bool selectable_;
-        
-        std::vector<std::string>  styles_;
-        std::string selection_style_;
-        
-        mutable std::vector<boost::shared_ptr<Feature> > selection_;
-        mutable datasource_p ds_;
-        
-    public:
-        explicit Layer(std::string const& name);
-        Layer(Layer const& l);
-        Layer& operator=(Layer const& l);
-        bool operator==(Layer const& other) const;
-        void set_name(std::string const& name);
-        const std::string& name() const;
-        void set_title(std::string const& title);
-        const std::string& title() const;
-        void set_abstract(std::string const& abstract);
-        const std::string& abstract() const;
-        void add_style(std::string const& stylename);
-        std::vector<std::string> const& styles() const;
-        void selection_style(const std::string& name);
-        const std::string& selection_style() const;
-        void setMinZoom(double minZoom);
-        void setMaxZoom(double maxZoom);
-        double getMinZoom() const;
-        double getMaxZoom() const;
-        void setActive(bool active);
-        bool isActive() const;
-        void setSelectable(bool selectable);
-        bool isSelectable() const;
-        bool isVisible(double scale) const;
-        void add_to_selection(boost::shared_ptr<Feature>& feature) const;
-        std::vector<boost::shared_ptr<Feature> >& selection() const;
-        void clear_selection() const;
-        void set_datasource(datasource_p const& ds);
-        datasource_p datasource() const;
-        Envelope<double> envelope() const;
-        ~Layer();
-    private:
-        void swap(const Layer& other);
-    };
-}
-
-#endif //LAYER_HPP

Deleted: trunk/include/line_pattern_symbolizer.hpp
===================================================================
--- trunk/include/line_pattern_symbolizer.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/line_pattern_symbolizer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,45 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id: polygon_symbolizer.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef LINE_PATTERN_SYMBOLIZER_HPP
-#define LINE_PATTERN_SYMBOLIZER_HPP
-
-#include <boost/shared_ptr.hpp>
-#include "graphics.hpp"
-
-namespace mapnik 
-{      
-    struct MAPNIK_DECL line_pattern_symbolizer
-    {
-	line_pattern_symbolizer(std::string const& file,
-				std::string const& type,
-				unsigned width,unsigned height);
-
-	line_pattern_symbolizer(line_pattern_symbolizer const& rhs);
-	ImageData32 const& get_pattern() const;
-    private:
-	boost::shared_ptr<ImageData32> pattern_;
-    };    
-}
-
-#endif // LINE_PATTERN_SYMBOLIZER_HPP

Deleted: trunk/include/line_symbolizer.hpp
===================================================================
--- trunk/include/line_symbolizer.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/line_symbolizer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,55 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id: line_symbolizer.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef LINE_SYMBOLIZER_HPP
-#define LINE_SYMBOLIZER_HPP
-
-#include "stroke.hpp"
-
-namespace mapnik 
-{
-    struct MAPNIK_DECL line_symbolizer
-    {
-        explicit line_symbolizer()
-            : stroke_() {}
-        
-        line_symbolizer(stroke const& stroke)
-            : stroke_(stroke) {}
-	
-        line_symbolizer(const Color& pen,float width=1.0)
-            : stroke_(pen,width) {}
-        stroke const& get_stroke() const
-        {
-            return stroke_;
-        }
-        void set_stroke(stroke const& stroke)
-        {
-            stroke_ = stroke;
-        }
-
-    private:
-		stroke stroke_;
-    };
-}
-
-#endif //LINE_SYMBOLIZER_HPP

Deleted: trunk/include/load_map.hpp
===================================================================
--- trunk/include/load_map.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/load_map.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,35 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-// $Id$
-
-#ifndef MAP_LOADER_HPP
-#define MAP_LOADER_HPP
-
-#include <string>
-#include "map.hpp"
-
-namespace mapnik
-{
-    void load_map(Map & map, std::string const& filename);
-}
-
-#endif // LOAD_MAP_HPP

Deleted: trunk/include/local_datasource.hpp
===================================================================
--- trunk/include/local_datasource.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/local_datasource.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,49 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id$
-
-#ifndef LOCAL_DATASOURCE_HPP
-#define LOCAL_DATASOURCE_HPP
-
-#include <vector>
-
-namespace mapnik
-{
-    /*
-    class local_datasource : public datasource 
-    {
-    public:
-	local_datasource(Parameters const& params);
-	int type() const;
-	static std::string name();
-	featureset_ptr features(query const& q) const;
-	const Envelope<double>& envelope() const;
-	virtual ~local_datasource();
-    private:
-	static std::string name_;
-	Envelope<double> extent_;
-	std::vector<Feature*>  
-    };
-    */
-}
-
-#endif //LOCAL_DATASOURCE_HPP

Deleted: trunk/include/logical.hpp
===================================================================
--- trunk/include/logical.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/logical.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,172 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id$
-
-#ifndef LOGICAL_HPP
-#define LOGICAL_HPP
-
-#include "filter.hpp"
-
-namespace mapnik
-{
-    template <typename FeatureT> 
-    struct logical_and : public filter<FeatureT>  
-    {
-	logical_and(filter<FeatureT> const& filter1,
-		    filter<FeatureT> const& filter2)
-	    : filter<FeatureT>(),
-	      filter1_(filter1.clone()),
-	      filter2_(filter2.clone()) {}
-	
-	logical_and(logical_and const& other)
-	    : filter<FeatureT>(),
-	      filter1_(other.filter1_->clone()),
-	      filter2_(other.filter2_->clone()) {}
-
-	bool pass(const FeatureT& feature) const
-	{
-	    return (filter1_->pass(feature) && 
-		filter2_->pass(feature));
-	}
-	std::string to_string() const
-	{
-	    return "("+filter1_->to_string()+" and "+filter2_->to_string()+")";
-	}
-	
-	filter<FeatureT>* clone() const
-	{
-	    return new logical_and(*this);
-	}
-
-	void accept(filter_visitor<FeatureT>& v)
-	{
-	    filter1_->accept(v);
-	    filter2_->accept(v);
-	    v.visit(*this);
-	}
-
-	virtual ~logical_and()
-	{
-	    delete filter1_;
-	    delete filter2_;
-	}
-	
-    private:
-	filter<FeatureT>* filter1_;
-	filter<FeatureT>* filter2_;
-    };
-
-    template <typename FeatureT> 
-    struct logical_or : public filter<FeatureT>  
-    {
-	
-	logical_or(const filter<FeatureT>& filter1,const filter<FeatureT>& filter2)
-	    : filter<FeatureT>(),
-	      filter1_(filter1.clone()),
-	      filter2_(filter2.clone()) {}
-	
-	logical_or(logical_or const& other)
-	    : filter<FeatureT>(),
-	      filter1_(other.filter1_->clone()),
-	      filter2_(other.filter2_->clone()) {}
-
-	bool pass(const FeatureT& feature) const
-	{
-	    if (filter1_->pass(feature))
-	    {
-		return true;
-	    }
-	    else
-	    {
-		return filter2_->pass(feature);
-	    }
-	}
-	filter<FeatureT>* clone() const
-	{
-	    return new logical_or(*this);
-	}
-
-	void accept(filter_visitor<FeatureT>& v)
-	{
-	    filter1_->accept(v);
-	    filter2_->accept(v);
-	    v.visit(*this);
-	}
-	std::string to_string() const
-	{
-	    return "("+filter1_->to_string()+" or "+filter2_->to_string()+")";
-	}	
-	virtual ~logical_or()
-	{  
-	    delete filter1_;
-	    delete filter2_;
-	}
-    private:
-	filter<FeatureT>* filter1_;
-	filter<FeatureT>* filter2_;
-    };
-
-    template <typename FeatureT> 
-    struct logical_not : public filter<FeatureT>  
-    {
-	logical_not(filter<FeatureT> const& _filter)
-	    : filter<FeatureT>(),
-	      filter_(_filter.clone()) {}
-	logical_not(logical_not const& other)
-	    : filter<FeatureT>(),
-	      filter_(other.filter_->clone()) {}
-
-	int type() const
-	{
-	    return filter<FeatureT>::LOGICAL_OPS;
-	}
-
-	bool pass(const FeatureT& feature) const
-	{
-	    return !(filter_->pass(feature));
-	}
-
-	filter<FeatureT>* clone() const
-	{
-	    return new logical_not(*this);
-	}
-	
-	void accept(filter_visitor<FeatureT>& v)
-	{
-	    filter_->accept(v);
-	    v.visit(*this);
-	}
-	std::string to_string() const
-	{
-	    return "not ("+filter_->to_string()+")";
-	}
-	 
-	~logical_not() 
-	{
-	    delete filter_;
-	}
-    private:
-	filter<FeatureT>* filter_;
-    };
-}
- 
-#endif //LOGICAL_HPP

Deleted: trunk/include/map.hpp
===================================================================
--- trunk/include/map.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/map.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,85 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id: map.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef MAP_HPP
-#define MAP_HPP
-
-#include "feature_type_style.hpp"
-
-namespace mapnik
-{
-    class Layer;
-
-    class MAPNIK_DECL Map
-    {	
-        static const unsigned MIN_MAPSIZE=16;
-        static const unsigned MAX_MAPSIZE=2048;
-        unsigned width_;
-        unsigned height_;
-        int srid_;
-        Color background_;
-        std::map<std::string,feature_type_style> styles_;
-        std::vector<Layer> layers_;
-        Envelope<double> currentExtent_;
-        
-    public:
- 
-        typedef std::map<std::string,feature_type_style>::const_iterator style_iterator;
-        
-        Map();
-        Map(int width,int height,int srid=-1);
-        Map(const Map& rhs);
-        Map& operator=(const Map& rhs);
-        style_iterator begin_styles() const;
-        style_iterator end_styles() const;
-        bool insert_style(std::string const& name,feature_type_style const& style);
-        void remove_style(const std::string& name);
-        feature_type_style const& find_style(std::string const& name) const;
-        size_t layerCount() const;
-        void addLayer(const Layer& l);
-        const Layer& getLayer(size_t index) const;
-        Layer& getLayer(size_t index);
-        void removeLayer(size_t index);
-        std::vector<Layer> const& layers() const;
-        unsigned getWidth() const;
-        unsigned getHeight() const;
-        void setWidth(unsigned width);
-        void setHeight(unsigned height);
-        void resize(unsigned width,unsigned height);
-        int srid() const;
-        void setBackground(const Color& c);
-        const Color& getBackground() const;
-        void zoom(double zoom);
-        void zoomToBox(const Envelope<double>& box);
-        void zoom_all();
-        void pan(int x,int y);
-        void pan_and_zoom(int x,int y,double zoom);
-        const Envelope<double>& getCurrentExtent() const;
-        double scale() const;
-        ~Map();
-    private:
-        void fixAspectRatio();
-    };
-}
-
-#endif //MAP_HPP

Copied: trunk/include/mapnik/agg_renderer.hpp (from rev 307, trunk/include/agg_renderer.hpp)
===================================================================
--- trunk/include/agg_renderer.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/agg_renderer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,63 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef AGG_RENDERER_HPP
+#define AGG_RENDERER_HPP
+
+// boost
+#include <boost/utility.hpp>
+// mapnik
+#include <mapnik/feature_style_processor.hpp>
+#include <mapnik/font_engine_freetype.hpp>
+#include <mapnik/label_collision_detector.hpp>
+#include <mapnik/map.hpp>
+#include <mapnik/config.hpp>
+
+namespace mapnik {
+    template <typename T>
+    class MAPNIK_DECL agg_renderer : public feature_style_processor<agg_renderer<T> >,
+                                     private boost::noncopyable
+    {
+    public:
+        agg_renderer(Map const& m, T & pixmap);
+        void start_map_processing(Map const& map);
+        void end_map_processing(Map const& map);
+        void start_layer_processing(Layer const& lay);
+        void end_layer_processing(Layer const& lay);
+        void process(point_symbolizer const& sym,Feature const& feature);
+        void process(line_symbolizer const& sym,Feature const& feature);
+        void process(line_pattern_symbolizer const& sym,Feature const& feature);
+        void process(polygon_symbolizer const& sym,Feature const& feature);
+        void process(polygon_pattern_symbolizer const& sym,Feature const& feature);
+        void process(raster_symbolizer const& sym,Feature const& feature);
+        void process(text_symbolizer const& sym,Feature const& feature);
+    private:
+        T & pixmap_;
+        CoordTransform t_;
+        face_manager<freetype_engine> font_manager_;
+        label_collision_detector2 detector_;
+    };
+}
+
+#endif //AGG_RENDERER_HPP

Copied: trunk/include/mapnik/attribute.hpp (from rev 307, trunk/include/attribute.hpp)
===================================================================
--- trunk/include/attribute.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/attribute.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,222 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: attribute.hpp 41 2005-04-13 20:21:56Z pavlenko $
+
+#ifndef ATTRIBUTE_HPP
+#define ATTRIBUTE_HPP
+
+// stl
+#include <typeinfo>
+#include <sstream>
+#include <map>
+// boost
+#include <boost/any.hpp>
+
+namespace mapnik {
+    template <typename T>
+    struct attribute_traits
+    {
+        static std::string to_string(const T& value)
+        {
+            std::stringstream ss;
+            ss << value;
+            return ss.str();
+        }
+    };
+
+    template <>
+    struct attribute_traits<std::string>
+    {
+        static std::string to_string(const std::string& value)
+        {
+            return value;
+        }
+    };
+    
+    class MAPNIK_DECL attribute
+    {	
+    public:
+        attribute()
+            : base_(0) {}
+
+        template <typename T>
+        attribute(const T& value)
+            : base_(new attribute_impl<T>(value)) 
+        {}
+
+        attribute(const attribute& rhs)
+            : base_(rhs.base_ ? rhs.base_->clone() : 0)
+        {}
+
+        ~attribute() 
+        {
+            delete base_;
+        }
+
+        template<typename T>
+        attribute& operator=(const T& rhs)
+        {
+            attribute(rhs).swap(*this);
+            return *this;
+        }
+
+        attribute& operator=(const attribute& rhs)
+        {
+            attribute(rhs).swap(*this);
+            return *this;
+        }
+
+        bool empty() const
+        {
+            return !base_;
+        }
+
+        const std::type_info & type() const
+        {
+            return base_ ? base_->type() : typeid(void);
+        }
+
+        const std::string to_string() const
+        {
+            return base_ ? base_->to_string() : "";
+        }
+    private:
+        attribute& swap(attribute& rhs)
+        {
+            std::swap(base_,rhs.base_);
+            return *this;
+        }
+	
+        class attribute_base
+        {
+        public:
+            virtual ~attribute_base() {}
+            virtual attribute_base* clone() const=0;
+            virtual std::string to_string() const=0;
+            virtual const std::type_info& type()  const=0;
+        };
+
+        template <typename T,typename ATraits=attribute_traits<T> >
+        class attribute_impl : public attribute_base
+        {	    
+        public:
+            typedef T value_type;
+            attribute_impl(const value_type& value)
+                : value_(value) {}
+	    
+            virtual std::string to_string() const
+            {
+                return  ATraits::to_string(value_);
+            }
+	    
+            virtual attribute_base* clone() const
+            {
+                return new attribute_impl(value_);
+            }
+            virtual const std::type_info& type() const 
+            {
+                return typeid(value_);
+            }
+            value_type value_;
+        };
+    private:
+        template<typename value_type>
+        friend value_type* attribute_cast(attribute*);
+        attribute_base* base_;
+    };
+    
+    
+    template<typename T>
+    struct bad_attribute_cast : public std::bad_cast
+    {
+        virtual const char* what() const throw()
+        {
+            return "attribute::failed conversion";
+        }
+    };
+    
+    template <typename T> 
+    bool is_type(const attribute& attr)
+    {
+        return attr.type()==typeid(T);
+    }
+    
+    template <typename T>
+    T* attribute_cast(attribute* attr)
+    {
+        return attr && attr->type() == typeid(T)
+            ? &static_cast<attribute::attribute_impl<T>*>(attr->base_)->value_
+            : 0;
+    }
+
+    template <typename T>
+    const T* attribute_cast(const attribute* attr)
+    {
+        return attribute_cast<T>(const_cast<attribute*>(attr));
+    }
+    
+    template <typename T>
+    T attribute_cast(const attribute& attr)
+    {
+        using namespace boost;
+        typedef BOOST_DEDUCED_TYPENAME remove_reference<T>::type nonref;
+        const nonref * result=attribute_cast<nonref>(&attr);
+        if (!result)
+        {
+            throw bad_attribute_cast<T>();
+        }
+        return *result;
+    }
+    
+    template <typename T>
+    T attribute_cast(attribute& attr)
+    {
+        using namespace boost;
+        typedef BOOST_DEDUCED_TYPENAME remove_reference<T>::type nonref;
+        nonref * result=attribute_cast<nonref>(&attr);
+        if (!result)
+            throw bad_attribute_cast<T>();
+        return *result;
+    }
+    
+       
+    template <typename T>
+    attribute attribute_from_string(const std::string& val)
+    {
+        std::istringstream is(val);
+        T t;
+        is >> t;
+        return attribute(t);
+    }
+
+    template <typename charT, typename traits>
+    inline std::basic_ostream<charT,traits>& 
+    operator << (std::basic_ostream<charT,traits>& out,
+                 const attribute& attr)
+    {
+        out << attr.to_string();
+        return out; 
+    }
+}
+
+#endif //ATTRIBUTE_HPP

Copied: trunk/include/mapnik/attribute_collector.hpp (from rev 307, trunk/include/attribute_collector.hpp)
===================================================================
--- trunk/include/attribute_collector.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/attribute_collector.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,98 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef ATTRIBUTE_COLLECTOR_HPP
+#define ATTRIBUTE_COLLECTOR_HPP
+
+// stl
+#include <set>
+#include <iostream>
+// mapnik
+#include <mapnik/filter.hpp>
+#include <mapnik/expression.hpp>
+#include <mapnik/feature_layer_desc.hpp>
+#include <mapnik/rule.hpp>
+
+namespace mapnik {
+    
+    struct symbolizer_attributes : public boost::static_visitor<>
+    {
+        symbolizer_attributes(std::set<std::string>& names)
+            : names_(names) {}
+	
+        template <typename T>
+        void operator () (T const&) const {}
+        void operator () (text_symbolizer const& sym)
+        {
+            names_.insert(sym.get_name());
+        }
+    private:
+        std::set<std::string>& names_;
+    };
+
+    template <typename FeatureT>
+    class attribute_collector : public filter_visitor<FeatureT>
+    {
+    private:
+        std::set<std::string>& names_;
+    public:
+	
+        attribute_collector(std::set<std::string>& names)
+            : names_(names) {}
+	
+        void visit(filter<FeatureT>& /*filter*/) 
+        { 
+            //not interested
+        }
+	
+        void visit(expression<FeatureT>& exp)
+        {
+            property<FeatureT>* pf;
+            if ((pf = dynamic_cast<property<FeatureT>*>(&exp)))
+            {
+                names_.insert(pf->name());
+            }
+        }
+        void visit(rule_type const& r)
+        {	    
+            const symbolizers& symbols = r.get_symbolizers();
+            symbolizers::const_iterator symIter=symbols.begin();
+            symbolizer_attributes attr(names_);
+            while (symIter != symbols.end())
+            {
+                boost::apply_visitor(attr,*symIter++);
+            }
+            filter_ptr const& filter = r.get_filter();
+            filter->accept(*this);
+        }
+
+        virtual ~attribute_collector() {}
+    private:	
+        // no copying 
+        attribute_collector(attribute_collector const&);
+        attribute_collector& operator=(attribute_collector const&);
+    };   
+}
+
+#endif //ATTRIBUTE_COLLECTOR_HPP

Copied: trunk/include/mapnik/attribute_descriptor.hpp (from rev 307, trunk/include/attribute_descriptor.hpp)
===================================================================
--- trunk/include/attribute_descriptor.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/attribute_descriptor.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,38 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef ATTRIBUTE_DESCRIPTOR
+#define ATTRIBUTE_DESCRIPTOR
+
+#include <string>
+
+namespace mapnik {
+    struct attribute_desc
+    {
+        std::string name;
+        eType type;
+    };
+}
+
+#endif // ATTRIBUTE_DESCRIPTOR_HPP

Copied: trunk/include/mapnik/color.hpp (from rev 307, trunk/include/color.hpp)
===================================================================
--- trunk/include/color.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/color.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,127 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: color.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef COLOR_HPP
+#define COLOR_HPP
+
+#include <sstream>
+#include <boost/format.hpp>
+#include <mapnik/config.hpp>
+
+namespace mapnik {
+
+    class MAPNIK_DECL Color
+    {
+    private:
+        unsigned int abgr_;
+    public:
+        Color()
+            :abgr_(0xffffffff) {}
+
+        Color(int red,int green,int blue,int alpha=0xff)
+            : abgr_((alpha&0xff) << 24 | 
+                    (blue&0xff) << 16  | 
+                    (green&0xff) << 8  | 
+                    red&0xff) {}
+        
+        explicit Color(int rgba)
+            : abgr_(rgba) {}
+
+        Color(const Color& rhs)
+            : abgr_(rhs.abgr_) {}
+
+        Color& operator=(const Color& rhs)
+        {
+            if (this==&rhs) return *this;
+            abgr_=rhs.abgr_;
+            return *this;
+        }
+        inline unsigned int red() const
+        {
+            return abgr_&0xff;
+        }
+        inline unsigned int green() const
+        {
+            return (abgr_>>8)&0xff;
+        }
+        inline unsigned int blue() const
+        {
+            return (abgr_>>16)&0xff;
+        }
+        inline unsigned int alpha() const
+        {
+            return (abgr_>>24)&0xff;
+        }
+	
+        inline void set_red(unsigned int r)
+        {
+            abgr_ = (abgr_ & 0xffffff00) | (r&0xff);
+        }
+        inline void set_green(unsigned int g)
+        {
+            abgr_ = (abgr_ & 0xffff00ff) | ((g&0xff) << 8);
+        }
+        inline void set_blue(unsigned int b)
+        {
+            abgr_ = (abgr_ & 0xff00ffff) | ((b&0xff) << 16);
+        }
+        inline void set_alpha(unsigned int a)
+        {
+            abgr_ = (abgr_ & 0x00ffffff | (a&0xff) << 24);
+        }
+
+        inline unsigned int rgba() const
+        {
+            return abgr_;
+        }
+        inline void set_bgr(unsigned bgr)
+        {
+            abgr_ = (abgr_ & 0xff000000) | (bgr & 0xffffff);
+        }
+        inline bool operator==(Color const& other) const
+        {
+            return abgr_ == other.abgr_;
+        }
+        
+        inline std::string to_string() const
+        {
+            std::stringstream ss;
+            ss << "rgb (" 
+               << red()   << ","  
+               << green() << ","  
+               << blue()  << ","
+               << alpha() << ")";
+            return ss.str();
+        }
+        
+        inline std::string to_hex_string() const
+        {
+            std::stringstream ss;
+            ss << boost::format("#%1$02x%2$02x%3$02x") % red() % green() % blue();
+            return ss.str();
+        }
+    };    
+}
+
+#endif //COLOR_HPP

Copied: trunk/include/mapnik/color_factory.hpp (from rev 307, trunk/include/color_factory.hpp)
===================================================================
--- trunk/include/color_factory.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/color_factory.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,53 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef COLOR_FACTORY_HPP
+#define COLOR_FACTORY_HPP
+
+#include <mapnik/config.hpp>
+#include <mapnik/css_color_parser.hpp>
+
+using namespace boost::spirit;
+
+namespace mapnik {    
+    class MAPNIK_DECL color_factory
+    {
+    public:
+        static Color from_string(char const* css_color)
+        {   
+            Color color;
+            actions<Color> a(color);
+            css_color_grammar<actions<Color> > grammar(a);
+            parse_info<> info = parse(css_color, grammar, space_p);
+            if (info.full) return color;
+            return Color(0,0,0);	
+        }    
+    private:
+        color_factory();
+        color_factory(color_factory const&);
+        color_factory& operator=(color_factory const&);
+    };
+}
+
+#endif //COLOR_FACTORY_HPP

Copied: trunk/include/mapnik/comparison.hpp (from rev 307, trunk/include/comparison.hpp)
===================================================================
--- trunk/include/comparison.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/comparison.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,149 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id$
+
+#ifndef COMPARISON_HPP
+#define COMPARISON_HPP
+
+#include <mapnik/filter.hpp>
+#include <mapnik/expression.hpp>
+#include <mapnik/attribute.hpp>
+
+namespace mapnik {   
+    template <typename T>  
+    struct greater_than
+    {
+        bool operator() (T const& left, T const& right) const
+        {
+            return left > right;
+        }
+        static std::string to_string()
+        {
+            return ">";
+        }
+    };
+
+    template <typename T>  
+    struct greater_than_or_equal
+    {
+        bool operator() (T const& left, T const& right) const
+        {
+            return left >= right;
+        }
+        static std::string to_string()
+        {
+            return ">=";
+        }
+    };
+    template <typename T>  
+    struct less_than
+    {
+        bool operator() (T const& left, T const& right) const
+        {
+            return left < right;
+        }
+        static std::string to_string()
+        {
+            return "<";
+        }
+    };
+    template <typename T>  
+    struct less_than_or_equal
+    {
+        bool operator() (T const& left, T const& right) const
+        {
+            return left <= right;
+        }
+        static std::string to_string()
+        {
+            return "<=";
+        }
+    };
+    template <typename T>  
+    struct equals
+    {
+        bool operator() (T const& left, T const& right) const
+        {
+            return left == right;
+        }
+        static std::string to_string()
+        {
+            return "=";
+        }
+    };
+    
+    template <typename T>  
+    struct not_equals
+    {
+        bool operator() (T const& left, T const& right) const
+        {
+            return left != right;
+        }
+        static std::string to_string()
+        {
+            return "<>";
+        }
+    };
+    
+    template <typename FeatureT,typename Op>
+    struct compare_filter : public filter<FeatureT>
+    {
+        compare_filter(expression<FeatureT> const& left,
+                       expression<FeatureT> const& right)
+            : filter<FeatureT>(),
+              left_(left.clone()), right_(right.clone()) {}
+
+        compare_filter(compare_filter const& other)
+            : filter<FeatureT>(),
+              left_(other.left_->clone()),right_(other.right_->clone()) {}
+	
+        bool pass(const FeatureT& feature) const
+        {   
+            return Op()(left_->get_value(feature),right_->get_value(feature));     
+        }
+        void accept(filter_visitor<FeatureT>& v)
+        {
+            left_->accept(v);
+            right_->accept(v);
+            v.visit(*this);
+        }
+        std::string to_string() const
+        {
+            return "("+left_->to_string()+Op::to_string()+right_->to_string()+")";
+        }
+
+        filter<FeatureT>* clone() const
+        {
+            return new compare_filter<FeatureT,Op>(*this);
+        }
+        virtual ~compare_filter() 
+        {
+            delete left_;
+            delete right_;
+        }
+    private:
+        expression<FeatureT>* left_;
+        expression<FeatureT>* right_;
+    };
+}
+
+#endif //COMPARISON_HPP

Copied: trunk/include/mapnik/config.hpp (from rev 307, trunk/include/config.hpp)
===================================================================
--- trunk/include/config.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/config.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,39 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+#ifndef CONFIG_HPP
+#define CONFIG_HPP
+
+// Window DLL support
+
+#ifdef _WINDOWS
+# define MAPNIK_DECL __declspec (dllexport)
+# pragma warning( disable: 4251 )
+# pragma warning( disable: 4275 )
+# if (_MSC_VER >= 1400) // vc8
+#   pragma warning(disable : 4996) //_CRT_SECURE_NO_DEPRECATE
+# endif
+#else
+# define MAPNIK_DECL 
+#endif
+
+#endif // CONFIG_HPP

Copied: trunk/include/mapnik/coord.hpp (from rev 307, trunk/include/coord.hpp)
===================================================================
--- trunk/include/coord.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/coord.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,136 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: coord.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef COORD_HPP
+#define COORD_HPP
+
+#include <iomanip>
+#include <sstream>
+
+namespace mapnik {   
+    template <typename T,int dim>
+    struct coord {
+        typedef T type;
+    };
+    
+    template <typename T>
+    struct coord<T,2> 
+    {
+        typedef T type;
+        T x;
+        T y;
+    public:
+        coord()
+            : x(),y() {}
+        coord(T x,T y)
+            : x(x),y(y) {}
+        template <typename T2>
+        coord (const coord<T2,2>& rhs)
+            : x(type(rhs.x)),
+              y(type(rhs.y)) {}
+
+        template <typename T2>
+        coord<T,2>& operator=(const coord<T2,2>& rhs)
+        {
+            if ((void*)this==(void*)&rhs)
+            {
+                return *this;
+            }
+            x=type(rhs.x);
+            y=type(rhs.y);
+            return *this;
+        }
+    };
+
+    template <typename T>
+    struct coord<T,3> 
+    {
+        typedef T type;
+        T x;
+        T y;
+        T z;
+    public:
+        coord()
+            : x(),y(),z() {}
+        coord(T x,T y,T z)
+            : x(x),y(y),z(z) {}
+        template <typename T2>
+        coord (const coord<T2,3>& rhs)
+            : x(type(rhs.x)),
+              y(type(rhs.y)),
+              z(type(rhs.z)) {}
+
+        template <typename T2>
+        coord<T,3>& operator=(const coord<T2,3>& rhs)
+        {
+            if ((void*)this==(void*)&rhs)
+            {
+                return *this;
+            }
+            x=type(rhs.x);
+            y=type(rhs.y);
+            z=type(rhs.z);
+            return *this;
+        }
+    };
+
+    typedef coord<double,2> coord2d;
+    typedef coord<int,2> coord2i;
+
+     
+    template <typename charT,typename traits,typename T ,int dim>
+    inline std::basic_ostream<charT,traits>&
+    operator << (std::basic_ostream<charT,traits>& out,
+                 const coord<T,dim>& c);
+    
+    template <typename charT,typename traits,typename T>
+    inline std::basic_ostream<charT,traits>&
+    operator << (std::basic_ostream<charT,traits>& out,
+                 const coord<T,2>& c)
+    {
+        std::basic_ostringstream<charT,traits> s;
+        s.copyfmt(out);
+        s.width(0);
+        s << "coord2(" << std::setprecision(16) 
+          << c.x << "," << c.y<< ")";
+        out << s.str();
+        return out;
+    }
+
+    template <typename charT,typename traits,typename T>
+    inline std::basic_ostream<charT,traits>&
+    operator << (std::basic_ostream<charT,traits>& out,
+                 const coord<T,3>& c)
+    {
+        std::basic_ostringstream<charT,traits> s;
+        s.copyfmt(out);
+        s.width(0);
+        s << "coord3(" << std::setprecision(16) 
+          << c.x << "," << c.y<< "," << c.z<<")";
+        out << s.str();
+        return out;
+    } 
+}
+
+#endif // COORD_HPP

Copied: trunk/include/mapnik/coord_array.hpp (from rev 307, trunk/include/coord_array.hpp)
===================================================================
--- trunk/include/coord_array.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/coord_array.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,92 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: coord_array.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef COORD_ARRAY_HPP
+#define COORD_ARRAY_HPP
+
+// stl
+#include <cassert>
+//mapnik
+#include <mapnik/coord.hpp>
+
+namespace mapnik {
+    template <typename T>
+    class coord_array 
+    {   
+        typedef T coord_type;
+        coord_type* pt_;
+        const unsigned size_;
+    public:	
+        coord_array(unsigned size=0)
+            : pt_(static_cast<coord_type*>(size==0?0: ::operator new (sizeof(coord_type)*size))),
+              size_(size) {}
+	
+        coord_array(const coord_array& rhs)
+            : pt_(static_cast<coord_type*>(rhs.size_==0?0: ::operator new (sizeof(coord_type)*rhs.size_))),
+              size_(rhs.size_) {
+            memcpy(pt_,rhs.pt_,sizeof(coord_type)*rhs.size_);
+        }
+	
+        ~coord_array() 
+        {
+            ::operator delete (pt_);
+        }
+	
+        unsigned size() const 
+        {
+            return size_;
+        }
+	
+        void set(unsigned index,double x,double y)
+        {
+            assert(index<size_);
+            pt_[index].x=x;
+            pt_[index].y=y;
+        }
+	
+        const coord_type& at(unsigned index) const 
+        {
+            assert(index<size_);
+            return pt_[index];
+        }
+	
+        const coord_type& operator[] (unsigned index) const
+        {
+            assert (index<size_);
+            return pt_[index];
+        }
+	
+        coord_type& operator[] (unsigned index)
+        {
+            assert (index<size_);
+            return pt_[index];
+        }
+	
+    private:
+        coord_array& operator=(const coord_array&);
+    };
+}
+
+
+#endif //COORD_ARRAY_HPP

Copied: trunk/include/mapnik/css_color_parser.hpp (from rev 307, trunk/include/css_color_parser.hpp)
===================================================================
--- trunk/include/css_color_parser.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/css_color_parser.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,387 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef CSS_COLOR_PARSER_HPP
+#define CSS_COLOR_PARSER_HPP
+
+#include <boost/spirit/core.hpp>
+#include <boost/spirit/symbols.hpp>
+
+using namespace boost::spirit;
+
+namespace mapnik {
+    template <typename ColorT>
+    struct named_colors : public symbols<ColorT>
+    {
+        named_colors()
+        {
+            symbols<ColorT>::add
+                ("aliceblue", ColorT(240, 248, 255))
+                ("antiquewhite", ColorT(250, 235, 215))
+                ("aqua", ColorT(0, 255, 255))
+                ("aquamarine", ColorT(127, 255, 212))
+                ("azure", ColorT(240, 255, 255))
+                ("beige", ColorT(245, 245, 220))
+                ("bisque", ColorT(255, 228, 196))
+                ("black", ColorT(0, 0, 0))
+                ("blanchedalmond", ColorT(255,235,205))
+                ("blue", ColorT(0, 0, 255))
+                ("blueviolet", ColorT(138, 43, 226))
+                ("brown", ColorT(165, 42, 42))
+                ("burlywood", ColorT(222, 184, 135))
+                ("cadetblue", ColorT(95, 158, 160))
+                ("chartreuse", ColorT(127, 255, 0))
+                ("chocolate", ColorT(210, 105, 30))
+                ("coral", ColorT(255, 127, 80))
+                ("cornflowerblue", ColorT(100, 149, 237))
+                ("cornsilk", ColorT(255, 248, 220))
+                ("crimson", ColorT(220, 20, 60))
+                ("cyan", ColorT(0, 255, 255))
+                ("darkblue", ColorT(0, 0, 139))
+                ("darkcyan", ColorT(0, 139, 139))
+                ("darkgoldenrod", ColorT(184, 134, 11))
+                ("darkgray", ColorT(169, 169, 169))
+                ("darkgreen", ColorT(0, 100, 0))
+                ("darkgrey", ColorT(169, 169, 169))
+                ("darkkhaki", ColorT(189, 183, 107))
+                ("darkmagenta", ColorT(139, 0, 139))
+                ("darkolivegreen", ColorT(85, 107, 47))
+                ("darkorange", ColorT(255, 140, 0))
+                ("darkorchid", ColorT(153, 50, 204))
+                ("darkred", ColorT(139, 0, 0))
+                ("darksalmon", ColorT(233, 150, 122))
+                ("darkseagreen", ColorT(143, 188, 143))
+                ("darkslateblue", ColorT(72, 61, 139))
+                ("darkslategrey", ColorT(47, 79, 79))
+                ("darkturquoise", ColorT(0, 206, 209))
+                ("darkviolet", ColorT(148, 0, 211))
+                ("deeppink", ColorT(255, 20, 147))
+                ("deepskyblue", ColorT(0, 191, 255))
+                ("dimgray", ColorT(105, 105, 105))
+                ("dimgrey", ColorT(105, 105, 105))
+                ("dodgerblue", ColorT(30, 144, 255))
+                ("firebrick", ColorT(178, 34, 34))
+                ("floralwhite", ColorT(255, 250, 240))
+                ("forestgreen", ColorT(34, 139, 34))
+                ("fuchsia", ColorT(255, 0, 255))
+                ("gainsboro", ColorT(220, 220, 220))
+                ("ghostwhite", ColorT(248, 248, 255))
+                ("gold", ColorT(255, 215, 0))
+                ("goldenrod", ColorT(218, 165, 32))
+                ("gray", ColorT(128, 128, 128))
+                ("grey", ColorT(128, 128, 128))
+                ("green", ColorT(0, 128, 0))
+                ("greenyellow", ColorT(173, 255, 47))
+                ("honeydew", ColorT(240, 255, 240))
+                ("hotpink", ColorT(255, 105, 180))
+                ("indianred", ColorT(205, 92, 92))
+                ("indigo", ColorT(75, 0, 130))
+                ("ivory", ColorT(255, 255, 240))
+                ("khaki", ColorT(240, 230, 140))
+                ("lavender", ColorT(230, 230, 250))
+                ("lavenderblush", ColorT(255, 240, 245))
+                ("lawngreen", ColorT(124, 252, 0))
+                ("lemonchiffon", ColorT(255, 250, 205))
+                ("lightblue", ColorT(173, 216, 230))
+                ("lightcoral", ColorT(240, 128, 128))
+                ("lightcyan", ColorT(224, 255, 255))
+                ("lightgoldenrodyellow", ColorT(250, 250, 210))
+                ("lightgray", ColorT(211, 211, 211))
+                ("lightgreen", ColorT(144, 238, 144))
+                ("lightgrey", ColorT(211, 211, 211))
+                ("lightpink", ColorT(255, 182, 193))
+                ("lightsalmon", ColorT(255, 160, 122))
+                ("lightseagreen", ColorT(32, 178, 170))
+                ("lightskyblue", ColorT(135, 206, 250))
+                ("lightslategray", ColorT(119, 136, 153))
+                ("lightslategrey", ColorT(119, 136, 153))
+                ("lightsteelblue", ColorT(176, 196, 222))
+                ("lightyellow", ColorT(255, 255, 224))
+                ("lime", ColorT(0, 255, 0))
+                ("limegreen", ColorT(50, 205, 50))
+                ("linen", ColorT(250, 240, 230))
+                ("magenta", ColorT(255, 0, 255))
+                ("maroon", ColorT(128, 0, 0))
+                ("mediumaquamarine", ColorT(102, 205, 170))
+                ("mediumblue", ColorT(0, 0, 205))
+                ("mediumorchid", ColorT(186, 85, 211))
+                ("mediumpurple", ColorT(147, 112, 219))
+                ("mediumseagreen", ColorT(60, 179, 113))
+                ("mediumslateblue", ColorT(123, 104, 238))
+                ("mediumspringgreen", ColorT(0, 250, 154))
+                ("mediumturquoise", ColorT(72, 209, 204))
+                ("mediumvioletred", ColorT(199, 21, 133))
+                ("midnightblue", ColorT(25, 25, 112))
+                ("mintcream", ColorT(245, 255, 250))
+                ("mistyrose", ColorT(255, 228, 225))
+                ("moccasin", ColorT(255, 228, 181))
+                ("navajowhite", ColorT(255, 222, 173))
+                ("navy", ColorT(0, 0, 128))
+                ("oldlace", ColorT(253, 245, 230))
+                ("olive", ColorT(128, 128, 0))
+                ("olivedrab", ColorT(107, 142, 35))
+                ("orange", ColorT(255, 165, 0))
+                ("orangered", ColorT(255, 69, 0))
+                ("orchid", ColorT(218, 112, 214))
+                ("palegoldenrod", ColorT(238, 232, 170))
+                ("palegreen", ColorT(152, 251, 152))
+                ("paleturquoise", ColorT(175, 238, 238))
+                ("palevioletred", ColorT(219, 112, 147))
+                ("papayawhip", ColorT(255, 239, 213))
+                ("peachpuff", ColorT(255, 218, 185))
+                ("peru", ColorT(205, 133, 63))
+                ("pink", ColorT(255, 192, 203))
+                ("plum", ColorT(221, 160, 221))
+                ("powderblue", ColorT(176, 224, 230))
+                ("purple", ColorT(128, 0, 128))
+                ("red", ColorT(255, 0, 0))
+                ("rosybrown", ColorT(188, 143, 143))
+                ("royalblue", ColorT(65, 105, 225))
+                ("saddlebrown", ColorT(139, 69, 19))
+                ("salmon", ColorT(250, 128, 114))
+                ("sandybrown", ColorT(244, 164, 96))
+                ("seagreen", ColorT(46, 139, 87))
+                ("seashell", ColorT(255, 245, 238))
+                ("sienna", ColorT(160, 82, 45))
+                ("silver", ColorT(192, 192, 192))
+                ("skyblue", ColorT(135, 206, 235))
+                ("slateblue", ColorT(106, 90, 205))
+                ("slategray", ColorT(112, 128, 144))
+                ("slategrey", ColorT(112, 128, 144))
+                ("snow", ColorT(255, 250, 250))
+                ("springgreen", ColorT(0, 255, 127))
+                ("steelblue", ColorT(70, 130, 180))
+                ("tan", ColorT(210, 180, 140))
+                ("teal", ColorT(0, 128, 128))
+                ("thistle", ColorT(216, 191, 216))
+                ("tomato", ColorT(255, 99, 71))
+                ("turquoise", ColorT(64, 224, 208))
+                ("violet", ColorT(238, 130, 238))
+                ("wheat", ColorT(245, 222, 179))
+                ("white", ColorT(255, 255, 255))
+                ("whitesmoke", ColorT(245, 245, 245))
+                ("yellow", ColorT(255, 255, 0))
+                ("yellowgreen", ColorT(154, 205, 50))
+                ;
+        }
+    };
+    
+    template <typename ActionsT>
+    struct css_color_grammar : public grammar<css_color_grammar<ActionsT> >
+    {
+        css_color_grammar(ActionsT& actions_)
+            : actions(actions_) {}
+    
+        template <typename ScannerT>
+        struct definition
+        {
+            definition(css_color_grammar const& self)
+            {
+                hex6 = ch_p('#') >> uint6x_p[self.actions.hex6_];
+                hex3 = ch_p('#') >> uint3x_p[self.actions.hex3_];
+                rgb = str_p("rgb") >> '(' >> uint3_p[self.actions.red_] 
+                                   >> ',' >> uint3_p[self.actions.green_] 
+                                   >> ',' >> uint3_p[self.actions.blue_] 
+                                   >> ')';
+                rgb_percent = str_p("rgb") >> '(' >> ureal_p[self.actions.red_p_] >> '%' 
+                                           >> ',' >> ureal_p[self.actions.green_p_] >> '%'
+                                           >> ',' >> ureal_p[self.actions.blue_p_] >> '%'
+                                           >> ')';
+                css_color = named_colors_p[self.actions.named_] | hex6 | hex3 | rgb_percent | rgb; 
+            }
+            boost::spirit::rule<ScannerT> rgb;
+            boost::spirit::rule<ScannerT> rgb_percent;
+            boost::spirit::rule<ScannerT> hex6;
+            boost::spirit::rule<ScannerT> hex3;
+            boost::spirit::rule<ScannerT> css_color;
+            boost::spirit::rule<ScannerT> const& start() const
+            {
+                return css_color;
+            }
+            uint_parser<unsigned, 10, 1, 3> uint3_p;
+            uint_parser<unsigned, 16, 6, 6> uint6x_p;
+            uint_parser<unsigned, 16, 3, 3> uint3x_p;
+            named_colors<typename ActionsT::color_type> named_colors_p;
+	    
+        };
+        ActionsT& actions;	
+    };
+    
+    template <typename ColorT>
+    struct named_color_action
+    {
+        named_color_action(ColorT& c)
+            : c_(c) {}
+	
+        void operator() (ColorT const&c) const
+        {
+            c_=c;
+        }
+        ColorT& c_;
+    };
+
+    template <typename ColorT>
+    struct hex6_action
+    {
+        hex6_action(ColorT& c)
+            : c_(c) {}
+	
+        void operator () (unsigned int hex) const
+        {
+            unsigned r = (hex >> 16) & 0xff;
+            unsigned g = (hex >> 8) & 0xff;
+            unsigned b = hex & 0xff;
+            c_.set_red(r);
+            c_.set_green(g);
+            c_.set_blue(b);
+        }
+        ColorT& c_;
+    };
+    
+    template <typename ColorT>
+    struct hex3_action
+    {
+        hex3_action(ColorT& c)
+            : c_(c) {}
+	
+        void operator () (unsigned int hex) const
+        {
+            unsigned int r = (hex >> 8) & 0xf;
+            unsigned int g = (hex >> 4) & 0xf;
+            unsigned int b = hex & 0xf;
+            c_.set_red( r | r << 4);
+            c_.set_green(g | g << 4);
+            c_.set_blue(b | b << 4);
+        }
+        ColorT& c_;
+    };
+
+    template <typename ColorT>
+    struct red_action
+    {
+        red_action(ColorT& c)
+            : c_(c) {}
+	
+        void operator () (unsigned int r) const
+        {
+            c_.set_red(r);
+        }
+        ColorT& c_;
+    };
+
+    template <typename ColorT>
+    struct green_action
+    {
+        green_action(ColorT& c)
+            : c_(c) {}
+	
+        void operator () (unsigned int g) const
+        {
+            c_.set_green(g);
+        }
+        ColorT& c_;
+    };
+	
+    template <typename ColorT>
+    struct blue_action
+    {
+        blue_action(ColorT& c)
+            : c_(c) {}
+	
+        void operator () (unsigned int b) const
+        {
+            c_.set_blue(b);
+        }
+        ColorT& c_;
+    };
+    
+
+    template <typename ColorT>
+    struct red_action_p
+    {
+        red_action_p(ColorT& c)
+            : c_(c) {}
+	
+        void operator () (double r) const
+        {
+            c_.set_red(unsigned((255.0 * r)/100.0 + 0.5));
+        }
+        ColorT& c_;
+    };
+
+    template <typename ColorT>
+    struct green_action_p
+    {
+        green_action_p(ColorT& c)
+            : c_(c) {}
+	
+        void operator () (double g) const
+        {
+            c_.set_green(unsigned((255.0 * g)/100.0 + 0.5));
+        }
+        ColorT& c_;
+    };
+
+    template <typename ColorT>
+    struct blue_action_p
+    {
+        blue_action_p(ColorT& c)
+            : c_(c) {}
+	
+        void operator () (double b) const
+        {
+            c_.set_blue(unsigned((255.0 * b)/100.0 + 0.5));
+        }
+        ColorT& c_;
+    };
+
+
+    template <typename ColorT>
+    struct actions
+    {
+        typedef ColorT color_type;
+        actions(ColorT& c)
+            : named_(c),
+              hex6_(c),
+              hex3_(c),
+              red_(c),
+              green_(c),
+              blue_(c),
+              red_p_(c),
+              green_p_(c),
+              blue_p_(c) {}
+        
+        named_color_action<ColorT> named_;
+        hex6_action<ColorT> hex6_;
+        hex3_action<ColorT> hex3_;
+        red_action<ColorT> red_;
+        green_action<ColorT> green_;
+        blue_action<ColorT> blue_;
+        red_action_p<ColorT> red_p_;
+        green_action_p<ColorT> green_p_;
+        blue_action_p<ColorT> blue_p_;
+    };
+}
+
+#endif //CSS_COLOR_PARSER_HPP

Copied: trunk/include/mapnik/ctrans.hpp (from rev 307, trunk/include/ctrans.hpp)
===================================================================
--- trunk/include/ctrans.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/ctrans.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,169 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: ctrans.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef CTRANS_HPP
+#define CTRANS_HPP
+
+#include <mapnik/envelope.hpp>
+#include <mapnik/coord_array.hpp>
+
+namespace mapnik {
+    typedef coord_array<coord2d> CoordinateArray;
+    
+    template <typename Transform,typename Geometry>
+    struct MAPNIK_DECL coord_transform
+    {
+        coord_transform(Transform const& t,Geometry& geom)
+            : t_(t), geom_(geom) {}
+	
+        unsigned  vertex(double *x , double *y) const
+        {
+            unsigned command = geom_.vertex(x,y);
+            *x = t_.forward_x_(x);
+            *y = t_.forward_y_(y);
+            return command;
+        }
+        void rewind (unsigned pos)
+        {
+            geom_.rewind(pos);
+        }
+	
+    private:
+        Transform const& t_;
+        Geometry& geom_;
+    };
+    
+    class CoordTransform
+    {
+    private:
+	    int width;
+	    int height;
+	    double scale_;
+	    Envelope<double> extent;
+    public:
+        CoordTransform(int width,int height,const Envelope<double>& extent)
+            :width(width),height(height),extent(extent)
+        {
+            double sx=((double)width)/extent.width();
+            double sy=((double)height)/extent.height();
+            scale_=std::min(sx,sy);
+        }
+	
+        inline double scale() const
+        {
+            return scale_;
+        }
+	
+        inline void forward_x(double* x) const 
+        {
+            *x = (*x - extent.minx() ) * scale_;   
+        }
+	
+        inline void forward_y(double* y) const 
+        {
+            *y = (extent.maxy() - *y) * scale_;
+        }
+
+        inline double forward_x_(double* x) const 
+        {
+            return (*x - extent.minx() ) * scale_;   
+        }
+	
+        inline double forward_y_(double* y) const 
+        {
+            return (extent.maxy() - *y) * scale_;
+        }
+
+        inline void backward_x(double* x) const
+        {
+            *x = extent.minx() + *x/scale_;
+        }
+	
+        inline void backward_y(double* y) const
+        {
+            *y = extent.maxy() - *y/scale_;
+        }
+	
+        inline coord2d& forward(coord2d& c) const
+        {
+            forward_x(&c.x);
+            forward_y(&c.y);
+            return c;
+        }
+
+        inline coord2d& backward(coord2d& c) const
+        {
+            backward_x(&c.x);
+            backward_y(&c.y);
+            return c;
+        }
+
+        inline Envelope<double> forward(const Envelope<double>& e) const
+        {
+            double x0 = e.minx();
+            double y0 = e.miny();
+            double x1 = e.maxx();
+            double y1 = e.maxy();
+            forward_x(&x0);
+            forward_y(&y0);
+            forward_x(&x1);
+            forward_y(&y1);
+            return Envelope<double>(x0,y0,x1,y1);
+        }
+
+        inline Envelope<double> backward(const Envelope<double>& e) const
+        {
+            double x0 = e.minx();
+            double y0 = e.miny();
+            double x1 = e.maxx();
+            double y1 = e.maxy();
+            backward_x(&x0);
+            backward_y(&y0);
+            backward_x(&x1);
+            backward_y(&y1);
+	    
+            return Envelope<double>(x0,y0,x1,y1);
+        }
+
+        inline CoordinateArray& forward(CoordinateArray& coords) const
+        {
+            for (unsigned i=0;i<coords.size();++i)
+            {
+                forward(coords[i]);
+            }
+            return coords;
+        }
+	
+        inline CoordinateArray& backward(CoordinateArray& coords) const
+        {
+            for (unsigned i=0;i<coords.size();++i)
+            {
+                backward(coords[i]);
+            }
+            return coords;
+        }
+    };
+}
+
+#endif //CTRANS_HPP

Copied: trunk/include/mapnik/datasource.hpp (from rev 307, trunk/include/datasource.hpp)
===================================================================
--- trunk/include/datasource.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/datasource.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,124 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: datasource.hpp 43 2005-04-22 18:52:47Z pavlenko $
+
+#ifndef DATASOURCE_HPP
+#define DATASOURCE_HPP
+// stl
+#include <map>
+#include <string>
+// boost
+#include <boost/utility.hpp>
+#include <boost/shared_ptr.hpp>
+// mapnik
+#include <mapnik/config.hpp>
+#include <mapnik/ctrans.hpp>
+#include <mapnik/params.hpp>
+#include <mapnik/feature.hpp>
+#include <mapnik/query.hpp>
+#include <mapnik/feature_layer_desc.hpp>
+
+namespace mapnik {    
+    typedef MAPNIK_DECL boost::shared_ptr<Feature> feature_ptr;
+    
+    struct MAPNIK_DECL Featureset
+    {
+        virtual feature_ptr next()=0;
+        virtual ~Featureset() {};
+    };
+
+    typedef boost::shared_ptr<Featureset> featureset_ptr;
+    
+    class MAPNIK_DECL datasource_exception : public std::exception
+    {
+    private:
+        const std::string message_;
+    public:
+        datasource_exception(const std::string& message=std::string())
+            :message_(message) {}
+
+        ~datasource_exception() throw() {}
+        virtual const char* what() const throw()
+        {
+            return message_.c_str();
+        }
+    };
+    
+    class MAPNIK_DECL datasource : private boost::noncopyable
+    {
+        parameters params_;
+    public:        
+        enum {
+            Vector,
+            Raster
+        };
+        
+        datasource (parameters const& params)
+            : params_(params) {}
+
+        parameters const& params() const
+        {
+            return params_;
+        }
+        
+        virtual int type() const=0;
+        virtual featureset_ptr features(const query& q) const=0;
+        virtual Envelope<double> const& envelope() const=0;
+        virtual layer_descriptor const& get_descriptor() const=0;
+        virtual ~datasource() {};
+    };
+    
+    typedef std::string datasource_name();
+    typedef datasource* create_ds(const parameters& params);
+    typedef void destroy_ds(datasource *ds);
+
+    
+    class datasource_deleter
+    {
+    public:
+        void operator() (datasource* ds)
+        {
+            delete ds;
+        }
+    };
+
+    typedef boost::shared_ptr<datasource> datasource_p;
+    
+    
+    #define DATASOURCE_PLUGIN(classname)                              \
+        extern "C" MAPNIK_DECL std::string datasource_name()            \
+        {                                                               \
+            return classname::name();                                   \
+        }                                                               \
+        extern "C"  MAPNIK_DECL datasource* create(const parameters &params) \
+        {                                                               \
+            return new classname(params);                               \
+        }                                                               \
+        extern "C" MAPNIK_DECL void destroy(datasource *ds)             \
+        {                                                               \
+            delete ds;                                                  \
+        }                                                               \
+        //
+}
+
+#endif //DATASOURCE_HPP

Copied: trunk/include/mapnik/datasource_cache.hpp (from rev 307, trunk/include/datasource_cache.hpp)
===================================================================
--- trunk/include/datasource_cache.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/datasource_cache.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,57 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: datasource_cache.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef DATASOURCE_CACHE_HPP
+#define DATASOURCE_CACHE_HPP
+
+// stl
+#include <map>
+// boost
+#include <boost/shared_ptr.hpp>
+// mapnik
+#include <mapnik/utils.hpp>
+#include <mapnik/params.hpp>
+#include <mapnik/plugin.hpp>
+#include <mapnik/datasource.hpp>
+
+namespace mapnik {
+    class MAPNIK_DECL datasource_cache : 
+        public singleton <datasource_cache,CreateStatic>
+    {
+        friend class CreateStatic<datasource_cache>;
+    private:
+        datasource_cache();
+        ~datasource_cache();
+        datasource_cache(const datasource_cache&);
+        datasource_cache& operator=(const datasource_cache&);
+        static std::map<std::string,boost::shared_ptr<PluginInfo> > plugins_;
+        static bool registered_;
+        static bool insert(const std::string&  name,const lt_dlhandle module);
+    public:
+        static void register_datasources(const std::string& path);
+        static boost::shared_ptr<datasource> create(parameters const& params);
+    };
+}
+
+#endif   //DATASOURCE_CACHE_HPP

Copied: trunk/include/mapnik/envelope.hpp (from rev 307, trunk/include/envelope.hpp)
===================================================================
--- trunk/include/envelope.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/envelope.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,89 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: envelope.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef ENVELOPE_HPP
+#define ENVELOPE_HPP
+
+// stl
+#include <iomanip>
+// mapnik
+#include <mapnik/config.hpp>
+#include <mapnik/coord.hpp>
+
+namespace mapnik {
+	template <class T> class MAPNIK_DECL Envelope
+    {
+    public:
+        typedef Envelope<T> EnvelopeType;
+    private:
+        T minx_;
+        T miny_;
+        T maxx_;
+        T maxy_;
+    public:
+        Envelope();
+        Envelope(T minx,T miny,T maxx,T maxy);
+        Envelope(const coord<T,2>& c0,const coord<T,2>& c1);
+        Envelope(const EnvelopeType& rhs);
+        T minx() const;
+        T miny() const;
+        T maxx() const;
+        T maxy() const;
+        T width() const;
+        T height() const;
+        void width(T w);
+        void height(T h);
+        coord<T,2> center() const;
+        void expand_to_include(T x,T y);
+        void expand_to_include(const coord<T,2>& c);
+        void expand_to_include(const EnvelopeType& other);
+        bool contains(const coord<T,2> &c) const;
+        bool contains(T x,T y) const;
+        bool contains(const EnvelopeType &other) const;
+        bool intersects(const coord<T,2> &c) const;
+        bool intersects(T x,T y) const;
+        bool intersects(const EnvelopeType &other) const;
+        EnvelopeType intersect(const EnvelopeType& other) const;
+        bool operator==(const EnvelopeType &other) const;
+        void re_center(T cx,T cy);
+        void init(T x0,T y0,T x1,T y1);
+    };
+    
+    template <class charT,class traits,class T>
+    inline std::basic_ostream<charT,traits>&
+    operator << (std::basic_ostream<charT,traits>& out,
+                 const Envelope<T>& e)
+    {
+        std::basic_ostringstream<charT,traits> s;
+        s.copyfmt(out);
+        s.width(0);
+        s <<"Envelope(" << std::setprecision(16) 
+          << e.minx() << "," << e.miny() <<"," 
+          << e.maxx() << "," << e.maxy() <<")";
+        out << s.str();
+        return out;
+    }
+}
+
+#endif // ENVELOPE_HPP

Copied: trunk/include/mapnik/expression.hpp (from rev 307, trunk/include/expression.hpp)
===================================================================
--- trunk/include/expression.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/expression.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,126 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef EXPRESSION_HPP
+#define EXPRESSION_HPP
+
+#include <mapnik/value.hpp>
+#include <mapnik/filter_visitor.hpp>
+
+namespace mapnik {
+    template <typename FeatureT> class filter_visitor;
+    template <typename FeatureT>
+    class expression
+    {
+    public:
+        virtual value get_value(FeatureT const& feature) const=0;
+        virtual void accept(filter_visitor<FeatureT>& v)=0;
+        virtual expression<FeatureT>* clone() const=0;
+        virtual std::string to_string() const=0;
+        virtual ~expression() {}
+    };
+
+    template <typename FeatureT> 
+    class literal : public expression<FeatureT>
+    {
+    public:
+        literal(int val)
+            : expression<FeatureT>(),
+              value_(val) {}
+        literal(double val)
+            : expression<FeatureT>(),
+              value_(val) {}
+        literal(std::string const& val)
+            : expression<FeatureT>(),
+              value_(val) {}
+        literal(literal const& other)
+            : expression<FeatureT>(),
+              value_(other.value_) {}
+	
+        value get_value(FeatureT const& /*feature*/) const
+        {
+            return value_;
+        }
+        void accept(filter_visitor<FeatureT>& v)
+        {
+            v.visit(*this);
+        }
+        expression<FeatureT>* clone() const
+        {
+            return new literal(*this); 
+        }
+        std::string to_string() const
+        {
+            return value_.to_expression_string();
+        }
+        ~literal() {}
+    private:
+        value value_;
+    };
+  
+
+    template <typename FeatureT> 
+    class property : public expression<FeatureT>
+    {
+    public:
+        property(std::string const& name)
+            : expression<FeatureT>(),
+              name_(name)
+	    {}
+	
+        property(property const& other)
+            : expression<FeatureT>(),
+              name_(other.name_)
+	    {}
+
+        value get_value(FeatureT const& feature) const
+        {
+            return feature[name_];
+        }
+        void accept(filter_visitor<FeatureT>& v)
+        {
+            v.visit(*this);
+        }
+        expression<FeatureT>* clone() const
+        {
+            return new property(*this); 
+        }
+        std::string const& name() const
+        {
+            return name_;
+        }
+
+        std::string to_string() const
+        {
+            return "["+name_+"]";
+        }
+
+        ~property() {}
+
+    private:
+	    std::string name_;
+    };
+}
+
+#endif //EXPRESSION_HPP

Copied: trunk/include/mapnik/factory.hpp (from rev 307, trunk/include/factory.hpp)
===================================================================
--- trunk/include/factory.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/factory.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,92 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: factory.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef FACTORY_HPP
+#define FACTORY_HPP
+
+// stl
+#include <stdexcept>
+#include <map>
+// mapnik
+#include <mapnik/utils.hpp>
+
+namespace mapnik {
+    template <typename key_type,
+              typename product_type>
+    class default_factory_error
+    {
+    public:
+        struct factory_exception : public std::exception
+        {
+            const char* what() const throw()
+            {
+                return "uknown object type";
+            }
+        };
+        static product_type* on_unknown_type(const key_type&)
+        {
+            return 0;
+        }
+    };
+
+    template
+    <
+        typename product_type,
+        typename key_type,
+        typename product_creator=product_type* (*)(),
+        template <typename,typename> class factory_error_policy=default_factory_error
+        >
+    class factory : public singleton<factory <product_type,
+                                              key_type,
+                                              product_creator,factory_error_policy> >,
+        factory_error_policy <key_type,product_type>
+    {
+    private:
+        typedef std::map<key_type,product_creator> product_map;
+        product_map map_;
+    public:
+
+        bool register_product(const key_type& key,product_creator creator)
+        {
+            return map_.insert(typename product_map::value_type(key,creator)).second;
+        }
+
+        bool unregister_product(const key_type& key)
+        {
+            return map_.erase(key)==1;
+        }
+
+        product_type* create_object(const key_type& key,const std::string& file)
+        {
+            typename product_map::const_iterator pos=map_.find(key);
+            if (pos!=map_.end())
+            {
+                return (pos->second)(file);
+            }
+            return on_unknown_type(key);
+        }
+    };
+}
+
+#endif //FACTORY_HPP

Copied: trunk/include/mapnik/feature.hpp (from rev 307, trunk/include/feature.hpp)
===================================================================
--- trunk/include/feature.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/feature.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,121 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: feature.hpp 40 2005-04-13 20:20:46Z pavlenko $
+
+#ifndef FEATURE_HPP
+#define FEATURE_HPP
+// stl
+#include <map>
+// boost
+#include <boost/property_map.hpp>
+#include <boost/utility.hpp>
+#include <boost/shared_ptr.hpp>
+// mapnik
+#include <mapnik/value.hpp>
+#include <mapnik/geometry.hpp>
+#include <mapnik/raster.hpp>
+
+namespace mapnik {
+    typedef boost::shared_ptr<raster> raster_ptr;    
+    typedef boost::associative_property_map<
+        std::map<std::string,value
+                 > > properties;
+    
+    template <typename T1,typename T2>
+    struct feature : public properties,
+                     private boost::noncopyable
+    {
+    public:
+        typedef T1 geometry_type;
+        typedef T2 raster_type;
+    private:
+        int id_;
+        geometry_type geom_;
+        raster_type   raster_;
+        std::map<std::string,value> props_;
+    public:
+        explicit feature(int id)
+            : properties(props_),
+              id_(id),
+              geom_(),
+              raster_() {}
+
+        feature(int id,const geometry_type& geom)
+            : properties(props_),
+              id_(id),
+              geom_(geom),
+              raster_() {}
+
+        int id() const 
+        {
+            return id_;
+        }
+	
+        void set_geometry(geometry_type& geom)
+        {
+            geom_=geom;
+        }
+	
+        geometry_type const& get_geometry() const
+        {
+            return geom_;
+        }
+        
+        const raster_type& get_raster() const
+        {
+            return raster_;
+        }
+        void set_raster(raster_type const& raster)
+        {
+            raster_=raster;
+        }
+	
+        const properties& get_properties() const 
+        {
+            return props_;
+        }
+	
+        std::string to_string() const
+        {
+            std::stringstream ss;
+            ss << "feature (" << std::endl;
+            for (std::map<std::string,value>::const_iterator itr=props_.begin();
+                 itr != props_.end();++itr)
+            {
+                ss << "  " << itr->first  << ":" <<  itr->second << std::endl;
+            }
+            ss << ")" << std::endl;
+            return ss.str();
+        }
+    };
+
+    typedef feature<geometry_ptr,raster_ptr> Feature;
+    
+    inline std::ostream& operator<< (std::ostream & out,Feature const& f)
+    {
+        out << f.to_string();
+    	return out;
+    }
+}
+
+#endif //FEATURE_HPP

Copied: trunk/include/mapnik/feature_factory.hpp (from rev 307, trunk/include/feature_factory.hpp)
===================================================================
--- trunk/include/feature_factory.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/feature_factory.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,41 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef FEATURE_FACTORY_HPP
+#define FEATURE_FACTORY_HPP
+
+#include <mapnik/feature.hpp>
+
+namespace mapnik
+{
+    struct feature_factory
+    {
+        static Feature* create (int fid)
+        {
+            return new Feature(fid);
+        }
+    }; 
+}
+
+#endif //FEATURE_FACTORY_HPP

Copied: trunk/include/mapnik/feature_layer_desc.hpp (from rev 307, trunk/include/feature_layer_desc.hpp)
===================================================================
--- trunk/include/feature_layer_desc.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/feature_layer_desc.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,250 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef FEATURE_LAYER_DESC_HPP
+#define FEATURE_LAYER_DESC_HPP
+
+#include <string>
+#include <vector>
+#include <iostream>
+
+namespace mapnik
+{
+    
+    using std::string;
+    using std::vector;
+    using std::clog;
+    using std::endl;
+    
+    enum {
+        Integer=1,
+        Float  =2,
+        Double =3,
+        String =4,
+        Geometry=5,
+        Object=6 
+    };
+    
+    class attribute_descriptor
+    {
+    public:
+        attribute_descriptor(string const& name,unsigned type,
+                             bool primary_key=false,
+                             int size=-1,
+                             int precision=-1)
+            : name_(name),
+              type_(type),
+              primary_key_(primary_key),
+              size_(size),
+              precision_(precision) {}
+	      
+        attribute_descriptor(attribute_descriptor const& other)
+            : name_(other.name_),
+              type_(other.type_),
+              primary_key_(other.primary_key_),
+              size_(other.size_),
+              precision_(other.precision_) {}
+
+        attribute_descriptor& operator=(attribute_descriptor const& other)
+        {
+            if (this == &other)
+                return *this;	    
+            name_=other.name_;
+            type_=other.type_;
+            primary_key_=other.primary_key_;
+            size_=other.size_;
+            precision_=other.precision_;
+            return *this;
+        }
+        string const& get_name() const
+        {
+            return name_;
+        }
+        unsigned  get_type() const
+        {
+            return type_;
+        }
+        bool is_primary_key() const
+        {
+            return primary_key_;
+        }
+        int get_size() const
+        {
+            return size_;
+        } 
+	
+        int get_precision() const
+        {
+            return precision_;
+        }
+    private:
+        string name_;
+        int type_;
+        bool primary_key_;
+        int size_;
+        int precision_;
+    };
+     
+    template <typename charT,typename traits>
+    inline std::basic_ostream<charT,traits>&
+    operator << (std::basic_ostream<charT,traits>& out,
+                 attribute_descriptor const& ad)
+    {
+        out << "name=" << ad.get_name() << endl;
+        out << "type=" << ad.get_type() << endl;
+        out << "size=" << ad.get_size() << endl;
+        return out;
+    }
+
+    class layer_descriptor 
+    {
+    public:
+        layer_descriptor(string const& name,int srid=-1)
+            : name_(name),
+              srid_(srid) {}
+
+        layer_descriptor(layer_descriptor const& other)
+            : name_(other.name_),
+              srid_(other.srid_),
+              desc_ar_(other.desc_ar_) {}
+	
+        void set_name(string const& name)
+        {
+            name_=name;
+        }
+        string const& get_name() const
+        {
+            return name_;
+        }
+	
+        void set_srid(int srid) 
+        {
+            srid_=srid;
+        }
+	
+        int get_srid() const
+        {
+            return srid_;
+        }
+
+        void add_descriptor(attribute_descriptor const& desc)
+        {
+            desc_ar_.push_back(desc);
+        }
+	
+        vector<attribute_descriptor> const& get_descriptors() const
+        {
+            return desc_ar_;
+        }	
+        vector<attribute_descriptor>& get_descriptors()
+        {
+            return desc_ar_;
+        }
+    private:
+        string name_;
+        int srid_;
+        vector<attribute_descriptor> desc_ar_;
+    };
+    
+    template <typename charT,typename traits>
+    inline std::basic_ostream<charT,traits>&
+    operator << (std::basic_ostream<charT,traits>& out,
+                 layer_descriptor const& ld)
+    {
+        out << "name=" << ld.get_name() << endl;
+        out << "srid=" << ld.get_srid() << endl;
+        vector<attribute_descriptor> const& desc_ar=ld.get_descriptors();
+        vector<attribute_descriptor>::const_iterator pos=desc_ar.begin();
+        while (pos != desc_ar.end())
+        {
+            out << *pos++ << endl;
+	    
+        }
+        return out;
+    }
+    /*    
+          bool layer_descriptor_to_wkb(layer_descriptor const& desc,array<>& wkb)
+          {
+          //srid	
+          int srid = desc.get_srid();
+          wkb.write(&srid,sizeof(int));
+
+          //attribute descriptors
+          vector<attribute_descriptor> const& desc_ar = desc.get_descriptors();
+          vector<attribute_descriptor>::const_iterator itr=desc_ar.begin();
+          size_t num_desc = desc_ar.size();
+          wkb.write(&num_desc,sizeof(int));
+	
+          while (itr != desc_ar.end())
+          {
+          string name = itr->get_name();
+          wkb.write(name.c_str(),name.size()+1);
+	       
+          unsigned type = static_cast<int>(itr->get_type());
+          wkb.write(&type,sizeof(unsigned));
+
+          bool prim_key = itr->is_primary_key();
+          wkb.write(&prim_key,sizeof(bool));
+
+          int size = itr->get_size();
+          wkb.write(&size,sizeof(int));
+            
+          ++itr;
+          }	
+          return true;
+          }
+    
+          bool layer_descriptor_from_wkb(const char* wkb, layer_descriptor &desc)
+          {
+          unsigned pos=0;
+          int srid;
+	
+          memcpy(&srid,wkb+pos,sizeof(int));
+          desc.set_srid(srid);
+          pos+=sizeof(int);
+	
+          int num_desc;
+          memcpy(&num_desc,wkb+pos,sizeof(int));
+          pos+=sizeof(int);
+	
+          for (int i=0;i<num_desc;++i)
+          {
+          string name = wkb+pos;
+          pos += name.size()+1;
+          //std::clog<<"name="<<name<<"\n";
+	    
+          int type;
+          memcpy(&type,wkb+pos,sizeof(int));
+          pos += sizeof(int);
+          attribute_descriptor ad(name,type);
+          desc.add_descriptor(ad);
+          //todo!!!
+          pos += 4+1;
+          }
+          return true;
+          }
+    */    
+}
+
+#endif //FEATURE_LAYER_DESC_HPP

Copied: trunk/include/mapnik/feature_style_processor.hpp (from rev 307, trunk/include/feature_style_processor.hpp)
===================================================================
--- trunk/include/feature_style_processor.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/feature_style_processor.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,189 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef FEATURE_STYLE_PROCESSOR_HPP
+#define FEATURE_STYLE_PROCESSOR_HPP
+
+//stl
+#include <vector>
+// boost
+#include <boost/progress.hpp>
+// mapnik
+#include <mapnik/envelope.hpp>
+#include <mapnik/datasource.hpp>
+#include <mapnik/layer.hpp>
+#include <mapnik/map.hpp>
+#include <mapnik/attribute_collector.hpp>
+#include <mapnik/utils.hpp>
+
+namespace mapnik
+{       
+    template <typename Processor>
+    class feature_style_processor 
+    {
+        struct symbol_dispatch : public boost::static_visitor<>
+        {
+            symbol_dispatch (Processor & output,Feature const& f)
+                : output_(output),f_(f) {}
+	    
+            template <typename T>
+            void operator () (T const& sym) const
+            {
+                output_.process(sym,f_);
+            }
+
+            Processor & output_;
+            Feature const& f_;
+        };
+    public:
+        feature_style_processor(Map const& m)
+            : m_(m) {}
+	
+        void apply()
+        {
+            boost::progress_timer t;
+            Processor & p = static_cast<Processor&>(*this);
+
+            p.start_map_processing(m_);
+	    
+            std::vector<Layer>::const_iterator itr = m_.layers().begin();
+            while (itr != m_.layers().end())
+            {
+                if (itr->isVisible(m_.scale()) && 
+                    itr->envelope().intersects(m_.getCurrentExtent()))
+                {
+                    apply_to_layer(*itr,p);
+                }
+                ++itr;
+            }
+            p.end_map_processing(m_);
+        }	
+    private:
+        void apply_to_layer(Layer const& lay,Processor & p)
+        {
+            p.start_layer_processing(lay);
+            datasource *ds=lay.datasource().get();
+            if (ds)
+            {
+                Envelope<double> const& bbox=m_.getCurrentExtent();
+                double scale = m_.scale();
+	
+                std::vector<std::string> const& style_names = lay.styles();
+                std::vector<std::string>::const_iterator stylesIter = style_names.begin();
+                while (stylesIter != style_names.end())
+                {
+                    std::set<std::string> names;
+                    attribute_collector<Feature> collector(names);
+                    std::vector<rule_type*> if_rules;
+                    std::vector<rule_type*> else_rules;
+		
+                    bool active_rules=false;
+		    
+                    feature_type_style const& style=m_.find_style(*stylesIter++);
+		    
+                    const std::vector<rule_type>& rules=style.get_rules();
+                    std::vector<rule_type>::const_iterator ruleIter=rules.begin();
+		    
+                    query q(bbox); //BBOX query
+                    while (ruleIter!=rules.end())
+                    {
+                        if (ruleIter->active(scale))
+                        {
+                            active_rules=true;
+                            ruleIter->accept(collector);
+
+                            if (ruleIter->has_else_filter())
+                            {
+                                else_rules.push_back(const_cast<rule_type*>(&(*ruleIter)));
+                            }
+                            else
+                            {
+                                if_rules.push_back(const_cast<rule_type*>(&(*ruleIter))); 		    
+                            }
+                        }
+                        ++ruleIter;
+                    }
+                    std::set<std::string>::const_iterator namesIter=names.begin();
+                    // push all property names
+                    while (namesIter!=names.end())
+                    {
+                        q.add_property_name(*namesIter);
+                        ++namesIter;
+                    }
+                    if (active_rules)
+                    {
+                        featureset_ptr fs=ds->features(q);
+                        if (fs)
+                        {   	    
+                            feature_ptr feature;
+                            while ((feature = fs->next()))
+                            {		   
+                                bool do_else=true;		    
+                                std::vector<rule_type*>::const_iterator itr=if_rules.begin();
+                                while (itr!=if_rules.end())
+                                {
+                                    filter_ptr const& filter=(*itr)->get_filter();    
+                                    if (filter->pass(*feature))
+                                    {   
+                                        do_else=false;
+                                        const symbolizers& symbols = (*itr)->get_symbolizers();
+                                        symbolizers::const_iterator symIter=symbols.begin();
+                                        while (symIter!=symbols.end())
+                                        {   
+                                            boost::apply_visitor
+                                                (symbol_dispatch(p,*feature),*symIter++);
+                                        }
+                                    }			    
+                                    ++itr;
+                                }
+                                if (do_else)
+                                {
+                                    //else filter
+                                    std::vector<rule_type*>::const_iterator itr=
+                                        else_rules.begin();
+                                    while (itr != else_rules.end())
+                                    {
+                                        const symbolizers& symbols = (*itr)->get_symbolizers();
+                                        symbolizers::const_iterator symIter=symbols.begin();
+                                        while (symIter!=symbols.end())
+                                        {
+                                            boost::apply_visitor
+                                                (symbol_dispatch(p,*feature),*symIter++);
+                                        }
+                                        ++itr;
+                                    }
+                                }	  
+                            }
+                        }
+                    }
+                }
+            }
+            p.end_layer_processing(lay);
+        }
+	
+        Map const& m_;
+    };
+}
+
+#endif //FEATURE_STYLE_PROCESSOR_HPP

Copied: trunk/include/mapnik/feature_type_style.hpp (from rev 307, trunk/include/feature_type_style.hpp)
===================================================================
--- trunk/include/feature_type_style.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/feature_type_style.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,67 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef FEATURE_TYPE_STYLE_HPP
+#define FEATURE_TYPE_STYLE_HPP
+// stl
+#include <vector>
+// mapnik 
+#include <mapnik/rule.hpp>
+#include <mapnik/feature.hpp>
+
+namespace mapnik
+{
+    typedef std::vector<rule_type> rules;
+    class feature_type_style
+    {
+    private:
+        rules  rules_;
+    public:
+        feature_type_style() {}
+
+        feature_type_style(feature_type_style const& rhs)
+            : rules_(rhs.rules_) {}
+	
+        feature_type_style& operator=(feature_type_style const& rhs)
+        {
+            if (this == &rhs) return *this;
+            rules_=rhs.rules_;
+            return *this;
+        }
+	
+        void add_rule(rule_type const& rule)
+        {
+            rules_.push_back(rule);
+        } 
+	
+        rules const& get_rules() const
+        {
+            return rules_;
+        }
+	
+        ~feature_type_style() {}
+    };
+}
+
+#endif //FEATURE_TYPE_STYLE_HPP

Copied: trunk/include/mapnik/fill.hpp (from rev 307, trunk/include/fill.hpp)

Copied: trunk/include/mapnik/filter.hpp (from rev 307, trunk/include/filter.hpp)
===================================================================
--- trunk/include/filter.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/filter.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,90 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef FILTER_HPP
+#define FILTER_HPP
+
+#include <mapnik/config.hpp>
+#include <mapnik/feature.hpp>
+
+namespace mapnik
+{
+    template <typename FeatureT> class filter_visitor;
+    template <typename FeatureT>
+    class MAPNIK_DECL filter
+    {
+	public:
+		virtual bool pass(const FeatureT& feature) const=0; 
+		virtual filter<FeatureT>* clone() const=0;
+		virtual void accept(filter_visitor<FeatureT>& v) = 0;
+        virtual std::string to_string() const=0;
+		virtual ~filter() {}
+    };
+    
+    typedef boost::shared_ptr<filter<Feature> > filter_ptr;
+    
+    template <typename FeatureT>
+    class all_filter : public filter<FeatureT>
+    {
+	public:
+		bool pass (const FeatureT&) const
+		{
+			return true;
+		}
+	
+		filter<FeatureT>* clone() const
+		{
+			return new all_filter<FeatureT>;
+		}
+		std::string to_string() const
+		{
+			return "true";
+		}  
+        void accept(filter_visitor<FeatureT>&) {}
+		virtual ~all_filter() {}
+    };
+      
+    template <typename FeatureT>
+    class none_filter : public filter<FeatureT>
+    {
+	public:
+		bool pass (const FeatureT&) const
+		{
+			return false;
+		}
+	
+		filter<FeatureT>* clone() const
+		{
+			return new none_filter<FeatureT>;
+		}
+		std::string to_string() const
+		{
+			return "false";
+		}  
+	    void accept(filter_visitor<FeatureT>&) {}
+		virtual ~none_filter() {}
+	};
+}
+
+#endif //FILTER_HPP

Copied: trunk/include/mapnik/filter_expression.hpp (from rev 307, trunk/include/filter_expression.hpp)
===================================================================
--- trunk/include/filter_expression.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/filter_expression.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,67 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef FILTER_TO_STRING_HPP
+#define FILTER_TO_STRING_HPP
+
+// stl
+#include <set>
+// mapnik
+#include <mapnik/filter.hpp>
+#include <mapnik/expression.hpp>
+
+namespace mapnik
+{
+    template <typename FeatureT>
+    class filter_to_string : public filter_visitor<FeatureT>
+    {
+    private:
+        std::string text_;
+    public:
+        filter_to_string() {}
+        void visit(filter<FeatureT>& /*filter*/) 
+        { 
+            //not interested
+        }
+        void visit(expression<FeatureT>& exp)
+        {
+            property<FeatureT>* pf;
+            if ((pf = dynamic_cast<property<FeatureT>*>(&exp)))
+            {
+                names_.insert(pf->name());
+            }
+        }
+        std::string const& text() const
+        {
+            return text_;
+        }
+	
+        virtual ~filter_to_string() {}
+    private:
+        filter_to_string(filter_to_string const&);
+        filter_to_string& operator=(filter_to_string const&);
+    };
+}
+
+#endif //FILTER_TO_STRING

Copied: trunk/include/mapnik/filter_factory.hpp (from rev 307, trunk/include/filter_factory.hpp)
===================================================================
--- trunk/include/filter_factory.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/filter_factory.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,60 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef FILTER_FACTORY_HPP
+#define FILTER_FACTORY_HPP
+
+#include <mapnik/filter_parser.hpp>
+
+namespace mapnik
+{
+    using std::string;
+    
+    template<typename FeatureT>
+    class MAPNIK_DECL filter_factory
+    {
+    public:
+        static filter_ptr compile(string const& str)
+        {
+            stack<shared_ptr<filter<FeatureT> > > filters;
+            stack<shared_ptr<expression<FeatureT> > > exps;
+            filter_grammar<FeatureT> grammar(filters,exps);
+            char const *text = str.c_str();
+            parse_info<> info = parse(text,text+strlen(text),grammar,space_p);
+            if (info.full && !filters.empty())
+            {
+                return filters.top();	
+            }
+            else 
+            {
+                clog << "failed at :" << info.stop << "\n";
+                return filter_ptr(new none_filter<FeatureT>());
+            }  
+        }
+    };
+    
+    MAPNIK_DECL filter_ptr create_filter (std::string const& wkt);
+}
+
+#endif //FILTER_FACTORY_HPP

Copied: trunk/include/mapnik/filter_parser.hpp (from rev 307, trunk/include/filter_parser.hpp)
===================================================================
--- trunk/include/filter_parser.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/filter_parser.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,453 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+
+//$Id$
+
+#ifndef FILTER_PARSER_HPP
+#define FILTER_PARSER_HPP
+// stl
+#include <stack>
+#include <iostream>
+// boost
+#include <boost/shared_ptr.hpp>
+#include <boost/spirit/core.hpp>
+#include <boost/spirit/symbols.hpp>
+#include <boost/spirit/utility/confix.hpp>
+#include <boost/spirit/utility/escape_char.hpp>
+#include <boost/spirit/utility/chset.hpp> 
+// mapnik
+#include <mapnik/value.hpp>
+#include <mapnik/comparison.hpp>
+#include <mapnik/math_expr.hpp>
+#include <mapnik/expression.hpp>
+#include <mapnik/filter.hpp>
+#include <mapnik/regex_filter.hpp>
+#include <mapnik/logical.hpp>
+
+using namespace boost::spirit;
+using boost::shared_ptr;
+
+namespace mapnik
+{    
+    using std::string;
+    using std::clog;
+    using std::stack;
+
+    template <typename FeatureT>
+    struct push_integer
+    {
+        push_integer(stack<shared_ptr<expression<FeatureT> > >& exprs)
+            : exprs_(exprs) {}
+	
+        void operator() (int val) const
+        {
+            exprs_.push(shared_ptr<expression<FeatureT> >
+                        ( new literal<FeatureT>(val)));
+        }
+        stack<shared_ptr<expression<FeatureT> > >& exprs_;
+    };
+   
+    template <typename FeatureT>
+    struct push_real
+    {
+        push_real(stack<shared_ptr<expression<FeatureT> > >& exprs)
+            : exprs_(exprs) {}
+        void operator() (double val) const
+        {
+            exprs_.push(shared_ptr<expression<FeatureT> >(new literal<FeatureT>(val)));
+        }
+        stack<shared_ptr<expression<FeatureT> > >& exprs_;
+    };
+    
+    template <typename FeatureT>
+    struct push_string
+    {
+        push_string(stack<shared_ptr<expression<FeatureT> > >& exprs)
+            : exprs_(exprs) {}
+	
+        template <typename Iter>
+        void operator() (Iter start,Iter end) const
+        {
+            string str(start,end);
+            char quote='\\';
+            string::size_type idx;
+            idx = str.find(quote);
+            while (idx != string::npos)
+            {	    		
+                str.erase(idx,1);
+                idx = str.find(quote);
+            }
+            exprs_.push(shared_ptr<expression<FeatureT> >(new literal<FeatureT>(str)));
+        }
+        stack<shared_ptr<expression<FeatureT> > >& exprs_;
+    };
+    
+    template <typename FeatureT>
+    struct push_property
+    {
+        push_property(stack<shared_ptr<expression<FeatureT> > >& exprs)
+            : exprs_(exprs) {}
+	
+        template <typename Iter>
+        void operator() (Iter start,Iter end) const
+        {
+            string str(start,end);
+            exprs_.push(shared_ptr<expression<FeatureT> >(new property<FeatureT>(str)));
+        }
+        stack<shared_ptr<expression<FeatureT> > >& exprs_;
+    };
+
+    template <typename FeatureT,typename Op>
+    struct compose_expression
+    {
+        compose_expression(stack<shared_ptr<expression<FeatureT> > >& exprs)
+            : exprs_(exprs) {}
+
+        template <typename Iter>
+        void operator() (Iter,Iter) const
+        {
+            if (exprs_.size()>=2)
+            {
+                shared_ptr<expression<FeatureT> > right = exprs_.top();
+                exprs_.pop();
+                shared_ptr<expression<FeatureT> > left = exprs_.top();
+                exprs_.pop();
+                if (left && right)
+                {
+                    exprs_.push(shared_ptr<expression<FeatureT> >
+                                (new mapnik::math_expr_b<FeatureT,Op>(*left,*right)));
+                }
+            }
+        }
+        stack<shared_ptr<expression<FeatureT> > >& exprs_;
+    };
+    
+    template <typename FeatureT>
+    struct compose_regex
+    {
+        compose_regex(stack<shared_ptr<filter<FeatureT> > >& filters,
+                      stack<shared_ptr<expression<FeatureT> > >& exprs)
+            : filters_(filters),exprs_(exprs) {}
+
+        template <typename Iter>
+        void operator() (Iter start,Iter end) const
+        {
+            if (exprs_.size()>=1)
+            {
+                shared_ptr<expression<FeatureT> > exp = exprs_.top();
+                exprs_.pop();
+                if (exp)
+                {		    
+                    std::string pattern(start,end);
+                    try 
+                    {
+                        filters_.push(shared_ptr<filter<FeatureT> >
+                                      (new regex_filter<FeatureT>(*exp,pattern)));
+                    }
+                    catch (...)//boost::regex_error& ex)
+                    {
+                        clog<<"error\n";//ex.what()<<"\n";
+                    }
+		    
+                }
+            }
+        }
+        stack<shared_ptr<filter<FeatureT> > >& filters_;
+        stack<shared_ptr<expression<FeatureT> > >& exprs_;
+    };
+
+  
+    template <typename FeatureT,typename Op>
+    struct compose_filter
+    {
+        compose_filter(stack<shared_ptr<filter<FeatureT> > >& filters,
+                       stack<shared_ptr<expression<FeatureT> > >& exprs)
+            : filters_(filters),exprs_(exprs) {}
+
+        template <typename Iter>
+        void operator() (Iter,Iter) const
+        {
+            if (exprs_.size()>=2)
+            {
+                shared_ptr<expression<FeatureT> > right = exprs_.top();
+                exprs_.pop();
+                shared_ptr<expression<FeatureT> > left = exprs_.top();
+                exprs_.pop();
+                if (left && right)
+                {
+                    filters_.push(shared_ptr<filter<FeatureT> >(new compare_filter<FeatureT,Op>(*left,*right)));
+                }
+            }
+        }
+        stack<shared_ptr<filter<FeatureT> > >& filters_;
+        stack<shared_ptr<expression<FeatureT> > >& exprs_;
+    };
+    
+    template <typename FeatureT>
+    struct compose_and_filter
+    {
+        compose_and_filter(stack<shared_ptr<filter<FeatureT> > >& filters)
+            : filters_(filters) {}
+
+        template <typename Iter>
+        void operator() (Iter,Iter) const
+        {
+            if (filters_.size()>=2)
+            {
+                shared_ptr<filter<FeatureT> > right = filters_.top();
+                filters_.pop();
+                shared_ptr<filter<FeatureT> > left = filters_.top();
+                filters_.pop();
+                if (left && right)
+                {
+                    filters_.push(shared_ptr<filter<FeatureT> >
+                                  (new logical_and<FeatureT>(*left,*right)));
+                }
+            }
+        }
+        stack<shared_ptr<filter<FeatureT> > >& filters_;
+    };
+    
+    template <typename FeatureT>
+    struct compose_or_filter
+    {
+        compose_or_filter(stack<shared_ptr<filter<FeatureT> > >& filters)
+            : filters_(filters) {}
+
+        template <typename Iter>
+        void operator() (Iter,Iter) const
+        {
+            if (filters_.size()>=2)
+            {
+                shared_ptr<filter<FeatureT> > right = filters_.top();
+                filters_.pop();
+                shared_ptr<filter<FeatureT> > left = filters_.top();
+                filters_.pop();
+                if (left && right)
+                {
+                    filters_.push(shared_ptr<filter<FeatureT> >
+                                  (new logical_or<FeatureT>(*left,*right)));
+                }
+            }
+        }
+        stack<shared_ptr<filter<FeatureT> > >& filters_;
+    };
+    
+    template <typename FeatureT>
+    struct compose_not_filter
+    {
+        compose_not_filter(stack<shared_ptr<filter<FeatureT> > >& filters)
+            : filters_(filters) {}
+
+        template <typename Iter>
+        void operator() (Iter,Iter) const
+        {
+            if (filters_.size()>=1)
+            {
+                shared_ptr<filter<FeatureT> > filter_ = filters_.top();
+                filters_.pop();
+                if (filter_)
+                {
+                    filters_.push(shared_ptr<filter<FeatureT> >(new logical_not<FeatureT>(*filter_)));
+                }
+            }
+        }
+        stack<shared_ptr<filter<FeatureT> > >& filters_;
+    };
+    
+    template <typename FeatureT>
+    struct filter_grammar : public grammar<filter_grammar<FeatureT> >
+    {
+        filter_grammar(stack<shared_ptr<filter<FeatureT> > >& filters_,
+                       stack<shared_ptr<expression<FeatureT> > >& exprs_)
+            : filters(filters_),exprs(exprs_) {}
+	
+        template <typename ScannerT>
+        struct definition
+        {
+            definition(filter_grammar const& self)
+            {	
+                typedef boost::spirit::chset<wchar_t> chset_t;
+
+                func1_op = "sqrt","sin","cos";
+                func2_op = "min","max";
+                spatial_op = "Equals","Disjoint","Touches","Within","Overlaps",
+                    "Crosses","Intersects","Contains","DWithin","Beyond","BBOX";
+		
+                chset_t BaseChar (L"\x41-\x5A\x61-\x7A\xC0-\xD6\xD8-\xF6\xF8-\xFF\x100-\x131\x134-\x13E"
+                                  L"\x141-\x148\x14A-\x17E\x180-\x1C3\x1CD-\x1F0\x1F4-\x1F5\x1FA-\x217"
+                                  L"\x250-\x2A8\x2BB-\x2C1\x386\x388-\x38A\x38C\x38E-\x3A1\x3A3-\x3CE"
+                                  L"\x3D0-\x3D6\x3DA\x3DC\x3DE\x3E0\x3E2-\x3F3\x401-\x40C\x40E-\x44F"
+                                  L"\x451-\x45C\x45E-\x481\x490-\x4C4\x4C7-\x4C8\x4CB-\x4CC\x4D0-\x4EB"
+                                  L"\x4EE-\x4F5\x4F8-\x4F9\x531-\x556\x559\x561-\x586\x5D0-\x5EA"
+                                  L"\x5F0-\x5F2\x621-\x63A\x641-\x64A\x671-\x6B7\x6BA-\x6BE\x6C0-\x6CE"
+                                  L"\x6D0-\x6D3\x6D5\x6E5-\x6E6\x905-\x939\x93D\x958-\x961\x985-\x98C"
+                                  L"\x98F-\x990\x993-\x9A8\x9AA-\x9B0\x9B2\x9B6-\x9B9\x9DC-\x9DD"
+                                  L"\x9DF-\x9E1\x9F0-\x9F1\xA05-\xA0A\xA0F-\xA10\xA13-\xA28\xA2A-\xA30"
+                                  L"\xA32-\xA33\xA35-\xA36\xA38-\xA39\xA59-\xA5C\xA5E\xA72-\xA74"
+                                  L"\xA85-\xA8B\xA8D\xA8F-\xA91\xA93-\xAA8\xAAA-\xAB0\xAB2-\xAB3"
+                                  L"\xAB5-\xAB9\xABD\xAE0\xB05-\xB0C\xB0F-\xB10\xB13-\xB28\xB2A-\xB30"
+                                  L"\xB32-\xB33\xB36-\xB39\xB3D\xB5C-\xB5D\xB5F-\xB61\xB85-\xB8A"
+                                  L"\xB8E-\xB90\xB92-\xB95\xB99-\xB9A\xB9C\xB9E-\xB9F\xBA3-\xBA4"
+                                  L"\xBA8-\xBAA\xBAE-\xBB5\xBB7-\xBB9\xC05-\xC0C\xC0E-\xC10\xC12-\xC28"
+                                  L"\xC2A-\xC33\xC35-\xC39\xC60-\xC61\xC85-\xC8C\xC8E-\xC90\xC92-\xCA8"
+                                  L"\xCAA-\xCB3\xCB5-\xCB9\xCDE\xCE0-\xCE1\xD05-\xD0C\xD0E-\xD10"
+                                  L"\xD12-\xD28\xD2A-\xD39\xD60-\xD61\xE01-\xE2E\xE30\xE32-\xE33"
+                                  L"\xE40-\xE45\xE81-\xE82\xE84\xE87-\xE88\xE8A\xE8D\xE94-\xE97"
+                                  L"\xE99-\xE9F\xEA1-\xEA3\xEA5\xEA7\xEAA-\xEAB\xEAD-\xEAE\xEB0"
+                                  L"\xEB2-\xEB3\xEBD\xEC0-\xEC4\xF40-\xF47\xF49-\xF69\x10A0-\x10C5"
+                                  L"\x10D0-\x10F6\x1100\x1102-\x1103\x1105-\x1107\x1109\x110B-\x110C"
+                                  L"\x110E-\x1112\x113C\x113E\x1140\x114C\x114E\x1150\x1154-\x1155"
+                                  L"\x1159\x115F-\x1161\x1163\x1165\x1167\x1169\x116D-\x116E"
+                                  L"\x1172-\x1173\x1175\x119E\x11A8\x11AB\x11AE-\x11AF\x11B7-\x11B8"
+                                  L"\x11BA\x11BC-\x11C2\x11EB\x11F0\x11F9\x1E00-\x1E9B\x1EA0-\x1EF9"
+                                  L"\x1F00-\x1F15\x1F18-\x1F1D\x1F20-\x1F45\x1F48-\x1F4D\x1F50-\x1F57"
+                                  L"\x1F59\x1F5B\x1F5D\x1F5F-\x1F7D\x1F80-\x1FB4\x1FB6-\x1FBC\x1FBE"
+                                  L"\x1FC2-\x1FC4\x1FC6-\x1FCC\x1FD0-\x1FD3\x1FD6-\x1FDB\x1FE0-\x1FEC"
+                                  L"\x1FF2-\x1FF4\x1FF6-\x1FFC\x2126\x212A-\x212B\x212E\x2180-\x2182"
+                                  L"\x3041-\x3094\x30A1-\x30FA\x3105-\x312C\xAC00-\xD7A3");
+            
+                chset_t Ideographic(L"\x4E00-\x9FA5\x3007\x3021-\x3029");
+                chset_t Letter = BaseChar | Ideographic;
+	    
+                chset_t CombiningChar(L"\x0300-\x0345\x0360-\x0361\x0483-\x0486\x0591-\x05A1\x05A3-\x05B9"
+                                      L"\x05BB-\x05BD\x05BF\x05C1-\x05C2\x05C4\x064B-\x0652\x0670"
+                                      L"\x06D6-\x06DC\x06DD-\x06DF\x06E0-\x06E4\x06E7-\x06E8\x06EA-\x06ED"
+                                      L"\x0901-\x0903\x093C\x093E-\x094C\x094D\x0951-\x0954\x0962-\x0963"
+                                      L"\x0981-\x0983\x09BC\x09BE\x09BF\x09C0-\x09C4\x09C7-\x09C8"
+                                      L"\x09CB-\x09CD\x09D7\x09E2-\x09E3\x0A02\x0A3C\x0A3E\x0A3F"
+                                      L"\x0A40-\x0A42\x0A47-\x0A48\x0A4B-\x0A4D\x0A70-\x0A71\x0A81-\x0A83"
+                                      L"\x0ABC\x0ABE-\x0AC5\x0AC7-\x0AC9\x0ACB-\x0ACD\x0B01-\x0B03\x0B3C"
+                                      L"\x0B3E-\x0B43\x0B47-\x0B48\x0B4B-\x0B4D\x0B56-\x0B57\x0B82-\x0B83"
+                                      L"\x0BBE-\x0BC2\x0BC6-\x0BC8\x0BCA-\x0BCD\x0BD7\x0C01-\x0C03"
+                                      L"\x0C3E-\x0C44\x0C46-\x0C48\x0C4A-\x0C4D\x0C55-\x0C56\x0C82-\x0C83"
+                                      L"\x0CBE-\x0CC4\x0CC6-\x0CC8\x0CCA-\x0CCD\x0CD5-\x0CD6\x0D02-\x0D03"
+                                      L"\x0D3E-\x0D43\x0D46-\x0D48\x0D4A-\x0D4D\x0D57\x0E31\x0E34-\x0E3A"
+                                      L"\x0E47-\x0E4E\x0EB1\x0EB4-\x0EB9\x0EBB-\x0EBC\x0EC8-\x0ECD"
+                                      L"\x0F18-\x0F19\x0F35\x0F37\x0F39\x0F3E\x0F3F\x0F71-\x0F84"
+                                      L"\x0F86-\x0F8B\x0F90-\x0F95\x0F97\x0F99-\x0FAD\x0FB1-\x0FB7\x0FB9"
+                                      L"\x20D0-\x20DC\x20E1\x302A-\x302F\x3099\x309A");
+	    
+                chset_t Digit(L"\x0030-\x0039\x0660-\x0669\x06F0-\x06F9\x0966-\x096F\x09E6-\x09EF"
+                              L"\x0A66-\x0A6F\x0AE6-\x0AEF\x0B66-\x0B6F\x0BE7-\x0BEF\x0C66-\x0C6F"
+                              L"\x0CE6-\x0CEF\x0D66-\x0D6F\x0E50-\x0E59\x0ED0-\x0ED9\x0F20-\x0F29");
+		
+                chset_t Extender(L"\x00B7\x02D0\x02D1\x0387\x0640\x0E46\x0EC6\x3005\x3031-\x3035"
+                                 L"\x309D-\x309E\x30FC-\x30FE");
+		
+                chset_t NameChar =
+                    Letter 
+                    | Digit 
+                    | L'.'
+                    | L'-'
+                    | L'_'
+                    | L':'
+                    | CombiningChar 
+                    | Extender;
+				
+                number = strict_real_p [push_real<FeatureT>(self.exprs)] 
+                    | int_p [push_integer<FeatureT>(self.exprs)];
+		
+                string_ = confix_p(L'\'',(*lex_escape_ch_p)
+                                   [push_string<FeatureT>(self.exprs)],
+                                   L'\'');
+		
+                property = L'[' >> ( (Letter | L'_' | L':') 
+                                     >> *NameChar )[push_property<FeatureT>(self.exprs)] >> L']';
+		
+                literal = number | string_ | property;
+		
+                function = literal | ( func1_op >> L'('>> literal >> L')') | 
+                    (func2_op >> L'(' >> literal >> L','>> literal >> L')');
+		
+                factor = function 
+                    | L'(' >> or_expr >> L')'
+                    | ( L'-' >> factor) 
+                    ;
+                term = factor
+                    >> *((L'*' >> factor) [compose_expression<FeatureT,mapnik::mult<value> >(self.exprs)] 
+                         | (L'/' >> factor) [compose_expression<FeatureT,mapnik::div<value> >(self.exprs)]);
+		
+                expression = term >> *((L'+' >> term) [compose_expression<FeatureT,mapnik::add<value> >(self.exprs)] 
+                                       | (L'-' >> term) [compose_expression<FeatureT,mapnik::sub<value> >(self.exprs)]);
+
+                regex = str_p(L".match")>>L'('>>confix_p(L'\'',(*lex_escape_ch_p)
+                                                         [compose_regex<FeatureT>(self.filters,self.exprs)],
+                                                         L'\'') >>L')';
+
+                relation   = expression 
+                    >> *((L">=" >> expression) 
+                         [compose_filter<FeatureT,greater_than_or_equal<value> >(self.filters,self.exprs)]
+                         | (L'>' >> expression)
+                         [compose_filter<FeatureT,mapnik::greater_than<value> >(self.filters,self.exprs)]
+                         | (L'<' >> expression)
+                         [compose_filter<FeatureT,mapnik::less_than<value> >(self.filters,self.exprs)]
+                         | (L"<=" >> expression)
+                         [compose_filter<FeatureT,less_than_or_equal<value> >(self.filters,self.exprs)]
+                         | regex );
+
+                equation = relation >> *( ( L'=' >> relation)
+                                          [compose_filter<FeatureT,mapnik::equals<value> >(self.filters,self.exprs)]
+                                          | ( L"<>" >> relation)
+                                          [compose_filter<FeatureT,not_equals<value> >(self.filters,self.exprs)]);
+
+                not_expr = equation | *(str_p(L"not") >> equation)[compose_not_filter<FeatureT>(self.filters)];
+
+                and_expr = not_expr >> *(L"and" >> not_expr)[compose_and_filter<FeatureT>(self.filters)];
+
+                or_expr  = and_expr >> *(L"or" >> and_expr)[compose_or_filter<FeatureT>(self.filters)];
+
+                filter_statement = or_expr;	
+            }
+	    
+            boost::spirit::rule<ScannerT> const& start() const
+            {
+                return filter_statement;
+            }
+	    	    
+            boost::spirit::rule<ScannerT> factor; 
+            boost::spirit::rule<ScannerT> term;
+            boost::spirit::rule<ScannerT> expression;
+            boost::spirit::rule<ScannerT> relation;
+            boost::spirit::rule<ScannerT> equation;
+            boost::spirit::rule<ScannerT> not_expr;
+            boost::spirit::rule<ScannerT> and_expr;
+            boost::spirit::rule<ScannerT> or_expr;
+	    
+            boost::spirit::rule<ScannerT> filter_statement;   
+            boost::spirit::rule<ScannerT> literal;
+            boost::spirit::rule<ScannerT> number;
+            boost::spirit::rule<ScannerT> string_;
+            boost::spirit::rule<ScannerT> property;
+            boost::spirit::rule<ScannerT> function;
+            boost::spirit::rule<ScannerT> regex;
+            symbols<string> func1_op;
+            symbols<string> func2_op;
+            symbols<string> spatial_op;
+        };
+        stack<shared_ptr<filter<FeatureT> > >& filters;
+        stack<shared_ptr<expression<FeatureT> > >& exprs;
+    };    
+}
+
+#endif //FILTER_PARSER_HPP 

Copied: trunk/include/mapnik/filter_parser_ast.hpp (from rev 307, trunk/include/filter_parser_ast.hpp)
===================================================================
--- trunk/include/filter_parser_ast.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/filter_parser_ast.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,266 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef FILTER_PARSER_AST_HPP
+#define FILTER_PARSER_AST_HPP
+// stl
+#include <iostream>
+// boost
+#include <boost/spirit/core.hpp>
+#include <boost/spirit/tree/ast.hpp>
+
+using namespace std;
+using namespace boost::spirit;
+
+namespace mapnik
+{
+    
+    struct filter_grammar_ast : public grammar<filter_grammar_ast>
+    {
+	
+        static const int integerID = 1;
+        static const int realID = 2;
+        static const int stringID = 3;
+        static const int propertyID = 4;
+        static const int factorID = 5;
+        static const int termID = 6;
+        static const int expressionID = 7;
+        static const int relationID = 8;
+        static const int equationID = 9;
+        static const int and_exprID = 10;
+        static const int or_exprID = 11;
+	
+        template <typename ScannerT>
+        struct definition
+        {
+	    
+            definition(filter_grammar_ast const& /*self*/)
+            {			
+                real = leaf_node_d[strict_real_p];
+                integer    = leaf_node_d[int_p];
+                number = real | integer;
+		
+                string_ = inner_node_d['\''>> leaf_node_d[( (alpha_p | '_')  >> 
+                                                            * (alnum_p | '_' ))] >>  '\''];
+		
+                property = inner_node_d['[' >> leaf_node_d[ ( (alpha_p | '_') >> * (alnum_p | '_' )) ] >> ']'];
+		
+                literal = number | string_ | property;
+		
+                factor = literal 
+                    | (root_node_d[str_p("not")] >> literal) 
+                    | inner_node_d[ch_p('(') >> or_expr >> ch_p(')') ]
+                    | (root_node_d[ch_p('-')] >> factor)
+                    ;
+		
+                term = factor
+                    >> *((root_node_d[ch_p('*')] >> factor) | (root_node_d[ch_p('/')] >> factor));
+		
+                expression = term >> *((root_node_d[ch_p('+')] >> term) | (root_node_d[ch_p('-')] >> term));
+                relation   = expression >> *((root_node_d[str_p(">=")] >> expression) 
+                                             | (root_node_d[ch_p('>')] >> expression)
+                                             | (root_node_d[ch_p('<')] >> expression)
+                                             | (root_node_d[str_p("<=")] >> expression));
+		
+                equation = relation >> *( (root_node_d[ch_p('=')] >> relation)
+                                          | (root_node_d[str_p("<>")] >> relation));
+                and_expr = equation >> *(root_node_d[str_p("and")] >> equation);
+                or_expr  = and_expr >> *(root_node_d[str_p("or")] >> and_expr);
+		
+                //spatial_op = str_p("Equals") | "Disjoint" | "Touches" | "Within" 
+                //   | "Overlaps" | "Crosses" | "Intersects" | "Contains" | "DWithin" | "Beyond" | "BBOX";
+
+                filter_statement = or_expr;
+            }
+	    
+            rule<ScannerT> const& start() const
+            {
+                return filter_statement;
+            }
+	    	    
+            rule<ScannerT,parser_context<>, parser_tag<factorID> > factor; 
+            rule<ScannerT,parser_context<>, parser_tag<termID> > term;
+            rule<ScannerT,parser_context<>, parser_tag<expressionID> > expression;
+            rule<ScannerT,parser_context<>, parser_tag<relationID> > relation;
+            rule<ScannerT,parser_context<>, parser_tag<equationID> > equation;
+	    
+            rule<ScannerT,parser_context<>, parser_tag<and_exprID> > and_expr;
+            rule<ScannerT,parser_context<>, parser_tag<or_exprID> > or_expr;
+	    
+            rule<ScannerT> filter_statement;
+            rule<ScannerT> literal,number;
+	    
+            rule<ScannerT,parser_context<>, parser_tag<integerID> > integer;
+            rule<ScannerT,parser_context<>, parser_tag<realID> > real;
+            rule<ScannerT,parser_context<>, parser_tag<stringID> > string_;
+            rule<ScannerT,parser_context<>, parser_tag<propertyID> > property;
+	    
+
+            //rule<ScannerT> spatial_op;
+
+        };
+	
+    }; 
+
+    class node_data
+    {
+    public:
+        enum  {
+            Unknown=0,
+            Integer=1,
+            Real   =2,
+            String =3,
+            Property=4
+        };
+        node_data()
+            : type_(Unknown) {}
+
+        node_data(int type)
+            : type_(type) {}
+    
+        node_data(node_data const& other)
+            : type_(other.type_) {}
+    
+        node_data& operator=(node_data const& other)
+        {
+            if (this==&other) 
+                return *this;
+            type_=other.type_;
+            return *this;
+        }
+        ~node_data() {}
+    private:
+        int type_;    
+    };
+
+    typedef char const* iterator_t;
+    typedef node_val_data_factory<node_data> factory_t;
+    typedef tree_match<iterator_t,factory_t>::tree_iterator iter_t;
+
+    void process_node(iter_t const&,string&);
+    
+    void walk_ast_tree(tree_parse_info<iterator_t,factory_t> info,string& text)
+    {
+        process_node(info.trees.begin(),text);
+    }
+    
+    void process_node(iter_t const& i,string& text)
+    {
+        //clog << "In eval_expression. i->value = " <<
+        //   string(i->value.begin(), i->value.end()) <<
+        //   " i->children.size() = " << i->children.size() << endl;
+        //std::clog<<typeid(*i).name()<<"\n";
+
+        if (i->value.id() == filter_grammar_ast::integerID)
+        {	
+            assert(i->children.size()==0);
+            string integer(i->value.begin(), i->value.end());	
+            text+= integer;
+        }
+        else if (i->value.id() == filter_grammar_ast::realID)
+        {	
+            assert(i->children.size()==0);
+            string real(i->value.begin(), i->value.end());
+            text += real;
+        }
+        else if (i->value.id() == filter_grammar_ast::stringID)
+        {	
+            assert(i->children.size()==0);
+            string str(i->value.begin(), i->value.end());
+            text += str;
+        }
+        else if (i->value.id() == filter_grammar_ast::propertyID)
+        {
+            assert(i->children.size()==0);
+            string property_name(i->value.begin(), i->value.end());
+            text += property_name;
+        }
+        else if (i->value.id() == filter_grammar_ast::expressionID)
+        {
+            assert(i->children.size() == 2);
+            assert(!i->children.begin()->value.is_root());
+            process_node(i->children.begin(),text);	     
+            text += string(i->value.begin(), i->value.end());
+            process_node(i->children.begin()+1,text);
+	    
+            text +="\n";
+        }
+        else if (i->value.id() == filter_grammar_ast::termID)
+        {
+            assert(i->children.size() == 2);
+            assert(!i->children.begin()->value.is_root());
+            process_node(i->children.begin(),text);
+            text +=  string(i->value.begin(), i->value.end());
+            process_node(i->children.begin()+1,text);
+	    
+            text +="\n";
+	
+        }
+        else if (i->value.id() == filter_grammar_ast::relationID)
+        {
+            assert(i->children.size() == 2);
+            assert(!i->children.begin()->value.is_root());
+            process_node(i->children.begin(),text);
+            text += string(i->value.begin(), i->value.end());
+            process_node(i->children.begin()+1,text);
+	    
+            text +="\n";
+
+        }
+        else if (i->value.id() == filter_grammar_ast::equationID)
+        {
+            assert(i->children.size() == 2);
+            assert(!i->children.begin()->value.is_root());
+            process_node(i->children.begin(),text);
+            text += string(i->value.begin(), i->value.end());
+            process_node(i->children.begin()+1,text);
+	    
+            text +="\n";
+        }
+        else if (i->value.id() == filter_grammar_ast::and_exprID)
+        {
+            assert(i->children.size() == 2);
+            assert(!i->children.begin()->value.is_root());
+            process_node(i->children.begin(),text);
+            text += string(i->value.begin(), i->value.end());
+            process_node(i->children.begin()+1,text);
+	    
+            text +="\n";
+        }
+        else if (i->value.id() == filter_grammar_ast::or_exprID)
+        {
+            assert(i->children.size() == 2);
+            assert(!i->children.begin()->value.is_root());
+            
+            process_node(i->children.begin(),text);
+            text += string(i->value.begin(), i->value.end());
+            process_node(i->children.begin()+1,text);
+	    
+            text +="\n";
+
+        }
+    }   
+}
+
+#endif //FILTER_PARSER_AST_HPP 

Copied: trunk/include/mapnik/filter_visitor.hpp (from rev 307, trunk/include/filter_visitor.hpp)
===================================================================
--- trunk/include/filter_visitor.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/filter_visitor.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,48 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef FILTER_VISITOR_HPP
+#define FILTER_VISITOR_HPP
+
+#include <mapnik/filter.hpp>
+#include <mapnik/expression.hpp>
+
+namespace mapnik
+{
+    template <typename FeatureT> class filter;
+    template <typename FeatureT> class expression;
+    template <typename FeatureT> class expression;
+    template <typename Feature,template <typename> class Filter> class rule;
+    template <typename FeatureT>
+    class filter_visitor
+    {
+	public:
+		virtual void visit(filter<FeatureT>& filter)=0;
+		virtual void visit(expression<FeatureT>&)=0;
+		virtual void visit(rule<FeatureT,filter> const& r)=0;
+		virtual ~filter_visitor() {}
+    };    
+}
+
+#endif //FILTER_VISITOR_HPP

Copied: trunk/include/mapnik/font_engine_freetype.hpp (from rev 307, trunk/include/font_engine_freetype.hpp)
===================================================================
--- trunk/include/font_engine_freetype.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/font_engine_freetype.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,432 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef FONT_ENGINE_FREETYPE_HPP
+#define FONT_ENGINE_FREETYPE_HPP
+
+// freetype2
+extern "C"
+{
+  #include <ft2build.h>
+  #include FT_FREETYPE_H
+  #include FT_GLYPH_H
+}
+
+// stl
+#include <string>
+#include <vector>
+#include <map>
+#include <iostream>
+// boost
+#include <boost/shared_ptr.hpp>
+#include <boost/utility.hpp>
+#include <boost/ptr_container/ptr_vector.hpp>
+#include <boost/thread/mutex.hpp>
+// mapnik
+#include <mapnik/color.hpp>
+#include <mapnik/utils.hpp>
+
+namespace mapnik
+{
+    class font_face : boost::noncopyable
+    {
+    public:
+    	font_face(FT_Face face)
+            : face_(face) {}
+	
+    	std::string  family_name() const
+    	{
+    	    return std::string(face_->family_name);
+    	}
+
+        std::string  style_name() const
+    	{
+    	    return std::string(face_->style_name);
+    	}
+	
+        unsigned num_glyphs() const
+        {
+            return face_->num_glyphs;
+        }
+
+        FT_GlyphSlot glyph() const
+        {
+            return face_->glyph;
+        }
+	
+        FT_Face get_face() const
+        {
+            return face_;
+        }
+	
+        bool set_pixel_sizes(unsigned size)
+        {
+            if (! FT_Set_Pixel_Sizes( face_, 0, size ))
+                return true;
+            return false;
+        }
+        
+	
+    	~font_face()
+    	{
+    	    std::clog << "clean up face:" << family_name()<<":" << style_name() << std::endl;
+    	    FT_Done_Face(face_);
+    	}
+	
+    private:
+    	FT_Face face_;
+    };
+    
+    typedef boost::shared_ptr<font_face> face_ptr;
+    
+    class MAPNIK_DECL freetype_engine : public mapnik::singleton<freetype_engine,mapnik::CreateStatic>,
+                                        private boost::noncopyable
+    {
+        friend class mapnik::CreateStatic<freetype_engine>;
+    public:
+
+        static bool register_font(std::string const& file_name);
+        static std::vector<std::string> face_names ();
+        static face_ptr create_face(std::string const& family_name);
+
+    private:
+        freetype_engine();
+        virtual ~freetype_engine();
+        static FT_Library library_;
+        static std::map<std::string,std::string> name2file_;
+    }; 
+    
+    template <typename T>
+    class MAPNIK_DECL face_manager : private boost::noncopyable
+    {
+        typedef T font_engine_type;
+        typedef std::map<std::string,face_ptr> faces;
+	
+    public:
+        face_ptr get_face(std::string const& name)
+        {
+            typename faces::iterator itr;
+            itr = faces_.find(name);
+            if (itr != faces_.end())
+            {
+                return itr->second;
+            }
+            else
+            {
+                face_ptr face = font_engine_type::instance()->create_face(name);
+                if (face)
+                {
+                    faces_.insert(make_pair(name,face));
+                }
+                return face;	
+            }
+        }
+    private:
+        faces faces_;
+    };
+        
+    inline std::wstring to_unicode(std::string const& text)
+    {
+        std::wstring out;
+        unsigned long code = 0;
+        int expect = 0;
+        std::string::const_iterator itr=text.begin();
+	
+        while ( itr != text.end())
+        {
+            unsigned p = (*itr++) & 0xff;
+            if ( p >= 0xc0)
+            {
+                if ( p < 0xe0)      // U+0080 - U+07ff
+                {
+                    expect = 1;
+                    code = p & 0x1f;
+                }
+                else if ( p < 0xf0)  // U+0800 - U+ffff
+                {
+                    expect = 2;
+                    code = p & 0x0f;
+                }
+                else if ( p  < 0xf8) // U+1000 - U+10ffff
+                {
+                    expect = 3;
+                    code = p & 0x07;
+                }
+                continue;
+            }
+            else if (p >= 0x80)
+            {
+                --expect;
+                if (expect >= 0)
+                {
+                    code <<= 6;
+                    code += p & 0x3f;
+                }
+                if (expect > 0)
+                    continue;
+                expect = 0;
+            }
+            else 
+            {
+                code = p;            // U+0000 - U+007f (ascii)
+            }
+            out.push_back(wchar_t(code));
+        }
+        return out;
+    }
+    
+    template <typename T>
+    struct text_renderer : private boost::noncopyable
+    {
+
+        struct glyph_t : boost::noncopyable
+        {
+            FT_Glyph image;
+            glyph_t(FT_Glyph image_) : image(image_) {}
+            ~glyph_t ()	{ FT_Done_Glyph(image);}
+        };
+	
+        typedef boost::ptr_vector<glyph_t> glyphs_t;
+        typedef std::pair<unsigned,unsigned> dimension_t;
+        typedef T pixmap_type;
+	
+        text_renderer (pixmap_type & pixmap, face_ptr face)
+            : pixmap_(pixmap),
+              face_(face),
+              fill_(0,0,0), 
+              halo_fill_(255,255,255),
+              halo_radius_(0),
+              angle_(0.0) {}
+    
+        void set_pixel_size(unsigned size)
+        {
+            face_->set_pixel_sizes(size);
+        }
+    
+        void set_angle(float angle)
+        {
+            angle_=angle;
+        }
+
+        void set_fill(mapnik::Color const& fill)
+        {
+            fill_=fill;
+        }
+    
+        void set_halo_fill(mapnik::Color const& halo)
+        {
+            halo_fill_=halo;
+        }
+    
+        void set_halo_radius( int radius=1)
+        {
+            halo_radius_=radius;
+        }
+
+        dimension_t prepare_glyphs(std::string const& text)
+        {
+            //clear glyphs
+            glyphs_.clear();
+	    
+            FT_Matrix matrix;
+            FT_Vector pen;
+            FT_Error  error;
+	    
+            FT_Face face = face_->get_face();
+            FT_GlyphSlot slot = face->glyph;
+            FT_Bool use_kerning;
+            FT_UInt previous = 0;
+	    
+            pen.x = 0;
+            pen.y = 0;
+	    
+            use_kerning = FT_HAS_KERNING(face)>0?true:false;
+	    
+            FT_BBox bbox;   
+            bbox.xMin = bbox.yMin = 32000; 
+            bbox.xMax = bbox.yMax = -32000; //hmm?? 
+	    
+            for (std::string::const_iterator i=text.begin();i!=text.end();++i)
+            {
+                FT_BBox glyph_bbox; 
+                FT_Glyph image;
+		
+                matrix.xx = (FT_Fixed)( cos( angle_ ) * 0x10000L ); 
+                matrix.xy = (FT_Fixed)(-sin( angle_ ) * 0x10000L ); 
+                matrix.yx = (FT_Fixed)( sin( angle_ ) * 0x10000L ); 
+                matrix.yy = (FT_Fixed)( cos( angle_ ) * 0x10000L );
+	        	
+                FT_Set_Transform (face,&matrix,&pen);
+		
+                FT_UInt glyph_index = FT_Get_Char_Index( face, unsigned(*i) & 0xff );
+		
+                if ( use_kerning && previous && glyph_index)
+                {
+                    FT_Vector delta;
+                    FT_Get_Kerning(face,previous,glyph_index,
+                                   FT_KERNING_DEFAULT,&delta);
+                    pen.x += delta.x;
+                    pen.y += delta.y;
+                }
+		
+                error = FT_Load_Glyph (face,glyph_index,FT_LOAD_DEFAULT); 
+                if ( error )
+                    continue;
+		
+                error = FT_Get_Glyph( face->glyph, &image);
+                if ( error )
+                    continue;
+		
+                FT_Glyph_Get_CBox(image,ft_glyph_bbox_pixels, &glyph_bbox); 
+                if (glyph_bbox.xMin < bbox.xMin) 
+                    bbox.xMin = glyph_bbox.xMin; 
+                if (glyph_bbox.yMin < bbox.yMin) 
+                    bbox.yMin = glyph_bbox.yMin; 
+                if (glyph_bbox.xMax > bbox.xMax) 
+                    bbox.xMax = glyph_bbox.xMax; 
+                if (glyph_bbox.yMax > bbox.yMax) 
+                    bbox.yMax = glyph_bbox.yMax;
+		
+                if ( bbox.xMin > bbox.xMax )
+                {
+                    bbox.xMin = 0; 
+                    bbox.yMin = 0; 
+                    bbox.xMax = 0; 
+                    bbox.yMax = 0; 
+                }
+		
+                pen.x += slot->advance.x;
+                pen.y += slot->advance.y;
+		
+                previous = glyph_index;
+                // take ownership of the glyph
+                glyphs_.push_back(new glyph_t(image));
+            }
+	    
+            unsigned string_width = (bbox.xMax - bbox.xMin); 
+            unsigned string_height = (bbox.yMax - bbox.yMin);
+            return dimension_t(string_width,string_height);
+        }
+	
+        void render(double x0, double y0)
+        {
+            FT_Error  error;
+            FT_Vector start;
+            unsigned height = pixmap_.height();
+	    
+            start.x = unsigned(x0 * (1 << 6)); 
+            start.y = unsigned((height - y0) * (1 << 6));
+            // now render transformed glyphs
+            typename glyphs_t::iterator pos;
+
+            if (halo_radius_ > 0)
+            {
+                //render halo 
+                for ( pos = glyphs_.begin(); pos != glyphs_.end();++pos)
+                {
+	    
+                    FT_Glyph_Transform(pos->image,0,&start);
+	    
+                    error = FT_Glyph_To_Bitmap( &(pos->image),FT_RENDER_MODE_NORMAL,0,1);
+                    if ( ! error )
+                    {
+			
+                        FT_BitmapGlyph bit = (FT_BitmapGlyph)pos->image;
+                        render_halo(&bit->bitmap, halo_fill_.rgba(), 
+                                    bit->left,
+                                    height - bit->top,halo_radius_);
+                    }
+                }  
+            }
+            //render actual text
+            for ( pos = glyphs_.begin(); pos != glyphs_.end();++pos)
+            {
+	    
+                FT_Glyph_Transform(pos->image,0,&start);
+	    
+                error = FT_Glyph_To_Bitmap( &(pos->image),FT_RENDER_MODE_NORMAL,0,1);
+                if ( ! error )
+                {
+		   
+                    FT_BitmapGlyph bit = (FT_BitmapGlyph)pos->image;
+                    render_bitmap(&bit->bitmap, fill_.rgba(), 
+                                  bit->left,
+                                  height - bit->top);
+                }
+            }  
+        }
+   	
+    private:
+    
+        void render_halo(FT_Bitmap *bitmap,unsigned rgba,int x,int y,int radius)
+        {
+            int x_max=x+bitmap->width;
+            int y_max=y+bitmap->rows;
+            int i,p,j,q;
+	
+            for (i=x,p=0;i<x_max;++i,++p)
+            {
+                for (j=y,q=0;j<y_max;++j,++q)
+                {
+                    int gray = bitmap->buffer[q*bitmap->width+p];
+                    if (gray)
+                    {
+                        for (int n=-halo_radius_; n <=halo_radius_; ++n)
+                            for (int m=-halo_radius_;m <= halo_radius_; ++m)
+                                pixmap_.blendPixel(i+m,j+n,rgba,gray);		        
+                    }
+                }
+            }
+        }
+    
+        void render_bitmap(FT_Bitmap *bitmap,unsigned rgba,int x,int y)
+        {
+            int x_max=x+bitmap->width;
+            int y_max=y+bitmap->rows;
+            int i,p,j,q;
+	
+            for (i=x,p=0;i<x_max;++i,++p)
+            {
+                for (j=y,q=0;j<y_max;++j,++q)
+                {
+                    int gray=bitmap->buffer[q*bitmap->width+p];
+                    if (gray)
+                    {
+                        pixmap_.blendPixel(i,j,rgba,gray);
+                    }
+                }
+            }
+        }
+    
+        pixmap_type & pixmap_;
+        face_ptr face_;
+        Color fill_;
+        Color halo_fill_;
+        int halo_radius_;
+        float angle_;
+        glyphs_t glyphs_;
+    }; 
+}
+
+#endif // FONT_ENGINE_FREETYPE_HPP

Copied: trunk/include/mapnik/gamma.hpp (from rev 307, trunk/include/gamma.hpp)
===================================================================
--- trunk/include/gamma.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/gamma.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,51 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: gamma.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef GAMMA_HPP
+#define GAMMA_HPP
+
+namespace mapnik 
+{
+    struct MAPNIK_DECL gamma
+    {
+        unsigned char g2l[256];
+        unsigned char l2g[256];
+        gamma(double gamma=2.0)
+        {
+            int result;
+            for (int i=0;i< 256;i++)
+            {
+                result=(int)(pow(i/255.0,gamma) * 255.0 + 0.5);
+                g2l[i]=(unsigned char)result;
+            }
+            for (int i = 0; i < 256; i++)
+            {
+                result = (int)(pow(i/255.0, 1/gamma) * 255.0 + 0.5);
+                l2g[i] = (unsigned char)result;
+            }
+        }
+    };
+}
+
+#endif  //GAMMA_HPP

Copied: trunk/include/mapnik/geom_util.hpp (from rev 307, trunk/include/geom_util.hpp)
===================================================================
--- trunk/include/geom_util.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/geom_util.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,194 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: geom_util.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef GEOM_UTIL_HPP
+#define GEOM_UTIL_HPP
+// stl
+#include <cmath>
+// boost
+#include <boost/tuple/tuple.hpp>
+// mapnik
+#include <mapnik/envelope.hpp>
+#include <mapnik/vertex.hpp>
+
+namespace mapnik
+{
+
+    template <typename T>
+    bool clip_test(T p,T q,double& tmin,double& tmax)
+    {
+        double r;
+        bool result=true;
+        if (p<0.0)
+        {
+            r=q/p;
+            if (r>tmax) result=false;
+            else if (r>tmin) tmin=r;
+        }
+        else if (p>0.0)
+        {
+            r=q/p;
+            if (r<tmin) result=false;
+            else if (r<tmax) tmax=r;
+        } else if (q<0.0) result=false;
+        return result;
+    }
+
+    template <typename T,typename Image>
+    bool clip_line(T& x0,T& y0,T& x1,T& y1,Envelope<T> const& box)
+    {
+        double tmin=0.0;
+        double tmax=1.0;
+        double dx=x1-x0;
+        if (clip_test<double>(-dx,x0,tmin,tmax))
+        {
+            if (clip_test<double>(dx,box.width()-x0,tmin,tmax))
+            {
+                double dy=y1-y0;
+                if (clip_test<double>(-dy,y0,tmin,tmax))
+                {
+                    if (clip_test<double>(dy,box.height()-y0,tmin,tmax))
+                    {
+                        if (tmax<1.0)
+                        {
+                            x1=static_cast<T>(x0+tmax*dx);
+                            y1=static_cast<T>(y0+tmax*dy);
+                        }
+                        if (tmin>0.0)
+                        {
+                            x0+=static_cast<T>(tmin*dx);
+                            y0+=static_cast<T>(tmin*dy);
+                        }
+                        return true;
+                    }
+                }
+            }
+        }
+        return false;
+    }
+    
+    template <typename Iter> 
+    inline bool point_inside_path(double x,double y,Iter start,Iter end)
+    {
+        bool inside=false;
+        double x0=boost::get<0>(*start);
+        double y0=boost::get<1>(*start);
+        
+        double x1,y1;
+        while (++start!=end) 
+        {
+            if ( boost::get<2>(*start) == SEG_MOVETO)
+            {
+                x0 = boost::get<0>(*start);
+                y0 = boost::get<1>(*start);
+                continue;
+            }		
+            x1=boost::get<0>(*start);
+            y1=boost::get<1>(*start);
+            
+            if ((((y1 <= y) && (y < y0)) ||
+                 ((y0 <= y) && (y < y1))) &&
+                ( x < (x0 - x1) * (y - y1)/ (y0 - y1) + x1))
+                inside=!inside;
+            x0=x1;
+            y0=y1;
+        }
+    	return inside;
+    }
+
+#define TOL 0.00001
+
+    /*
+      (Ay-Cy)(Bx-Ax)-(Ax-Cx)(By-Ay)
+      s = -----------------------------
+      L^2
+    */
+
+    inline bool point_in_circle(double x,double y,double cx,double cy,double r)
+    {
+        double dx = x - cx;
+        double dy = y - cy;
+        double d2 = dx * dx + dy * dy;
+        return (d2 <= r * r);
+    }
+    
+    inline bool point_on_segment(double x,double y,double x0,double y0,double x1,double y1)
+    {	
+        double dx = x1 - x0;
+        double dy = y1 - y0;
+        if ( fabs(dx) > TOL  ||  fabs(dy) > TOL )
+        {
+            double s = (y0 - y) * dx - (x0 - x) * dy;
+            return ( fabs (s) < TOL ) ;
+        } 
+        return false;
+    }
+
+    inline bool point_on_segment2(double x,double y,double x0,double y0,double x1,double y1)
+    {	 
+        double d  = sqrt ((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0));
+        double d0 = sqrt ((x0 - x) * (x0 - x) + (y0 - y) * (y0 - y));
+        double d1 = sqrt ((x1 - x) * (x1 - x) + (y1 - y) * (y1 - y));
+        double d2 = d0 + d1;
+        return ( d2 - d < 0.01);
+    }
+    
+#undef TOL
+    template <typename Iter> 
+    inline bool point_on_path(double x,double y,Iter start,Iter end)
+    {
+        return false;
+    }
+    
+    template <typename Iter> 
+    inline bool point_on_points (double x,double y,Iter start,Iter end) 
+    {
+        return false; 
+    }
+
+    struct filter_in_box
+    {
+        Envelope<double> box_;
+        explicit filter_in_box(const Envelope<double>& box)
+            : box_(box) {}
+
+        bool pass(const Envelope<double>& extent) const
+        {
+            return extent.intersects(box_);
+        }
+    };
+
+    struct filter_at_point
+    {
+        coord2d pt_;
+        explicit filter_at_point(const coord2d& pt)
+            : pt_(pt) {}
+        bool pass(const Envelope<double>& extent) const
+        {
+            return extent.contains(pt_);
+        }
+    };
+}
+
+#endif                                            //GEOM_UTIL_HPP

Copied: trunk/include/mapnik/geometry.hpp (from rev 307, trunk/include/geometry.hpp)
===================================================================
--- trunk/include/geometry.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/geometry.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,387 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+
+//$Id: geometry.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef GEOMETRY_HPP
+#define GEOMETRY_HPP
+
+// boost
+#include <boost/shared_ptr.hpp>
+#include <boost/utility.hpp>
+// mapnik
+#include <mapnik/vertex_vector.hpp>
+#include <mapnik/vertex_transform.hpp>
+#include <mapnik/ctrans.hpp>
+#include <mapnik/geom_util.hpp>
+
+namespace mapnik {
+    enum {
+    	Point = 1,
+    	LineString = 2,
+    	Polygon = 3
+    };
+    
+    template <typename T>
+    class geometry : private boost::noncopyable
+    {   
+    public:
+        typedef T vertex_type;
+        typedef typename vertex_type::type value_type;
+    private:
+        int srid_;
+    public:
+        geometry (int srid=-1)
+            : srid_(srid) {}	
+
+        int srid() const
+        {
+            return srid_;
+        }
+	
+        Envelope<double> envelope()
+        {
+            Envelope<double> result;		
+            double x,y;
+            for (unsigned i=0;i<num_points();++i)
+            {
+                vertex(&x,&y);
+                if (i==0)
+                {
+                    result.init(x,y,x,y);
+                }
+                else
+                {
+                    result.expand_to_include(x,y);
+                }
+            }
+            return result;
+        }
+
+        virtual int type() const=0;
+        virtual bool hit_test(value_type x,value_type y) const=0;	
+        virtual void label_position(double *x, double *y) const=0;
+        virtual void move_to(value_type x,value_type y)=0;
+        virtual void line_to(value_type x,value_type y)=0;
+        virtual void transform(const mapnik::CoordTransform& t)=0;
+        virtual unsigned num_points() const = 0;
+        virtual unsigned vertex(double* x, double* y)=0;
+        virtual void rewind(unsigned )=0;
+        virtual void set_capacity(size_t size)=0;
+        virtual ~geometry() {}
+    };
+    
+    template <typename T>
+    class point : public geometry<T>
+    {
+        typedef geometry<T> geometry_base;
+        typedef typename geometry<T>::vertex_type vertex_type;
+        typedef typename geometry<T>::value_type value_type;
+    private:
+        vertex_type pt_;
+    public:
+        point(int srid)
+            : geometry<T>(srid)
+        {}
+	 
+        int type() const 
+        {
+            return Point;
+        }
+        void label_position(double *x, double *y) const
+        {
+            *x = pt_.x;
+            *y = pt_.y;
+        }
+	
+        void move_to(value_type x,value_type y)
+        {
+            pt_.x = x;
+            pt_.y = y;
+        }
+	
+        void line_to(value_type ,value_type ) {}
+	
+        void transform(const mapnik::CoordTransform& t)
+        {
+            t.forward_x(&pt_.x);
+            t.forward_y(&pt_.y);
+        }
+	
+        unsigned num_points() const
+        {
+            return 1;
+        }
+	
+        unsigned vertex(double* x, double* y)
+        {
+            *x = pt_.x;
+            *y = pt_.y;
+            return SEG_LINETO;
+        }
+	
+        void rewind(unsigned ) {}
+	
+        bool hit_test(value_type x,value_type y) const
+        {
+            return false;
+        }
+        void set_capacity(size_t) {}
+        virtual ~point() {}
+    };
+
+    template <typename T, template <typename> class Container=vertex_vector2>
+    class polygon : public geometry<T>
+    {
+        typedef geometry<T> geometry_base;
+        typedef typename geometry<T>::vertex_type vertex_type;
+        typedef typename geometry_base::value_type value_type;
+        typedef Container<vertex_type> container_type;
+    private:
+        container_type cont_;
+        mutable unsigned itr_;
+    public:
+        polygon(int srid)
+            : geometry_base(srid),
+              itr_(0)
+        {}
+        
+        int type() const 
+        {
+            return Polygon;
+        }
+	
+        void label_position(double *x, double *y) const
+        {
+	    
+            unsigned size = cont_.size();
+            if (size < 3) 
+            {
+                cont_.get_vertex(0,x,y);
+                return;
+            }
+	      
+            double ai;
+            double atmp = 0;
+            double xtmp = 0;
+            double ytmp = 0;
+            double x0 =0;
+            double y0 =0;
+            double x1 =0;
+            double y1 =0;
+	    
+            unsigned i,j;
+            for (i = size-1,j = 0; j < size; i = j, ++j)
+            {
+		
+                cont_.get_vertex(i,&x0,&y0);
+                cont_.get_vertex(j,&x1,&y1);
+                ai = x0 * y1 - x1 * y0;
+                atmp += ai;
+                xtmp += (x1 + x0) * ai;
+                ytmp += (y1 + y0) * ai;
+            }	  
+            if (atmp != 0)
+            {
+                *x = xtmp/(3*atmp);
+                *y = ytmp /(3*atmp);
+                return;
+            }
+            *x=x0;
+            *y=y0;	    	    
+        }
+
+        void line_to(value_type x,value_type y)
+        {
+            cont_.push_back(x,y,SEG_LINETO);
+        }
+
+        void move_to(value_type x,value_type y)
+        {
+            cont_.push_back(x,y,SEG_MOVETO);
+        }
+	
+        void transform(mapnik::CoordTransform const& t)
+        {
+            unsigned size = cont_.size();
+            for (unsigned pos=0; pos < size; ++pos)
+            {	
+                cont_.transform_at(pos,t);
+            }
+        }
+	
+        unsigned num_points() const
+        {
+            return cont_.size();
+        }
+	
+        unsigned vertex(double* x, double* y)
+        {
+            return cont_.get_vertex(itr_++,x,y);
+        }
+	
+        void rewind(unsigned )
+        {
+            itr_=0;
+        }
+	
+        bool hit_test(value_type x,value_type y) const
+        {	    
+            return point_inside_path(x,y,cont_.begin(),cont_.end());
+        } 
+        
+        void set_capacity(size_t size) 
+        {
+            cont_.set_capacity(size);
+        }
+        virtual ~polygon() {}
+    };
+    
+    template <typename T, template <typename> class Container=vertex_vector>
+    class line_string : public geometry<T>
+    {
+        typedef geometry<T> geometry_base;
+        typedef typename geometry_base::value_type value_type;
+        typedef typename geometry<T>::vertex_type vertex_type;
+        typedef Container<vertex_type> container_type;
+    private:
+        container_type cont_;
+        mutable unsigned itr_;
+    public:
+        line_string(int srid)
+            : geometry_base(srid),
+              itr_(0)
+        {}
+        
+        int type() const 
+        {
+            return LineString;
+        }
+        void label_position(double *x, double *y) const
+        {
+            // calculate mid point on line string
+            double x0=0;
+            double y0=0;
+            double x1=0;
+            double y1=0;
+	    
+            unsigned size = cont_.size();
+            if (size == 1)
+            {
+                cont_.get_vertex(0,x,y); 
+            }
+            else if (size == 2)
+            {
+
+                cont_.get_vertex(0,&x0,&y0);
+                cont_.get_vertex(1,&x1,&y1);
+                *x = 0.5 * (x1 + x0);
+                *y = 0.5 * (y1 + y0);		
+            }
+            else
+            {
+                double len=0.0;
+                for (unsigned pos = 1; pos < size; ++pos)
+                {
+                    cont_.get_vertex(pos-1,&x0,&y0);
+                    cont_.get_vertex(pos,&x1,&y1);
+                    double dx = x1 - x0;
+                    double dy = y1 - y0;
+                    len += sqrt(dx * dx + dy * dy);
+                }
+                double midlen = 0.5 * len;
+                double dist = 0.0;
+                for (unsigned pos = 1; pos < size;++pos)
+                {
+                    cont_.get_vertex(pos-1,&x0,&y0);
+                    cont_.get_vertex(pos,&x1,&y1);
+                    double dx = x1 - x0;
+                    double dy = y1 - y0; 
+                    double seg_len = sqrt(dx * dx + dy * dy);
+                    if (( dist + seg_len) >= midlen)
+                    {
+                        double r = (midlen - dist)/seg_len;
+                        *x = x0 + (x1 - x0) * r;
+                        *y = y0 + (y1 - y0) * r;
+                        break;
+                    }
+                    dist += seg_len;
+                }
+            }
+	    
+        }
+        void line_to(value_type x,value_type y)
+        {
+            cont_.push_back(x,y,SEG_LINETO);
+        }
+
+        void move_to(value_type x,value_type y)
+        {
+            cont_.push_back(x,y,SEG_MOVETO);
+        }
+	
+        void transform(mapnik::CoordTransform const& t)
+        {
+            unsigned size = cont_.size();
+            for (unsigned pos=0; pos < size; ++pos)
+            {	
+                cont_.transform_at(pos,t);
+            }
+        }
+	
+        unsigned num_points() const
+        {
+            return cont_.size();
+        }
+	
+        unsigned vertex(double* x, double* y)
+        {
+            return cont_.get_vertex(itr_++,x,y);
+        }
+	
+        void rewind(unsigned )
+        {
+            itr_=0;
+        }
+	
+        bool hit_test(value_type x,value_type y) const
+        {	    
+            return false;
+        } 
+	
+        void set_capacity(size_t size) 
+        {
+            cont_.set_capacity(size);
+        }
+        virtual ~line_string() {}
+    };
+
+    typedef point<vertex2d> point_impl;
+    typedef line_string<vertex2d,vertex_vector2> line_string_impl;
+    typedef polygon<vertex2d,vertex_vector2> polygon_impl;
+    
+    typedef geometry<vertex2d> geometry_type;
+    typedef boost::shared_ptr<geometry_type> geometry_ptr;
+}
+
+#endif //GEOMETRY_HPP

Copied: trunk/include/mapnik/global.hpp (from rev 307, trunk/include/global.hpp)
===================================================================
--- trunk/include/global.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/global.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,61 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef GLOBAL_HPP
+#define GLOBAL_HPP
+
+#include <boost/cstdint.hpp>
+
+namespace mapnik
+{
+    using namespace boost;
+#define int2net(A)  (int32_t) (((uint32_t) ((uint8_t) (A)[1]))      |   \
+                               (((uint32_t) ((uint8_t) (A)[0])) << 8))
+
+#define int4net(A)  (int32_t) (((uint32_t) ((uint8_t) (A)[3]))      |   \
+                               (((uint32_t) ((uint8_t) (A)[2])) << 8)  | \
+                               (((uint32_t) ((uint8_t) (A)[1])) << 16) | \
+                               (((uint32_t) ((uint8_t) (A)[0])) << 24))
+
+
+    typedef char byte;
+#define float8net(V,M)   do { double def_temp;  \
+        ((byte*) &def_temp)[0]=(M)[7];          \
+        ((byte*) &def_temp)[1]=(M)[6];          \
+        ((byte*) &def_temp)[2]=(M)[5];          \
+        ((byte*) &def_temp)[3]=(M)[4];          \
+        ((byte*) &def_temp)[4]=(M)[3];          \
+        ((byte*) &def_temp)[5]=(M)[2];          \
+        ((byte*) &def_temp)[6]=(M)[1];          \
+        ((byte*) &def_temp)[7]=(M)[0];          \
+        (V) = def_temp; } while(0)
+#define float4net(V,M)   do { float def_temp;   \
+        ((byte*) &def_temp)[0]=(M)[3];          \
+        ((byte*) &def_temp)[1]=(M)[2];          \
+        ((byte*) &def_temp)[2]=(M)[1];          \
+        ((byte*) &def_temp)[3]=(M)[0];          \
+        (V)=def_temp; } while(0)
+}
+
+#endif //GLOBAL_HPP

Copied: trunk/include/mapnik/graphics.hpp (from rev 307, trunk/include/graphics.hpp)
===================================================================
--- trunk/include/graphics.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/graphics.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,183 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: graphics.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef GRAPHICS_HPP
+#define GRAPHICS_HPP
+// stl
+#include <cmath>
+#include <string>
+#include <cassert>
+// mapnik
+#include <mapnik/color.hpp>
+#include <mapnik/gamma.hpp>
+#include <mapnik/image_data.hpp>
+#include <mapnik/envelope.hpp>
+
+namespace mapnik
+{
+    class MAPNIK_DECL Image32
+    {
+    private:
+        unsigned width_;
+        unsigned height_;
+        Color background_;
+        ImageData32 data_;
+    public:
+        Image32(int width,int height);
+        Image32(const Image32& rhs);
+        ~Image32();
+        void setBackground(const Color& background);
+        const Color& getBackground() const;     
+        const ImageData32& data() const;
+        
+        inline ImageData32& data() 
+        {
+            return data_;
+        }
+        
+        inline const unsigned char* raw_data() const
+        {
+            return data_.getBytes();
+        }
+	
+        inline unsigned char* raw_data()
+        {
+            return data_.getBytes();
+        }
+	
+        void saveToFile(const std::string& file,const std::string& format="auto"); 
+    private:
+
+        inline bool checkBounds(unsigned x, unsigned y) const
+        {
+            return (x < width_ && y < height_);
+        }
+
+    public:
+        inline void setPixel(int x,int y,unsigned int rgba)
+        {
+            if (checkBounds(x,y))
+            {
+                data_(x,y)=rgba;
+            }
+        }
+        inline void blendPixel(int x,int y,unsigned int rgba1,int t)
+        {
+            if (checkBounds(x,y))
+            {
+                unsigned rgba0 = data_(x,y);	
+                unsigned a1 = t;//(rgba1 >> 24) & 0xff;
+                if (a1 == 0) return;
+                unsigned r1 = rgba1 & 0xff;
+                unsigned g1 = (rgba1 >> 8 ) & 0xff;
+                unsigned b1 = (rgba1 >> 16) & 0xff;
+		
+                unsigned a0 = (rgba0 >> 24) & 0xff;
+                unsigned r0 = (rgba0 & 0xff) * a0;
+                unsigned g0 = ((rgba0 >> 8 ) & 0xff) * a0;
+                unsigned b0 = ((rgba0 >> 16) & 0xff) * a0;
+		
+		
+                a0 = ((a1 + a0) << 8) - a0*a1;
+		
+                r0 = ((((r1 << 8) - r0) * a1 + (r0 << 8)) / a0);
+                g0 = ((((g1 << 8) - g0) * a1 + (g0 << 8)) / a0);
+                b0 = ((((b1 << 8) - b0) * a1 + (b0 << 8)) / a0);
+                a0 = a0 >> 8;
+                data_(x,y)= (a0 << 24)| (b0 << 16) |  (g0 << 8) | (r0) ;
+            }
+        }
+
+        inline unsigned width() const
+        {
+            return width_;
+        }
+	
+        inline unsigned height() const
+        {
+            return height_;
+        }
+
+        inline void set_rectangle(int x0,int y0,ImageData32 const& data)
+        {
+            Envelope<int> ext0(0,0,width_,height_);   
+            Envelope<int> ext1(x0,y0,x0+data.width(),y0+data.height());
+	    
+            if (ext0.intersects(ext1))
+            {	
+                Envelope<int> box = ext0.intersect(ext1);
+                for (int y = box.miny(); y < box.maxy(); ++y)
+                {
+                    for (int x = box.minx(); x < box.maxx(); ++x)
+                    {
+                        if ((data(x-x0,y-y0) & 0xff000000)) 
+                        {
+                            data_(x,y)=data(x-x0,y-y0);
+                        }
+                    }
+                }   
+            }
+        }
+	
+        inline void set_rectangle_alpha(int x0,int y0,const ImageData32& data)
+        {
+            Envelope<int> ext0(0,0,width_,height_);   
+            Envelope<int> ext1(x0,y0,x0 + data.width(),y0 + data.height());
+	    
+            if (ext0.intersects(ext1))
+            {	                		
+                Envelope<int> box = ext0.intersect(ext1);		
+                for (int y = box.miny(); y < box.maxy(); ++y)
+                {
+                    for (int x = box.minx(); x < box.maxx(); ++x)
+                    {
+                        unsigned rgba0 = data_(x,y);
+                        unsigned rgba1 = data(x-x0,y-y0);
+		    
+                        unsigned a1 = (rgba1 >> 24) & 0xff;
+                        if (a1 == 0) continue;
+                        unsigned r1 = rgba1 & 0xff;
+                        unsigned g1 = (rgba1 >> 8 ) & 0xff;
+                        unsigned b1 = (rgba1 >> 16) & 0xff;
+		    
+                        unsigned a0 = (rgba0 >> 24) & 0xff;
+                        unsigned r0 = (rgba0 & 0xff) * a0;
+                        unsigned g0 = ((rgba0 >> 8 ) & 0xff) * a0;
+                        unsigned b0 = ((rgba0 >> 16) & 0xff) * a0;
+		    
+		    
+                        a0 = ((a1 + a0) << 8) - a0*a1;
+		    
+                        r0 = ((((r1 << 8) - r0) * a1 + (r0 << 8)) / a0);
+                        g0 = ((((g1 << 8) - g0) * a1 + (g0 << 8)) / a0);
+                        b0 = ((((b1 << 8) - b0) * a1 + (b0 << 8)) / a0);
+                        a0 = a0 >> 8;
+                        data_(x,y)= (a0 << 24)| (b0 << 16) |  (g0 << 8) | (r0) ;
+                    }
+                }
+            }
+        }
+    };
+}
+#endif //GRAPHICS_HPP

Copied: trunk/include/mapnik/image_data.hpp (from rev 307, trunk/include/image_data.hpp)

Copied: trunk/include/mapnik/image_reader.hpp (from rev 307, trunk/include/image_reader.hpp)
===================================================================
--- trunk/include/image_reader.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/image_reader.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,64 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: image_reader.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef IMAGE_READER_HPP
+#define IMAGE_READER_HPP
+// stl
+#include <stdexcept>
+#include <string>
+// mapnik
+#include <mapnik/image_data.hpp>
+#include <mapnik/config.hpp>
+
+namespace mapnik 
+{
+    class ImageReaderException : public std::exception
+    {
+    private:
+        std::string message_;
+    public:
+        ImageReaderException(const std::string& message) 
+            : message_(message) {}
+
+        ~ImageReaderException() throw() {}
+
+        virtual const char* what() const throw()
+        {
+            return message_.c_str();
+        }
+    };
+
+    struct MAPNIK_DECL ImageReader
+    {
+        virtual unsigned width() const=0;
+        virtual unsigned height() const=0;
+        virtual void read(unsigned x,unsigned y,ImageData32& image)=0;
+        virtual ~ImageReader() {}
+    };
+
+    bool register_image_reader(const std::string& type,ImageReader* (*)(const std::string&));
+    MAPNIK_DECL ImageReader* get_image_reader(const std::string& type,const std::string& file);
+}
+
+#endif //IMAGE_READER_HPP

Copied: trunk/include/mapnik/image_util.hpp (from rev 307, trunk/include/image_util.hpp)
===================================================================
--- trunk/include/image_util.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/image_util.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,223 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: image_util.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef IMAGE_UTIL_HPP
+#define IMAGE_UTIL_HPP
+
+// stl
+#include <string>
+// mapnik
+#include <mapnik/config.hpp>
+#include <mapnik/graphics.hpp>
+
+namespace mapnik
+{
+    class MAPNIK_DECL ImageUtils
+    {
+    public:
+        static void save_to_file(const std::string& filename,
+                                 const std::string& type,
+                                 const Image32& image);
+    private:
+        static void save_as_png(const std::string& filename,
+                                const Image32& image);
+        static void save_as_jpeg(const std::string& filename,
+                                 int quality, 
+                                 const Image32& image);
+    };
+    
+    template <typename T>
+    double distance(T x0,T y0,T x1,T y1)
+    {
+        double dx = x1-x0;
+        double dy = y1-y0;
+        return sqrt(dx * dx + dy * dy);
+    }
+
+    template <typename Image>
+    inline void scale_down2(Image& target,const Image& source)
+    {
+        int source_width=source.width();
+        int source_height=source.height();
+
+        int target_width=target.width();
+        int target_height=target.height();
+        if (target_width<source_width/2 || target_height<source_height/2)
+            return;
+        int y1,x1;
+        for (int y=0;y<target_height;++y)
+        {
+            y1=2*y;
+            for(int x=0;x<target_width;++x)
+            {
+                x1=2*x;
+                //todo calculate average???
+                target(x,y)=source(x1,y1);
+            }
+        }
+    }
+
+    template <typename Image,int scale>
+    struct image_op
+    {
+        static void scale_up(Image& target,const Image& source)
+        {
+            if (scale<3) return;
+            int source_width=source.width();
+            int source_height=source.height();
+
+            int target_width=target.width();
+            int target_height=target.height();
+            if (target_width<scale*source_width || target_height<scale*source_height)
+                return;
+            for (int y=0;y<source_height;++y)
+            {
+                for(int x=0;x<source_width;++x)
+                {
+                    unsigned p=source(x,y);
+                    for (int i=0;i<scale;++i)
+                        for (int j=0;j<scale;++j)
+                            target(scale*x+i,scale*y+j)=p;
+                }
+            }
+        }
+    };
+
+    template <typename Image>
+    struct image_op<Image,2>
+    {
+        static void scale_up(Image& target,const Image& source)
+        {
+            int source_width=source.width();
+            int source_height=source.height();
+
+            int target_width=target.width();
+            int target_height=target.height();
+            if (target_width<2*source_width || target_height<2*source_height)
+                return;
+            for (int y=0;y<source_height;++y)
+            {
+                for(int x=0;x<source_width;++x)
+                {
+                    target(2*x,2*y)=source(x,y);
+                    target(2*x+1,2*y)=source(x,y);
+                    target(2*x+1,2*y+1)=source(x,y);
+                    target(2*x,2*y+1)=source(x,y);
+                }
+            }
+        }
+    };
+
+    namespace
+    {
+        template <typename Image>
+        inline void scale_up(Image& target,const Image& source,unsigned scale)
+        {
+            int source_width=source.width();
+            int source_height=source.height();
+
+            int target_width=target.width();
+            int target_height=target.height();
+            if (target_width<scale*source_width || target_height<scale*source_height)
+                return;
+            for (int y=0;y<source_height;++y)
+            {
+                for(int x=0;x<source_width;++x)
+                {
+                    unsigned p=source(x,y);
+                    for (int i=0;i<scale;++i)
+                        for (int j=0;j<scale;++j)
+                            target(scale*x+i,scale*y+j)=p;
+                }
+            }
+        }
+    }
+    
+    template <typename Image>
+    void scale_image(Image& target,const Image& source,unsigned scale)
+    {
+        if (scale==2)
+        {
+            image_op<Image,2>::scale_up(target,source);
+        }
+        else
+        {
+            scale_up<Image>(target,source,scale);
+        }
+    }
+
+    template <typename Image>
+    inline void scale_image (Image& target,const Image& source)
+    {
+
+        int source_width=source.width();
+        int source_height=source.height();
+
+        int target_width=target.width();
+        int target_height=target.height();
+
+        if (source_width<1 || source_height<1 ||
+            target_width<1 || target_height<1) return;
+        int int_part_y=source_height/target_height;
+        int fract_part_y=source_height%target_height;
+        int err_y=0;
+        int int_part_x=source_width/target_width;
+        int fract_part_x=source_width%target_width;
+        int err_x=0;
+        int x=0,y=0,xs=0,ys=0;
+        int prev_y=-1;
+        for (y=0;y<target_height;++y)
+        {
+            if (ys==prev_y)
+            {
+                target.setRow(y,target.getRow(y-1),target_width);
+            }
+            else
+            {
+                xs=0;
+                for (x=0;x<target_width;++x)
+                {
+                    target(x,y)=source(xs,ys);
+                    xs+=int_part_x;
+                    err_x+=fract_part_x;
+                    if (err_x>=target_width)
+                    {
+                        err_x-=target_width;
+                        ++xs;
+                    }
+                }
+                prev_y=ys;
+            }
+            ys+=int_part_y;
+            err_y+=fract_part_y;
+            if (err_y>=target_height)
+            {
+                err_y-=target_height;
+                ++ys;
+            }
+        }
+    }
+}
+
+#endif //IMAGE_UTIL_HPP

Copied: trunk/include/mapnik/label_collision_detector.hpp (from rev 307, trunk/include/label_collision_detector.hpp)
===================================================================
--- trunk/include/label_collision_detector.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/label_collision_detector.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,88 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#if !defined LABEL_COLLISION_DETECTOR
+#define LABEL_COLLISION_DETECTOR
+// stl
+#include <vector>
+// mapnik
+#include <mapnik/quad_tree.hpp>
+
+namespace mapnik
+{
+    //this needs to be tree structure 
+    //as a proof of a concept _only_ we use sequential scan 
+
+    struct label_collision_detector
+    {
+        typedef std::vector<Envelope<double> > label_placements;
+
+        bool has_plasement(Envelope<double> const& box)
+        {
+            label_placements::const_iterator itr=labels_.begin();
+            for( ; itr !=labels_.end();++itr)
+            {
+                if (itr->intersects(box))
+                {
+                    return false;
+                }
+            }
+            labels_.push_back(box);
+            return true;
+        }
+    private:
+
+        label_placements labels_;
+    };
+
+    // quad_tree based label collision detector
+    class label_collision_detector2 : boost::noncopyable
+    {
+        typedef quad_tree<Envelope<double> > tree_t;
+        tree_t tree_;
+    public:
+	
+        explicit label_collision_detector2(Envelope<double> const& extent)
+            : tree_(extent) {}
+	
+        bool has_placement(Envelope<double> const& box)
+        {
+            tree_t::query_iterator itr = tree_.query_in_box(box);
+            tree_t::query_iterator end = tree_.query_end();
+	    
+            for ( ;itr != end; ++itr)
+            {
+                if (itr->intersects(box))
+                {
+                    return false;
+                }
+            }
+	    
+            tree_.insert(box,box);
+            return true;
+        }	
+    };
+}
+
+#endif 

Copied: trunk/include/mapnik/label_placement.hpp (from rev 307, trunk/include/label_placement.hpp)

Copied: trunk/include/mapnik/layer.hpp (from rev 307, trunk/include/layer.hpp)
===================================================================
--- trunk/include/layer.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/layer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,87 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id: layer.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef LAYER_HPP
+#define LAYER_HPP
+// stl
+#include <vector>
+// boost
+#include <boost/shared_ptr.hpp>
+// mapnik
+#include <mapnik/feature.hpp>
+#include <mapnik/datasource.hpp>
+
+namespace mapnik
+{
+    class MAPNIK_DECL Layer
+    {
+        std::string name_;
+        std::string title_;
+        std::string abstract_;
+        double minZoom_;
+        double maxZoom_;
+        bool active_;
+        bool selectable_;
+        std::vector<std::string>  styles_;
+        std::string selection_style_;
+        datasource_p ds_;
+        
+        mutable std::vector<boost::shared_ptr<Feature> > selection_;
+        
+    public:
+        explicit Layer(std::string const& name);
+        Layer(Layer const& l);
+        Layer& operator=(Layer const& l);
+        bool operator==(Layer const& other) const;
+        void set_name(std::string const& name);
+        const std::string& name() const;
+        void set_title(std::string const& title);
+        const std::string& title() const;
+        void set_abstract(std::string const& abstract);
+        const std::string& abstract() const;
+        void add_style(std::string const& stylename);
+        std::vector<std::string> const& styles() const;
+        void selection_style(const std::string& name);
+        const std::string& selection_style() const;
+        void setMinZoom(double minZoom);
+        void setMaxZoom(double maxZoom);
+        double getMinZoom() const;
+        double getMaxZoom() const;
+        void setActive(bool active);
+        bool isActive() const;
+        void setSelectable(bool selectable);
+        bool isSelectable() const;
+        bool isVisible(double scale) const;
+        void add_to_selection(boost::shared_ptr<Feature>& feature) const;
+        std::vector<boost::shared_ptr<Feature> >& selection() const;
+        void clear_selection() const;
+        void set_datasource(datasource_p const& ds);
+        datasource_p datasource() const;
+        Envelope<double> envelope() const;
+        ~Layer();
+    private:
+        void swap(const Layer& other);
+    };
+}
+
+#endif //LAYER_HPP

Copied: trunk/include/mapnik/line_pattern_symbolizer.hpp (from rev 307, trunk/include/line_pattern_symbolizer.hpp)
===================================================================
--- trunk/include/line_pattern_symbolizer.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/line_pattern_symbolizer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,45 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id: polygon_symbolizer.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef LINE_PATTERN_SYMBOLIZER_HPP
+#define LINE_PATTERN_SYMBOLIZER_HPP
+
+#include <boost/shared_ptr.hpp>
+#include <mapnik/graphics.hpp>
+
+namespace mapnik 
+{      
+    struct MAPNIK_DECL line_pattern_symbolizer
+    {
+        line_pattern_symbolizer(std::string const& file,
+                                std::string const& type,
+                                unsigned width,unsigned height);
+
+        line_pattern_symbolizer(line_pattern_symbolizer const& rhs);
+        ImageData32 const& get_pattern() const;
+    private:
+        boost::shared_ptr<ImageData32> pattern_;
+    };    
+}
+
+#endif // LINE_PATTERN_SYMBOLIZER_HPP

Copied: trunk/include/mapnik/line_symbolizer.hpp (from rev 307, trunk/include/line_symbolizer.hpp)
===================================================================
--- trunk/include/line_symbolizer.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/line_symbolizer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,55 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id: line_symbolizer.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef LINE_SYMBOLIZER_HPP
+#define LINE_SYMBOLIZER_HPP
+
+#include <mapnik/stroke.hpp>
+
+namespace mapnik 
+{
+    struct MAPNIK_DECL line_symbolizer
+    {
+        explicit line_symbolizer()
+            : stroke_() {}
+        
+        line_symbolizer(stroke const& stroke)
+            : stroke_(stroke) {}
+	
+        line_symbolizer(const Color& pen,float width=1.0)
+            : stroke_(pen,width) {}
+        stroke const& get_stroke() const
+        {
+            return stroke_;
+        }
+        void set_stroke(stroke const& stroke)
+        {
+            stroke_ = stroke;
+        }
+
+    private:
+		stroke stroke_;
+    };
+}
+
+#endif //LINE_SYMBOLIZER_HPP

Copied: trunk/include/mapnik/load_map.hpp (from rev 307, trunk/include/load_map.hpp)
===================================================================
--- trunk/include/load_map.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/load_map.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,35 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+// $Id$
+
+#ifndef MAP_LOADER_HPP
+#define MAP_LOADER_HPP
+
+#include <string>
+#include <mapnik/map.hpp>
+
+namespace mapnik
+{
+    void load_map(Map & map, std::string const& filename);
+}
+
+#endif // LOAD_MAP_HPP

Copied: trunk/include/mapnik/local_datasource.hpp (from rev 307, trunk/include/local_datasource.hpp)

Copied: trunk/include/mapnik/logical.hpp (from rev 307, trunk/include/logical.hpp)
===================================================================
--- trunk/include/logical.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/logical.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,172 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id$
+
+#ifndef LOGICAL_HPP
+#define LOGICAL_HPP
+
+#include <mapnik/filter.hpp>
+
+namespace mapnik
+{
+    template <typename FeatureT> 
+    struct logical_and : public filter<FeatureT>  
+    {
+	logical_and(filter<FeatureT> const& filter1,
+		    filter<FeatureT> const& filter2)
+	    : filter<FeatureT>(),
+	      filter1_(filter1.clone()),
+	      filter2_(filter2.clone()) {}
+	
+	logical_and(logical_and const& other)
+	    : filter<FeatureT>(),
+	      filter1_(other.filter1_->clone()),
+	      filter2_(other.filter2_->clone()) {}
+
+	bool pass(const FeatureT& feature) const
+	{
+	    return (filter1_->pass(feature) && 
+		filter2_->pass(feature));
+	}
+	std::string to_string() const
+	{
+	    return "("+filter1_->to_string()+" and "+filter2_->to_string()+")";
+	}
+	
+	filter<FeatureT>* clone() const
+	{
+	    return new logical_and(*this);
+	}
+
+	void accept(filter_visitor<FeatureT>& v)
+	{
+	    filter1_->accept(v);
+	    filter2_->accept(v);
+	    v.visit(*this);
+	}
+
+	virtual ~logical_and()
+	{
+	    delete filter1_;
+	    delete filter2_;
+	}
+	
+    private:
+	filter<FeatureT>* filter1_;
+	filter<FeatureT>* filter2_;
+    };
+
+    template <typename FeatureT> 
+    struct logical_or : public filter<FeatureT>  
+    {
+	
+	logical_or(const filter<FeatureT>& filter1,const filter<FeatureT>& filter2)
+	    : filter<FeatureT>(),
+	      filter1_(filter1.clone()),
+	      filter2_(filter2.clone()) {}
+	
+	logical_or(logical_or const& other)
+	    : filter<FeatureT>(),
+	      filter1_(other.filter1_->clone()),
+	      filter2_(other.filter2_->clone()) {}
+
+	bool pass(const FeatureT& feature) const
+	{
+	    if (filter1_->pass(feature))
+	    {
+		return true;
+	    }
+	    else
+	    {
+		return filter2_->pass(feature);
+	    }
+	}
+	filter<FeatureT>* clone() const
+	{
+	    return new logical_or(*this);
+	}
+
+	void accept(filter_visitor<FeatureT>& v)
+	{
+	    filter1_->accept(v);
+	    filter2_->accept(v);
+	    v.visit(*this);
+	}
+	std::string to_string() const
+	{
+	    return "("+filter1_->to_string()+" or "+filter2_->to_string()+")";
+	}	
+	virtual ~logical_or()
+	{  
+	    delete filter1_;
+	    delete filter2_;
+	}
+    private:
+	filter<FeatureT>* filter1_;
+	filter<FeatureT>* filter2_;
+    };
+
+    template <typename FeatureT> 
+    struct logical_not : public filter<FeatureT>  
+    {
+	logical_not(filter<FeatureT> const& _filter)
+	    : filter<FeatureT>(),
+	      filter_(_filter.clone()) {}
+	logical_not(logical_not const& other)
+	    : filter<FeatureT>(),
+	      filter_(other.filter_->clone()) {}
+
+	int type() const
+	{
+	    return filter<FeatureT>::LOGICAL_OPS;
+	}
+
+	bool pass(const FeatureT& feature) const
+	{
+	    return !(filter_->pass(feature));
+	}
+
+	filter<FeatureT>* clone() const
+	{
+	    return new logical_not(*this);
+	}
+	
+	void accept(filter_visitor<FeatureT>& v)
+	{
+	    filter_->accept(v);
+	    v.visit(*this);
+	}
+	std::string to_string() const
+	{
+	    return "not ("+filter_->to_string()+")";
+	}
+	 
+	~logical_not() 
+	{
+	    delete filter_;
+	}
+    private:
+	filter<FeatureT>* filter_;
+    };
+}
+ 
+#endif //LOGICAL_HPP

Copied: trunk/include/mapnik/map.hpp (from rev 307, trunk/include/map.hpp)
===================================================================
--- trunk/include/map.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/map.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,85 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id: map.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef MAP_HPP
+#define MAP_HPP
+
+#include <mapnik/feature_type_style.hpp>
+
+namespace mapnik
+{
+    class Layer;
+
+    class MAPNIK_DECL Map
+    {	
+        static const unsigned MIN_MAPSIZE=16;
+        static const unsigned MAX_MAPSIZE=2048;
+        unsigned width_;
+        unsigned height_;
+        int srid_;
+        Color background_;
+        std::map<std::string,feature_type_style> styles_;
+        std::vector<Layer> layers_;
+        Envelope<double> currentExtent_;
+        
+    public:
+ 
+        typedef std::map<std::string,feature_type_style>::const_iterator style_iterator;
+        
+        Map();
+        Map(int width,int height,int srid=-1);
+        Map(const Map& rhs);
+        Map& operator=(const Map& rhs);
+        style_iterator begin_styles() const;
+        style_iterator end_styles() const;
+        bool insert_style(std::string const& name,feature_type_style const& style);
+        void remove_style(const std::string& name);
+        feature_type_style const& find_style(std::string const& name) const;
+        size_t layerCount() const;
+        void addLayer(const Layer& l);
+        const Layer& getLayer(size_t index) const;
+        Layer& getLayer(size_t index);
+        void removeLayer(size_t index);
+        std::vector<Layer> const& layers() const;
+        unsigned getWidth() const;
+        unsigned getHeight() const;
+        void setWidth(unsigned width);
+        void setHeight(unsigned height);
+        void resize(unsigned width,unsigned height);
+        int srid() const;
+        void setBackground(const Color& c);
+        const Color& getBackground() const;
+        void zoom(double zoom);
+        void zoomToBox(const Envelope<double>& box);
+        void zoom_all();
+        void pan(int x,int y);
+        void pan_and_zoom(int x,int y,double zoom);
+        const Envelope<double>& getCurrentExtent() const;
+        double scale() const;
+        ~Map();
+    private:
+        void fixAspectRatio();
+    };
+}
+
+#endif //MAP_HPP

Copied: trunk/include/mapnik/math_expr.hpp (from rev 307, trunk/include/math_expr.hpp)
===================================================================
--- trunk/include/math_expr.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/math_expr.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,128 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id$
+
+#ifndef MATH_EXPR_HPP
+#define MATH_EXPR_HPP
+
+#include <mapnik/expression.hpp>
+
+namespace mapnik
+{
+    template <typename T>
+    struct add
+    {
+        T operator () (T const& left, T const& right)
+        {
+            return left + right;
+        }
+        static std::string to_string()
+        {
+            return "+";
+        } 
+    };
+
+    template <typename T>
+    struct sub
+    {
+        T operator () (T const& left, T const& right)
+        {
+            return left - right;
+        }
+        static std::string to_string()
+        {
+            return "-";
+        } 
+    };
+    
+    template <typename T>
+    struct mult
+    {
+        T operator () (T const& left, T const& right)
+        {
+            return left * right;
+        }
+        static std::string to_string()
+        {
+            return "*";
+        } 
+    };
+    
+    template <typename T>
+    struct div
+    {
+        T operator () (T const& left, T const& right)
+        {
+            return left / right;
+        }
+        static std::string to_string()
+        {
+            return "/";
+        } 
+    };
+    
+    template <typename FeatureT,typename Op>
+    struct math_expr_b : public expression<FeatureT>
+    {
+        math_expr_b(expression<FeatureT> const& left,
+                    expression<FeatureT> const& right)
+            : expression<FeatureT>(),
+              left_(left.clone()), 
+              right_(right.clone()) {}
+        math_expr_b(math_expr_b const& other)
+            : expression<FeatureT>(),
+              left_(other.left_->clone()),
+              right_(other.right_->clone()) {}
+
+        value get_value(FeatureT const& feature) const
+        {
+            return Op ()(left_->get_value(feature),right_->get_value(feature));
+        }
+
+        void accept(filter_visitor<FeatureT>& v)
+        {
+            left_->accept(v);
+            right_->accept(v);
+            v.visit(*this);
+        }
+
+        expression<FeatureT>* clone() const
+        {
+            return new math_expr_b<FeatureT,Op>(*this);
+        }
+        std::string to_string() const
+        {
+            return "("+left_->to_string() + Op::to_string() + right_->to_string()+")";
+        }
+
+        ~math_expr_b() 
+        {
+            delete left_;
+            delete right_;
+        }
+    private:
+        expression<FeatureT>* left_;
+        expression<FeatureT>* right_;	
+    }; 
+}
+
+#endif //

Copied: trunk/include/mapnik/memory.hpp (from rev 307, trunk/include/memory.hpp)
===================================================================
--- trunk/include/memory.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/memory.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,88 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id: memory.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef MEMORY_HPP
+#define MEMORY_HPP
+
+#include <iostream>
+#include <cassert>
+
+namespace mapnik
+{
+    class MemoryUtils
+    {
+    public:
+        static size_t alignPointerSize(size_t ptrSize);
+    private:
+        MemoryUtils();
+        MemoryUtils(const MemoryUtils&);
+        MemoryUtils& operator=(const MemoryUtils&);
+    };
+
+    class MemoryManager
+    {
+    public:
+        virtual void* allocate(size_t size)=0;
+        virtual void deallocate(void* p)=0;
+        virtual ~MemoryManager();
+    protected:
+        MemoryManager();                      // {}
+    private:
+        MemoryManager(const MemoryManager&);
+        MemoryManager& operator=(const MemoryManager&);
+    };
+
+    class Object
+    {
+    public:
+        void* operator new(size_t size);
+        void* operator new(size_t size, MemoryManager* manager);
+        void operator delete(void* p);
+        void operator delete(void* p, MemoryManager* manager);
+    protected:
+        virtual ~Object() {}
+        Object() {}
+        Object(const Object&) {}
+    protected:
+        Object& operator=(const Object&)
+        {
+            return *this;
+        }
+    };
+
+    template <typename Geometry>
+    class geometry_pool
+    {
+    public:
+        void* allocate()
+        {
+            return ::operator new(sizeof(Geometry));
+        }
+        void deallocate(void* p)
+        {
+            ::operator delete(p);
+        }
+    };
+
+}
+#endif //MEMORY_HPP

Copied: trunk/include/mapnik/params.hpp (from rev 307, trunk/include/params.hpp)
===================================================================
--- trunk/include/params.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/params.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,53 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id: params.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef PARAMS_HPP
+#define PARAMS_HPP
+
+#include <string>
+#include <map>
+
+namespace mapnik
+{
+
+    typedef std::pair<const std::string,std::string> parameter;
+    typedef std::map<const std::string,std::string> param_map;
+
+    class parameters : public param_map
+    {
+    public:
+
+        parameters() {}
+        const std::string get(std::string const& key) const
+        {
+            param_map::const_iterator itr=find(key);
+            if (itr != end())
+            {
+                return itr->second;
+            }
+            return std::string();
+        }
+    };
+}
+
+#endif //PARAMS_HPP

Copied: trunk/include/mapnik/plugin.hpp (from rev 307, trunk/include/plugin.hpp)
===================================================================
--- trunk/include/plugin.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/plugin.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,50 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: plugin.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef PLUGIN_HPP
+#define PLUGIN_HPP
+// ltdl
+#include <ltdl.h>
+// stl
+#include <string>
+// boost
+#include <boost/utility.hpp>
+
+namespace mapnik
+{
+    class PluginInfo : boost::noncopyable
+    {
+    private:
+        std::string name_;
+        lt_dlhandle module_;
+	
+    public:
+        PluginInfo (const std::string& name,const lt_dlhandle module);
+        ~PluginInfo();
+        const std::string& name() const;
+        lt_dlhandle handle() const;
+    };
+}
+
+#endif //PLUGIN_HPP

Copied: trunk/include/mapnik/point_symbolizer.hpp (from rev 307, trunk/include/point_symbolizer.hpp)
===================================================================
--- trunk/include/point_symbolizer.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/point_symbolizer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,50 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id: image_symbolizer.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef POINT_SYMBOLIZER_HPP
+#define POINT_SYMBOLIZER_HPP
+
+#include <boost/shared_ptr.hpp>
+#include <mapnik/graphics.hpp> 
+
+namespace mapnik 
+{   
+    struct MAPNIK_DECL point_symbolizer
+    {	
+        explicit point_symbolizer();
+        point_symbolizer(std::string const& file,
+                         std::string const& type,
+                         unsigned width,unsigned height);
+        point_symbolizer(point_symbolizer const& rhs);
+        void set_data (boost::shared_ptr<ImageData32> symbol);
+        boost::shared_ptr<ImageData32> const& get_data() const;        
+        void set_allow_overlap(bool overlap);
+        bool get_allow_overlap() const;
+        
+    private:
+        boost::shared_ptr<ImageData32> symbol_;
+        bool overlap_;
+    };
+}
+
+#endif // POINT_SYMBOLIZER_HPP

Copied: trunk/include/mapnik/polygon_pattern_symbolizer.hpp (from rev 307, trunk/include/polygon_pattern_symbolizer.hpp)
===================================================================
--- trunk/include/polygon_pattern_symbolizer.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/polygon_pattern_symbolizer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,47 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id$
+
+#ifndef POLYGON_PATTERN_SYMBOLIZER_HPP
+#define POLYGON_PATTERN_SYMBOLIZER_HPP
+
+#include <boost/shared_ptr.hpp>
+#include <mapnik/graphics.hpp> 
+
+namespace mapnik
+{
+    struct MAPNIK_DECL polygon_pattern_symbolizer
+    {
+	
+        polygon_pattern_symbolizer(std::string const& file,
+                                   std::string const& type,
+                                   unsigned width,unsigned height);
+        
+        polygon_pattern_symbolizer(polygon_pattern_symbolizer const& rhs);
+        
+        ImageData32 const& get_pattern() const;
+    private:
+        boost::shared_ptr<ImageData32> pattern_;
+    };
+}
+
+#endif //POLYGON_PATTERN_SYMBOLIZER_HPP

Copied: trunk/include/mapnik/polygon_symbolizer.hpp (from rev 307, trunk/include/polygon_symbolizer.hpp)
===================================================================
--- trunk/include/polygon_symbolizer.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/polygon_symbolizer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,64 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: polygon_symbolizer.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef POLYGON_SYMBOLIZER_HPP
+#define POLYGON_SYMBOLIZER_HPP
+
+#include <mapnik/color.hpp>
+
+namespace mapnik 
+{
+    struct MAPNIK_DECL polygon_symbolizer
+    {
+        explicit polygon_symbolizer() 
+            : fill_(Color(128,128,128)),
+              opacity_(1.0) {}
+
+        polygon_symbolizer(Color const& fill)
+            : fill_(fill),
+              opacity_(1.0) {}
+        
+        Color const& get_fill() const
+        {
+            return fill_;
+        }
+        void set_fill(Color const& fill)
+        {
+            fill_ = fill;
+        }
+        void set_opacity(float opacity)
+        {
+            opacity_ = opacity;
+        }
+        float get_opacity() const
+        {
+            return opacity_;
+        }
+    private:
+        Color fill_;
+        float opacity_;
+    };  
+}
+
+#endif // POLYGON_SYMBOLIZER_HPP

Copied: trunk/include/mapnik/pool.hpp (from rev 307, trunk/include/pool.hpp)
===================================================================
--- trunk/include/pool.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/pool.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,122 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: pool.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef POOL_HPP
+#define POOL_HPP
+
+// stl
+#include <iostream>
+#include <map>
+#include <deque>
+#include <ctime>
+// boost
+#include <boost/shared_ptr.hpp>
+#include <boost/thread/mutex.hpp>
+#include <boost/utility.hpp>
+// mapnik
+#include <mapnik/utils.hpp>
+
+namespace mapnik
+{
+    template <typename T, typename PoolT>
+    class PoolGuard
+    {
+    private:
+        const T& obj_;
+        PoolT& pool_; 
+    public:
+        explicit PoolGuard(const T& ptr,PoolT& pool)
+            : obj_(ptr),
+              pool_(pool) {}
+
+        ~PoolGuard() 
+        {
+            pool_->returnObject(obj_);
+        }
+
+    private:
+        PoolGuard();
+        PoolGuard(const PoolGuard&);
+        PoolGuard& operator=(const PoolGuard&);
+    };
+
+    template <typename T,template <typename> class Creator>
+    class Pool : private boost::noncopyable
+    {
+        typedef boost::shared_ptr<T> HolderType;
+        typedef std::deque<HolderType> ContType;	
+	
+        Creator<T> creator_;
+        const int initialSize_; 
+        const int maxSize_;
+        ContType usedPool_;
+        ContType unusedPool_;
+        boost::mutex mutex_;
+    public:
+
+        Pool(const Creator<T>& creator,int initialSize=5,int maxSize=20)
+            :creator_(creator),
+             initialSize_(initialSize),
+             maxSize_(maxSize)
+        {
+            for (int i=0;i<initialSize_;++i) 
+            {
+                unusedPool_.push_back(HolderType(creator_()));
+            }
+        }
+
+        const HolderType& borrowObject()
+        {	    
+            mutex::scoped_lock lock(mutex_);
+            typename ContType::iterator itr=unusedPool_.begin();
+            if (itr!=unusedPool_.end())
+            {  
+                std::clog<<"borrow "<<(*itr).get()<<"\n";
+                usedPool_.push_back(*itr);
+                itr=unusedPool_.erase(itr);
+                return usedPool_[usedPool_.size()-1];
+            }
+            static const HolderType defaultObj;
+            return defaultObj;
+        } 
+
+        void returnObject(const HolderType& obj)
+        {
+            mutex::scoped_lock lock(mutex_);
+            typename ContType::iterator itr=usedPool_.begin();
+            while (itr != usedPool_.end())
+            {
+                if (obj.get()==(*itr).get()) 
+                {
+                    std::clog<<"return "<<(*itr).get()<<"\n";
+                    unusedPool_.push_back(*itr);
+                    usedPool_.erase(itr);
+                    return;
+                }
+                ++itr;
+            }
+        }
+    };
+}
+#endif //POOL_HPP

Copied: trunk/include/mapnik/quad_tree.hpp (from rev 307, trunk/include/quad_tree.hpp)
===================================================================
--- trunk/include/quad_tree.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/quad_tree.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,210 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id$
+
+#if !defined QUAD_TREE_HPP
+#define QUAD_TREE_HPP
+// stl
+#include <vector>
+// boost
+#include <boost/ptr_container/ptr_vector.hpp>
+#include <boost/noncopyable.hpp>
+// mapnik
+#include <mapnik/envelope.hpp>
+
+namespace mapnik
+{
+    template <typename T>
+    class quad_tree : boost::noncopyable
+    {
+        struct node
+        {
+            typedef T value_t;
+            typedef std::vector<T> cont_t;
+            typedef typename cont_t::iterator iterator;
+            typedef typename cont_t::const_iterator const_iterator;
+            Envelope<double> extent_;
+            cont_t cont_;
+            node * children_[4];
+
+            explicit node(Envelope<double> const& ext)
+                : extent_(ext)
+            {
+                std::memset(children_,0,4*sizeof(node*));
+            }
+   
+            Envelope<double> const& extent() const
+            {
+                return extent_;
+            }
+	    
+            iterator begin() 
+            {
+                return cont_.begin();
+            }
+	    
+            const_iterator begin() const 
+            {
+                return cont_.begin();
+            }
+	    
+            iterator end() 
+            {
+                return cont_.end();
+            }
+	    
+            const_iterator end() const 
+            {
+                return cont_.end();
+            }
+            ~node () {}
+        };
+	
+        typedef boost::ptr_vector<node> nodes_t;	
+        typedef typename node::cont_t cont_t;
+        typedef typename cont_t::iterator node_data_iterator;
+	
+        nodes_t nodes_;
+        node * root_;	
+        const double ratio_; 
+	
+    public:
+        typedef typename nodes_t::iterator iterator;
+        typedef typename nodes_t::const_iterator const_iterator;
+        typedef typename boost::ptr_vector<T,boost::view_clone_allocator> result_t;	
+        typedef typename result_t::iterator query_iterator;
+   
+        result_t query_result_;
+	
+        explicit quad_tree(Envelope<double> const& ext,double ratio=0.55) 
+            : ratio_(ratio)
+        {
+            nodes_.push_back(new node(ext));
+            root_ = &nodes_[0];
+        }
+		
+        void insert(T data, Envelope<double> const& box)
+        {
+            do_insert_data(data,box,root_);
+        }
+        
+        query_iterator query_in_box(Envelope<double> const& box)
+        {
+            query_result_.clear();
+            query_node(box,query_result_,root_);
+            return query_result_.begin();
+        }
+	
+        query_iterator query_end()
+        {
+            return query_result_.end();
+        }
+
+        iterator begin()
+        {
+            return nodes_.begin();
+        }
+	
+        const_iterator begin() const
+        {
+            return nodes_.begin();
+        }
+
+        iterator end()
+        {
+            return  nodes_.end();
+        }
+	
+        const_iterator end() const
+        {
+            return  nodes_.end();
+        }
+	
+    private:
+        
+        void query_node(Envelope<double> const& box, result_t & result, node * node_) const
+        {
+            if (node_)
+            {
+                Envelope<double> const& node_extent = node_->extent();
+                if (box.intersects(node_extent))
+                {
+                    node_data_iterator i=node_->begin();
+                    node_data_iterator end=node_->end();
+                    while ( i!=end)
+                    {
+                        result.push_back(&(*i));
+                        ++i;
+                    }
+                    for (int k = 0; k < 4; ++k)
+                    {
+                        query_node(box,result,node_->children_[k]);
+                    }
+                }
+            }
+        }
+	
+        void do_insert_data(T data, Envelope<double> const& box, node * n)
+        {
+            if (n)
+            {
+                Envelope<double> const& node_extent = n->extent();
+                Envelope<double> ext[4];
+                split_box(node_extent,ext);		
+                for (int i=0;i<4;++i)
+                {
+                    if (ext[i].contains(box))
+                    {
+                        if (!n->children_[i])
+                        {
+                            nodes_.push_back(new node(ext[i]));
+                            n->children_[i]=&nodes_.back();
+                        }
+                        do_insert_data(data,box,n->children_[i]);
+                        return;
+                    }
+                }
+                n->cont_.push_back(data);
+            }
+        }
+	
+        void split_box(Envelope<double> const& node_extent,Envelope<double> * ext)
+        {
+            coord2d c=node_extent.center();
+
+            double width=node_extent.width();
+            double height=node_extent.height();
+	    
+            double lox=node_extent.minx();
+            double loy=node_extent.miny();
+            double hix=node_extent.maxx();
+            double hiy=node_extent.maxy();
+	    
+            ext[0]=Envelope<double>(lox,loy,lox + width * ratio_,loy + height * ratio_);
+            ext[1]=Envelope<double>(hix - width * ratio_,loy,hix,loy + height * ratio_);
+            ext[2]=Envelope<double>(lox,hiy - height*ratio_,lox + width * ratio_,hiy);
+            ext[3]=Envelope<double>(hix - width * ratio_,hiy - height*ratio_,hix,hiy);
+        }
+    };    
+} 
+
+#endif

Copied: trunk/include/mapnik/query.hpp (from rev 307, trunk/include/query.hpp)
===================================================================
--- trunk/include/query.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/query.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,112 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef QUERY_HPP
+#define QUERY_HPP
+// stl
+#include <set>
+#include <limits>
+//mapnik
+#include <mapnik/filter.hpp>
+#include <mapnik/envelope.hpp>
+#include <mapnik/feature.hpp>
+
+namespace mapnik
+{
+    class query 
+    {
+    private:
+        Envelope<double> bbox_;
+        filter<Feature>* filter_;
+        std::set<std::string> names_;
+    public:
+        query() 
+            : bbox_(std::numeric_limits<double>::min(),
+                    std::numeric_limits<double>::min(),
+                    std::numeric_limits<double>::max(),
+                    std::numeric_limits<double>::max()),
+              filter_(new all_filter<Feature>)
+        {}
+        
+        query(const Envelope<double>& bbox)
+            : bbox_(bbox),
+              filter_(new all_filter<Feature>)
+        {}
+	
+        query(const Envelope<double>& bbox, const filter<Feature>& f)
+            : bbox_(bbox),
+              filter_(f.clone())
+        {}
+	
+        query(const query& other)
+            : bbox_(other.bbox_),
+              filter_(other.filter_->clone())
+        {}
+        
+        query& operator=(const query& other)
+        {
+            filter<Feature>* tmp=other.filter_->clone();
+            delete filter_;
+            filter_=tmp;
+            bbox_=other.bbox_;
+            names_=other.names_;
+            return *this;
+        }
+	
+        const filter<Feature>* get_filter() const
+        {
+            return  filter_;
+        }
+	
+        const Envelope<double>& get_bbox() const
+        {
+            return bbox_;
+        }
+
+        void set_filter(const filter<Feature>& f)
+        {
+            filter<Feature>* tmp=f.clone();
+            delete filter_;
+            filter_=tmp;
+        }
+        
+        void add_property_name(const std::string& name)
+        {
+            names_.insert(name);
+        } 
+	
+        const std::set<std::string>& property_names() const
+        {
+            return names_;
+        }
+	
+        ~query() 
+        {
+            delete filter_;
+        }
+    };
+}
+
+
+#endif //QUERY_HPP

Copied: trunk/include/mapnik/raster.hpp (from rev 307, trunk/include/raster.hpp)
===================================================================
--- trunk/include/raster.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/raster.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,41 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id: raster.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef RASTER_HPP
+#define RASTER_HPP
+
+#include <mapnik/graphics.hpp>
+
+namespace mapnik {
+    struct raster
+    {
+        Envelope<double> ext_;
+        ImageData32 data_;
+        raster(Envelope<double> const ext,ImageData32& data)
+            : ext_(ext),
+              data_(data) {}
+    };
+}
+
+#endif //RASTER_HPP
+

Copied: trunk/include/mapnik/raster_symbolizer.hpp (from rev 307, trunk/include/raster_symbolizer.hpp)
===================================================================
--- trunk/include/raster_symbolizer.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/raster_symbolizer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,34 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id$
+
+#ifndef RASTER_SYMBOLIZER_HPP
+#define RASTER_SYMBOLIZER_HPP
+
+#include <mapnik/config.hpp>
+
+namespace mapnik
+{
+    struct MAPNIK_DECL raster_symbolizer { /* TODO */};
+}
+
+#endif //RASTER_SYMBOLIZER_HPP

Copied: trunk/include/mapnik/regex_filter.hpp (from rev 307, trunk/include/regex_filter.hpp)
===================================================================
--- trunk/include/regex_filter.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/regex_filter.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,81 @@
+/* This file is part of Mapnik (c++ mapping toolkit)
+ * Copyright (C) 2005 Artem Pavlenko
+ *
+ * Mapnik is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+//$Id$
+
+#ifndef REGEX_FILTER_HPP
+#define REGEX_FILTER_HPP
+// boost
+#include <boost/regex.hpp>
+#include <boost/algorithm/string.hpp>
+// mapnik
+#include <mapnik/filter.hpp>
+#include <mapnik/expression.hpp>
+
+namespace mapnik
+{ 
+    template <typename FeatureT>
+    struct regex_filter : public filter<FeatureT>
+    {
+
+        regex_filter(expression<FeatureT> const& exp,
+                     std::string const& pattern)
+            : filter<FeatureT>(),
+              exp_(exp.clone()),
+              pattern_(pattern) {}
+	
+        regex_filter(regex_filter const& other)
+            :  filter<FeatureT>(),
+               exp_(other.exp_->clone()),
+               pattern_(other.pattern_) {}
+	
+        bool pass(FeatureT const& feature) const
+        {
+            std::string text=exp_->get_value(feature).to_string();
+            boost::trim_if(text, boost::is_any_of("'"));
+            return boost::regex_match(text,pattern_);
+        } 
+	
+        void accept(filter_visitor<FeatureT>& v)
+        {
+            exp_->accept(v);
+            v.visit(*this);
+        }
+	
+        filter<FeatureT>* clone() const
+        {
+            return new regex_filter(*this);
+        }
+        std::string to_string() const
+        {
+            return exp_->to_string()+".match("+pattern_.str()+")";
+        }
+        ~regex_filter()
+        {
+            delete exp_;
+        }
+	
+    private:
+        expression<FeatureT>* exp_;
+        boost::regex pattern_;
+	
+    };   
+}
+
+
+#endif //REGEX_FILTER_HPP

Copied: trunk/include/mapnik/rule.hpp (from rev 307, trunk/include/rule.hpp)
===================================================================
--- trunk/include/rule.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/rule.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,283 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+#ifndef RULE_HPP
+#define RULE_HPP
+// stl
+#include <string>
+#include <vector>
+// boost
+#include <boost/shared_ptr.hpp>
+#include <boost/variant.hpp>
+// mapnik
+#include <mapnik/line_symbolizer.hpp>
+#include <mapnik/line_pattern_symbolizer.hpp>
+#include <mapnik/polygon_symbolizer.hpp>
+#include <mapnik/polygon_pattern_symbolizer.hpp>
+#include <mapnik/point_symbolizer.hpp>
+#include <mapnik/raster_symbolizer.hpp>
+#include <mapnik/text_symbolizer.hpp>
+#include <mapnik/filter.hpp>
+#include <mapnik/filter_visitor.hpp>
+
+namespace mapnik
+{
+    inline bool operator==(point_symbolizer const& lhs,
+                           point_symbolizer const& rhs)
+    {
+        return (&lhs == &rhs); 
+    }
+    inline bool operator==(line_symbolizer const& lhs,
+                           line_symbolizer const& rhs)
+    {
+        return (&lhs == &rhs); 
+    }
+    inline bool operator==(line_pattern_symbolizer const& lhs,
+                           line_pattern_symbolizer const& rhs)
+    {
+        return (&lhs == &rhs); 
+    }
+
+    inline bool operator==(polygon_symbolizer const& lhs,
+                           polygon_symbolizer const& rhs)
+    {
+        return (&lhs == &rhs); 
+    }
+    
+    inline bool operator==(polygon_pattern_symbolizer const& lhs,
+                           polygon_pattern_symbolizer const& rhs)
+    {
+        return (&lhs == &rhs); 
+    }
+    
+    inline bool operator==(raster_symbolizer const& lhs,
+                           raster_symbolizer const& rhs)
+    {
+        return (&lhs == &rhs); 
+    }
+    
+    inline bool operator==(text_symbolizer const& lhs,
+                           text_symbolizer const& rhs)
+    {
+        return (&lhs == &rhs); 
+    }
+    
+    typedef boost::variant<point_symbolizer,
+                           line_symbolizer,
+                           line_pattern_symbolizer,
+                           polygon_symbolizer,
+                           polygon_pattern_symbolizer,
+                           raster_symbolizer,
+                           text_symbolizer> symbolizer;
+    
+        
+    typedef std::vector<symbolizer> symbolizers;
+    
+    template <typename FeatureT> class all_filter;
+
+    template <typename FeatureT,template <typename> class Filter>
+    class rule
+    {
+        typedef Filter<FeatureT> filter_type;
+        typedef boost::shared_ptr<filter_type> filter_ptr;
+    private:
+
+        std::string name_;
+        std::string title_;
+        std::string abstract_;
+        double min_scale_;
+        double max_scale_;
+        symbolizers syms_;
+        filter_ptr filter_;
+        bool else_filter_;
+    public:
+        rule()
+            : name_(),
+              title_(),
+              abstract_(),
+              min_scale_(0),
+              max_scale_(std::numeric_limits<double>::infinity()),
+              syms_(),
+              filter_(new all_filter<FeatureT>),
+              else_filter_(false) {}
+                
+        rule(const std::string& name,
+             const std::string& title="",
+             double min_scale_denominator=0,
+             double max_scale_denominator=std::numeric_limits<double>::infinity())
+            : name_(name),
+              title_(title),
+              min_scale_(min_scale_denominator),
+              max_scale_(max_scale_denominator),
+              syms_(),
+              filter_(new all_filter<FeatureT>),
+              else_filter_(false) {}
+	    
+        rule(const rule& rhs)    
+            : name_(rhs.name_),
+              title_(rhs.title_),
+              abstract_(rhs.abstract_),
+              min_scale_(rhs.min_scale_),
+              max_scale_(rhs.max_scale_),
+              syms_(rhs.syms_),
+              filter_(rhs.filter_),
+              else_filter_(rhs.else_filter_) {}
+	
+        rule& operator=(rule const& rhs) 
+        {
+            rule tmp(rhs);
+            swap(tmp);
+            return *this;
+        }
+        bool operator==(rule const& other)
+        {
+            return  (this == &other); 
+        }
+	
+        void set_max_scale(double scale)
+        {
+            max_scale_=scale;
+        }
+        
+        double get_max_scale() const
+        {
+            return max_scale_;
+        }
+        
+        void set_min_scale(double scale)
+        {
+            min_scale_=scale;
+        }
+
+        double get_min_scale() const
+        {
+            return min_scale_;
+        }
+
+       
+        void set_name(std::string const& name)
+        {
+            name_=name;
+        }
+	
+        std::string const& get_name() const
+        {
+            return name_;
+        }
+	
+        std::string const& get_title() const
+        {
+            return  title_;
+        }
+
+        void set_title(std::string const& title)
+        {
+            title_=title;
+        }
+  
+        void set_abstract(std::string const& abstract)
+        {
+            abstract_=abstract;
+        }
+	
+        std::string const& get_abstract() const
+        {
+            return abstract_;
+        }
+		
+        void append(const symbolizer& sym)
+        {
+            syms_.push_back(sym);
+        }
+	
+        void remove_at(size_t index)
+        {
+            if (index < syms_.size())
+            {
+                syms_.erase(syms_.begin()+index);
+            }
+        }
+	
+        const symbolizers& get_symbolizers() const
+        {
+            return syms_;
+        }
+	
+        symbolizers::const_iterator begin()
+        {
+            return syms_.begin();
+        }
+	
+        symbolizers::const_iterator end()
+        {
+            return syms_.end();
+        }
+	
+        void set_filter(const filter_ptr& filter)
+        {
+            filter_=filter;
+        }
+
+        filter_ptr const& get_filter() const
+        {
+            return filter_;
+        }
+	
+        void set_else(bool else_filter)
+        {
+            else_filter_=else_filter;
+        }
+     
+        bool has_else_filter() const
+        {
+            return else_filter_;
+        }
+        
+        bool active(double scale) const
+        {
+            return ( scale > min_scale_ && scale < max_scale_ );
+        }
+
+        void accept(filter_visitor<FeatureT>& v) const
+        {
+            v.visit(*this);
+        }
+	
+    private:
+	
+        void swap(rule& rhs) throw()
+        {
+            name_=rhs.name_;
+            title_=rhs.title_;
+            abstract_=rhs.abstract_;
+            min_scale_=rhs.min_scale_;
+            max_scale_=rhs.max_scale_;
+            syms_=rhs.syms_;
+            filter_=rhs.filter_;
+            else_filter_=rhs.else_filter_;
+        }
+    };
+
+    typedef rule<Feature,filter> rule_type;
+}
+
+#endif //RULE_HPP

Copied: trunk/include/mapnik/save_map.hpp (from rev 307, trunk/include/save_map.hpp)
===================================================================
--- trunk/include/save_map.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/save_map.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,36 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+// $Id$
+
+#ifndef SAVE_MAP_HPP
+#define SAVE_MAP_HPP
+// stl
+#include <string>
+// mapnik
+#include <mapnik/map.hpp>
+
+namespace mapnik
+{
+    void save_map(Map const& map, std::string const& filename);
+}
+
+#endif // SAVE_MAP_HPP

Copied: trunk/include/mapnik/spatial.hpp (from rev 307, trunk/include/spatial.hpp)
===================================================================
--- trunk/include/spatial.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/spatial.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,153 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+#ifndef SPATIAL_HPP
+#define SPATIAL_HPP
+
+#include <mapnik/filter.hpp>
+#include <mapnik/filter_visitor.hpp>
+
+namespace mapnik
+{    
+
+    template <typename FeatureT>
+    struct equals_ : public filter<FeatureT>
+    {
+
+        bool pass(const FeatureT& feature) const
+        {
+            return false;
+        }
+	
+        void accept(const filter_visitor<FeatureT>& v)
+        {
+            v.visit(*this);
+        }
+    };
+    
+    template <typename FeatureT>
+    struct disjoint : public filter<FeatureT>
+    {
+	  
+	
+        bool pass(const FeatureT& feature) const
+        {
+            return false;
+        }
+	
+        void accept(const filter_visitor<FeatureT>& v)
+        {
+            v.visit(*this);
+        }
+    };
+  
+    template <typename FeatureT>
+    struct touches : public filter<FeatureT>
+    {
+
+	
+        bool pass(const FeatureT& feature) const
+        {
+            return false;
+        }
+	
+        void accept(const filter_visitor<FeatureT>& v)
+        {
+            v.visit(*this);
+        }
+    };
+
+    template <typename FeatureT>
+    struct within : public filter<FeatureT>
+    {
+
+        bool pass(const FeatureT& feature) const
+        {
+            return false;
+        }
+
+        void accept(const filter_visitor<FeatureT>& v)
+        {
+            v.visit(*this);
+        }
+    };
+
+    template <typename FeatureT>
+    struct overlaps : public filter<FeatureT>
+    {
+
+        bool pass(const FeatureT& feature) const
+        {
+            return false;
+        }
+	
+        void accept(const filter_visitor<FeatureT>& v)
+        {
+            v.visit(*this);
+        }
+    };
+
+    template <typename FeatureT>
+    struct crosses : public filter<FeatureT>
+    {
+
+	
+        bool pass(const FeatureT& feature) const
+        {
+            return false;
+        }
+	
+        void accept(const filter_visitor<FeatureT>& v)
+        {
+            v.visit(*this);
+        }
+    };
+    
+    template <typename FeatureT>
+    struct bbox  : public filter<FeatureT> 
+    {
+    private:
+        Envelope<double> box_;
+    public:
+        bbox(const Envelope<double>& box)
+            : box_(box) {}
+
+	
+        bool pass(const FeatureT& feature) const
+        {
+            return box_.contains(feature.get_geometry()->bbox());
+        }
+	
+
+        filter<FeatureT>* clone() const
+        {
+            return new bbox<FeatureT>(box_);
+        }
+        void accept(const filter_visitor<FeatureT>& v)
+        {
+            v.visit(*this);
+        }
+	
+        virtual ~bbox() {}
+    };
+}
+
+#endif //SPATIAL_HPP

Copied: trunk/include/mapnik/stroke.hpp (from rev 307, trunk/include/stroke.hpp)
===================================================================
--- trunk/include/stroke.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/stroke.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,170 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id$
+
+#ifndef STROKE_HPP
+#define STROKE_HPP
+// stl
+#include <vector>
+// mapnik
+#include <mapnik/color.hpp>
+ 
+namespace mapnik
+{
+    using std::pair;
+    using std::vector;
+    typedef vector<pair<float,float> > dash_array;
+    
+    enum line_cap_e
+        {
+            BUTT_CAP,
+            SQUARE_CAP,
+            ROUND_CAP
+        }; 
+    
+    enum line_join_e
+        {
+            MITER_JOIN,
+            MITER_REVERT_JOIN,
+            ROUND_JOIN,
+            BEVEL_JOIN
+        };
+    
+    class stroke
+    {	
+        Color c_;
+        float width_;
+        float opacity_; // 0.0 - 1.0
+        line_cap_e  line_cap_;
+        line_join_e line_join_;
+        dash_array dash_;	
+    public:
+        explicit stroke() 
+            : c_(0,0,0),
+              width_(1.0),
+              opacity_(1.0),
+              line_cap_(BUTT_CAP),
+              line_join_(MITER_JOIN),
+              dash_() {}
+	
+        stroke(Color const& c, float width=1.0)
+            : c_(c),
+              width_(width),
+              opacity_(1.0),
+              line_cap_(BUTT_CAP),
+              line_join_(MITER_JOIN),
+              dash_() {}
+
+        stroke(stroke const& other)
+            : c_(other.c_),
+              width_(other.width_),
+              opacity_(other.opacity_),
+              line_cap_(other.line_cap_),
+              line_join_(other.line_join_),
+              dash_(other.dash_) {}
+	    
+        stroke& operator=(const stroke& rhs)
+        {
+            stroke tmp(rhs);
+            swap(tmp);
+            return *this;
+        }
+
+        void set_color(const Color& c) 
+        {
+            c_=c;
+        }
+	
+        Color const& get_color() const
+        {
+            return c_;
+        }
+	
+        float get_width() const
+        {
+            return width_;
+        }
+        void set_width(float w)
+        {
+            width_=w;
+        }
+
+        void set_opacity(float opacity)
+        {    
+            if (opacity > 1.0) opacity_=1.0;
+            else if (opacity < 0.0) opacity_=0.0;
+            else opacity_=opacity;
+        }
+
+        float get_opacity() const 
+        {
+            return opacity_;
+        }
+	
+        void set_line_cap(line_cap_e line_cap)
+        {
+            line_cap_=line_cap;
+        }
+
+        line_cap_e get_line_cap() const 
+        {
+            return line_cap_;
+        }
+	
+        void set_line_join(line_join_e line_join) 
+        {
+            line_join_=line_join;
+        }
+	
+        line_join_e get_line_join() const 
+        {
+            return line_join_;
+        }
+	
+        void add_dash(float dash,float gap)
+        {
+            dash_.push_back(std::make_pair(dash,gap));
+        }
+        bool has_dash() const 
+        {
+            return dash_.size()>0 ? true : false ;
+        }
+	
+        dash_array const& get_dash_array() const
+        {
+            return  dash_;
+        }
+	
+    private:
+        void swap(const stroke& other) throw()
+        {
+            c_=other.c_;
+            width_=other.width_;
+            opacity_=other.opacity_;
+            line_cap_=other.line_cap_;
+            line_join_=other.line_join_;
+            dash_ = other.dash_;
+        }
+    };
+}
+
+#endif //STROKE_HPP

Copied: trunk/include/mapnik/style.hpp (from rev 307, trunk/include/style.hpp)
===================================================================
--- trunk/include/style.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/style.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,38 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id: style.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef STYLE_HPP
+#define STYLE_HPP
+// stl
+#include <vector>
+#include <algorithm>
+#include <functional>
+// boost
+#include <boost/shared_ptr.hpp>
+// mapnik
+#include <mapnik/color.hpp>
+#include <mapnik/symbolizer.hpp>
+
+namespace mapnik { }
+
+#endif //STYLE_HPP

Copied: trunk/include/mapnik/style_factory.hpp (from rev 307, trunk/include/style_factory.hpp)
===================================================================
--- trunk/include/style_factory.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/style_factory.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,37 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id: style_factory.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef STYLE_FACTORY_HPP
+#define STYLE_FACTORY_HPP
+
+//#include <mapnik/style.hpp>
+
+namespace mapnik {
+    
+    class style_factory 
+    {
+    };
+}
+
+
+#endif //STYLE_FACTORY_HPP

Copied: trunk/include/mapnik/symbolizer.hpp (from rev 307, trunk/include/symbolizer.hpp)

Copied: trunk/include/mapnik/text_symbolizer.hpp (from rev 307, trunk/include/text_symbolizer.hpp)
===================================================================
--- trunk/include/text_symbolizer.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/text_symbolizer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,69 @@
+/* This file is part of Mapnik (c++ mapping toolkit)
+ * Copyright (C) 2005 Artem Pavlenko
+ *
+ * Mapnik is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+//$Id$
+
+#ifndef TEXT_SYMBOLIZER_HPP
+#define TEXT_SYMBOLIZER_HPP
+// stl
+#include <string>
+// boost
+#include <boost/tuple/tuple.hpp>
+// mapnik
+#include <mapnik/color.hpp>
+
+namespace mapnik
+{
+    enum label_placement_e {
+        point_placement=1,
+        line_placement=2
+    };
+        
+    typedef boost::tuple<double,double> position;
+    
+    struct MAPNIK_DECL text_symbolizer
+    {		
+        text_symbolizer(std::string const& name,unsigned size,Color const& fill);	
+        text_symbolizer(text_symbolizer const& rhs);
+        text_symbolizer& operator=(text_symbolizer const& rhs);
+        std::string const& get_name() const;
+        unsigned get_text_size() const;
+        Color const& get_fill() const;
+        void set_halo_fill(Color const& fill);
+        Color const& get_halo_fill() const;
+        void set_halo_radius(unsigned radius);
+        unsigned get_halo_radius() const;
+        void set_label_placement(label_placement_e label_p);
+        label_placement_e get_label_placement() const;
+        void set_anchor(double x, double y);	
+        position const& get_anchor() const;	
+        void set_displacement(double x, double y);
+        position const& get_displacement() const;
+    private:
+        std::string name_;
+        unsigned size_;
+        Color fill_;
+        Color halo_fill_;
+        unsigned halo_radius_;
+        label_placement_e label_p_;
+        position anchor_;
+        position displacement_;
+    };
+}
+
+#endif //TEXT_SYMBOLIZER_HPP

Copied: trunk/include/mapnik/utils.hpp (from rev 307, trunk/include/utils.hpp)
===================================================================
--- trunk/include/utils.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/utils.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,222 @@
+/* This file is part of Mapnik (c++ mapping toolkit)
+ * Copyright (C) 2005 Artem Pavlenko
+ *
+ * Mapnik is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+//$Id: utils.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef UTILS_HPP
+#define UTILS_HPP
+// stl
+#include <stdexcept>
+#include <limits>
+#include <ctime>
+#include <sstream>
+#include <iostream>
+#include <algorithm>
+#include <cmath>
+// boost
+#include <boost/thread/mutex.hpp>
+
+namespace mapnik
+{
+    using boost::mutex;
+    
+    template <typename T>
+    class CreateUsingNew
+    {
+    public:
+        static T* create()
+        {
+            return new T;
+        }
+        static void destroy(T* obj)
+        {
+            delete obj;
+        }
+    };
+
+    template <typename T>
+    class CreateStatic
+    {
+    private:
+        union MaxAlign
+        {
+            char t_[sizeof(T)];
+            short int shortInt_;
+            int int_;
+            long int longInt_;
+            float float_;
+            double double_;
+            long double longDouble_;
+            struct Test;
+            int Test::* pMember_;
+            int (Test::*pMemberFn_)(int);
+        };
+    public:
+        static T* create()
+        {
+            static MaxAlign staticMemory;
+            return new(&staticMemory) T;
+        }
+        static void destroy(volatile T* obj)
+        {
+            obj->~T();
+        }
+    };
+
+    template <typename T,
+              template <typename T> class CreatePolicy=CreateStatic> class singleton
+              {
+                  friend class CreatePolicy<T>;
+                  static T* pInstance_;
+                  static bool destroyed_;
+                  singleton(const singleton &rhs);
+                  singleton& operator=(const singleton&);
+                  static void onDeadReference()
+                  {
+                      throw std::runtime_error("dead reference!");
+                  }
+              protected:
+                  static mutex mutex_;
+                  singleton() {}
+                  virtual ~singleton()
+                  {
+                      CreatePolicy<T>::destroy(pInstance_);
+                      destroyed_=true;
+                  }
+              public:
+                  static  T* instance()
+                  {
+                      if (!pInstance_)
+                      {
+                          mutex::scoped_lock lock(mutex_);
+                          if (!pInstance_)
+                          {
+                              if (destroyed_)
+                              {
+                                  onDeadReference();
+                              }
+                              else
+                              {
+                                  pInstance_=CreatePolicy<T>::create();
+                              }
+                          }
+                      }
+                      return pInstance_;
+                  }
+              };
+
+    template <typename T,
+              template <typename T> class CreatePolicy> mutex singleton<T,CreatePolicy>::mutex_;
+    template <typename T,
+              template <typename T> class CreatePolicy> T* singleton<T,CreatePolicy>::pInstance_=0;
+    template <typename T,
+              template <typename T> class CreatePolicy> bool singleton<T,CreatePolicy>::destroyed_=false;
+
+    template <class T> class Handle
+    {
+        T* ptr_;
+        int* pCount_;
+    public:
+        T* operator->() {return ptr_;}
+        const T* operator->() const {return ptr_;}
+        Handle(T* ptr)
+            :ptr_(ptr),pCount_(new int(1)) {}
+        Handle(const Handle& rhs)
+            :ptr_(rhs.ptr_),pCount_(rhs.pCount_)
+        {
+            (*pCount_)++;
+        }
+        Handle& operator=(const Handle& rhs)
+        {
+            if (ptr_==rhs.ptr_) return *this;
+            if (--(*pCount_)==0)
+            {
+                delete ptr_;
+                delete pCount_;
+            }
+            ptr_=rhs.ptr_;
+            pCount_=rhs.pCount_;
+            (*pCount_)++;
+            return *this;
+        }
+        ~Handle()
+        {
+            if (--(*pCount_)==0)
+            {
+                delete ptr_;
+                delete pCount_;
+            }
+        }
+    };
+
+
+    struct timer
+    {
+        //struct timeval tv_;
+        timer()
+        {
+            //gettimeofday (&tv_,0);
+        }
+        void start()
+        {
+            //gettimeofday (&tv_,0);
+        }
+        void stop()
+        {
+            //timeval tv;
+            //gettimeofday (&tv,0);
+            //std::ostringstream s;
+            //long sec=1000*(tv.tv_sec-tv_.tv_sec);
+            //long total_ms=sec+static_cast<long>(0.001*(tv.tv_usec-tv_.tv_usec));
+            //s << "elapsed time is "<<total_ms<<" ms";
+            //std::clog<<s.str()<<std::endl;
+        }
+    };
+    
+    //converters
+    class BadConversion : public std::runtime_error
+    {
+    public:
+        BadConversion(const std::string& s)
+            :std::runtime_error(s)
+        {}
+    };
+    
+    template <typename T>
+    inline std::string toString(const T& x)
+    {
+        std::ostringstream o;
+        if (!(o << x))
+            throw BadConversion(std::string("toString(")
+                                + typeid(x).name() + ")");
+        return o.str();
+    }
+    
+    template<typename T>
+    inline void fromString(const std::string& s, T& x,
+                           bool failIfLeftoverChars = true)
+    {
+        std::istringstream i(s);
+        char c;
+        if (!(i >> x) || (failIfLeftoverChars && i.get(c)))
+            throw BadConversion("fromString("+s+")");
+    }
+}
+
+
+#endif //UTILS_HPP

Copied: trunk/include/mapnik/value.hpp (from rev 307, trunk/include/value.hpp)
===================================================================
--- trunk/include/value.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/value.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,452 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id$
+
+#ifndef VALUE_HPP
+#define VALUE_HPP
+
+// stl
+#include <iostream>
+#include <string>
+#include <sstream>
+
+// boost
+#include <boost/variant.hpp>
+
+namespace mapnik  {
+    typedef boost::variant<int,double,std::string> value_base;
+    
+    namespace impl {
+        struct equals
+            : public boost::static_visitor<bool>
+        {
+            template <typename T, typename U>
+            bool operator() (const T &, const U & ) const
+            {
+                return false;
+            }
+	
+            template <typename T>
+            bool operator() (T lhs, T rhs) const
+            {
+                return lhs == rhs;
+            }
+	
+            bool operator() (int lhs, double rhs) const
+            {
+                return  lhs == rhs;
+            }
+	
+            bool operator() (double lhs, int rhs) const
+            {
+                return  lhs == rhs;
+            }
+	
+            bool operator() (std::string const& lhs, 
+                             std::string const& rhs) const
+            {
+                return  lhs == rhs;
+            }
+        };
+    
+        struct greater_than
+            : public boost::static_visitor<bool>
+        {
+            template <typename T, typename U>
+            bool operator()( const T &, const U & ) const
+            {
+                return false;
+            }
+	
+            template <typename T>
+            bool operator()( T lhs, T rhs ) const
+            {
+                return lhs > rhs;
+            }
+	
+            bool operator() (int lhs, double rhs) const
+            {
+                return  lhs > rhs;
+            }
+	
+            bool operator() (double lhs, int rhs) const
+            {
+                return  lhs > rhs;
+            }
+	
+            bool operator() (std::string const& lhs, std::string const& rhs) const
+            {
+                return  lhs > rhs;
+            }
+        };
+    
+        struct greater_or_equal
+            : public boost::static_visitor<bool>
+        {	
+            template <typename T, typename U>
+            bool operator()( const T &, const U & ) const
+            {
+                return false;
+            }
+	
+            template <typename T>
+            bool operator() (T lhs, T rhs) const
+            {
+                return lhs >= rhs;
+            }
+      
+            bool operator() (int lhs, double rhs) const
+            {
+                return  lhs >= rhs;
+            }
+	
+            bool operator() (double lhs, int rhs) const
+            {
+                return  lhs >= rhs;
+            }
+	
+            bool operator() (std::string const& lhs, std::string const& rhs ) const
+            {
+                return lhs >= rhs;
+            }
+        };
+    
+        struct less_than
+            : public boost::static_visitor<bool>
+        {	
+            template <typename T, typename U>
+            bool operator()( const T &, const U & ) const
+            {
+                return false;
+            }
+	
+            template <typename T>
+            bool operator()( T  lhs,T  rhs) const
+            {
+                return lhs < rhs;
+            }
+	
+            bool operator() (int lhs, double rhs) const
+            {
+                return  lhs < rhs;
+            }
+	   
+            bool operator() (double lhs, int rhs) const
+            {
+                return  lhs < rhs;
+            }
+	
+            bool operator()( std::string const& lhs, 
+                             std::string const& rhs ) const
+            {
+                return lhs < rhs;
+            }
+        };
+
+        struct less_or_equal
+            : public boost::static_visitor<bool>
+        {	
+            template <typename T, typename U>
+            bool operator()( const T &, const U & ) const
+            {
+                return false;
+            }
+	
+            template <typename T>
+            bool operator()(T lhs, T rhs ) const
+            {
+                return lhs <= rhs;
+            }
+	    
+            bool operator() (int lhs, double rhs) const
+            {
+                return  lhs <= rhs;
+            }
+	
+            bool operator() (double lhs, int rhs) const
+            {
+                return  lhs <= rhs;
+            }
+	
+            template <typename T>
+            bool operator()( std::string const& lhs, 
+                             std::string const& rhs ) const
+            {
+                return lhs <= rhs;
+            }
+        };
+    
+        template <typename V>
+        struct add : public boost::static_visitor<V>
+        { 
+            typedef V value_type;
+            template <typename T1, typename T2>
+            value_type operator() (T1 const& lhs, T2 const&) const
+            {
+                return lhs;
+            }
+            template <typename T>
+            value_type operator() (T lhs, T rhs) const
+            {
+                return lhs + rhs ;
+            }
+	
+            value_type operator() (std::string const& lhs , 
+                                   std::string const& rhs ) const
+            {
+                return lhs + rhs;
+            }
+	
+            value_type operator() (double lhs, int rhs) const
+            {
+                return lhs + rhs;
+            }
+	
+            value_type operator() (int lhs, double rhs) const
+            {
+                return lhs + rhs;
+            }
+        };
+        template <typename V>
+        struct sub : public boost::static_visitor<V>
+        { 
+            typedef V value_type;
+            template <typename T1, typename T2>
+            value_type operator() (T1 const& lhs, T2 const&) const
+            {
+                return lhs;
+            }
+
+            template <typename T>
+            value_type operator() (T  lhs, T rhs) const
+            {
+                return lhs - rhs ;
+            }
+
+            value_type operator() (std::string const& lhs,
+                                   std::string const& ) const
+            {
+                return lhs;
+            }
+        	
+            value_type operator() (double lhs, int rhs) const
+            {
+                return lhs - rhs;
+            }
+	
+            value_type operator() (int lhs, double rhs) const
+            {
+                return lhs - rhs;
+            }
+        };
+    
+        template <typename V>
+        struct mult : public boost::static_visitor<V>
+        { 
+            typedef V value_type;
+            template <typename T1, typename T2>
+            value_type operator() (T1 const& lhs , T2 const& ) const
+            {
+                return lhs;
+            }
+            template <typename T>
+            value_type operator() (T lhs, T rhs) const
+            {
+                return lhs * rhs;
+            }
+	
+            value_type operator() (std::string const& lhs,
+                                   std::string const& ) const
+            {
+                return lhs;
+            }	
+	
+            value_type operator() (double lhs, int rhs) const
+            {
+                return lhs * rhs;
+            }
+	
+            value_type operator() (int lhs, double rhs) const
+            {
+                return lhs * rhs;
+            }
+        };
+
+        template <typename V>
+        struct div: public boost::static_visitor<V>
+        { 
+            typedef V value_type;
+            template <typename T1, typename T2>
+            value_type operator() (T1 const& lhs, T2 const&) const
+            {
+                return lhs;
+            }
+	    
+            template <typename T>
+            value_type operator() (T lhs, T rhs) const
+            {
+                return lhs / rhs;
+            }
+	
+            value_type operator() (std::string const& lhs,
+                                   std::string const&) const
+            {
+                return lhs;
+            }
+	
+            value_type operator() (double lhs, int rhs) const
+            {
+                return lhs / rhs;
+            }
+	
+            value_type operator() (int lhs, double rhs) const
+            {
+                return lhs / rhs;
+            }
+        };
+    
+        struct to_string : public boost::static_visitor<std::string>
+        {
+            template <typename T>
+            std::string operator() (T val) const
+            {
+                std::stringstream ss;
+                ss << val;
+                return ss.str();
+            } 
+            std::string const& operator() (std::string const& val) const
+            {
+                return val;
+            }
+        };
+	
+        struct to_expression_string : public boost::static_visitor<std::string>
+        {
+            template <typename T>
+            std::string operator() (T val) const
+            {
+                std::stringstream ss;
+                ss << val;
+                return ss.str();
+            } 
+            std::string operator() (std::string const& val) const
+            {
+                return "'" + val + "'";
+            }
+        };
+    }
+    
+    class value
+    {
+        value_base base_;
+        friend const value operator+(value const&,value const&);
+        friend const value operator-(value const&,value const&);
+        friend const value operator*(value const&,value const&);
+        friend const value operator/(value const&,value const&);
+        
+    public:
+        value ()
+            : base_(0) {}
+	
+        template <typename T> value(T _val_)
+            : base_(_val_) {}
+
+        bool operator==(value const& other) const
+        {
+            return boost::apply_visitor(impl::equals(),base_,other.base_);
+        }
+
+        bool operator!=(value const& other) const
+        {
+            return !(boost::apply_visitor(impl::equals(),base_,other.base_));
+        }
+	
+        bool operator>(value const& other) const
+        {
+            return boost::apply_visitor(impl::greater_than(),base_,other.base_);
+        }
+
+        bool operator>=(value const& other) const
+        {
+            return boost::apply_visitor(impl::greater_or_equal(),base_,other.base_);
+        }
+
+        bool operator<(value const& other) const
+        {
+            return boost::apply_visitor(impl::less_than(),base_,other.base_);
+        }
+
+        bool operator<=(value const& other) const
+        {
+            return boost::apply_visitor(impl::less_or_equal(),base_,other.base_);
+        }
+        value_base const& base() const
+        {
+            return base_;
+        }
+
+        std::string to_expression_string() const
+        {
+            return boost::apply_visitor(impl::to_expression_string(),base_);
+        }
+
+        std::string to_string() const
+        {
+            return boost::apply_visitor(impl::to_string(),base_);
+        }
+    };
+    
+    inline const value operator+(value const& p1,value const& p2)
+    {
+
+        return value(boost::apply_visitor(impl::add<value>(),p1.base_, p2.base_));
+    }
+
+    inline const value operator-(value const& p1,value const& p2)
+    {
+
+        return value(boost::apply_visitor(impl::sub<value>(),p1.base_, p2.base_));
+    }
+
+    inline const value operator*(value const& p1,value const& p2)
+    {
+
+        return value(boost::apply_visitor(impl::mult<value>(),p1.base_, p2.base_));
+    }
+
+    inline const value operator/(value const& p1,value const& p2)
+    {
+
+        return value(boost::apply_visitor(impl::div<value>(),p1.base_, p2.base_));
+    }
+
+    template <typename charT, typename traits>
+    inline std::basic_ostream<charT,traits>& 
+    operator << (std::basic_ostream<charT,traits>& out,
+                 value const& v)
+    {
+    	out << v.base();
+    	return out; 
+    }
+}
+
+#endif //VALUE_HPP

Copied: trunk/include/mapnik/vertex.hpp (from rev 307, trunk/include/vertex.hpp)
===================================================================
--- trunk/include/vertex.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/vertex.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,112 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id: vertex.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef VERTEX_HPP
+#define VERTEX_HPP
+
+#include <iostream>
+#include <sstream>
+
+namespace mapnik 
+{
+    enum {
+        SEG_END   =0,
+        SEG_MOVETO=1,
+        SEG_LINETO=2,
+        SEG_CLOSE =3
+    };
+    
+    template <typename T,int dim>
+    struct vertex {
+        typedef T type;
+    };
+    
+    template <typename T>
+    struct vertex<T,2> 
+    {
+        typedef T type;
+        T x;
+        T y;
+        unsigned cmd;
+        vertex() 
+            : x(0),y(0),cmd(SEG_END) {}
+        vertex(T x,T y,unsigned cmd)
+            : x(x),y(y),cmd(cmd) {}
+
+        template <typename T2>
+        vertex(const vertex<T2,2>& rhs)
+            : x(type(rhs.x)),
+              y(type(rhs.y)),
+              cmd(rhs.cmd) {}
+	
+        template <typename T2> vertex<T,2> operator=(const vertex<T2,2>& rhs)
+        {
+            if ((void*)this == (void*)&rhs)
+            {
+                return *this;
+            }
+            x=type(rhs.x);
+            y=type(rhs.y);
+            cmd=rhs.cmd;
+            return *this;
+        }	
+    };
+    
+    typedef vertex<double,2> vertex2d;
+    typedef vertex<int,2> vertex2i;
+
+    
+    template <class charT,class traits,class T,int dim>
+    inline std::basic_ostream<charT,traits>&
+    operator << (std::basic_ostream<charT,traits>& out,
+                 const vertex<T,dim>& c);
+
+    template <class charT,class traits,class T>
+    inline std::basic_ostream<charT,traits>&
+    operator << (std::basic_ostream<charT,traits>& out,
+                 const vertex<T,2>& v)
+    {
+        std::basic_ostringstream<charT,traits> s;
+        s.copyfmt(out);
+        s.width(0);
+        s<<"vertex2("<<v.x<<","<<v.y<<",cmd="<<v.cmd<<" )";
+        out << s.str();
+        return out;
+    }
+
+    template <class charT,class traits,class T>
+    inline std::basic_ostream<charT,traits>&
+    operator << (std::basic_ostream<charT,traits>& out,
+                 const vertex<T,3>& v)
+    {
+        std::basic_ostringstream<charT,traits> s;
+        s.copyfmt(out);
+        s.width(0);
+        s<<"vertex3("<<v.x<<","<<v.y<<","<<v.z<<",cmd="<<v.cmd<<")";
+        out << s.str();
+        return out;
+    } 
+
+}
+
+#endif // VERTEX_HPP

Copied: trunk/include/mapnik/vertex_transform.hpp (from rev 307, trunk/include/vertex_transform.hpp)
===================================================================
--- trunk/include/vertex_transform.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/vertex_transform.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,93 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id: vertex_transform.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef VERTEX_TRANSFORM_HPP
+#define VERTEX_TRANSFORM_HPP
+
+// mapnik
+#include <mapnik/envelope.hpp>
+#include <mapnik/vertex.hpp>
+
+namespace mapnik
+{
+    template <typename T0 ,typename T1,int shift=8>
+    struct Shift
+    {
+	typedef T0 value_type;
+	typedef T1 return_type;
+	static return_type apply(value_type val)
+	{
+	    return static_cast<return_type>(val*(1<<shift));
+	}
+    };
+
+    template <typename T0,typename T1>
+    struct Shift<T0,T1,0> 
+    {
+	typedef T0 value_type;
+	typedef T1 return_type;
+	static return_type apply(value_type val)
+	{
+	    return static_cast<return_type>(val);
+	}
+    };
+
+    template <typename T>
+    struct Shift<T,T,0>
+    {
+	typedef T value_type;
+	typedef T return_type;
+	static T& apply(T& val)
+	{
+	    return val;
+	}
+    };
+
+    typedef Shift<double,double,0> NO_SHIFT;
+    typedef Shift<double,int,0> SHIFT0;
+    typedef Shift<double,int,8> SHIFT8;
+    
+    
+    template <typename T0,typename T1,typename Trans>
+    struct view_transform;
+    
+    template <typename Trans>
+    struct view_transform <vertex2d,vertex2d,Trans>   
+    {
+	
+    };
+    
+    template <typename Trans>
+    struct view_transform <vertex2d,vertex2i,Trans>   
+    {
+	
+    };
+
+    template <typename Trans>
+    struct view_transform<Envelope<double>,Envelope<double>,Trans>
+    {
+	
+    };
+}
+
+#endif //VERTEX_TRANSFORM_HPP

Copied: trunk/include/mapnik/vertex_vector.hpp (from rev 307, trunk/include/vertex_vector.hpp)
===================================================================
--- trunk/include/vertex_vector.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/vertex_vector.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,200 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//  Credits:
+//  I gratefully acknowledge the inspiring work of Maxim Shemanarev (McSeem), 
+//  author of Anti-Grain Geometry (http://www.antigrain.com). I have used 
+//  the datastructure from AGG as a template for my own. 
+
+
+//$Id: vertex_vector.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef VERTEX_VECTOR_HPP
+#define VERTEX_VECTOT_HPP
+// stl
+#include <vector>
+// boost
+#include <boost/utility.hpp>
+#include <boost/tuple/tuple.hpp>
+// mapnik
+#include <mapnik/vertex.hpp>
+#include <mapnik/ctrans.hpp>
+
+namespace mapnik
+{
+    template <typename T>
+    class vertex_vector : private boost::noncopyable
+    {
+        typedef typename T::type value_type;
+        typedef vertex<value_type,2> vertex_type;
+        enum {
+            block_shift = 8,
+            block_size  = 1<<block_shift,
+            block_mask  = block_size - 1,
+            grow_by     = 256
+        };
+
+    private:
+        unsigned num_blocks_;
+        unsigned max_blocks_;
+        value_type** vertexs_;
+        unsigned char** commands_;
+        unsigned pos_;
+    public:
+	
+        vertex_vector() 
+            : num_blocks_(0),
+              max_blocks_(0),
+              vertexs_(0),
+              commands_(0),
+              pos_(0) {}
+
+        ~vertex_vector()
+        {
+            if ( num_blocks_ )
+            {
+                value_type** vertexs=vertexs_ + num_blocks_ - 1;
+                while ( num_blocks_-- )
+                {
+                    delete [] *vertexs;
+                    --vertexs;
+                }
+                delete [] vertexs_;
+            }
+        }
+        unsigned size() const 
+        {
+            return pos_;
+        }
+	
+        void push_back (value_type x,value_type y,unsigned command)
+        {
+            unsigned block = pos_ >> block_shift;
+            if (block >= num_blocks_)
+            {
+                allocate_block(block);
+            }
+            value_type* vertex = vertexs_[block] + ((pos_ & block_mask) << 1);
+            unsigned char* cmd= commands_[block] + (pos_ & block_mask);
+	    
+            *cmd = static_cast<unsigned char>(command);
+            *vertex++ = x;
+            *vertex   = y;
+            ++pos_;
+        }
+        unsigned get_vertex(unsigned pos,value_type* x,value_type* y) const
+        {
+            if (pos >= pos_) return SEG_END;
+            unsigned block = pos >> block_shift;
+            const value_type* vertex = vertexs_[block] + (( pos & block_mask) << 1);
+            *x = (*vertex++);
+            *y = (*vertex);
+            return commands_[block] [pos & block_mask];
+        }
+        	
+        void transform_at(unsigned pos,const CoordTransform& t)
+        {
+            if (pos >= pos_) return;
+            unsigned block = pos >> block_shift;
+            value_type* vertex = vertexs_[block] + (( pos & block_mask) << 1);
+            t.forward_x(vertex);
+            ++vertex;
+            t.forward_y(vertex);
+        }
+        void set_capacity(size_t)
+        {
+            //do nothing
+        }
+    private:
+        void allocate_block(unsigned block)
+        {
+            if (block >= max_blocks_)
+            {
+                value_type** new_vertexs = new value_type* [(max_blocks_ + grow_by) * 2];
+                unsigned char** new_commands = (unsigned char**)(new_vertexs + max_blocks_ + grow_by);
+                if (vertexs_)
+                {
+                    std::memcpy(new_vertexs,vertexs_,max_blocks_ * sizeof(value_type*));
+                    std::memcpy(new_commands,commands_,max_blocks_ * sizeof(unsigned char*));
+                    delete [] vertexs_;
+                }
+                vertexs_ = new_vertexs;
+                commands_ = new_commands;
+                max_blocks_ += grow_by;
+            }
+            vertexs_[block] = new value_type [block_size * 2 + block_size / (sizeof(value_type))];
+            commands_[block] = (unsigned char*)(vertexs_[block] + block_size*2);
+            ++num_blocks_;
+        }
+    };
+
+    template <typename T>
+    struct vertex_vector2 : boost::noncopyable
+    {
+        typedef typename T::type value_type;
+        typedef boost::tuple<value_type,value_type,char> vertex_type;
+        typedef typename std::vector<vertex_type>::const_iterator const_iterator;
+        vertex_vector2() {}
+        unsigned size() const 
+        {
+            return cont_.size();
+        }
+
+        void push_back (value_type x,value_type y,unsigned command)
+        {
+            cont_.push_back(vertex_type(x,y,command));
+        }
+        unsigned get_vertex(unsigned pos,value_type* x,value_type* y) const
+        {
+            if (pos >= cont_.size()) return SEG_END;
+            vertex_type const& c = cont_[pos];
+            *x = boost::get<0>(c);
+            *y = boost::get<1>(c);
+            return boost::get<2>(c);
+        }
+        
+        const_iterator begin() const
+        {
+            return cont_.begin();
+        }
+        
+        const_iterator end() const
+        {
+            return cont_.end();
+        }
+
+        void transform_at(unsigned pos,const CoordTransform& t)
+        {
+            if (pos >= cont_.size()) return;
+            vertex_type & c = cont_[pos];
+            t.forward_x(&boost::get<0>(c));
+            t.forward_y(&boost::get<1>(c));
+        }
+        void set_capacity(size_t size)
+        {
+            cont_.reserve(size);
+        }
+    private:
+        std::vector<vertex_type> cont_;
+    };
+}
+
+#endif //VERTEX_VECTOR_HPP

Copied: trunk/include/mapnik/wkb.hpp (from rev 307, trunk/include/wkb.hpp)
===================================================================
--- trunk/include/wkb.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/wkb.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,43 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: wkb.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef WKB_HPP
+#define WKB_HPP
+
+#include <mapnik/geometry.hpp>
+#include <mapnik/ctrans.hpp>
+
+namespace mapnik
+{
+    class MAPNIK_DECL geometry_utils 
+    {
+    public:
+        static geometry_ptr from_wkb(const char* wkb, unsigned size,int srid);
+    private:
+        geometry_utils();
+        geometry_utils(const geometry_utils&);
+        geometry_utils& operator=(const geometry_utils&);
+    };
+}
+#endif                                            //WKB_HPP

Deleted: trunk/include/math_expr.hpp
===================================================================
--- trunk/include/math_expr.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/math_expr.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,128 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id$
-
-#ifndef MATH_EXPR_HPP
-#define MATH_EXPR_HPP
-
-#include "expression.hpp"
-
-namespace mapnik
-{
-    template <typename T>
-    struct add
-    {
-        T operator () (T const& left, T const& right)
-        {
-            return left + right;
-        }
-        static std::string to_string()
-        {
-            return "+";
-        } 
-    };
-
-    template <typename T>
-    struct sub
-    {
-        T operator () (T const& left, T const& right)
-        {
-            return left - right;
-        }
-        static std::string to_string()
-        {
-            return "-";
-        } 
-    };
-    
-    template <typename T>
-    struct mult
-    {
-        T operator () (T const& left, T const& right)
-        {
-            return left * right;
-        }
-        static std::string to_string()
-        {
-            return "*";
-        } 
-    };
-    
-    template <typename T>
-    struct div
-    {
-        T operator () (T const& left, T const& right)
-        {
-            return left / right;
-        }
-        static std::string to_string()
-        {
-            return "/";
-        } 
-    };
-    
-    template <typename FeatureT,typename Op>
-    struct math_expr_b : public expression<FeatureT>
-    {
-        math_expr_b(expression<FeatureT> const& left,
-                    expression<FeatureT> const& right)
-            : expression<FeatureT>(),
-              left_(left.clone()), 
-              right_(right.clone()) {}
-        math_expr_b(math_expr_b const& other)
-            : expression<FeatureT>(),
-              left_(other.left_->clone()),
-              right_(other.right_->clone()) {}
-
-        value get_value(FeatureT const& feature) const
-        {
-            return Op ()(left_->get_value(feature),right_->get_value(feature));
-        }
-
-        void accept(filter_visitor<FeatureT>& v)
-        {
-            left_->accept(v);
-            right_->accept(v);
-            v.visit(*this);
-        }
-
-        expression<FeatureT>* clone() const
-        {
-            return new math_expr_b<FeatureT,Op>(*this);
-        }
-        std::string to_string() const
-        {
-            return "("+left_->to_string() + Op::to_string() + right_->to_string()+")";
-        }
-
-        ~math_expr_b() 
-        {
-            delete left_;
-            delete right_;
-        }
-    private:
-        expression<FeatureT>* left_;
-        expression<FeatureT>* right_;	
-    }; 
-}
-
-#endif //

Deleted: trunk/include/memory.hpp
===================================================================
--- trunk/include/memory.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/memory.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,88 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id: memory.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef MEMORY_HPP
-#define MEMORY_HPP
-
-#include <iostream>
-#include <cassert>
-
-namespace mapnik
-{
-    class MemoryUtils
-    {
-    public:
-	static size_t alignPointerSize(size_t ptrSize);
-    private:
-	MemoryUtils();
-	MemoryUtils(const MemoryUtils&);
-	MemoryUtils& operator=(const MemoryUtils&);
-    };
-
-    class MemoryManager
-    {
-    public:
-	virtual void* allocate(size_t size)=0;
-	virtual void deallocate(void* p)=0;
-	virtual ~MemoryManager();
-    protected:
-	MemoryManager();                      // {}
-    private:
-	MemoryManager(const MemoryManager&);
-	MemoryManager& operator=(const MemoryManager&);
-    };
-
-    class Object
-    {
-    public:
-	void* operator new(size_t size);
-	void* operator new(size_t size, MemoryManager* manager);
-	void operator delete(void* p);
-	void operator delete(void* p, MemoryManager* manager);
-    protected:
-	virtual ~Object() {}
-	Object() {}
-	Object(const Object&) {}
-    protected:
-	Object& operator=(const Object&)
-	{
-	    return *this;
-	}
-    };
-
-    template <typename Geometry>
-    class geometry_pool
-    {
-    public:
-	void* allocate()
-	{
-	    return ::operator new(sizeof(Geometry));
-	}
-	void deallocate(void* p)
-	{
-	    ::operator delete(p);
-	}
-    };
-
-}
-#endif                                            //MEMORY_HPP

Deleted: trunk/include/params.hpp
===================================================================
--- trunk/include/params.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/params.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,53 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id: params.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef PARAMS_HPP
-#define PARAMS_HPP
-
-#include <string>
-#include <map>
-
-namespace mapnik
-{
-
-    typedef std::pair<const std::string,std::string> parameter;
-    typedef std::map<const std::string,std::string> param_map;
-
-    class parameters : public param_map
-    {
-     public:
-
-        parameters() {}
-        const std::string get(std::string const& key) const
-        {
-            param_map::const_iterator itr=find(key);
-            if (itr != end())
-            {
-                return itr->second;
-            }
-            return std::string();
-        }
-    };
-}
-
-#endif //PARAMS_HPP

Deleted: trunk/include/plugin.hpp
===================================================================
--- trunk/include/plugin.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/plugin.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,48 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: plugin.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef PLUGIN_HPP
-#define PLUGIN_HPP
-
-#include <ltdl.h>
-#include <string>
-#include <boost/utility.hpp>
-
-namespace mapnik
-{
-    class PluginInfo : boost::noncopyable
-    {
-    private:
-	std::string name_;
-	lt_dlhandle module_;
-	
-    public:
-	PluginInfo (const std::string& name,const lt_dlhandle module);
-	~PluginInfo();
-	const std::string& name() const;
-	lt_dlhandle handle() const;
-    };
-}
-
-#endif //PLUGIN_HPP

Deleted: trunk/include/point_symbolizer.hpp
===================================================================
--- trunk/include/point_symbolizer.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/point_symbolizer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,50 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id: image_symbolizer.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef POINT_SYMBOLIZER_HPP
-#define POINT_SYMBOLIZER_HPP
-
-#include <boost/shared_ptr.hpp>
-#include "graphics.hpp" 
-
-namespace mapnik 
-{   
-    struct MAPNIK_DECL point_symbolizer
-    {	
-        explicit point_symbolizer();
-        point_symbolizer(std::string const& file,
-                         std::string const& type,
-                         unsigned width,unsigned height);
-        point_symbolizer(point_symbolizer const& rhs);
-        void set_data (boost::shared_ptr<ImageData32> symbol);
-        boost::shared_ptr<ImageData32> const& get_data() const;        
-        void set_allow_overlap(bool overlap);
-        bool get_allow_overlap() const;
-        
-    private:
-        boost::shared_ptr<ImageData32> symbol_;
-        bool overlap_;
-    };
-}
-
-#endif // POINT_SYMBOLIZER_HPP

Deleted: trunk/include/polygon_pattern_symbolizer.hpp
===================================================================
--- trunk/include/polygon_pattern_symbolizer.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/polygon_pattern_symbolizer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,47 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id$
-
-#ifndef POLYGON_PATTERN_SYMBOLIZER_HPP
-#define POLYGON_PATTERN_SYMBOLIZER_HPP
-
-#include <boost/shared_ptr.hpp>
-#include "graphics.hpp" 
-
-namespace mapnik
-{
-    struct MAPNIK_DECL polygon_pattern_symbolizer
-    {
-	
-	polygon_pattern_symbolizer(std::string const& file,
-				   std::string const& type,
-				   unsigned width,unsigned height);
-        
-	polygon_pattern_symbolizer(polygon_pattern_symbolizer const& rhs);
-        
-	ImageData32 const& get_pattern() const;
-    private:
-	boost::shared_ptr<ImageData32> pattern_;
-    };
-}
-
-#endif //POLYGON_PATTERN_SYMBOLIZER_HPP

Deleted: trunk/include/polygon_symbolizer.hpp
===================================================================
--- trunk/include/polygon_symbolizer.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/polygon_symbolizer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,64 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: polygon_symbolizer.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef POLYGON_SYMBOLIZER_HPP
-#define POLYGON_SYMBOLIZER_HPP
-
-#include "color.hpp"
-
-namespace mapnik 
-{
-    struct MAPNIK_DECL polygon_symbolizer
-    {
-        explicit polygon_symbolizer() 
-            : fill_(Color(128,128,128)),
-              opacity_(1.0) {}
-
-        polygon_symbolizer(Color const& fill)
-            : fill_(fill),
-              opacity_(1.0) {}
-        
-        Color const& get_fill() const
-        {
-            return fill_;
-        }
-        void set_fill(Color const& fill)
-        {
-            fill_ = fill;
-        }
-        void set_opacity(float opacity)
-        {
-            opacity_ = opacity;
-        }
-        float get_opacity() const
-        {
-            return opacity_;
-        }
-    private:
-        Color fill_;
-        float opacity_;
-    };  
-}
-
-#endif // POLYGON_SYMBOLIZER_HPP

Deleted: trunk/include/pool.hpp
===================================================================
--- trunk/include/pool.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/pool.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,119 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: pool.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef POOL_HPP
-#define POOL_HPP
-
-#include <iostream>
-#include <map>
-#include <deque>
-#include <ctime>
-#include "utils.hpp"
-#include <boost/shared_ptr.hpp>
-#include <boost/thread/mutex.hpp>
-#include <boost/utility.hpp>
-
-namespace mapnik
-{
-    template <typename T, typename PoolT>
-    class PoolGuard
-    {
-    private:
-	const T& obj_;
-        PoolT& pool_; 
-    public:
-	explicit PoolGuard(const T& ptr,PoolT& pool)
-	    : obj_(ptr),
-	      pool_(pool) {}
-
-	~PoolGuard() 
-	{
-	    pool_->returnObject(obj_);
-	}
-
-    private:
-	PoolGuard();
-	PoolGuard(const PoolGuard&);
-	PoolGuard& operator=(const PoolGuard&);
-    };
-
-    template <typename T,template <typename> class Creator>
-    class Pool : private boost::noncopyable
-    {
-	typedef boost::shared_ptr<T> HolderType;
-	typedef std::deque<HolderType> ContType;	
-	
-	Creator<T> creator_;
-	const int initialSize_; 
-	const int maxSize_;
-	ContType usedPool_;
-	ContType unusedPool_;
-	boost::mutex mutex_;
-    public:
-
-	Pool(const Creator<T>& creator,int initialSize=5,int maxSize=20)
-	    :creator_(creator),
-	     initialSize_(initialSize),
-	     maxSize_(maxSize)
-	{
-	    for (int i=0;i<initialSize_;++i) 
-	    {
-		unusedPool_.push_back(HolderType(creator_()));
-	    }
-	}
-
-	const HolderType& borrowObject()
-	{	    
-	    mutex::scoped_lock lock(mutex_);
-	    typename ContType::iterator itr=unusedPool_.begin();
-	    if (itr!=unusedPool_.end())
-	    {  
-		std::clog<<"borrow "<<(*itr).get()<<"\n";
-		usedPool_.push_back(*itr);
-		itr=unusedPool_.erase(itr);
-		return usedPool_[usedPool_.size()-1];
-	    }
-	    static const HolderType defaultObj;
-	    return defaultObj;
-	} 
-
-	void returnObject(const HolderType& obj)
-	{
-	    mutex::scoped_lock lock(mutex_);
-	    typename ContType::iterator itr=usedPool_.begin();
-	    while (itr != usedPool_.end())
-	    {
-		if (obj.get()==(*itr).get()) 
-		{
-		    std::clog<<"return "<<(*itr).get()<<"\n";
-		    unusedPool_.push_back(*itr);
-		    usedPool_.erase(itr);
-		    return;
-		}
-		++itr;
-	    }
-	}
-    };
-}
-#endif                                            //POOL_HPP

Deleted: trunk/include/quad_tree.hpp
===================================================================
--- trunk/include/quad_tree.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/quad_tree.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,209 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id$
-
-#if !defined QUAD_TREE_HPP
-#define QUAD_TREE_HPP
-
-#include <boost/ptr_container/ptr_vector.hpp>
-#include <boost/noncopyable.hpp>
-#include <vector>
-#include "envelope.hpp"
-
-
-namespace mapnik
-{
-    template <typename T>
-    class quad_tree : boost::noncopyable
-    {
-        struct node
-        {
-            typedef T value_t;
-            typedef std::vector<T> cont_t;
-            typedef typename cont_t::iterator iterator;
-            typedef typename cont_t::const_iterator const_iterator;
-            Envelope<double> extent_;
-            cont_t cont_;
-            node * children_[4];
-
-            explicit node(Envelope<double> const& ext)
-                : extent_(ext)
-            {
-                std::memset(children_,0,4*sizeof(node*));
-            }
-   
-            Envelope<double> const& extent() const
-            {
-                return extent_;
-            }
-	    
-            iterator begin() 
-            {
-                return cont_.begin();
-            }
-	    
-            const_iterator begin() const 
-            {
-                return cont_.begin();
-            }
-	    
-            iterator end() 
-            {
-                return cont_.end();
-            }
-	    
-            const_iterator end() const 
-            {
-                return cont_.end();
-            }
-            ~node () {}
-        };
-	
-        typedef boost::ptr_vector<node> nodes_t;	
-        typedef typename node::cont_t cont_t;
-        typedef typename cont_t::iterator node_data_iterator;
-	
-        nodes_t nodes_;
-        node * root_;	
-        const double ratio_; 
-	
-    public:
-        typedef typename nodes_t::iterator iterator;
-        typedef typename nodes_t::const_iterator const_iterator;
-        typedef typename boost::ptr_vector<T,boost::view_clone_allocator> result_t;	
-        typedef typename result_t::iterator query_iterator;
-   
-        result_t query_result_;
-	
-        explicit quad_tree(Envelope<double> const& ext,double ratio=0.55) 
-            : ratio_(ratio)
-        {
-            nodes_.push_back(new node(ext));
-            root_ = &nodes_[0];
-        }
-		
-        void insert(T data, Envelope<double> const& box)
-        {
-            do_insert_data(data,box,root_);
-        }
-        
-        query_iterator query_in_box(Envelope<double> const& box)
-        {
-            query_result_.clear();
-            query_node(box,query_result_,root_);
-            return query_result_.begin();
-        }
-	
-        query_iterator query_end()
-        {
-            return query_result_.end();
-        }
-
-        iterator begin()
-        {
-            return nodes_.begin();
-        }
-	
-        const_iterator begin() const
-        {
-            return nodes_.begin();
-        }
-
-        iterator end()
-        {
-            return  nodes_.end();
-        }
-	
-        const_iterator end() const
-        {
-            return  nodes_.end();
-        }
-	
-    private:
-        
-        void query_node(Envelope<double> const& box, result_t & result, node * node_) const
-        {
-            if (node_)
-            {
-                Envelope<double> const& node_extent = node_->extent();
-                if (box.intersects(node_extent))
-                {
-                    node_data_iterator i=node_->begin();
-                    node_data_iterator end=node_->end();
-                    while ( i!=end)
-                    {
-                        result.push_back(&(*i));
-                        ++i;
-                    }
-                    for (int k = 0; k < 4; ++k)
-                    {
-                        query_node(box,result,node_->children_[k]);
-                    }
-                }
-            }
-        }
-	
-        void do_insert_data(T data, Envelope<double> const& box, node * n)
-        {
-            if (n)
-            {
-                Envelope<double> const& node_extent = n->extent();
-                Envelope<double> ext[4];
-                split_box(node_extent,ext);		
-                for (int i=0;i<4;++i)
-                {
-                    if (ext[i].contains(box))
-                    {
-                        if (!n->children_[i])
-                        {
-                            nodes_.push_back(new node(ext[i]));
-                            n->children_[i]=&nodes_.back();
-                        }
-                        do_insert_data(data,box,n->children_[i]);
-                        return;
-                    }
-                }
-                n->cont_.push_back(data);
-            }
-        }
-	
-        void split_box(Envelope<double> const& node_extent,Envelope<double> * ext)
-        {
-            coord2d c=node_extent.center();
-
-            double width=node_extent.width();
-            double height=node_extent.height();
-	    
-            double lox=node_extent.minx();
-            double loy=node_extent.miny();
-            double hix=node_extent.maxx();
-            double hiy=node_extent.maxy();
-	    
-            ext[0]=Envelope<double>(lox,loy,lox + width * ratio_,loy + height * ratio_);
-            ext[1]=Envelope<double>(hix - width * ratio_,loy,hix,loy + height * ratio_);
-            ext[2]=Envelope<double>(lox,hiy - height*ratio_,lox + width * ratio_,hiy);
-            ext[3]=Envelope<double>(hix - width * ratio_,hiy - height*ratio_,hix,hiy);
-        }
-    };    
-} 
-
-#endif

Deleted: trunk/include/query.hpp
===================================================================
--- trunk/include/query.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/query.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,111 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef QUERY_HPP
-#define QUERY_HPP
-
-#include <set>
-#include <limits>
-#include "filter.hpp"
-#include "envelope.hpp"
-#include "feature.hpp"
-
-namespace mapnik
-{
-    class query 
-    {
-    private:
-        Envelope<double> bbox_;
-        filter<Feature>* filter_;
-        std::set<std::string> names_;
-    public:
-        query() 
-            : bbox_(std::numeric_limits<double>::min(),
-                    std::numeric_limits<double>::min(),
-                    std::numeric_limits<double>::max(),
-                    std::numeric_limits<double>::max()),
-              filter_(new all_filter<Feature>)
-        {}
-        
-        query(const Envelope<double>& bbox)
-            : bbox_(bbox),
-              filter_(new all_filter<Feature>)
-        {}
-	
-        query(const Envelope<double>& bbox, const filter<Feature>& f)
-            : bbox_(bbox),
-              filter_(f.clone())
-        {}
-	
-        query(const query& other)
-            : bbox_(other.bbox_),
-              filter_(other.filter_->clone())
-        {}
-        
-        query& operator=(const query& other)
-        {
-            filter<Feature>* tmp=other.filter_->clone();
-            delete filter_;
-            filter_=tmp;
-            bbox_=other.bbox_;
-            names_=other.names_;
-            return *this;
-        }
-	
-        const filter<Feature>* get_filter() const
-        {
-            return  filter_;
-        }
-	
-        const Envelope<double>& get_bbox() const
-        {
-            return bbox_;
-        }
-
-        void set_filter(const filter<Feature>& f)
-        {
-            filter<Feature>* tmp=f.clone();
-            delete filter_;
-            filter_=tmp;
-        }
-        
-        void add_property_name(const std::string& name)
-        {
-            names_.insert(name);
-        } 
-	
-        const std::set<std::string>& property_names() const
-        {
-            return names_;
-        }
-	
-        ~query() 
-        {
-            delete filter_;
-        }
-    };
-}
-
-
-#endif //QUERY_HPP

Deleted: trunk/include/raster.hpp
===================================================================
--- trunk/include/raster.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/raster.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,41 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id: raster.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef RASTER_HPP
-#define RASTER_HPP
-
-#include "graphics.hpp"
-
-namespace mapnik
-{
-    struct raster
-    {
-        Envelope<double> ext_;
-        ImageData32 data_;
-	raster(Envelope<double> const ext,ImageData32& data)
-	    : ext_(ext),
-	      data_(data) {}
-    };
-}
-
-#endif //RASTER_HPP

Deleted: trunk/include/raster_symbolizer.hpp
===================================================================
--- trunk/include/raster_symbolizer.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/raster_symbolizer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,35 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id$
-
-#ifndef RASTER_SYMBOLIZER_HPP
-#define RASTER_SYMBOLIZER_HPP
-
-#include <boost/shared_ptr.hpp> 
-#include <config.hpp>
-
-namespace mapnik
-{
-    struct MAPNIK_DECL raster_symbolizer { /* TODO */};
-}
-
-#endif //RASTER_SYMBOLIZER

Deleted: trunk/include/regex_filter.hpp
===================================================================
--- trunk/include/regex_filter.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/regex_filter.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,81 +0,0 @@
-/* This file is part of Mapnik (c++ mapping toolkit)
- * Copyright (C) 2005 Artem Pavlenko
- *
- * Mapnik is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- */
-
-//$Id$
-
-#ifndef REGEX_FILTER_HPP
-#define REGEX_FILTER_HPP
-
-#include "filter.hpp"
-#include "expression.hpp"
-
-#include <boost/regex.hpp>
-#include <boost/algorithm/string.hpp>
-
-namespace mapnik
-{ 
-    template <typename FeatureT>
-    struct regex_filter : public filter<FeatureT>
-    {
-
-	regex_filter(expression<FeatureT> const& exp,
-		     std::string const& pattern)
-	    : filter<FeatureT>(),
-	      exp_(exp.clone()),
-	      pattern_(pattern) {}
-	
-	regex_filter(regex_filter const& other)
-	    :  filter<FeatureT>(),
-	       exp_(other.exp_->clone()),
-	       pattern_(other.pattern_) {}
-	
-	bool pass(FeatureT const& feature) const
-	{
-	    std::string text=exp_->get_value(feature).to_string();
-	    boost::trim_if(text,is_any_of("'"));
-	    return boost::regex_match(text,pattern_);
-	}
-	
-	void accept(filter_visitor<FeatureT>& v)
-	{
-	    exp_->accept(v);
-	    v.visit(*this);
-	}
-	
-	filter<FeatureT>* clone() const
-	{
-	    return new regex_filter(*this);
-	}
-	std::string to_string() const
-	{
-	    return exp_->to_string()+".match("+pattern_.str()+")";
-	}
-	~regex_filter()
-	{
-	    delete exp_;
-	}
-	
-    private:
-	expression<FeatureT>* exp_;
-	boost::regex pattern_;
-	
-    };   
-}
-
-
-#endif //REGEX_FILTER_HPP

Deleted: trunk/include/rule.hpp
===================================================================
--- trunk/include/rule.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/rule.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,280 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-#ifndef RULE_HPP
-#define RULE_HPP
-
-#include "line_symbolizer.hpp"
-#include "line_pattern_symbolizer.hpp"
-#include "polygon_symbolizer.hpp"
-#include "polygon_pattern_symbolizer.hpp"
-#include "point_symbolizer.hpp"
-#include "raster_symbolizer.hpp"
-#include "text_symbolizer.hpp"
-#include "filter.hpp"
-#include "filter_visitor.hpp"
-#include <boost/shared_ptr.hpp>
-#include <boost/variant.hpp>
-#include <string>
-#include <vector>
-
-namespace mapnik
-{
-    inline bool operator==(point_symbolizer const& lhs,
-                           point_symbolizer const& rhs)
-    {
-        return (&lhs == &rhs); 
-    }
-    inline bool operator==(line_symbolizer const& lhs,
-                           line_symbolizer const& rhs)
-    {
-        return (&lhs == &rhs); 
-    }
-    inline bool operator==(line_pattern_symbolizer const& lhs,
-                           line_pattern_symbolizer const& rhs)
-    {
-        return (&lhs == &rhs); 
-    }
-
-    inline bool operator==(polygon_symbolizer const& lhs,
-                           polygon_symbolizer const& rhs)
-    {
-        return (&lhs == &rhs); 
-    }
-    
-    inline bool operator==(polygon_pattern_symbolizer const& lhs,
-                           polygon_pattern_symbolizer const& rhs)
-    {
-        return (&lhs == &rhs); 
-    }
-    
-    inline bool operator==(raster_symbolizer const& lhs,
-                           raster_symbolizer const& rhs)
-    {
-        return (&lhs == &rhs); 
-    }
-    
-    inline bool operator==(text_symbolizer const& lhs,
-                           text_symbolizer const& rhs)
-    {
-        return (&lhs == &rhs); 
-    }
-    
-    typedef boost::variant<point_symbolizer,
-                           line_symbolizer,
-                           line_pattern_symbolizer,
-                           polygon_symbolizer,
-                           polygon_pattern_symbolizer,
-                           raster_symbolizer,
-                           text_symbolizer> symbolizer;
-    
-        
-    typedef std::vector<symbolizer> symbolizers;    
-    template <typename FeatureT> class all_filter;
-
-    template <typename FeatureT,template <typename> class Filter>
-    class rule
-    {
-        typedef Filter<FeatureT> filter_type;
-        typedef boost::shared_ptr<filter_type> filter_ptr;
-    private:
-
-        std::string name_;
-        std::string title_;
-        std::string abstract_;
-        double min_scale_;
-        double max_scale_;
-        symbolizers syms_;
-        filter_ptr filter_;
-        bool else_filter_;
-    public:
-        rule()
-            : name_(),
-              title_(),
-              abstract_(),
-              min_scale_(0),
-              max_scale_(std::numeric_limits<double>::infinity()),
-              syms_(),
-              filter_(new all_filter<FeatureT>),
-              else_filter_(false) {}
-                
-        rule(const std::string& name,
-             const std::string& title="",
-             double min_scale_denominator=0,
-             double max_scale_denominator=std::numeric_limits<double>::infinity())
-            : name_(name),
-              title_(title),
-              min_scale_(min_scale_denominator),
-              max_scale_(max_scale_denominator),
-              syms_(),
-              filter_(new all_filter<FeatureT>),
-              else_filter_(false) {}
-	    
-        rule(const rule& rhs)    
-            : name_(rhs.name_),
-              title_(rhs.title_),
-              abstract_(rhs.abstract_),
-              min_scale_(rhs.min_scale_),
-              max_scale_(rhs.max_scale_),
-              syms_(rhs.syms_),
-              filter_(rhs.filter_),
-              else_filter_(rhs.else_filter_) {}
-	
-        rule& operator=(rule const& rhs) 
-        {
-            rule tmp(rhs);
-            swap(tmp);
-            return *this;
-        }
-        bool operator==(rule const& other)
-        {
-            return  (this == &other); 
-        }
-	
-        void set_max_scale(double scale)
-        {
-            max_scale_=scale;
-        }
-        
-        double get_max_scale() const
-        {
-            return max_scale_;
-        }
-        
-        void set_min_scale(double scale)
-        {
-            min_scale_=scale;
-        }
-
-        double get_min_scale() const
-        {
-            return min_scale_;
-        }
-
-       
-        void set_name(std::string const& name)
-        {
-            name_=name;
-        }
-	
-        std::string const& get_name() const
-        {
-            return name_;
-        }
-	
-        std::string const& get_title() const
-        {
-            return  title_;
-        }
-
-        void set_title(std::string const& title)
-        {
-            title_=title;
-        }
-  
-        void set_abstract(std::string const& abstract)
-        {
-            abstract_=abstract;
-        }
-	
-        std::string const& get_abstract() const
-        {
-            return abstract_;
-        }
-		
-        void append(const symbolizer& sym)
-        {
-            syms_.push_back(sym);
-        }
-	
-        void remove_at(size_t index)
-        {
-            if (index < syms_.size())
-            {
-                syms_.erase(syms_.begin()+index);
-            }
-        }
-	
-        const symbolizers& get_symbolizers() const
-        {
-            return syms_;
-        }
-	
-        symbolizers::const_iterator begin()
-        {
-            return syms_.begin();
-        }
-	
-        symbolizers::const_iterator end()
-        {
-            return syms_.end();
-        }
-	
-        void set_filter(const filter_ptr& filter)
-        {
-            filter_=filter;
-        }
-
-        filter_ptr const& get_filter() const
-        {
-            return filter_;
-        }
-	
-        void set_else(bool else_filter)
-        {
-            else_filter_=else_filter;
-        }
-     
-        bool has_else_filter() const
-        {
-            return else_filter_;
-        }
-        
-        bool active(double scale) const
-        {
-            return ( scale > min_scale_ && scale < max_scale_ );
-        }
-
-        void accept(filter_visitor<FeatureT>& v) const
-        {
-            v.visit(*this);
-        }
-	
-    private:
-	
-        void swap(rule& rhs) throw()
-        {
-            name_=rhs.name_;
-            title_=rhs.title_;
-            abstract_=rhs.abstract_;
-            min_scale_=rhs.min_scale_;
-            max_scale_=rhs.max_scale_;
-            syms_=rhs.syms_;
-            filter_=rhs.filter_;
-            else_filter_=rhs.else_filter_;
-        }
-    };
-
-    typedef rule<Feature,filter> rule_type;
-}
-
-#endif //RULE_HPP

Deleted: trunk/include/save_map.hpp
===================================================================
--- trunk/include/save_map.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/save_map.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,35 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-// $Id$
-
-#ifndef SAVE_MAP_HPP
-#define SAVE_MAP_HPP
-
-#include <string>
-#include "map.hpp"
-
-namespace mapnik
-{
-    void save_map(Map const& map, std::string const& filename);
-}
-
-#endif // SAVE_MAP_HPP

Deleted: trunk/include/spatial.hpp
===================================================================
--- trunk/include/spatial.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/spatial.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,154 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-#ifndef SPATIAL_HPP
-#define SPATIAL_HPP
-
-#include "filter.hpp"
-#include "filter_visitor.hpp"
-
-namespace mapnik
-{    
-
-    template <typename FeatureT>
-    struct equals_ : public filter<FeatureT>
-    {
-
-	bool pass(const FeatureT& feature) const
-	{
-	    return false;
-	}
-	
-	void accept(const filter_visitor<FeatureT>& v)
-	{
-	    v.visit(*this);
-	}
-    };
-    
-    template <typename FeatureT>
-    struct disjoint : public filter<FeatureT>
-    {
-	  
-	
-	bool pass(const FeatureT& feature) const
-	{
-	    return false;
-	}
-	
-	void accept(const filter_visitor<FeatureT>& v)
-	{
-	    v.visit(*this);
-	}
-    };
-  
-    template <typename FeatureT>
-    struct touches : public filter<FeatureT>
-    {
-
-	
-	bool pass(const FeatureT& feature) const
-	{
-	    return false;
-	}
-	
-	void accept(const filter_visitor<FeatureT>& v)
-	{
-	    v.visit(*this);
-	}
-    };
-
-    template <typename FeatureT>
-    struct within : public filter<FeatureT>
-    {
-
-	bool pass(const FeatureT& feature) const
-	{
-	    return false;
-	}
-
-	void accept(const filter_visitor<FeatureT>& v)
-	{
-	    v.visit(*this);
-	}
-    };
-
-    template <typename FeatureT>
-    struct overlaps : public filter<FeatureT>
-    {
-
-	bool pass(const FeatureT& feature) const
-	{
-	    return false;
-	}
-	
-	void accept(const filter_visitor<FeatureT>& v)
-	{
-	    v.visit(*this);
-	}
-    };
-
-    template <typename FeatureT>
-    struct crosses : public filter<FeatureT>
-    {
-
-	
-	bool pass(const FeatureT& feature) const
-	{
-	    return false;
-	}
-	
-	void accept(const filter_visitor<FeatureT>& v)
-	{
-	    v.visit(*this);
-	}
-    };
-    
-    template <typename FeatureT>
-    struct bbox  : public filter<FeatureT> 
-    {
-    private:
-	Envelope<double> box_;
-    public:
-	bbox(const Envelope<double>& box)
-	    : box_(box) {}
-
-	
-	bool pass(const FeatureT& feature) const
-	{
-	    return box_.contains(feature.get_geometry()->bbox());
-	}
-	
-
-	filter<FeatureT>* clone() const
-	{
-	    return new bbox<FeatureT>(box_);
-	}
-	void accept(const filter_visitor<FeatureT>& v)
-	{
-	    v.visit(*this);
-	}
-	
-	
-	virtual ~bbox() {}
-    };
-}
-
-#endif //SPATIAL_HPP

Deleted: trunk/include/stroke.hpp
===================================================================
--- trunk/include/stroke.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/stroke.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,169 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id$
-
-#ifndef STROKE_HPP
-#define STROKE_HPP
-
-#include "color.hpp"
-#include <vector>
-
-namespace mapnik
-{
-    using std::pair;
-    using std::vector;
-    typedef vector<pair<float,float> > dash_array;
-    
-    enum line_cap_e
-        {
-            BUTT_CAP,
-            SQUARE_CAP,
-            ROUND_CAP
-        }; 
-    
-    enum line_join_e
-        {
-            MITER_JOIN,
-            MITER_REVERT_JOIN,
-            ROUND_JOIN,
-            BEVEL_JOIN
-        };
-    
-    class stroke
-    {	
-        Color c_;
-        float width_;
-        float opacity_; // 0.0 - 1.0
-        line_cap_e  line_cap_;
-        line_join_e line_join_;
-        dash_array dash_;	
-    public:
-        explicit stroke() 
-            : c_(0,0,0),
-              width_(1.0),
-              opacity_(1.0),
-              line_cap_(BUTT_CAP),
-              line_join_(MITER_JOIN),
-              dash_() {}
-	
-        stroke(Color const& c, float width=1.0)
-            : c_(c),
-              width_(width),
-              opacity_(1.0),
-              line_cap_(BUTT_CAP),
-              line_join_(MITER_JOIN),
-              dash_() {}
-
-        stroke(stroke const& other)
-            : c_(other.c_),
-              width_(other.width_),
-              opacity_(other.opacity_),
-              line_cap_(other.line_cap_),
-              line_join_(other.line_join_),
-              dash_(other.dash_) {}
-	    
-        stroke& operator=(const stroke& rhs)
-        {
-            stroke tmp(rhs);
-            swap(tmp);
-            return *this;
-        }
-
-        void set_color(const Color& c) 
-        {
-            c_=c;
-        }
-	
-        Color const& get_color() const
-        {
-            return c_;
-        }
-	
-        float get_width() const
-        {
-            return width_;
-        }
-        void set_width(float w)
-        {
-            width_=w;
-        }
-
-        void set_opacity(float opacity)
-        {    
-            if (opacity > 1.0) opacity_=1.0;
-            else if (opacity < 0.0) opacity_=0.0;
-            else opacity_=opacity;
-        }
-
-        float get_opacity() const 
-        {
-            return opacity_;
-        }
-	
-        void set_line_cap(line_cap_e line_cap)
-        {
-            line_cap_=line_cap;
-        }
-
-        line_cap_e get_line_cap() const 
-        {
-            return line_cap_;
-        }
-	
-        void set_line_join(line_join_e line_join) 
-        {
-            line_join_=line_join;
-        }
-	
-        line_join_e get_line_join() const 
-        {
-            return line_join_;
-        }
-	
-        void add_dash(float dash,float gap)
-        {
-            dash_.push_back(std::make_pair(dash,gap));
-        }
-        bool has_dash() const 
-        {
-            return dash_.size()>0 ? true : false ;
-        }
-	
-        dash_array const& get_dash_array() const
-        {
-            return  dash_;
-        }
-	
-    private:
-        void swap(const stroke& other) throw()
-        {
-            c_=other.c_;
-            width_=other.width_;
-            opacity_=other.opacity_;
-            line_cap_=other.line_cap_;
-            line_join_=other.line_join_;
-            dash_ = other.dash_;
-        }
-    };
-}
-
-#endif //STROKE_HPP

Deleted: trunk/include/style.hpp
===================================================================
--- trunk/include/style.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/style.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,39 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id: style.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef STYLE_HPP
-#define STYLE_HPP
-
-#include "color.hpp"
-#include "symbolizer.hpp"
-
-#include <vector>
-#include <algorithm>
-#include <functional>
-#include <boost/shared_ptr.hpp>
-
-namespace mapnik
-{      
-}
-
-#endif //STYLE_HPP

Deleted: trunk/include/style_factory.hpp
===================================================================
--- trunk/include/style_factory.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/style_factory.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,37 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id: style_factory.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef STYLE_FACTORY_HPP
-#define STYLE_FACTORY_HPP
-
-//#include "style.hpp"
-
-namespace mapnik {
-    
-    class style_factory 
-    {
-    };
-}
-
-
-#endif //STYLE_FACTORY_HPP

Deleted: trunk/include/symbolizer.hpp
===================================================================
--- trunk/include/symbolizer.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/symbolizer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,31 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id: symbolizer.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef SYMBOLIZER_HPP
-#define SYMBOLIZER_HPP
-
-namespace mapnik 
-{
-}
-
-#endif //SYMBOLIZER_HPP

Deleted: trunk/include/text_symbolizer.hpp
===================================================================
--- trunk/include/text_symbolizer.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/text_symbolizer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,68 +0,0 @@
-/* This file is part of Mapnik (c++ mapping toolkit)
- * Copyright (C) 2005 Artem Pavlenko
- *
- * Mapnik is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- */
-
-//$Id$
-
-#ifndef TEXT_SYMBOLIZER_HPP
-#define TEXT_SYMBOLIZER_HPP
-
-#include <string>
-#include <boost/tuple/tuple.hpp>
-#include "color.hpp"
-
-namespace mapnik
-{
-    enum label_placement_e {
-	point_placement=1,
-	line_placement=2
-    };
-        
-    typedef boost::tuple<double,double> position;
-    
-    struct MAPNIK_DECL text_symbolizer
-    {		
-	text_symbolizer(std::string const& name,unsigned size,Color const& fill);	
-	text_symbolizer(text_symbolizer const& rhs);
-	text_symbolizer& operator=(text_symbolizer const& rhs);
-	std::string const& get_name() const;
-	unsigned get_text_size() const;
-	Color const& get_fill() const;
-	void set_halo_fill(Color const& fill);
-	Color const& get_halo_fill() const;
-	void set_halo_radius(unsigned radius);
-	unsigned get_halo_radius() const;
-	void set_label_placement(label_placement_e label_p);
-	label_placement_e get_label_placement() const;
-        void set_anchor(double x, double y);	
-	position const& get_anchor() const;	
-	void set_displacement(double x, double y);
-	position const& get_displacement() const;
-	
-    private:
-	std::string name_;
-	unsigned size_;
-	Color fill_;
-	Color halo_fill_;
-	unsigned halo_radius_;
-	label_placement_e label_p_;
-	position anchor_;
-	position displacement_;
-    };
-}
-
-#endif //TEXT_SYMBOLIZER_HPP

Deleted: trunk/include/utils.hpp
===================================================================
--- trunk/include/utils.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/utils.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,249 +0,0 @@
-/* This file is part of Mapnik (c++ mapping toolkit)
- * Copyright (C) 2005 Artem Pavlenko
- *
- * Mapnik is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- */
-
-//$Id: utils.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef UTILS_HPP
-#define UTILS_HPP
-
-#include <stdexcept>
-#include <limits>
-#include <ctime>
-//#include <sys/time.h>
-#include <sstream>
-#include <iostream>
-#include <algorithm>
-#include <cmath>
-
-#include <boost/thread/mutex.hpp>
-
-namespace mapnik
-{
-    using boost::mutex;
-    
-    template <typename T>
-    class CreateUsingNew
-    {
-    public:
-	static T* create()
-	{
-	    return new T;
-	}
-	static void destroy(T* obj)
-	{
-	    delete obj;
-	}
-    };
-
-    template <typename T>
-    class CreateStatic
-    {
-    private:
-	union MaxAlign
-	{
-	    char t_[sizeof(T)];
-	    short int shortInt_;
-	    int int_;
-	    long int longInt_;
-	    float float_;
-	    double double_;
-	    long double longDouble_;
-	    struct Test;
-	    int Test::* pMember_;
-	    int (Test::*pMemberFn_)(int);
-	};
-    public:
-	static T* create()
-	{
-	    static MaxAlign staticMemory;
-	    return new(&staticMemory) T;
-	}
-	static void destroy(volatile T* obj)
-	{
-	    obj->~T();
-	}
-    };
-
-    template <typename T,
-	      template <typename T> class CreatePolicy=CreateStatic> class singleton
-	      {
-		  friend class CreatePolicy<T>;
-		  static T* pInstance_;
-		  static bool destroyed_;
-		  singleton(const singleton &rhs);
-		  singleton& operator=(const singleton&);
-		  static void onDeadReference()
-		  {
-		      throw std::runtime_error("dead reference!");
-		  }
-	      protected:
-		  static mutex mutex_;
-		  singleton() {}
-		  virtual ~singleton()
-		  {
-		      CreatePolicy<T>::destroy(pInstance_);
-		      destroyed_=true;
-		  }
-	      public:
-		  static  T* instance()
-		  {
-		      if (!pInstance_)
-		      {
-			  mutex::scoped_lock lock(mutex_);
-			  if (!pInstance_)
-			  {
-			      if (destroyed_)
-			      {
-				  onDeadReference();
-			      }
-			      else
-			      {
-				  pInstance_=CreatePolicy<T>::create();
-			      }
-			  }
-		      }
-		      return pInstance_;
-		  }
-	      };
-
-    template <typename T,
-	      template <typename T> class CreatePolicy> mutex singleton<T,CreatePolicy>::mutex_;
-    template <typename T,
-	      template <typename T> class CreatePolicy> T* singleton<T,CreatePolicy>::pInstance_=0;
-    template <typename T,
-	      template <typename T> class CreatePolicy> bool singleton<T,CreatePolicy>::destroyed_=false;
-
-    template <class T> class Handle
-    {
-        T* ptr_;
-        int* pCount_;
-    public:
-	T* operator->() {return ptr_;}
-	const T* operator->() const {return ptr_;}
-	Handle(T* ptr)
-	    :ptr_(ptr),pCount_(new int(1)) {}
-	Handle(const Handle& rhs)
-	    :ptr_(rhs.ptr_),pCount_(rhs.pCount_)
-	{
-	    (*pCount_)++;
-	}
-	Handle& operator=(const Handle& rhs)
-	{
-	    if (ptr_==rhs.ptr_) return *this;
-	    if (--(*pCount_)==0)
-	    {
-		delete ptr_;
-		delete pCount_;
-	    }
-	    ptr_=rhs.ptr_;
-	    pCount_=rhs.pCount_;
-	    (*pCount_)++;
-	    return *this;
-	}
-	~Handle()
-	{
-	    if (--(*pCount_)==0)
-	    {
-		delete ptr_;
-		delete pCount_;
-	    }
-	}
-    };
-
-
-    struct timer
-    {
-        //struct timeval tv_;
-        timer()
-        {
-            //gettimeofday (&tv_,0);
-        }
-        void start()
-        {
-            //gettimeofday (&tv_,0);
-        }
-        void stop()
-        {
-            //timeval tv;
-            //gettimeofday (&tv,0);
-            //std::ostringstream s;
-            //long sec=1000*(tv.tv_sec-tv_.tv_sec);
-            //long total_ms=sec+static_cast<long>(0.001*(tv.tv_usec-tv_.tv_usec));
-            //s << "elapsed time is "<<total_ms<<" ms";
-            //std::clog<<s.str()<<std::endl;
-        }
-    };
-    
-    //converters
-    class BadConversion : public std::runtime_error
-    {
-    public:
-	BadConversion(const std::string& s)
-	    :std::runtime_error(s)
-	{}
-    };
-    
-    template <typename T>
-    inline std::string toString(const T& x)
-    {
-        std::ostringstream o;
-        if (!(o << x))
-            throw BadConversion(std::string("toString(")
-                                + typeid(x).name() + ")");
-        return o.str();
-    }
-    
-    template<typename T>
-    inline void fromString(const std::string& s, T& x,
-                           bool failIfLeftoverChars = true)
-    {
-        std::istringstream i(s);
-        char c;
-        if (!(i >> x) || (failIfLeftoverChars && i.get(c)))
-            throw BadConversion("fromString("+s+")");
-    }
-    
-    //inline bool space (char c)
-    //{
-//		return isspace(c);
- //   }
-    
-   // inline bool not_space (char c)
-    //{
-//		return !isspace(c);
- //   }
-    
-    //inline std::string trim_left(const std::string& str)
-    //{
-//		typedef std::string::const_iterator iter;
-//		iter i = std::find_if(str.begin(),str.end(),not_space);
-		//return std::string(i,str.end());	
-    //}
-    //inline std::string trim_right(const std::string& str)
-    //{
-	//	std::string::size_type idx=str.find_last_not_of(" ");
-//		return str.substr(0,idx+1);
- //   }
-//	inline std::string trim(const std::string& str)
-  //  {
-	//	return trim_left(trim_right(str));
-	//}
-}
-
-
-#endif                                            //UTILS_HPP

Deleted: trunk/include/value.hpp
===================================================================
--- trunk/include/value.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/value.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,443 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id$
-
-#ifndef VALUE_HPP
-#define VALUE_HPP
-
-#include <string>
-#include <sstream>
-#include <boost/variant.hpp>
-
-using namespace boost;
-namespace mapnik {
-
-    typedef variant<int,double,std::string> value_base;
-    
-    namespace impl {
-	struct equals
-	    : public boost::static_visitor<bool>
-	{
-	    template <typename T, typename U>
-	    bool operator() (const T &, const U & ) const
-	    {
-		return false;
-	    }
-	
-	    template <typename T>
-	    bool operator() (T lhs, T rhs) const
-	    {
-		return lhs == rhs;
-	    }
-	
-	    bool operator() (int lhs, double rhs) const
-	    {
-		return  lhs == rhs;
-	    }
-	
-	    bool operator() (double lhs, int rhs) const
-	    {
-		return  lhs == rhs;
-	    }
-	
-	    bool operator() (std::string const& lhs, std::string const& rhs) const
-	    {
-		return  lhs == rhs;
-	    }
-	};
-    
-	struct greater_than
-	    : public boost::static_visitor<bool>
-	{
-	    template <typename T, typename U>
-	    bool operator()( const T &, const U & ) const
-	    {
-		return false;
-	    }
-	
-	    template <typename T>
-	    bool operator()( T lhs, T rhs ) const
-	    {
-		return lhs > rhs;
-	    }
-	
-	    bool operator() (int lhs, double rhs) const
-	    {
-		return  lhs > rhs;
-	    }
-	
-	    bool operator() (double lhs, int rhs) const
-	    {
-		return  lhs > rhs;
-	    }
-	
-	    bool operator() (std::string const& lhs, std::string const& rhs) const
-	    {
-		return  lhs > rhs;
-	    }
-	};
-    
-	struct greater_or_equal
-	    : public boost::static_visitor<bool>
-	{	
-	    template <typename T, typename U>
-	    bool operator()( const T &, const U & ) const
-	    {
-		return false;
-	    }
-	
-	    template <typename T>
-	    bool operator() (T lhs, T rhs) const
-	    {
-		return lhs >= rhs;
-	    }
-      
-	    bool operator() (int lhs, double rhs) const
-	    {
-		return  lhs >= rhs;
-	    }
-	
-	    bool operator() (double lhs, int rhs) const
-	    {
-		return  lhs >= rhs;
-	    }
-	
-	    bool operator() (std::string const& lhs, std::string const& rhs ) const
-	    {
-		return lhs >= rhs;
-	    }
-	};
-    
-	struct less_than
-	    : public boost::static_visitor<bool>
-	{	
-	    template <typename T, typename U>
-	    bool operator()( const T &, const U & ) const
-	    {
-		return false;
-	    }
-	
-	    template <typename T>
-	    bool operator()( T  lhs,T  rhs) const
-	    {
-		return lhs < rhs;
-	    }
-	
-	    bool operator() (int lhs, double rhs) const
-	    {
-		return  lhs < rhs;
-	    }
-	   
-	    bool operator() (double lhs, int rhs) const
-	    {
-		return  lhs < rhs;
-	    }
-	
-	    bool operator()( std::string const& lhs, std::string const& rhs ) const
-	    {
-		return lhs < rhs;
-	    }
-	};
-
-	struct less_or_equal
-	    : public boost::static_visitor<bool>
-	{	
-	    template <typename T, typename U>
-	    bool operator()( const T &, const U & ) const
-	    {
-		return false;
-	    }
-	
-	    template <typename T>
-	    bool operator()(T lhs, T rhs ) const
-	    {
-		return lhs <= rhs;
-	    }
-	    
-	    bool operator() (int lhs, double rhs) const
-	    {
-		return  lhs <= rhs;
-	    }
-	
-	    bool operator() (double lhs, int rhs) const
-	    {
-		return  lhs <= rhs;
-	    }
-	
-	    template <typename T>
-	    bool operator()( std::string const& lhs, std::string const& rhs ) const
-	    {
-		return lhs <= rhs;
-	    }
-	};
-    
-	template <typename V>
-	struct add : public boost::static_visitor<V>
-	{ 
-	    typedef V value_type;
-	    template <typename T1, typename T2>
-	    value_type operator() (T1 const& lhs, T2 const&) const
-	    {
-		return lhs;
-	    }
-	    template <typename T>
-	    value_type operator() (T lhs, T rhs) const
-	    {
-		return lhs + rhs ;
-	    }
-	
-	    value_type operator() (std::string const& lhs,std::string const& rhs ) const
-	    {
-		return lhs + rhs;
-	    }
-	
-	    value_type operator() (double lhs, int rhs) const
-	    {
-		return lhs + rhs;
-	    }
-	
-	    value_type operator() (int lhs, double rhs) const
-	    {
-		return lhs + rhs;
-	    }
-	};
-	template <typename V>
-	struct sub : public boost::static_visitor<V>
-	{ 
-	    typedef V value_type;
-	    template <typename T1, typename T2>
-	    value_type operator() (T1 const& lhs, T2 const&) const
-	    {
-		return lhs;
-	    }
-
-	    template <typename T>
-	    value_type operator() (T  lhs, T rhs) const
-	    {
-		return lhs - rhs ;
-	    }
-
-	    value_type operator() (std::string const& lhs,std::string const& ) const
-	    {
-		return lhs;
-	    }
-        	
-	    value_type operator() (double lhs, int rhs) const
-	    {
-		return lhs - rhs;
-	    }
-	
-	    value_type operator() (int lhs, double rhs) const
-	    {
-		return lhs - rhs;
-	    }
-	};
-    
-	template <typename V>
-	struct mult : public boost::static_visitor<V>
-	{ 
-	    typedef V value_type;
-	    template <typename T1, typename T2>
-	    value_type operator() (T1 const& lhs , T2 const& ) const
-	    {
-		return lhs;
-	    }
-	    template <typename T>
-	    value_type operator() (T lhs, T rhs) const
-	    {
-		return lhs * rhs;
-	    }
-	
-	    value_type operator() (std::string const& lhs,std::string const& ) const
-	    {
-		return lhs;
-	    }	
-	
-	    value_type operator() (double lhs, int rhs) const
-	    {
-		return lhs * rhs;
-	    }
-	
-	    value_type operator() (int lhs, double rhs) const
-	    {
-		return lhs * rhs;
-	    }
-	};
-
-	template <typename V>
-	struct div: public boost::static_visitor<V>
-	{ 
-	    typedef V value_type;
-	    template <typename T1, typename T2>
-	    value_type operator() (T1 const& lhs, T2 const&) const
-	    {
-		return lhs;
-	    }
-	    
-	    template <typename T>
-	    value_type operator() (T lhs, T rhs) const
-	    {
-		return lhs / rhs;
-	    }
-	
-	    value_type operator() (std::string const& lhs,std::string const&) const
-	    {
-		return lhs;
-	    }
-	
-	    value_type operator() (double lhs, int rhs) const
-	    {
-		return lhs / rhs;
-	    }
-	
-	    value_type operator() (int lhs, double rhs) const
-	    {
-		return lhs / rhs;
-	    }
-	};
-    
-	struct to_string : public boost::static_visitor<std::string>
-	{
-	    template <typename T>
-	    std::string operator() (T val) const
-	    {
-		std::stringstream ss;
-		ss << val;
-		return ss.str();
-	    } 
-	    std::string const& operator() (std::string const& val) const
-	    {
-		return val;
-	    }
-	};
-	
-	struct to_expression_string : public boost::static_visitor<std::string>
-	{
-	    template <typename T>
-	    std::string operator() (T val) const
-	    {
-		std::stringstream ss;
-		ss << val;
-		return ss.str();
-	    } 
-	    std::string operator() (std::string const& val) const
-	    {
-		return "'" + val + "'";
-	    }
-	};
-    }
-    
-    class value
-    {
-        value_base base_;
-        friend const value operator+(value const&,value const&);
-        friend const value operator-(value const&,value const&);
-        friend const value operator*(value const&,value const&);
-        friend const value operator/(value const&,value const&);
-
-    public:
-	value ()
-	    : base_(0) {}
-	
-	template <typename T> value(T _val_)
-	    : base_(_val_) {}
-
-	bool operator==(value const& other) const
-	{
-	    return boost::apply_visitor(impl::equals(),base_,other.base_);
-	}
-
-	bool operator!=(value const& other) const
-	{
-	    return !(boost::apply_visitor(impl::equals(),base_,other.base_));
-	}
-	
-	bool operator>(value const& other) const
-	{
-	    return boost::apply_visitor(impl::greater_than(),base_,other.base_);
-	}
-
-	bool operator>=(value const& other) const
-	{
-	    return boost::apply_visitor(impl::greater_or_equal(),base_,other.base_);
-	}
-
-	bool operator<(value const& other) const
-	{
-	    return boost::apply_visitor(impl::less_than(),base_,other.base_);
-	}
-
-	bool operator<=(value const& other) const
-	{
-	    return boost::apply_visitor(impl::less_or_equal(),base_,other.base_);
-	}
-	value_base const& base() const
-	{
-	    return base_;
-	}
-
-	std::string to_expression_string() const
-	{
-	    return boost::apply_visitor(impl::to_expression_string(),base_);
-	}
-
-	std::string to_string() const
-	{
-	    return boost::apply_visitor(impl::to_string(),base_);
-	}
-    };
-    
-    inline const value operator+(value const& p1,value const& p2)
-    {
-
-	return value(boost::apply_visitor(impl::add<value>(),p1.base_, p2.base_));
-    }
-
-    inline const value operator-(value const& p1,value const& p2)
-    {
-
-	return value(boost::apply_visitor(impl::sub<value>(),p1.base_, p2.base_));
-    }
-
-    inline const value operator*(value const& p1,value const& p2)
-    {
-
-	return value(boost::apply_visitor(impl::mult<value>(),p1.base_, p2.base_));
-    }
-
-    inline const value operator/(value const& p1,value const& p2)
-    {
-
-	return value(boost::apply_visitor(impl::div<value>(),p1.base_, p2.base_));
-    }
-
-    template <typename charT, typename traits>
-    inline std::basic_ostream<charT,traits>& 
-    operator << (std::basic_ostream<charT,traits>& out,
-    		 value const& v)
-    {
-    	out << v.base();
-    	return out; 
-    }
-}
-
-#endif //VALUE_HPP

Deleted: trunk/include/vertex.hpp
===================================================================
--- trunk/include/vertex.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/vertex.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,113 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id: vertex.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef VERTEX_HPP
-#define VERTEX_HPP
-
-#include <iostream>
-#include <sstream>
-
-namespace mapnik 
-{
-    enum
-    {
-        SEG_END   =0,
-        SEG_MOVETO=1,
-        SEG_LINETO=2,
-        SEG_CLOSE =3
-    };
-    
-    template <typename T,int dim>
-    struct vertex {
-	typedef T type;
-    };
-    
-    template <typename T>
-    struct vertex<T,2> 
-    {
-	typedef T type;
-	T x;
-	T y;
-	unsigned cmd;
-	vertex() 
-	    : x(0),y(0),cmd(SEG_END) {}
-	vertex(T x,T y,unsigned cmd)
-	    : x(x),y(y),cmd(cmd) {}
-
-	template <typename T2>
-	vertex(const vertex<T2,2>& rhs)
-	    : x(type(rhs.x)),
-	      y(type(rhs.y)),
-	      cmd(rhs.cmd) {}
-	
-	template <typename T2> vertex<T,2> operator=(const vertex<T2,2>& rhs)
-	{
-	    if ((void*)this == (void*)&rhs)
-	    {
-		return *this;
-	    }
-	    x=type(rhs.x);
-	    y=type(rhs.y);
-	    cmd=rhs.cmd;
-	    return *this;
-	}	
-    };
-    
-    typedef vertex<double,2> vertex2d;
-    typedef vertex<int,2> vertex2i;
-
-    
-    template <class charT,class traits,class T,int dim>
-    inline std::basic_ostream<charT,traits>&
-    operator << (std::basic_ostream<charT,traits>& out,
-		 const vertex<T,dim>& c);
-
-    template <class charT,class traits,class T>
-    inline std::basic_ostream<charT,traits>&
-    operator << (std::basic_ostream<charT,traits>& out,
-		 const vertex<T,2>& v)
-    {
-        std::basic_ostringstream<charT,traits> s;
-        s.copyfmt(out);
-        s.width(0);
-        s<<"vertex2("<<v.x<<","<<v.y<<",cmd="<<v.cmd<<" )";
-        out << s.str();
-        return out;
-    }
-
-    template <class charT,class traits,class T>
-    inline std::basic_ostream<charT,traits>&
-    operator << (std::basic_ostream<charT,traits>& out,
-		 const vertex<T,3>& v)
-    {
-        std::basic_ostringstream<charT,traits> s;
-        s.copyfmt(out);
-        s.width(0);
-        s<<"vertex3("<<v.x<<","<<v.y<<","<<v.z<<",cmd="<<v.cmd<<")";
-        out << s.str();
-        return out;
-    } 
-
-}
-
-#endif // VERTEX_HPP

Deleted: trunk/include/vertex_transform.hpp
===================================================================
--- trunk/include/vertex_transform.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/vertex_transform.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,92 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id: vertex_transform.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef VERTEX_TRANSFORM_HPP
-#define VERTEX_TRANSFORM_HPP
-
-#include "vertex.hpp"
-#include "envelope.hpp"
-
-namespace mapnik
-{
-    template <typename T0 ,typename T1,int shift=8>
-    struct Shift
-    {
-	typedef T0 value_type;
-	typedef T1 return_type;
-	static return_type apply(value_type val)
-	{
-	    return static_cast<return_type>(val*(1<<shift));
-	}
-    };
-
-    template <typename T0,typename T1>
-    struct Shift<T0,T1,0> 
-    {
-	typedef T0 value_type;
-	typedef T1 return_type;
-	static return_type apply(value_type val)
-	{
-	    return static_cast<return_type>(val);
-	}
-    };
-
-    template <typename T>
-    struct Shift<T,T,0>
-    {
-	typedef T value_type;
-	typedef T return_type;
-	static T& apply(T& val)
-	{
-	    return val;
-	}
-    };
-
-    typedef Shift<double,double,0> NO_SHIFT;
-    typedef Shift<double,int,0> SHIFT0;
-    typedef Shift<double,int,8> SHIFT8;
-    
-    
-    template <typename T0,typename T1,typename Trans>
-    struct view_transform;
-    
-    template <typename Trans>
-    struct view_transform <vertex2d,vertex2d,Trans>   
-    {
-	
-    };
-    
-    template <typename Trans>
-    struct view_transform <vertex2d,vertex2i,Trans>   
-    {
-	
-    };
-
-    template <typename Trans>
-    struct view_transform<Envelope<double>,Envelope<double>,Trans>
-    {
-	
-    };
-}
-
-#endif //VERTEX_TRANSFORM_HPP

Deleted: trunk/include/vertex_vector.hpp
===================================================================
--- trunk/include/vertex_vector.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/vertex_vector.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,199 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//  Credits:
-//  I gratefully acknowledge the inspiring work of Maxim Shemanarev (McSeem), 
-//  author of Anti-Grain Geometry (http://www.antigrain.com). I have used 
-//  the datastructure from AGG as a template for my own. 
-
-
-//$Id: vertex_vector.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef VERTEX_VECTOR_HPP
-#define VERTEX_VECTOT_HPP
-
-#include "vertex.hpp"
-#include "ctrans.hpp"
-
-#include <vector>
-#include <boost/utility.hpp>
-#include <boost/tuple/tuple.hpp>
-
-namespace mapnik
-{
-    template <typename T>
-    class vertex_vector : private boost::noncopyable
-    {
-        typedef typename T::type value_type;
-        typedef vertex<value_type,2> vertex_type;
-        enum {
-            block_shift = 8,
-            block_size  = 1<<block_shift,
-            block_mask  = block_size - 1,
-            grow_by     = 256
-        };
-
-    private:
-        unsigned num_blocks_;
-        unsigned max_blocks_;
-        value_type** vertexs_;
-        unsigned char** commands_;
-        unsigned pos_;
-    public:
-	
-        vertex_vector() 
-            : num_blocks_(0),
-              max_blocks_(0),
-              vertexs_(0),
-              commands_(0),
-              pos_(0) {}
-
-        ~vertex_vector()
-        {
-            if ( num_blocks_ )
-            {
-                value_type** vertexs=vertexs_ + num_blocks_ - 1;
-                while ( num_blocks_-- )
-                {
-                    delete [] *vertexs;
-                    --vertexs;
-                }
-                delete [] vertexs_;
-            }
-        }
-        unsigned size() const 
-        {
-            return pos_;
-        }
-	
-        void push_back (value_type x,value_type y,unsigned command)
-        {
-            unsigned block = pos_ >> block_shift;
-            if (block >= num_blocks_)
-            {
-                allocate_block(block);
-            }
-            value_type* vertex = vertexs_[block] + ((pos_ & block_mask) << 1);
-            unsigned char* cmd= commands_[block] + (pos_ & block_mask);
-	    
-            *cmd = static_cast<unsigned char>(command);
-            *vertex++ = x;
-            *vertex   = y;
-            ++pos_;
-        }
-        unsigned get_vertex(unsigned pos,value_type* x,value_type* y) const
-        {
-            if (pos >= pos_) return SEG_END;
-            unsigned block = pos >> block_shift;
-            const value_type* vertex = vertexs_[block] + (( pos & block_mask) << 1);
-            *x = (*vertex++);
-            *y = (*vertex);
-            return commands_[block] [pos & block_mask];
-        }
-        	
-        void transform_at(unsigned pos,const CoordTransform& t)
-        {
-            if (pos >= pos_) return;
-            unsigned block = pos >> block_shift;
-            value_type* vertex = vertexs_[block] + (( pos & block_mask) << 1);
-            t.forward_x(vertex);
-            ++vertex;
-            t.forward_y(vertex);
-        }
-        void set_capacity(size_t)
-        {
-            //do nothing
-        }
-    private:
-        void allocate_block(unsigned block)
-        {
-            if (block >= max_blocks_)
-            {
-                value_type** new_vertexs = new value_type* [(max_blocks_ + grow_by) * 2];
-                unsigned char** new_commands = (unsigned char**)(new_vertexs + max_blocks_ + grow_by);
-                if (vertexs_)
-                {
-                    std::memcpy(new_vertexs,vertexs_,max_blocks_ * sizeof(value_type*));
-                    std::memcpy(new_commands,commands_,max_blocks_ * sizeof(unsigned char*));
-                    delete [] vertexs_;
-                }
-                vertexs_ = new_vertexs;
-                commands_ = new_commands;
-                max_blocks_ += grow_by;
-            }
-            vertexs_[block] = new value_type [block_size * 2 + block_size / (sizeof(value_type))];
-            commands_[block] = (unsigned char*)(vertexs_[block] + block_size*2);
-            ++num_blocks_;
-        }
-    };
-
-    template <typename T>
-    struct vertex_vector2 : boost::noncopyable
-    {
-        typedef typename T::type value_type;
-        typedef boost::tuple<value_type,value_type,char> vertex_type;
-        typedef typename std::vector<vertex_type>::const_iterator const_iterator;
-        vertex_vector2() {}
-        unsigned size() const 
-        {
-            return cont_.size();
-        }
-
-        void push_back (value_type x,value_type y,unsigned command)
-        {
-            cont_.push_back(vertex_type(x,y,command));
-        }
-        unsigned get_vertex(unsigned pos,value_type* x,value_type* y) const
-        {
-            if (pos >= cont_.size()) return SEG_END;
-            vertex_type const& c = cont_[pos];
-            *x = boost::get<0>(c);
-            *y = boost::get<1>(c);
-            return boost::get<2>(c);
-        }
-        
-        const_iterator begin() const
-        {
-            return cont_.begin();
-        }
-        
-        const_iterator end() const
-        {
-            return cont_.end();
-        }
-
-        void transform_at(unsigned pos,const CoordTransform& t)
-        {
-            if (pos >= cont_.size()) return;
-            vertex_type & c = cont_[pos];
-            t.forward_x(&boost::get<0>(c));
-            t.forward_y(&boost::get<1>(c));
-        }
-        void set_capacity(size_t size)
-        {
-            cont_.reserve(size);
-        }
-    private:
-        std::vector<vertex_type> cont_;
-    };
-}
-
-#endif //VERTEX_VECTOR_HPP

Deleted: trunk/include/wkb.hpp
===================================================================
--- trunk/include/wkb.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/wkb.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,43 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: wkb.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef WKB_HPP
-#define WKB_HPP
-
-#include "geometry.hpp"
-#include "ctrans.hpp"
-
-namespace mapnik
-{
-    class MAPNIK_DECL geometry_utils 
-    {
-    public:
-	static geometry_ptr from_wkb(const char* wkb, unsigned size,int srid);
-    private:
-	geometry_utils();
-	geometry_utils(const geometry_utils&);
-	geometry_utils& operator=(const geometry_utils&);
-    };
-}
-#endif                                            //WKB_HPP

Modified: trunk/plugins/input/postgis/SConscript
===================================================================
--- trunk/plugins/input/postgis/SConscript	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/postgis/SConscript	2006-10-04 11:22:18 UTC (rev 313)
@@ -32,5 +32,5 @@
 
 postgis_inputdriver = env.SharedLibrary('postgis', source=postgis_src, SHLIBPREFIX='', LIBS='pq')
 
-env.Install(prefix + '/' + env['LIB_PLATFORM'] + '/mapnik/input', postgis_inputdriver)
-env.Alias('install', prefix + '/' + env['LIB_PLATFORM'] + '/mapnik/input')
+env.Install(prefix + '/' + env['LIBDIR_SCHEMA'] + '/mapnik/input', postgis_inputdriver)
+env.Alias('install', prefix + '/' + env['LIBDIR_SCHEMA'] + '/mapnik/input')

Modified: trunk/plugins/input/raster/SConscript
===================================================================
--- trunk/plugins/input/raster/SConscript	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/raster/SConscript	2006-10-04 11:22:18 UTC (rev 313)
@@ -33,5 +33,5 @@
 
 raster_inputdriver = env.SharedLibrary('raster', source=raster_src, SHLIBPREFIX='', LIBS=[])
 
-env.Install(prefix + '/' + env['LIB_PLATFORM'] + '/mapnik/input', raster_inputdriver)
-env.Alias('install', prefix + '/' + env['LIB_PLATFORM'] + '/mapnik/input')
+env.Install(prefix + '/' + env['LIBDIR_SCHEMA'] + '/mapnik/input', raster_inputdriver)
+env.Alias('install', prefix + '/' + env['LIBDIR_SCHEMA'] + '/mapnik/input')

Modified: trunk/plugins/input/raster/raster_datasource.cpp
===================================================================
--- trunk/plugins/input/raster/raster_datasource.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/raster/raster_datasource.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -20,13 +20,16 @@
  *
  *****************************************************************************/
 //$Id: raster_datasource.cc 44 2005-04-22 18:53:54Z pavlenko $
+// boost
+#include <boost/lexical_cast.hpp>
+// mapnik
+#include <mapnik/image_reader.hpp>
 
-#include "raster_datasource.hpp"
-#include "image_reader.hpp"
 #include "raster_featureset.hpp"
 #include "raster_info.hpp"
-#include <boost/lexical_cast.hpp>
 
+#include "raster_datasource.hpp"
+
 DATASOURCE_PLUGIN(raster_datasource)
 
 using std::clog;

Modified: trunk/plugins/input/raster/raster_datasource.hpp
===================================================================
--- trunk/plugins/input/raster/raster_datasource.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/raster/raster_datasource.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -24,10 +24,9 @@
 #ifndef RASTER_DATASOURCE_HH
 #define RASTER_DATASOURCE_HH 
 
-#include "datasource.hpp"
-#include "envelope.hpp"
-#include "feature.hpp"
-#include "image_reader.hpp"
+#include <mapnik/envelope.hpp>
+#include <mapnik/feature.hpp>
+#include <mapnik/datasource.hpp>
 
 using namespace mapnik;
 

Modified: trunk/plugins/input/raster/raster_featureset.cpp
===================================================================
--- trunk/plugins/input/raster/raster_featureset.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/raster/raster_featureset.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -19,9 +19,11 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
  *****************************************************************************/
+// mapnik
+#include <mapnik/image_reader.hpp>
+#include <mapnik/image_util.hpp>
+
 #include "raster_featureset.hpp"
-#include "image_reader.hpp"
-#include "image_util.hpp"
 
 template <typename LookupPolicy>
 raster_featureset<LookupPolicy>::raster_featureset(LookupPolicy const& policy,

Modified: trunk/plugins/input/raster/raster_featureset.hpp
===================================================================
--- trunk/plugins/input/raster/raster_featureset.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/raster/raster_featureset.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,9 +22,10 @@
 #ifndef RASTER_FEATURESET_HH
 #define RASTER_FEATURESET_HH
 
+#include <vector>
+
 #include "raster_datasource.hpp"
 #include "raster_info.hpp"
-#include <vector>
 
 using std::vector;
 

Modified: trunk/plugins/input/shape/SConscript
===================================================================
--- trunk/plugins/input/shape/SConscript	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/shape/SConscript	2006-10-04 11:22:18 UTC (rev 313)
@@ -38,5 +38,5 @@
 
 shape_inputdriver = env.SharedLibrary('shape', source=shape_src, SHLIBPREFIX='', LIBS=[])
 
-env.Install(prefix + '/' + env['LIB_PLATFORM'] + '/mapnik/input', shape_inputdriver)
-env.Alias('install', prefix + '/' + env['LIB_PLATFORM'] + '/mapnik/input')
+env.Install(prefix + '/' + env['LIBDIR_SCHEMA'] + '/mapnik/input', shape_inputdriver)
+env.Alias('install', prefix + '/' + env['LIBDIR_SCHEMA'] + '/mapnik/input')

Modified: trunk/plugins/input/shape/dbffile.cpp
===================================================================
--- trunk/plugins/input/shape/dbffile.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/shape/dbffile.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -19,13 +19,16 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
  *****************************************************************************/
-
-#include "dbffile.hpp"
-#include "utils.hpp"
+// stl
+#include <string>
+// boost
 #include <boost/algorithm/string.hpp>
 #include <boost/lexical_cast.hpp>
-#include <string>
+// mapnik
+#include <mapnik/utils.hpp>
 
+#include "dbffile.hpp"
+
 dbf_file::dbf_file()
     : num_records_(0),
       num_fields_(0),

Modified: trunk/plugins/input/shape/dbffile.hpp
===================================================================
--- trunk/plugins/input/shape/dbffile.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/shape/dbffile.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -20,15 +20,15 @@
  *
  *****************************************************************************/
 
-#ifndef DBFFILE_HH
-#define DBFFILE_HH
+#ifndef DBFFILE_HPP
+#define DBFFILE_HPP
 
 #include <vector>
 #include <string>
 #include <fstream>
 #include <cassert>
 
-#include "feature.hpp"
+#include <mapnik/feature.hpp>
 
 using namespace mapnik;
 
@@ -44,34 +44,35 @@
 
 class dbf_file
 {
-    private:
+private:
 
-        int num_records_;
-        int num_fields_;
-        int record_length_;
-        std::vector<field_descriptor> fields_;
-        std::ifstream file_;
-        char* record_;
-    public:
-        dbf_file();
-        dbf_file(const char* file_name);
-        dbf_file(const std::string& file_name);
-        ~dbf_file();
-        bool open(const std::string& file_name);
-        bool is_open();
-        void close();
-        int num_records() const;
-        int num_fields() const;
-        field_descriptor const& descriptor(int col) const;
-        void move_to(int index);
-        std::string string_value(int col) const;
-        void add_attribute(int col,Feature const& f) const throw();
-    private:
-        dbf_file(const dbf_file&);
-        dbf_file& operator=(const dbf_file&);
-        void read_header();
-        int read_short();
-        int read_int();
-        void skip(int bytes);
+    int num_records_;
+    int num_fields_;
+    int record_length_;
+    std::vector<field_descriptor> fields_;
+    std::ifstream file_;
+    char* record_;
+public:
+    dbf_file();
+    dbf_file(const char* file_name);
+    dbf_file(const std::string& file_name);
+    ~dbf_file();
+    bool open(const std::string& file_name);
+    bool is_open();
+    void close();
+    int num_records() const;
+    int num_fields() const;
+    field_descriptor const& descriptor(int col) const;
+    void move_to(int index);
+    std::string string_value(int col) const;
+    void add_attribute(int col,Feature const& f) const throw();
+private:
+    dbf_file(const dbf_file&);
+    dbf_file& operator=(const dbf_file&);
+    void read_header();
+    int read_short();
+    int read_int();
+    void skip(int bytes);
 };
-#endif                                            //DBFFILE_HH
+
+#endif //DBFFILE_HPP

Modified: trunk/plugins/input/shape/shape.cpp
===================================================================
--- trunk/plugins/input/shape/shape.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/shape/shape.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -20,13 +20,17 @@
  *
  *****************************************************************************/
 
-#include "shape.hpp"
+#include <iostream>
+#include <fstream>
+#include <stdexcept>
+
+#include <mapnik/geom_util.hpp>
+
+
 #include "shape_featureset.hpp"
 #include "shape_index_featureset.hpp"
-#include "geom_util.hpp"
 
-#include <iostream>
-#include <stdexcept>
+#include "shape.hpp"
 
 DATASOURCE_PLUGIN(shape_datasource)
 

Modified: trunk/plugins/input/shape/shape.hpp
===================================================================
--- trunk/plugins/input/shape/shape.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/shape/shape.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -20,11 +20,14 @@
  *
  *****************************************************************************/
 
-#ifndef SHAPE_HH
-#define SHAPE_HH
+// $Id$
 
-#include "datasource.hpp"
-#include "envelope.hpp"
+#ifndef SHAPE_HPP
+#define SHAPE_HPP
+
+#include <mapnik/datasource.hpp>
+#include <mapnik/envelope.hpp>
+
 #include "shape_io.hpp"
 
 using namespace mapnik;
@@ -54,4 +57,4 @@
     static std::string name_;
 };
 
-#endif //SHAPE_HH
+#endif //SHAPE_HPP

Modified: trunk/plugins/input/shape/shape_featureset.cpp
===================================================================
--- trunk/plugins/input/shape/shape_featureset.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/shape/shape_featureset.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -20,8 +20,8 @@
  *
  *****************************************************************************/
 
+#include <iostream>
 #include "shape_featureset.hpp"
-#include <iostream>
 
 template <typename filterT>
 shape_featureset<filterT>::shape_featureset(const filterT& filter, 

Modified: trunk/plugins/input/shape/shape_featureset.hpp
===================================================================
--- trunk/plugins/input/shape/shape_featureset.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/shape/shape_featureset.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -23,8 +23,8 @@
 #ifndef SHAPE_FS_HH
 #define SHAPE_FS_HH
 
+#include <mapnik/geom_util.hpp>
 #include "shape.hpp"
-#include "geom_util.hpp"
 
 using namespace mapnik;
 
@@ -42,7 +42,7 @@
     mutable int count_;
 public:
     shape_featureset(const filterT& filter, const std::string& shape_file,
-		     const std::set<std::string>& attribute_names,long file_length);
+                     const std::set<std::string>& attribute_names,long file_length);
     virtual ~shape_featureset();
     feature_ptr next();
 private:

Modified: trunk/plugins/input/shape/shape_index_featureset.cpp
===================================================================
--- trunk/plugins/input/shape/shape_index_featureset.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/shape/shape_index_featureset.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,8 +22,8 @@
 
 //$Id: shape_index_featureset.cc 36 2005-04-05 14:32:18Z pavlenko $
 
+#include <mapnik/feature_factory.hpp>
 #include "shape_index_featureset.hpp"
-#include "feature_factory.hpp"
 
 template <typename filterT>
 shape_index_featureset<filterT>::shape_index_featureset(const filterT& filter,

Modified: trunk/plugins/input/shape/shape_index_featureset.hpp
===================================================================
--- trunk/plugins/input/shape/shape_index_featureset.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/shape/shape_index_featureset.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -20,13 +20,14 @@
  *
  *****************************************************************************/
 
-#ifndef SHAPE_SQT_FS_HH
-#define SHAPE_SQT_FS_HH
+#ifndef SHAPE_INDEX_FEATURESET_HPP
+#define SHAPE_INDEX_FEATURESET_HPP
 
-#include "shape_featureset.hpp"
 #include <set>
 #include <vector>
 
+#include "shape_featureset.hpp"
+
 template <typename filterT>
 class MAPNIK_DECL shape_index_featureset : public Featureset
 {
@@ -42,7 +43,7 @@
 
 public:
     shape_index_featureset(const filterT& filter,const std::string& shape_file,
-			   const std::set<std::string>& attribute_names);
+                           const std::set<std::string>& attribute_names);
     virtual ~shape_index_featureset();
     feature_ptr next();
 private:
@@ -50,4 +51,5 @@
     shape_index_featureset(const shape_index_featureset&);
     shape_index_featureset& operator=(const shape_index_featureset&);
 };
-#endif //SHAPE_SQT_FS_HH
+
+#endif //SHAPE_INDEX_FEATURESET_HPP

Modified: trunk/plugins/input/shape/shapefile.cpp
===================================================================
--- trunk/plugins/input/shape/shapefile.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/shape/shapefile.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -24,7 +24,6 @@
 
 shape_file::shape_file() {}
 
-
 shape_file::shape_file(const std::string& file_name)
 {
     //file_.rdbuf()->pubsetbuf(buff_,buffer_size);

Modified: trunk/plugins/input/shape/shapefile.hpp
===================================================================
--- trunk/plugins/input/shape/shapefile.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/shape/shapefile.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,12 +22,12 @@
 
 //$Id: shapefile.hh 33 2005-04-04 13:01:03Z pavlenko $
 
-#ifndef SHAPEFILE_HH
-#define SHAPEFILE_HH
+#ifndef SHAPEFILE_HPP
+#define SHAPEFILE_HPP
 
 #include <fstream>
 
-#include "envelope.hpp"
+#include <mapnik/envelope.hpp>
 
 using namespace mapnik;
 
@@ -37,64 +37,66 @@
     size_t size;
     size_t pos;
     explicit shape_record(size_t size)
-	: data(static_cast<char*>(::operator new(sizeof(char)*size))),
-	  size(size),
-	  pos(0) {}
+        : data(static_cast<char*>(::operator new(sizeof(char)*size))),
+          size(size),
+          pos(0) {}
     
     char* rawdata()
     {
-	return &data[0]; 
+        return &data[0]; 
     }
+
     void skip(unsigned n)
     {
-	pos+=n;
+        pos+=n;
     }
+
     int read_ndr_integer()
     {
-	int val=(data[pos] & 0xff)     | 
-	    (data[pos+1] & 0xff) << 8  |
-	    (data[pos+2] & 0xff) << 16 |
-	    (data[pos+3] & 0xff) << 24;
-	pos+=4;
-	return val;
+        int val=(data[pos] & 0xff)     | 
+            (data[pos+1] & 0xff) << 8  |
+            (data[pos+2] & 0xff) << 16 |
+            (data[pos+3] & 0xff) << 24;
+        pos+=4;
+        return val;
     }
     
     int read_xdr_integer()
     {
-	int val=(data[pos] & 0xff) << 24 | 
-	    (data[pos+1] & 0xff)   << 16   |
-	    (data[pos+2] & 0xff)   << 8    |
-	    (data[pos+3] & 0xff);
-	pos+=4;
-	return val;
+        int val=(data[pos] & 0xff) << 24 | 
+            (data[pos+1] & 0xff)   << 16   |
+            (data[pos+2] & 0xff)   << 8    |
+            (data[pos+3] & 0xff);
+        pos+=4;
+        return val;
     }
     
     double read_double()
     {
-	double val;		
+        double val;		
 #ifndef WORDS_BIGENDIAN
-	std::memcpy(&val,&data[pos],8);	
+        std::memcpy(&val,&data[pos],8);	
 #else
        	long long bits = ((long long)data[pos] & 0xff) | 
-	    ((long long)data[pos+1] & 0xff) << 8   |
-	    ((long long)data[pos+2] & 0xff) << 16  |
-	    ((long long)data[pos+3] & 0xff) << 24  |
-	    ((long long)data[pos+4] & 0xff) << 32  |
-	    ((long long)data[pos+5] & 0xff) << 40  |
-	    ((long long)data[pos+6] & 0xff) << 48  |
-	    ((long long)data[pos+7] & 0xff) << 56  ;
-	std::memcpy(&val,&bits,8);
+            ((long long)data[pos+1] & 0xff) << 8   |
+            ((long long)data[pos+2] & 0xff) << 16  |
+            ((long long)data[pos+3] & 0xff) << 24  |
+            ((long long)data[pos+4] & 0xff) << 32  |
+            ((long long)data[pos+5] & 0xff) << 40  |
+            ((long long)data[pos+6] & 0xff) << 48  |
+            ((long long)data[pos+7] & 0xff) << 56  ;
+        std::memcpy(&val,&bits,8);
 #endif 
-	pos+=8;
-	return val;
+        pos+=8;
+        return val;
     }
     long remains() 
     {
-	return (size-pos);
+        return (size-pos);
     }
     ~shape_record() 
     {
-	::operator delete(data);
+        ::operator delete(data);
     }	
 };
 
@@ -113,88 +115,87 @@
     
     inline void read_record(shape_record& rec)
     {
-	file_.read(rec.rawdata(),rec.size);  
+        file_.read(rec.rawdata(),rec.size);  
     }
 
     inline int read_xdr_integer()
     {
-	char b[4];
-	file_.read(b, 4);
-	return b[3] & 0xffu | (b[2] & 0xffu) << 8 |
-	    (b[1] & 0xffu) << 16 | (b[0] & 0xffu) << 24;
+        char b[4];
+        file_.read(b, 4);
+        return b[3] & 0xffu | (b[2] & 0xffu) << 8 |
+            (b[1] & 0xffu) << 16 | (b[0] & 0xffu) << 24;
     }
 
     inline int read_ndr_integer()
     {
-	char b[4];
-	file_.read(b,4);
-	return b[0]&0xffu | (b[1]&0xffu) << 8 | 
-	    (b[2]&0xffu) << 16 | (b[3]&0xffu) << 24;
+        char b[4];
+        file_.read(b,4);
+        return b[0]&0xffu | (b[1]&0xffu) << 8 | 
+            (b[2]&0xffu) << 16 | (b[3]&0xffu) << 24;
     }
 
     inline double read_double()
     {
-	double val;
+        double val;
 #ifndef WORDS_BIGENDIAN
-	file_.read(reinterpret_cast<char*>(&val),8);
+        file_.read(reinterpret_cast<char*>(&val),8);
 #else
-	char b[8];
-	file_.read(b,8);
-	long long bits = ((long long)b[0] & 0xff) | 
-	    ((long long)b[1] & 0xff) << 8   |
-	    ((long long)b[2] & 0xff) << 16  |
-	    ((long long)b[3] & 0xff) << 24  |
-	    ((long long)b[4] & 0xff) << 32  |
-	    ((long long)b[5] & 0xff) << 40  |
-	    ((long long)b[6] & 0xff) << 48  |
-	    ((long long)b[7] & 0xff) << 56  ;
-	memcpy(&val,&bits,8);
+        char b[8];
+        file_.read(b,8);
+        long long bits = ((long long)b[0] & 0xff) | 
+            ((long long)b[1] & 0xff) << 8   |
+            ((long long)b[2] & 0xff) << 16  |
+            ((long long)b[3] & 0xff) << 24  |
+            ((long long)b[4] & 0xff) << 32  |
+            ((long long)b[5] & 0xff) << 40  |
+            ((long long)b[6] & 0xff) << 48  |
+            ((long long)b[7] & 0xff) << 56  ;
+        memcpy(&val,&bits,8);
 #endif
-	return val;
+        return val;
     }
 
     inline void read_envelope(Envelope<double>& envelope)
     {
 #ifndef WORDS_BIGENDIAN
-	file_.read(reinterpret_cast<char*>(&envelope),sizeof(envelope));
+        file_.read(reinterpret_cast<char*>(&envelope),sizeof(envelope));
 #else
-	double minx=read_double();
-	double miny=read_double();
-	double maxx=read_double();
-	double maxy=read_double();
-	envelope.init(minx,miny,maxx,maxy);
+        double minx=read_double();
+        double miny=read_double();
+        double maxx=read_double();
+        double maxy=read_double();
+        envelope.init(minx,miny,maxx,maxy);
 #endif  
     }
 
     inline void skip(std::streampos bytes)
     {
-	file_.seekg(bytes,std::ios::cur);
+        file_.seekg(bytes,std::ios::cur);
     }
 
     inline void rewind()
     {
-	seek(100);
+        seek(100);
     }
 
     inline void seek(std::streampos pos)
     {
-	file_.seekg(pos,std::ios::beg);
+        file_.seekg(pos,std::ios::beg);
     }
 
-
     inline std::streampos pos()
     {
-	return file_.tellg();
+        return file_.tellg();
     }
 
-
     inline bool is_eof()
     {
-	return file_.eof();
+        return file_.eof();
     }
     
 private:
     shape_file(const shape_file&);
     shape_file& operator=(const shape_file&);
 };
-#endif                                            //SHAPEFILE_HH
+
+#endif //SHAPEFILE_HPP

Modified: trunk/plugins/input/shape/shp_index.cpp
===================================================================
--- trunk/plugins/input/shape/shp_index.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/shape/shp_index.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -19,9 +19,8 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
  *****************************************************************************/
-
+#include <mapnik/geom_util.hpp>
 #include "shp_index.hpp"
-#include "geom_util.hpp"
 
 template <typename filterT>
 void shp_index<filterT>::query(const filterT& filter,std::ifstream& file,std::set<int>& pos)

Modified: trunk/plugins/input/shape/shp_index.hpp
===================================================================
--- trunk/plugins/input/shape/shp_index.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/shape/shp_index.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -23,10 +23,12 @@
 #ifndef SHP_INDEX_HH
 #define SHP_INDEX_HH
 
-#include "envelope.hpp"
-#include "query.hpp"
+// st
 #include <fstream>
 #include <set>
+// mapnik
+#include <mapnik/envelope.hpp>
+#include <mapnik/query.hpp>
 
 using namespace mapnik;
 

Modified: trunk/src/SConscript
===================================================================
--- trunk/src/SConscript	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/SConscript	2006-10-04 11:22:18 UTC (rev 313)
@@ -32,32 +32,33 @@
 
 source = Split(
     """
+    agg_renderer.cpp
     datasource_cache.cpp
     envelope.cpp
+    filter_factory.cpp
+    font_engine_freetype.cpp
     graphics.cpp
     image_reader.cpp
     image_util.cpp
     layer.cpp
+    line_pattern_symbolizer.cpp
+    load_map.cpp
     map.cpp
     memory.cpp
     params.cpp
     plugin.cpp
     png_reader.cpp
-    tiff_reader.cpp
-    wkb.cpp
-    agg_renderer.cpp
     point_symbolizer.cpp
     polygon_pattern_symbolizer.cpp
-    line_pattern_symbolizer.cpp
+    save_map.cpp
     text_symbolizer.cpp
-    font_engine_freetype.cpp
-    load_map.cpp
-    save_map.cpp
+    tiff_reader.cpp
+    wkb.cpp
     """
     )
 
 mapnik = env.SharedLibrary('mapnik', source, LIBS=libraries, LINKFLAGS=linkflags)
 
-env.Alias(target='install', source=env.Install(prefix + '/' + env['LIB_PLATFORM'], mapnik))
-includes = glob.glob('../include' + '/*.hpp')
+env.Alias(target='install', source=env.Install(prefix + '/' + env['LIBDIR_SCHEMA'], mapnik))
+includes = glob.glob('../include/mapnik' + '/*.hpp')
 env.Alias(target='install', source=env.Install(prefix+'/include/mapnik', includes))

Modified: trunk/src/agg_renderer.cpp
===================================================================
--- trunk/src/agg_renderer.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/agg_renderer.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -21,8 +21,11 @@
  *****************************************************************************/
 //$Id$
 
-#include "agg_renderer.hpp"
-
+// stl
+#include <iostream>
+// boost
+#include <boost/utility.hpp>
+// agg
 #include "agg_basics.h"
 #include "agg_rendering_buffer.h"
 #include "agg_rasterizer_scanline_aa.h"
@@ -52,12 +55,11 @@
 #include "agg_renderer_scanline.h"
 #include "agg_pattern_filters_rgba.h"
 #include "agg_renderer_outline_image.h"
+// mapnik
+#include <mapnik/image_util.hpp>
+#include <mapnik/agg_renderer.hpp>
 
-#include <boost/utility.hpp>
-#include <iostream>
-#include "image_util.hpp"
-
-namespace mapnik
+namespace mapnik 
 {
     class pattern_source : private boost::noncopyable
     {
@@ -76,7 +78,10 @@
         agg::rgba8 pixel(int x, int y) const
         {
             unsigned c = pattern_(x,y);
-            return agg::rgba8(c & 0xff, (c >> 8) & 0xff, (c >> 16) & 0xff,(c >> 24) & 0xff);
+            return agg::rgba8(c & 0xff, 
+                              (c >> 8) & 0xff, 
+                              (c >> 16) & 0xff,
+                              (c >> 24) & 0xff);
         }
     private:
         ImageData32 const& pattern_;
@@ -97,7 +102,8 @@
     template <typename T>
     void agg_renderer<T>::start_map_processing(Map const& map)
     {
-        std::clog << "start map processing bbox=" << map.getCurrentExtent() <<  std::endl;
+        std::clog << "start map processing bbox=" 
+                  << map.getCurrentExtent() << "\n";
     }
 
     template <typename T>
@@ -460,7 +466,6 @@
                 }
             }  
         }
-    }
-    
+    }   
     template class agg_renderer<Image32>;
 }

Modified: trunk/src/datasource_cache.cpp
===================================================================
--- trunk/src/datasource_cache.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/datasource_cache.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -21,13 +21,14 @@
  *****************************************************************************/
 //$Id: datasource_cache.cpp 23 2005-03-22 22:16:34Z pavlenko $
 
-#include "datasource_cache.hpp"
-
+// stl
 #include <algorithm>
 #include <stdexcept>
-
+// boost
 #include <boost/thread/mutex.hpp>
 #include <boost/filesystem/operations.hpp>
+// mapnik
+#include <mapnik/datasource_cache.hpp>
 
 namespace mapnik
 {
@@ -58,7 +59,8 @@
             {
                 if (itr->second->handle())
                 {
-                    create_ds* create_datasource = (create_ds*) lt_dlsym(itr->second->handle(), "create");
+                    create_ds* create_datasource = 
+                        (create_ds*) lt_dlsym(itr->second->handle(), "create");
                     if (!create_datasource)
                     {
                         std::clog << "Cannot load symbols: " << lt_dlerror() << std::endl;
@@ -88,7 +90,8 @@
 
     bool datasource_cache::insert(const std::string& type,const lt_dlhandle module)
     {	      
-        return plugins_.insert(make_pair(type,boost::shared_ptr<PluginInfo>(new PluginInfo(type,module)))).second;     
+        return plugins_.insert(make_pair(type,boost::shared_ptr<PluginInfo>
+                                         (new PluginInfo(type,module)))).second;     
     }
 
     void datasource_cache::register_datasources(const std::string& str)
@@ -106,7 +109,8 @@
                     lt_dlhandle module=lt_dlopenext(itr->string().c_str());
                     if (module)
                     {
-                        datasource_name* ds_name = (datasource_name*) lt_dlsym(module, "datasource_name");
+                        datasource_name* ds_name = 
+                            (datasource_name*) lt_dlsym(module, "datasource_name");
                         if (ds_name && insert(ds_name(),module))
                         {                           
                             std::clog<<"registered datasource : "<<ds_name()<<std::endl;

Modified: trunk/src/envelope.cpp
===================================================================
--- trunk/src/envelope.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/envelope.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -21,34 +21,34 @@
  *****************************************************************************/
 //$Id: envelope.cpp 17 2005-03-08 23:58:43Z pavlenko $
 
-#include "envelope.hpp"
+#include <mapnik/envelope.hpp>
 
 namespace mapnik
 {
     template <typename T>
-        Envelope<T>::Envelope()
+    Envelope<T>::Envelope()
         :minx_(0),miny_(0),maxx_(-1),maxy_(-1) {}
 
     template <typename T>
-        Envelope<T>::Envelope(T minx_,T miny_,T maxx_,T maxy_)
+    Envelope<T>::Envelope(T minx_,T miny_,T maxx_,T maxy_)
     {
         init(minx_,miny_,maxx_,maxy_);
     }
 
     template <typename T>
-        Envelope<T>::Envelope(const coord<T,2> &c0,const coord<T,2> &c1)
+    Envelope<T>::Envelope(const coord<T,2> &c0,const coord<T,2> &c1)
     {
         init(c0.x,c0.y,c1.x,c1.y);
     }
 
     template <typename T>
-        Envelope<T>::Envelope(const Envelope &rhs)
+    Envelope<T>::Envelope(const Envelope &rhs)
     {
         init(rhs.minx_,rhs.miny_,rhs.maxx_,rhs.maxy_);
     }
 
     template <typename T>
-        inline bool Envelope<T>::operator==(const Envelope<T>& other) const
+    inline bool Envelope<T>::operator==(const Envelope<T>& other) const
     {
         return minx_==other.minx_ &&
             miny_==other.miny_ &&
@@ -57,43 +57,43 @@
     }
 
     template <typename T>
-        inline T Envelope<T>::minx() const
+    inline T Envelope<T>::minx() const
     {
         return minx_;
     }
 
     template <typename T>
-        inline T Envelope<T>::maxx() const
+    inline T Envelope<T>::maxx() const
     {
         return maxx_;
     }
 
     template <typename T>
-        inline T Envelope<T>::miny() const
+    inline T Envelope<T>::miny() const
     {
         return miny_;
     }
 
     template <typename T>
-        inline T Envelope<T>::maxy() const
+    inline T Envelope<T>::maxy() const
     {
         return maxy_;
     }
 
     template <typename T>
-        inline T Envelope<T>::width() const
+    inline T Envelope<T>::width() const
     {
         return maxx_-minx_;
     }
 
     template <typename T>
-        inline T Envelope<T>::height() const
+    inline T Envelope<T>::height() const
     {
         return maxy_-miny_;
     }
 
     template <typename T>
-        inline void Envelope<T>::width(T w)
+    inline void Envelope<T>::width(T w)
     {
         T cx=center().x;
         minx_=static_cast<T>(cx-w*0.5);
@@ -101,7 +101,7 @@
     }
 
     template <typename T>
-        inline void Envelope<T>::height(T h)
+    inline void Envelope<T>::height(T h)
     {
         T cy=center().y;
         miny_=static_cast<T>(cy-h*0.5);
@@ -109,20 +109,20 @@
     }
 
     template <typename T>
-        inline coord<T,2> Envelope<T>::center() const
+    inline coord<T,2> Envelope<T>::center() const
     {
         return coord<T,2>(static_cast<T>(0.5*(minx_+maxx_)),
-            static_cast<T>(0.5*(miny_+maxy_)));
+                          static_cast<T>(0.5*(miny_+maxy_)));
     }
 
     template <typename T>
-        inline void Envelope<T>::expand_to_include(const coord<T,2>& c)
+    inline void Envelope<T>::expand_to_include(const coord<T,2>& c)
     {
         expand_to_include(c.x,c.y);
     }
 
     template <typename T>
-        inline void Envelope<T>::expand_to_include(T x,T y)
+    inline void Envelope<T>::expand_to_include(T x,T y)
     {
         if (x<minx_) minx_=x;
         if (x>maxx_) maxx_=x;
@@ -131,7 +131,7 @@
     }
 
     template <typename T>
-        void Envelope<T>::expand_to_include(const Envelope<T> &other)
+    void Envelope<T>::expand_to_include(const Envelope<T> &other)
     {
         if (other.minx_<minx_) minx_=other.minx_;
         if (other.maxx_>maxx_) maxx_=other.maxx_;
@@ -140,19 +140,19 @@
     }
 
     template <typename T>
-        inline bool Envelope<T>::contains(const coord<T,2> &c) const
+    inline bool Envelope<T>::contains(const coord<T,2> &c) const
     {
         return contains(c.x,c.y);
     }
 
     template <typename T>
-        inline bool Envelope<T>::contains(T x,T y) const
+    inline bool Envelope<T>::contains(T x,T y) const
     {
         return x>=minx_ && x<=maxx_ && y>=miny_ && y<=maxy_;
     }
 
     template <typename T>
-        inline bool Envelope<T>::contains(const Envelope<T> &other) const
+    inline bool Envelope<T>::contains(const Envelope<T> &other) const
     {
         return other.minx_>=minx_ &&
             other.maxx_<=maxx_ &&
@@ -161,26 +161,26 @@
     }
 
     template <typename T>
-        inline bool Envelope<T>::intersects(const coord<T,2> &c) const
+    inline bool Envelope<T>::intersects(const coord<T,2> &c) const
     {
         return intersects(c.x,c.y);
     }
 
     template <typename T>
-        bool Envelope<T>::intersects(T x,T y) const
+    bool Envelope<T>::intersects(T x,T y) const
     {
         return !(x>maxx_ || x<minx_ || y>maxy_ || y<miny_);
     }
 
     template <typename T>
-        inline bool Envelope<T>::intersects(const Envelope<T> &other) const
+    inline bool Envelope<T>::intersects(const Envelope<T> &other) const
     {
         return !(other.minx_>maxx_ || other.maxx_<minx_ ||
-            other.miny_>maxy_ || other.maxy_<miny_);
+                 other.miny_>maxy_ || other.maxy_<miny_);
     }
 
     template <typename T>
-        inline Envelope<T> Envelope<T>::intersect(const EnvelopeType& other) const
+    inline Envelope<T> Envelope<T>::intersect(const EnvelopeType& other) const
     {
 
         T x0=std::max(minx_,other.minx_);
@@ -193,7 +193,7 @@
     }
 
     template <typename T>
-        inline void Envelope<T>::re_center(T cx,T cy)
+    inline void Envelope<T>::re_center(T cx,T cy)
     {
         T dx=cx-center().x;
         T dy=cy-center().y;
@@ -204,7 +204,7 @@
     }
 
     template <typename T>
-        inline void Envelope<T>::init(T x0,T y0,T x1,T y1)
+    inline void Envelope<T>::init(T x0,T y0,T x1,T y1)
     {
         if (x0<x1)
         {

Modified: trunk/src/filter_factory.cpp
===================================================================
--- trunk/src/filter_factory.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/filter_factory.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -21,7 +21,7 @@
  *****************************************************************************/
 //$Id$
 
-#include "filter_factory.hpp"
+#include <mapnik/filter_factory.hpp>
 
 namespace mapnik
 {

Modified: trunk/src/font_engine_freetype.cpp
===================================================================
--- trunk/src/font_engine_freetype.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/font_engine_freetype.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -21,7 +21,7 @@
  *****************************************************************************/
 //$Id$
 
-#include "font_engine_freetype.hpp"
+#include <mapnik/font_engine_freetype.hpp>
 
 namespace mapnik
 {

Modified: trunk/src/graphics.cpp
===================================================================
--- trunk/src/graphics.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/graphics.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -21,24 +21,26 @@
  *****************************************************************************/
 //$Id: graphics.cpp 17 2005-03-08 23:58:43Z pavlenko $
 
+// stl
 #include <cassert>
 #include <string.h>
 #include <stack>
 #include <iostream>
-#include "graphics.hpp"
-#include "image_util.hpp"
+// mapnik
+#include <mapnik/graphics.hpp>
+#include <mapnik/image_util.hpp>
 
 namespace mapnik
 {
     Image32::Image32(int width,int height)
         :width_(width),
-        height_(height),
-        data_(width,height) {}
+         height_(height),
+         data_(width,height) {}
 
     Image32::Image32(const Image32& rhs)
         :width_(rhs.width_),
-        height_(rhs.height_),
-        data_(rhs.data_) {}
+         height_(rhs.height_),
+         data_(rhs.data_) {}
 
     Image32::~Image32() {}
 

Modified: trunk/src/image_reader.cpp
===================================================================
--- trunk/src/image_reader.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/image_reader.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -21,10 +21,9 @@
  *****************************************************************************/
 //$Id: image_reader.cpp 17 2005-03-08 23:58:43Z pavlenko $
 
+#include <mapnik/factory.hpp>
+#include <mapnik/image_reader.hpp>
 
-#include "image_reader.hpp"
-#include "factory.hpp"
-
 namespace mapnik
 {  
     typedef factory<ImageReader,std::string, 

Modified: trunk/src/image_util.cpp
===================================================================
--- trunk/src/image_util.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/image_util.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,15 +22,17 @@
 
 //$Id: image_util.cpp 36 2005-04-05 14:32:18Z pavlenko $
 
+// stl
 #include <string>
-#include "graphics.hpp"
-#include "memory.hpp"
-#include "image_util.hpp"
-
+// mapnik
+#include <mapnik/graphics.hpp>
+#include <mapnik/memory.hpp>
+#include <mapnik/image_util.hpp>
+// jpeg png
 extern "C"
 {
-  #include <png.h>
-  #include <jpeglib.h>
+#include <png.h>
+#include <jpeglib.h>
 }
 
 namespace mapnik
@@ -47,7 +49,9 @@
         Object::operator delete(ptr);
     }
     //
-    void ImageUtils::save_to_file(const std::string& filename,const std::string& type,const Image32& image)
+    void ImageUtils::save_to_file(const std::string& filename,
+                                  const std::string& type,
+                                  const Image32& image)
     {
         //all that should go into image_writer factory
         if (type=="png")
@@ -66,20 +70,20 @@
         if (!fp) return;
         png_voidp mem_ptr=0;
         png_structp png_ptr=png_create_write_struct(PNG_LIBPNG_VER_STRING,
-						    (png_voidp)mem_ptr,0, 0);
+                                                    (png_voidp)mem_ptr,0, 0);
 	
         if (!png_ptr) return;
         png_set_mem_fn(png_ptr,mem_ptr,malloc_fn,free_fn);
 
         // switch on optimization
-	#if defined(PNG_LIBPNG_VER) && (PNG_LIBPNG_VER >= 10200)
+#if defined(PNG_LIBPNG_VER) && (PNG_LIBPNG_VER >= 10200)
         png_uint_32 mask, flags;
 
         flags = png_get_asm_flags(png_ptr);
         mask = png_get_asm_flagmask(PNG_SELECT_READ | PNG_SELECT_WRITE);
         png_set_asm_flags(png_ptr, flags | mask);
-	#endif
-	png_set_filter (png_ptr, 0, PNG_FILTER_NONE);
+#endif
+        png_set_filter (png_ptr, 0, PNG_FILTER_NONE);
         png_infop info_ptr = png_create_info_struct(png_ptr);
         if (!info_ptr)
         {
@@ -95,11 +99,11 @@
         }
 
         png_init_io(png_ptr, fp);
-	//png_set_compression_level(png_ptr, Z_BEST_COMPRESSION);
-	//png_set_compression_strategy(png_ptr, Z_FILTERED);
+        //png_set_compression_level(png_ptr, Z_BEST_COMPRESSION);
+        //png_set_compression_strategy(png_ptr, Z_FILTERED);
         png_set_IHDR(png_ptr, info_ptr,image.width(),image.height(),8,
-            PNG_COLOR_TYPE_RGB_ALPHA,PNG_INTERLACE_NONE,
-            PNG_COMPRESSION_TYPE_DEFAULT,PNG_FILTER_TYPE_DEFAULT);
+                     PNG_COLOR_TYPE_RGB_ALPHA,PNG_INTERLACE_NONE,
+                     PNG_COMPRESSION_TYPE_DEFAULT,PNG_FILTER_TYPE_DEFAULT);
         png_write_info(png_ptr, info_ptr);
 
         const ImageData32& imageData=image.data();
@@ -116,43 +120,43 @@
 
     void ImageUtils::save_as_jpeg(const std::string& filename,int quality, const Image32& image)
     {
-	FILE *fp=fopen(filename.c_str(), "wb");
+        FILE *fp=fopen(filename.c_str(), "wb");
         if (!fp) return;
-	struct jpeg_compress_struct cinfo;
-	struct jpeg_error_mgr jerr;
+        struct jpeg_compress_struct cinfo;
+        struct jpeg_error_mgr jerr;
 
-	int width=image.width();
-	int height=image.height();
+        int width=image.width();
+        int height=image.height();
 	
-	cinfo.err = jpeg_std_error(&jerr);
-	jpeg_create_compress(&cinfo);
-	jpeg_stdio_dest(&cinfo, fp);
-	cinfo.image_width = width;
-	cinfo.image_height = height;
-	cinfo.input_components = 3;
-	cinfo.in_color_space = JCS_RGB; 
-	jpeg_set_defaults(&cinfo);
-	jpeg_set_quality(&cinfo, quality,1);
-	jpeg_start_compress(&cinfo, 1);
-	JSAMPROW row_pointer[1];
-	JSAMPLE* row=new JSAMPLE[width*3];
-	const ImageData32& imageData=image.data();
-	while (cinfo.next_scanline < cinfo.image_height) 
-	{
-	    const unsigned* imageRow=imageData.getRow(cinfo.next_scanline);
-	    int index=0;
-	    for (int i=0;i<width;++i)
-	    {
-		row[index++]=(imageRow[i])&0xff;
-		row[index++]=(imageRow[i]>>8)&0xff;
-		row[index++]=(imageRow[i]>>16)&0xff;
-	    }
-	    row_pointer[0] = &row[0];
-	    (void) jpeg_write_scanlines(&cinfo, row_pointer, 1);
-	}
-	delete [] row;
-	jpeg_finish_compress(&cinfo);
-	fclose(fp);
-	jpeg_destroy_compress(&cinfo);
+        cinfo.err = jpeg_std_error(&jerr);
+        jpeg_create_compress(&cinfo);
+        jpeg_stdio_dest(&cinfo, fp);
+        cinfo.image_width = width;
+        cinfo.image_height = height;
+        cinfo.input_components = 3;
+        cinfo.in_color_space = JCS_RGB; 
+        jpeg_set_defaults(&cinfo);
+        jpeg_set_quality(&cinfo, quality,1);
+        jpeg_start_compress(&cinfo, 1);
+        JSAMPROW row_pointer[1];
+        JSAMPLE* row=new JSAMPLE[width*3];
+        const ImageData32& imageData=image.data();
+        while (cinfo.next_scanline < cinfo.image_height) 
+        {
+            const unsigned* imageRow=imageData.getRow(cinfo.next_scanline);
+            int index=0;
+            for (int i=0;i<width;++i)
+            {
+                row[index++]=(imageRow[i])&0xff;
+                row[index++]=(imageRow[i]>>8)&0xff;
+                row[index++]=(imageRow[i]>>16)&0xff;
+            }
+            row_pointer[0] = &row[0];
+            (void) jpeg_write_scanlines(&cinfo, row_pointer, 1);
+        }
+        delete [] row;
+        jpeg_finish_compress(&cinfo);
+        fclose(fp);
+        jpeg_destroy_compress(&cinfo);
     }
 }

Modified: trunk/src/layer.cpp
===================================================================
--- trunk/src/layer.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/layer.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,18 +22,22 @@
 
 //$Id: layer.cpp 17 2005-03-08 23:58:43Z pavlenko $
 
-
-#include "style.hpp"
-#include "datasource.hpp"
-#include "datasource_cache.hpp"
-#include "layer.hpp"
-
+// stl
 #include <string>
 #include <iostream>
+// boost
+#include <boost/shared_ptr.hpp>
+// mapnik
+#include <mapnik/style.hpp>
+#include <mapnik/datasource.hpp>
+#include <mapnik/datasource_cache.hpp>
+#include <mapnik/layer.hpp>
 
+using namespace std;
+using boost::shared_ptr;
+
 namespace mapnik
-{
-    using namespace std;
+{   
     Layer::Layer(std::string const& name)
         : name_(name),
           title_(""),
@@ -42,8 +46,8 @@
           maxZoom_(std::numeric_limits<double>::max()),
           active_(true),
           selectable_(false),
-          selection_style_("default_selection")
-    {}
+          selection_style_("default_selection"),
+          ds_() {}
     
     Layer::Layer(const Layer& rhs)
         : name_(rhs.name_),
@@ -54,8 +58,8 @@
           active_(rhs.active_),
           selectable_(rhs.selectable_),
           styles_(rhs.styles_),
-          ds_(rhs.ds_),
-          selection_style_(rhs.selection_style_) {}
+          selection_style_(rhs.selection_style_),
+          ds_(rhs.ds_) {}
     
     Layer& Layer::operator=(const Layer& rhs)
     {
@@ -79,8 +83,8 @@
         active_=rhs.active_;
         selectable_=rhs.selectable_;
         styles_=rhs.styles_;
+        selection_style_=rhs.selection_style_;
         ds_=rhs.ds_;
-        selection_style_=rhs.selection_style_;
     }
     
     Layer::~Layer() {}

Modified: trunk/src/line_pattern_symbolizer.cpp
===================================================================
--- trunk/src/line_pattern_symbolizer.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/line_pattern_symbolizer.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -21,36 +21,37 @@
  *****************************************************************************/
 
 //$Id$
+// stl
+#include <iostream>
+// mapnik
+#include <mapnik/image_reader.hpp>
+#include <mapnik/line_pattern_symbolizer.hpp>
 
-#include "line_pattern_symbolizer.hpp"
-#include "image_reader.hpp"
-
-
 namespace mapnik
 {
     
     line_pattern_symbolizer::line_pattern_symbolizer(std::string const& file,
-			    std::string const& type,
-			    unsigned width,unsigned height) 
-	: pattern_(new ImageData32(width,height))
+                                                     std::string const& type,
+                                                     unsigned width,unsigned height) 
+        : pattern_(new ImageData32(width,height))
     {
-	try 
-	{
-	    std::auto_ptr<ImageReader> reader(get_image_reader(type,file));
-	    if (reader.get())
-		reader->read(0,0,*pattern_);		
-	} 
-	catch (...) 
-	{
-	    std::clog << "exception caught..." << std::endl;
-	}
+        try 
+        {
+            std::auto_ptr<ImageReader> reader(get_image_reader(type,file));
+            if (reader.get())
+                reader->read(0,0,*pattern_);		
+        } 
+        catch (...) 
+        {
+            std::clog << "exception caught..." << std::endl;
+        }
     }
 
     line_pattern_symbolizer::line_pattern_symbolizer(line_pattern_symbolizer const& rhs)
-	: pattern_(rhs.pattern_) {}
+        : pattern_(rhs.pattern_) {}
 
     ImageData32 const& line_pattern_symbolizer::get_pattern() const
     {
-	return *pattern_;
+        return *pattern_;
     }
 }

Modified: trunk/src/load_map.cpp
===================================================================
--- trunk/src/load_map.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/load_map.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -19,9 +19,9 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
  *****************************************************************************/
-
+// stl
 #include <iostream>
-
+// boost
 #include <boost/foreach.hpp>
 #include <boost/optional.hpp>
 #include <boost/algorithm/string.hpp>
@@ -29,14 +29,19 @@
 #include <boost/tokenizer.hpp>
 #include <boost/property_tree/ptree.hpp>
 #include <boost/property_tree/xml_parser.hpp>
+// mapnik
+#include <mapnik/color.hpp>
+#include <mapnik/color_factory.hpp>
+#include <mapnik/filter_factory.hpp>
+#include <mapnik/layer.hpp>
+#include <mapnik/datasource_cache.hpp>
 
-#include "color.hpp"
-#include "color_factory.hpp"
-#include "filter_factory.hpp"
-#include "layer.hpp"
-#include "datasource_cache.hpp"
-#include "load_map.hpp"
+#include <mapnik/load_map.hpp>
 
+using boost::lexical_cast;
+using boost::bad_lexical_cast;
+using boost::tokenizer;
+
 namespace mapnik 
 {
     void load_map(Map & map, std::string const& filename)

Modified: trunk/src/map.cpp
===================================================================
--- trunk/src/map.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/map.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -20,12 +20,12 @@
  *
  *****************************************************************************/
 
-//$Id: map.cpp 17 2005-03-08 23:58:43Z pavlenko $
+//$Id: map.cpp 17 2005-03-08 23:58:43Z pavlenko $,
 
-#include "style.hpp"
-#include "datasource.hpp"
-#include "layer.hpp"
-#include "map.hpp"
+#include <mapnik/style.hpp>
+#include <mapnik/datasource.hpp>
+#include <mapnik/layer.hpp>
+#include <mapnik/map.hpp>
 
 namespace mapnik
 {

Modified: trunk/src/memory.cpp
===================================================================
--- trunk/src/memory.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/memory.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,11 +22,8 @@
 
 //$Id: memory.cpp 17 2005-03-08 23:58:43Z pavlenko $
 
-#include "memory.hpp"
+#include <mapnik/memory.hpp>
 
-//#define GC_THREADS
-//#include "gc.h"
-
 namespace mapnik
 {
     void* Object::operator new(size_t size)

Modified: trunk/src/params.cpp
===================================================================
--- trunk/src/params.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/params.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,7 +22,7 @@
 
 //$Id: params.cpp 17 2005-03-08 23:58:43Z pavlenko $
 
-#include "params.hpp"
+#include <mapnik/params.hpp>
 
 namespace mapnik
 {

Modified: trunk/src/plugin.cpp
===================================================================
--- trunk/src/plugin.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/plugin.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,7 +22,7 @@
 
 //$Id: plugin.cpp 17 2005-03-08 23:58:43Z pavlenko $
 
-#include "plugin.hpp"
+#include <mapnik/plugin.hpp>
 
 namespace mapnik
 {

Modified: trunk/src/png_reader.cpp
===================================================================
--- trunk/src/png_reader.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/png_reader.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,13 +22,12 @@
 
 //$Id: png_reader.cpp 33 2005-04-04 13:01:03Z pavlenko $
 
-
 #include <iostream>
-#include "image_reader.hpp"
+#include <mapnik/image_reader.hpp>
 
 extern "C"
 {
-   #include <png.h>
+#include <png.h>
 }
 
 namespace mapnik
@@ -64,10 +63,10 @@
 
     PngReader::PngReader(const std::string& fileName) 
         : fileName_(fileName),
-	  width_(0),
-	  height_(0),
-	  bit_depth_(0),
-	  color_type_(0)
+          width_(0),
+          height_(0),
+          bit_depth_(0),
+          color_type_(0)
     {
         try 
         {
@@ -87,7 +86,7 @@
     {
         png_size_t check;
         check = (png_size_t)fread(data, (png_size_t)1, length,
-				  (FILE *)png_ptr->io_ptr);
+                                  (FILE *)png_ptr->io_ptr);
 
         if (check != length)
         {

Modified: trunk/src/point_symbolizer.cpp
===================================================================
--- trunk/src/point_symbolizer.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/point_symbolizer.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -21,11 +21,14 @@
  *****************************************************************************/
 
 //$Id$
-
+// stl
+#include <iostream>
+// boost
 #include <boost/scoped_ptr.hpp>
-#include "point_symbolizer.hpp"
-#include "image_data.hpp"
-#include "image_reader.hpp"
+// mapnik
+#include <mapnik/point_symbolizer.hpp>
+#include <mapnik/image_data.hpp>
+#include <mapnik/image_reader.hpp>
 
 namespace mapnik
 {

Modified: trunk/src/polygon_pattern_symbolizer.cpp
===================================================================
--- trunk/src/polygon_pattern_symbolizer.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/polygon_pattern_symbolizer.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -19,36 +19,36 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
  *****************************************************************************/
-
 //$Id$
+// stl
+#include <iostream>
+// mapnik
+#include <mapnik/image_reader.hpp>
+#include <mapnik/polygon_pattern_symbolizer.hpp>
 
-#include "polygon_pattern_symbolizer.hpp"
-
-#include "image_reader.hpp"
-
 namespace mapnik
 {
     polygon_pattern_symbolizer::polygon_pattern_symbolizer(std::string const& file,
-							   std::string const& type,
-							   unsigned width,unsigned height) 
-	: pattern_(new ImageData32(width,height))
+                                                           std::string const& type,
+                                                           unsigned width,unsigned height) 
+        : pattern_(new ImageData32(width,height))
     {
-	try 
-	{
-	    std::auto_ptr<ImageReader> reader(get_image_reader(type,file));
-	    if (reader.get())
-		reader->read(0,0,*pattern_);		
-	} 
-	catch (...) 
-	{
-	    std::clog<<"exception caught..."<<std::endl;
-	}
+        try 
+        {
+            std::auto_ptr<ImageReader> reader(get_image_reader(type,file));
+            if (reader.get())
+                reader->read(0,0,*pattern_);		
+        } 
+        catch (...) 
+        {
+            std::clog<<"exception caught..."<<std::endl;
+        }
     }
     polygon_pattern_symbolizer::polygon_pattern_symbolizer(polygon_pattern_symbolizer const& rhs)
-	: pattern_(rhs.pattern_) {}
+        : pattern_(rhs.pattern_) {}
     
     ImageData32 const& polygon_pattern_symbolizer::get_pattern() const
     {
-	return *pattern_;
+        return *pattern_;
     }
 }

Modified: trunk/src/save_map.cpp
===================================================================
--- trunk/src/save_map.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/save_map.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -19,25 +19,19 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
  *****************************************************************************/
-
-
+// $Id$
+// stl
 #include <iostream>
-
+// boost
 #include <boost/foreach.hpp>
-//#include <boost/optional.hpp>
 #include <boost/algorithm/string.hpp>
 #include <boost/lexical_cast.hpp>
 #include <boost/tokenizer.hpp>
 #include <boost/property_tree/ptree.hpp>
 #include <boost/property_tree/xml_parser.hpp>
+// mapnik
+#include <mapnik/save_map.hpp>
 
-//#include "color.hpp"
-//#include "color_factory.hpp"
-//#include "filter_factory.hpp"
-//#include "layer.hpp"
-//#include "datasource_cache.hpp"
-#include "save_map.hpp"
-
 namespace mapnik 
 {
     void save_map(Map & map, std::string const& filename)

Modified: trunk/src/text_symbolizer.cpp
===================================================================
--- trunk/src/text_symbolizer.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/text_symbolizer.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,7 +22,7 @@
 
 //$Id$
 
-#include "text_symbolizer.hpp"
+#include <mapnik/text_symbolizer.hpp>
 
 namespace mapnik
 {

Modified: trunk/src/tiff_reader.cpp
===================================================================
--- trunk/src/tiff_reader.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/tiff_reader.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -21,15 +21,16 @@
  *****************************************************************************/
 
 //$Id: tiff_reader.cpp 17 2005-03-08 23:58:43Z pavlenko $
+// stl
+#include <iostream>
+// mapnik
+#include <mapnik/image_reader.hpp>
 
-#include <iostream>
-#include "image_reader.hpp"
 extern "C" 
 {
    #include <tiffio.h>    
 }
 
-
 namespace mapnik 
 {
 

Modified: trunk/src/wkb.cpp
===================================================================
--- trunk/src/wkb.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/wkb.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,62 +22,62 @@
 
 //$Id: wkb.cpp 19 2005-03-22 13:53:27Z pavlenko $
 
-#include "wkb.hpp"
-#include "geom_util.hpp"
+#include <mapnik/wkb.hpp>
+#include <mapnik/geom_util.hpp>
 
 namespace mapnik
 {
     struct wkb_reader
     {
     private:
-	enum wkbByteOrder {
-	    wkbXDR=0,
-	    wkbNDR=1
-	};
-	const char* wkb_;
-	unsigned size_;
-	int srid_;
-	unsigned pos_;
-	wkbByteOrder byteOrder_;
-	bool needSwap_;
+        enum wkbByteOrder {
+            wkbXDR=0,
+            wkbNDR=1
+        };
+        const char* wkb_;
+        unsigned size_;
+        int srid_;
+        unsigned pos_;
+        wkbByteOrder byteOrder_;
+        bool needSwap_;
     public:
 	
-	enum wkbGeometryType {
-	    wkbPoint=1,
-	    wkbLineString=2,
-	    wkbPolygon=3,
-	    wkbMultiPoint=4,
-	    wkbMultiLineString=5,
-	    wkbMultiPolygon=6,
-	    wkbGeometryCollection=7
-	};
+        enum wkbGeometryType {
+            wkbPoint=1,
+            wkbLineString=2,
+            wkbPolygon=3,
+            wkbMultiPoint=4,
+            wkbMultiLineString=5,
+            wkbMultiPolygon=6,
+            wkbGeometryCollection=7
+        };
 	
-	wkb_reader(const char* wkb,unsigned size,int srid)
-	    : wkb_(wkb),
-	      size_(size),
-	      srid_(srid),
-	      pos_(0),
-	      byteOrder_((wkbByteOrder)wkb_[0])
-	{
-	    ++pos_;
+        wkb_reader(const char* wkb,unsigned size,int srid)
+            : wkb_(wkb),
+              size_(size),
+              srid_(srid),
+              pos_(0),
+              byteOrder_((wkbByteOrder)wkb_[0])
+        {
+            ++pos_;
 	    
 #ifndef WORDS_BIGENDIAN
-	    needSwap_=byteOrder_?wkbXDR:wkbNDR;
+            needSwap_=byteOrder_?wkbXDR:wkbNDR;
 #else
-	    needSwap_=byteOrder_?wkbNDR:wkbXDR;	
+            needSwap_=byteOrder_?wkbNDR:wkbXDR;	
 #endif	    
-	}
+        }
 
-	~wkb_reader() {}
+        ~wkb_reader() {}
 
-	geometry_ptr read() 
-	{
-	    geometry_ptr geom;
-	    int type=read_integer();
-	    switch (type)
-	    {
+        geometry_ptr read() 
+        {
+            geometry_ptr geom;
+            int type=read_integer();
+            switch (type)
+            {
             case wkbPoint:
-		geom = read_point();
+                geom = read_point();
                 break;
             case wkbLineString:
                 geom = read_linestring();
@@ -86,7 +86,7 @@
                 geom = read_polygon();
                 break;
             case wkbMultiPoint:
-		geom = read_multipoint();
+                geom = read_multipoint();
                 break;
             case wkbMultiLineString:
                 geom = read_multilinestring();
@@ -98,193 +98,192 @@
                 break;
             default:
                 break;
-	    }
-	    return geom;
-	}
+            }
+            return geom;
+        }
 	
     private:
-	wkb_reader(const wkb_reader&);
-	wkb_reader& operator=(const wkb_reader&);
+        wkb_reader(const wkb_reader&);
+        wkb_reader& operator=(const wkb_reader&);
 	
-	int read_integer() 
-	{
-	    int n;
+        int read_integer() 
+        {
+            int n;
 
-	    if (!needSwap_)
-	    {
-		memcpy(&n,wkb_+pos_,4);
-	    } 
-	    else 
-	    {
-		const char* b=wkb_+pos_;
-		n = b[3]&0xff | (b[2]&0xff)<<8 | (b[1]&0xff)<<16 | (b[0]&0xff)<<24;
-	    }
-	    pos_+=4;
+            if (!needSwap_)
+            {
+                memcpy(&n,wkb_+pos_,4);
+            } 
+            else 
+            {
+                const char* b=wkb_+pos_;
+                n = b[3]&0xff | (b[2]&0xff)<<8 | (b[1]&0xff)<<16 | (b[0]&0xff)<<24;
+            }
+            pos_+=4;
 
-	    return n;
-	}
+            return n;
+        }
 	
-	double read_double()
-	{
-	    double d;
+        double read_double()
+        {
+            double d;
 
-	    if (!needSwap_)
-	    {
-		memcpy(&d,wkb_+pos_,8);
-	    }
-	    else 
-	    {
-		// we rely on the fact that "long long" is in C standard,
-		// but not in C++ yet
-		// this is not quite portable
-		const char* b= wkb_+pos_;
-		long long n = (long long)b[7]&0xff | 
-		    ((long long)b[6]&0xff)<<8 | 
-		    ((long long)b[5]&0xff)<<16 | 
-		    ((long long)b[4]&0xff)<<24 |
-		    ((long long)b[3]&0xff)<<32 |
-		    ((long long)b[2]&0xff)<<40 |
-		    ((long long)b[1]&0xff)<<48 |
-		    ((long long)b[0]&0xff)<<56;
-		memcpy(&d,&n,8);
-	    }
-	    pos_+=8;
+            if (!needSwap_)
+            {
+                memcpy(&d,wkb_+pos_,8);
+            }
+            else 
+            {
+                // we rely on the fact that "long long" is in C standard,
+                // but not in C++ yet
+                // this is not quite portable
+                const char* b= wkb_+pos_;
+                long long n = (long long)b[7]&0xff | 
+                    ((long long)b[6]&0xff)<<8 | 
+                    ((long long)b[5]&0xff)<<16 | 
+                    ((long long)b[4]&0xff)<<24 |
+                    ((long long)b[3]&0xff)<<32 |
+                    ((long long)b[2]&0xff)<<40 |
+                    ((long long)b[1]&0xff)<<48 |
+                    ((long long)b[0]&0xff)<<56;
+                memcpy(&d,&n,8);
+            }
+            pos_+=8;
 
-	    return d;
-	}
+            return d;
+        }
 	
-	void read_coords(CoordinateArray& ar)
-	{
-	    int size=sizeof(coord<double,2>)*ar.size();
-	    if (!needSwap_)
-	    {
-		std::memcpy(&ar[0],wkb_+pos_,size);
+        void read_coords(CoordinateArray& ar)
+        {
+            int size=sizeof(coord<double,2>)*ar.size();
+            if (!needSwap_)
+            {
+                std::memcpy(&ar[0],wkb_+pos_,size);
 		
-	    }
-	    else 
-	    {
-		for (unsigned i=0;i<ar.size();++i)
-		{
-		    ar[i].x=read_double();
-		    ar[i].y=read_double();
-		}
-	    }
-	    pos_+=size;
-	}
+            }
+            else 
+            {
+                for (unsigned i=0;i<ar.size();++i)
+                {
+                    ar[i].x=read_double();
+                    ar[i].y=read_double();
+                }
+            }
+            pos_+=size;
+        }
 	
-	geometry_ptr read_point()
-	{
-	    geometry_ptr pt(new point<vertex2d>(srid_));
-	    double x = read_double();
-	    double y = read_double();
-	    pt->move_to(x,y);
-	    return pt;
-	}
+        geometry_ptr read_point()
+        {
+            geometry_ptr pt(new point<vertex2d>(srid_));
+            double x = read_double();
+            double y = read_double();
+            pt->move_to(x,y);
+            return pt;
+        }
 	
-	geometry_ptr read_multipoint()
-	{
-	    geometry_ptr pt(new point<vertex2d>(srid_));
-	    int num_points = read_integer();
-	    for (int i=0;i<num_points;++i) 
-	    {
-		pos_+=5; 
-		double x = read_double();
-		double y = read_double();
-		pt->move_to(x,y);
-	    }
-	    return pt; 
-	}
+        geometry_ptr read_multipoint()
+        {
+            geometry_ptr pt(new point<vertex2d>(srid_));
+            int num_points = read_integer();
+            for (int i=0;i<num_points;++i) 
+            {
+                pos_+=5; 
+                double x = read_double();
+                double y = read_double();
+                pt->move_to(x,y);
+            }
+            return pt; 
+        }
 
-	geometry_ptr read_linestring()
-	{
-	    geometry_ptr line(new line_string<vertex2d>(srid_));
-	    int num_points=read_integer();
-	    CoordinateArray ar(num_points);
-	    read_coords(ar);
-	    line->set_capacity(num_points);
-	    line->move_to(ar[0].x,ar[0].y);
-	    for (int i=1;i<num_points;++i)
-	    {
-		line->line_to(ar[i].x,ar[i].y);
-	    }
-	    return line;
-	}
+        geometry_ptr read_linestring()
+        {
+            geometry_ptr line(new line_string<vertex2d>(srid_));
+            int num_points=read_integer();
+            CoordinateArray ar(num_points);
+            read_coords(ar);
+            line->set_capacity(num_points);
+            line->move_to(ar[0].x,ar[0].y);
+            for (int i=1;i<num_points;++i)
+            {
+                line->line_to(ar[i].x,ar[i].y);
+            }
+            return line;
+        }
 
-	geometry_ptr read_multilinestring()
-	{
-	    geometry_ptr line(new line_string<vertex2d>(srid_));
-	    int num_lines=read_integer();
+        geometry_ptr read_multilinestring()
+        {
+            geometry_ptr line(new line_string<vertex2d>(srid_));
+            int num_lines=read_integer();
 
-	    for (int i=0;i<num_lines;++i)
-	    {
-		pos_+=5;
+            for (int i=0;i<num_lines;++i)
+            {
+                pos_+=5;
 		
-		int num_points=read_integer();
-		CoordinateArray ar(num_points);
-		read_coords(ar);
-		line->move_to(ar[0].x,ar[0].y);
+                int num_points=read_integer();
+                CoordinateArray ar(num_points);
+                read_coords(ar);
+                line->move_to(ar[0].x,ar[0].y);
 		
-		for (int i=1;i<num_points;++i)
-		{
-		    line->line_to(ar[i].x,ar[i].y);
-		}
-	    }
-	    return line;
-	}
+                for (int i=1;i<num_points;++i)
+                {
+                    line->line_to(ar[i].x,ar[i].y);
+                }
+            }
+            return line;
+        }
 
-	geometry_ptr read_polygon() 
-	{
-	    geometry_ptr poly(new polygon<vertex2d>(srid_));
+        geometry_ptr read_polygon() 
+        {
+            geometry_ptr poly(new polygon<vertex2d>(srid_));
 	    
-	    int num_rings=read_integer();
+            int num_rings=read_integer();
 
-	    for (int i=0;i<num_rings;++i)
-	    {
-		int num_points=read_integer();
-		CoordinateArray ar(num_points);
-		read_coords(ar);
-		poly->move_to(ar[0].x,ar[0].y);
+            for (int i=0;i<num_rings;++i)
+            {
+                int num_points=read_integer();
+                CoordinateArray ar(num_points);
+                read_coords(ar);
+                poly->move_to(ar[0].x,ar[0].y);
 
-		for (int j=1;j<num_points;++j)
-		{
-		    poly->line_to(ar[j].x,ar[j].y);
-		}
-		poly->line_to(ar[0].x,ar[0].y);
+                for (int j=1;j<num_points;++j)
+                {
+                    poly->line_to(ar[j].x,ar[j].y);
+                }
+                poly->line_to(ar[0].x,ar[0].y);
 		
-	    }
-	    return poly;
-	}
+            }
+            return poly;
+        }
 	
-	geometry_ptr read_multipolygon()
-	{
-	    geometry_ptr poly(new polygon<vertex2d>(srid_));
+        geometry_ptr read_multipolygon()
+        {
+            geometry_ptr poly(new polygon<vertex2d>(srid_));
 
-	    int num_polys=read_integer();
-	    for (int i=0;i<num_polys;++i)
-	    {
-		pos_+=5;
-		int num_rings=read_integer();
-		for (int i=0;i<num_rings;++i)
-		{
-		    int num_points=read_integer();
-		    CoordinateArray ar(num_points);
-		    read_coords(ar);
-		    poly->move_to(ar[0].x,ar[0].y);
-		    for (int j=1;j<num_points;++j)
-		    {
-			poly->line_to(ar[j].x,ar[j].y);
-		    }
-		    poly->line_to(ar[0].x,ar[0].y);
-		}
-	    }
-	    return poly;
+            int num_polys=read_integer();
+            for (int i=0;i<num_polys;++i)
+            {
+                pos_+=5;
+                int num_rings=read_integer();
+                for (int i=0;i<num_rings;++i)
+                {
+                    int num_points=read_integer();
+                    CoordinateArray ar(num_points);
+                    read_coords(ar);
+                    poly->move_to(ar[0].x,ar[0].y);
+                    for (int j=1;j<num_points;++j)
+                    {
+                        poly->line_to(ar[j].x,ar[j].y);
+                    }
+                    poly->line_to(ar[0].x,ar[0].y);
+                }
+            }
+            return poly;
         }
     };
-
-
+    
     geometry_ptr geometry_utils::from_wkb(const char* wkb, unsigned size,int srid) 
     {
-	wkb_reader reader(wkb,size,srid);
-	return reader.read();
+        wkb_reader reader(wkb,size,srid);
+        return reader.read();
     }    
 }

Modified: trunk/utils/shapeindex/SConscript
===================================================================
--- trunk/utils/shapeindex/SConscript	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/utils/shapeindex/SConscript	2006-10-04 11:22:18 UTC (rev 313)
@@ -33,7 +33,7 @@
     """
     )
 
-headers = ['#plugins/input/shape'] + env['CPPPATH']
+headers = ['#plugins/input/shape'] + env['CPPPATH'] 
 
 shapeindex = env.Program('shapeindex', source, CPPPATH=headers, LIBS='boost_program_options%s' % env['BOOST_APPEND'])
 

Modified: trunk/utils/shapeindex/quadtree.hpp
===================================================================
--- trunk/utils/shapeindex/quadtree.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/utils/shapeindex/quadtree.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -23,10 +23,11 @@
 
 #ifndef QUADTREE_HH
 #define QUADTREE_HH
-
-#include "envelope.hpp"
+// stl
 #include <vector>
 #include <fstream>
+// mapnik
+#include <mapnik/envelope.hpp>
 
 using namespace mapnik;
 

Modified: trunk/utils/shapeindex/shapeindex.cpp
===================================================================
--- trunk/utils/shapeindex/shapeindex.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/utils/shapeindex/shapeindex.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -21,17 +21,18 @@
  *****************************************************************************/
 //$Id: shapeindex.cc 27 2005-03-30 21:45:40Z pavlenko $
 
-#include "shape.hpp"
-#include "quadtree.hpp"
 
+#include <iostream>
+#include <vector>
+#include <string>
+
+
 #include <boost/tokenizer.hpp>
 #include <boost/algorithm/string.hpp>
 #include <boost/program_options.hpp>
+#include "quadtree.hpp"
+#include "shape.hpp"
 
-#include <iostream>
-#include <vector>
-#include <string>
-
 const int MAXDEPTH = 64;
 const int DEFAULT_DEPTH = 8;
 const double MINRATIO=0.5;



From pavlenko at mail.berlios.de  Wed Oct  4 15:57:10 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Wed, 4 Oct 2006 15:57:10 +0200
Subject: [Mapnik-svn] r314 - trunk/src
Message-ID: <200610041357.k94DvACc028881@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-04 15:57:08 +0200 (Wed, 04 Oct 2006)
New Revision: 314

Modified:
   trunk/src/load_map.cpp
Log:
BOOST_FOREACH is not released yet, revert to std::const_iterator



Modified: trunk/src/load_map.cpp
===================================================================
--- trunk/src/load_map.cpp	2006-10-04 11:22:18 UTC (rev 313)
+++ trunk/src/load_map.cpp	2006-10-04 13:57:08 UTC (rev 314)
@@ -22,7 +22,6 @@
 // stl
 #include <iostream>
 // boost
-#include <boost/foreach.hpp>
 #include <boost/optional.hpp>
 #include <boost/algorithm/string.hpp>
 #include <boost/lexical_cast.hpp>
@@ -59,15 +58,23 @@
             map.setBackground(bg);
         }
         
-        BOOST_FOREACH (ptree::value_type & v, pt.get_child("Map"))
+        ptree::const_iterator itr = pt.get_child("Map").begin();
+        ptree::const_iterator end = pt.get_child("Map").end();
+        for (; itr != end; ++itr)
         {
+            ptree::value_type const& v = *itr;
+            
             if (v.first == "Style")
             {
                 std::string name = v.second.get<std::string>("<xmlattr>.name");
                 feature_type_style style;
                 
-                BOOST_FOREACH(ptree::value_type & rule_tag, v.second)
+                ptree::const_iterator ruleIter = v.second.begin();
+                ptree::const_iterator endRule = v.second.end();
+                
+                for (; ruleIter!=endRule; ++ruleIter)    
                 {
+                    ptree::value_type const& rule_tag = *ruleIter;
                     if (rule_tag.first == "Rule")
                     {
                         std::string name = 
@@ -98,8 +105,13 @@
                             rule.set_max_scale(*max_scale);   
                         }    
                         
-                        BOOST_FOREACH(ptree::value_type & sym, rule_tag.second)
+                        ptree::const_iterator symIter = rule_tag.second.begin();
+                        ptree::const_iterator endSym = rule_tag.second.end();
+                        
+                        for( ;symIter != endSym; ++symIter)
                         {
+                            ptree::value_type const& sym = *symIter;
+                            
                             if ( sym.first == "PointSymbolizer")
                             {
                                 std::cout << sym.first << "\n";
@@ -107,8 +119,12 @@
                             else  if ( sym.first == "LineSymbolizer")
                             {
                                 stroke strk;
-                                BOOST_FOREACH (ptree::value_type & css, sym.second)
+                                ptree::const_iterator cssIter = sym.second.begin();
+                                ptree::const_iterator endCss = sym.second.end();
+                                
+                                for(; cssIter != endCss; ++cssIter)
                                 {
+                                    ptree::value_type const& css = * cssIter;
                                     std::string css_name  = 
                                         css.second.get<std::string>("<xmlattr>.name");
                                     std::string data = css.second.data();
@@ -211,8 +227,14 @@
                             else if ( sym.first == "PolygonSymbolizer")
                             {
                                 polygon_symbolizer poly_sym;
-                                BOOST_FOREACH (ptree::value_type & css, sym.second)
+                                
+                                ptree::const_iterator cssIter = sym.second.begin();
+                                ptree::const_iterator endCss = sym.second.end();
+                                
+                                for(; cssIter != endCss; ++cssIter)
                                 {
+                                    ptree::value_type const& css = * cssIter;
+                                    
                                     std::string css_name  = 
                                         css.second.get<std::string>("<xmlattr>.name");
                                     std::string data = css.second.data();
@@ -268,8 +290,13 @@
                 }
                 
                 
-                BOOST_FOREACH (ptree::value_type & child, v.second)
+                ptree::const_iterator itr2 = v.second.begin();
+                ptree::const_iterator end2 = v.second.end();
+                
+                for(; itr2 != end2; ++itr2)
                 {
+                    ptree::value_type const& child = *itr2;
+                    
                     if (child.first == "StyleName")
                     {
                         lyr.add_style(child.second.data());
@@ -277,9 +304,12 @@
                     else if (child.first == "Datasource")
                     {
                         parameters params;
-                        BOOST_FOREACH (ptree::value_type & param_tag, child.second)
+                        ptree::const_iterator paramIter = child.second.begin();
+                        ptree::const_iterator endParam = child.second.end();
+                        for (; paramIter != endParam; ++paramIter)
                         {
-
+                            ptree::value_type const& param_tag=*paramIter;
+                            
                             if (param_tag.first == "Parameter")
                             {
                                 std::string name = param_tag.second.get<std::string>("<xmlattr>.name");



From pavlenko at mail.berlios.de  Wed Oct  4 20:54:30 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Wed, 4 Oct 2006 20:54:30 +0200
Subject: [Mapnik-svn] r315 - trunk/src
Message-ID: <200610041854.k94IsUiL025774@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-04 20:54:27 +0200 (Wed, 04 Oct 2006)
New Revision: 315

Modified:
   trunk/src/save_map.cpp
Log:
removed boost::foreach.hpp

Modified: trunk/src/save_map.cpp
===================================================================
--- trunk/src/save_map.cpp	2006-10-04 13:57:08 UTC (rev 314)
+++ trunk/src/save_map.cpp	2006-10-04 18:54:27 UTC (rev 315)
@@ -23,7 +23,6 @@
 // stl
 #include <iostream>
 // boost
-#include <boost/foreach.hpp>
 #include <boost/algorithm/string.hpp>
 #include <boost/lexical_cast.hpp>
 #include <boost/tokenizer.hpp>



From pavlenko at mail.berlios.de  Thu Oct  5 11:00:38 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Thu, 5 Oct 2006 11:00:38 +0200
Subject: [Mapnik-svn] r316 - trunk/plugins/input/postgis
Message-ID: <200610050900.k9590cd2002557@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-05 11:00:36 +0200 (Thu, 05 Oct 2006)
New Revision: 316

Modified:
   trunk/plugins/input/postgis/connection_manager.hpp
   trunk/plugins/input/postgis/postgis.hpp
   trunk/plugins/input/postgis/postgisfs.cpp
Log:
Use <mapnik/*.hpp> includes. Thanks to Vince Spader from 10east.com



Modified: trunk/plugins/input/postgis/connection_manager.hpp
===================================================================
--- trunk/plugins/input/postgis/connection_manager.hpp	2006-10-04 18:54:27 UTC (rev 315)
+++ trunk/plugins/input/postgis/connection_manager.hpp	2006-10-05 09:00:36 UTC (rev 316)
@@ -26,8 +26,8 @@
 #define CONNECTION_MANAGER_HPP
 
 #include <string>
-#include "pool.hpp"
-#include "utils.hpp"
+#include <mapnik/pool.hpp>
+#include <mapnik/utils.hpp>
 #include "connection.hpp"
 #include <boost/shared_ptr.hpp>
 #include <boost/thread/mutex.hpp>

Modified: trunk/plugins/input/postgis/postgis.hpp
===================================================================
--- trunk/plugins/input/postgis/postgis.hpp	2006-10-04 18:54:27 UTC (rev 315)
+++ trunk/plugins/input/postgis/postgis.hpp	2006-10-05 09:00:36 UTC (rev 316)
@@ -26,9 +26,9 @@
 #define POSTGIS_HPP
 
 
-#include "datasource.hpp"
-#include "envelope.hpp"
-#include "feature.hpp"
+#include <mapnik/datasource.hpp>
+#include <mapnik/envelope.hpp>
+#include <mapnik/feature.hpp>
 
 #include "connection_manager.hpp"
 #include <boost/lexical_cast.hpp>

Modified: trunk/plugins/input/postgis/postgisfs.cpp
===================================================================
--- trunk/plugins/input/postgis/postgisfs.cpp	2006-10-04 18:54:27 UTC (rev 315)
+++ trunk/plugins/input/postgis/postgisfs.cpp	2006-10-05 09:00:36 UTC (rev 316)
@@ -24,8 +24,8 @@
 
 
 #include "postgis.hpp"
-#include "global.hpp"
-#include "wkb.hpp"
+#include <mapnik/global.hpp>
+#include <mapnik/wkb.hpp>
 
 using boost::lexical_cast;
 using boost::bad_lexical_cast;



From pavlenko at mail.berlios.de  Mon Oct  9 11:43:11 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Mon, 9 Oct 2006 11:43:11 +0200
Subject: [Mapnik-svn] r317 - trunk/src
Message-ID: <200610090943.k999hBqh008688@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-09 11:43:09 +0200 (Mon, 09 Oct 2006)
New Revision: 317

Modified:
   trunk/src/map.cpp
Log:
added remove_all 



Modified: trunk/src/map.cpp
===================================================================
--- trunk/src/map.cpp	2006-10-05 09:00:36 UTC (rev 316)
+++ trunk/src/map.cpp	2006-10-09 09:43:09 UTC (rev 317)
@@ -80,7 +80,8 @@
     
     feature_type_style const&  Map::find_style(std::string const& name) const
     {
-        std::map<std::string,feature_type_style>::const_iterator itr=styles_.find(name);
+        std::map<std::string,feature_type_style>::const_iterator itr
+            = styles_.find(name);
         if (itr!=styles_.end()) 
             return itr->second;
         static feature_type_style default_style;
@@ -100,7 +101,12 @@
     {
         layers_.erase(layers_.begin()+index);
     }
-
+    
+    void Map::remove_all() 
+    {
+        layers_.clear();
+    }
+    
     const Layer& Map::getLayer(size_t index) const
     {
         return layers_[index];



From pavlenko at mail.berlios.de  Mon Oct  9 11:43:45 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Mon, 9 Oct 2006 11:43:45 +0200
Subject: [Mapnik-svn] r318 - trunk/include/mapnik
Message-ID: <200610090943.k999hjHS008739@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-09 11:43:43 +0200 (Mon, 09 Oct 2006)
New Revision: 318

Modified:
   trunk/include/mapnik/map.hpp
Log:
added remove_all



Modified: trunk/include/mapnik/map.hpp
===================================================================
--- trunk/include/mapnik/map.hpp	2006-10-09 09:43:09 UTC (rev 317)
+++ trunk/include/mapnik/map.hpp	2006-10-09 09:43:43 UTC (rev 318)
@@ -61,6 +61,7 @@
         Layer& getLayer(size_t index);
         void removeLayer(size_t index);
         std::vector<Layer> const& layers() const;
+        void remove_all();        
         unsigned getWidth() const;
         unsigned getHeight() const;
         void setWidth(unsigned width);



From pavlenko at mail.berlios.de  Mon Oct  9 11:45:46 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Mon, 9 Oct 2006 11:45:46 +0200
Subject: [Mapnik-svn] r319 - trunk/plugins/input/postgis
Message-ID: <200610090945.k999jkMx008907@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-09 11:45:45 +0200 (Mon, 09 Oct 2006)
New Revision: 319

Modified:
   trunk/plugins/input/postgis/postgis.cpp
   trunk/plugins/input/postgis/postgisfs.cpp
Log:
don't rely on feature id column name. 
 


Modified: trunk/plugins/input/postgis/postgis.cpp
===================================================================
--- trunk/plugins/input/postgis/postgis.cpp	2006-10-09 09:43:43 UTC (rev 318)
+++ trunk/plugins/input/postgis/postgis.cpp	2006-10-09 09:45:45 UTC (rev 319)
@@ -193,8 +193,8 @@
         {       
             PoolGuard<shared_ptr<Connection>,shared_ptr<Pool<Connection,ConnectionCreator> > > guard(conn,pool);
             std::ostringstream s;
-            // can we rely on 'gid' name???
-            s << "select ogc_fid,asbinary("<<geometryColumn_<<") as geom";
+            
+            s << "select asbinary("<<geometryColumn_<<") as geom";
             std::set<std::string> const& props=q.property_names();
             std::set<std::string>::const_iterator pos=props.begin();
             while (pos!=props.end())

Modified: trunk/plugins/input/postgis/postgisfs.cpp
===================================================================
--- trunk/plugins/input/postgis/postgisfs.cpp	2006-10-09 09:43:43 UTC (rev 318)
+++ trunk/plugins/input/postgis/postgisfs.cpp	2006-10-09 09:45:45 UTC (rev 319)
@@ -32,7 +32,7 @@
 using std::string;
 
 postgis_featureset::postgis_featureset(boost::shared_ptr<ResultSet> const& rs,
-				     unsigned num_attrs=0)
+                                       unsigned num_attrs=0)
     : rs_(rs),
       num_attrs_(num_attrs),
       totalGeomSize_(0),
@@ -42,66 +42,63 @@
 {
     if (rs_->next())
     { 
-	const char* buf = rs_->getValue(0);
-        int id = int4net(buf);
-	feature_ptr feature(new Feature(id));
-        int size=rs_->getFieldLength(1);
-        const char *data=rs_->getValue(1);
+        feature_ptr feature(new Feature(count_));
+        int size=rs_->getFieldLength(0);
+        const char *data=rs_->getValue(0);
         geometry_ptr geom=geometry_utils::from_wkb(data,size,-1);
-	totalGeomSize_+=size;
+        totalGeomSize_+=size;
 	     
         if (geom)
         {
             feature->set_geometry(geom);
-	    unsigned start=2;
-	    for (unsigned pos=0;pos<num_attrs_;++pos)
-	    {
-		std::string name = rs_->getFieldName(start + pos);
-		const char* buf=rs_->getValue(start + pos);
-		//int field_size = rs_->getFieldLength(start + pos);
-		int oid = rs_->getTypeOID(start + pos);
+            
+            for (unsigned pos=1;pos<num_attrs_;++pos)
+            {
+                std::string name = rs_->getFieldName(pos);
+                const char* buf=rs_->getValue(pos);
+                int oid = rs_->getTypeOID(pos);
 		
-		if (oid==23) //int4
-		{
-		    int val = int4net(buf);
-		    boost::put(*feature,name,val);
-		}
-		else if (oid==21) //int2
-		{
-		    int val = int2net(buf);
-		    boost::put(*feature,name,val);
-		}
-		else if (oid == 700) // float4
-		{
-		    float val;
-		    float4net(val,buf);
-		    boost::put(*feature,name,val);
-		}
-		else if (oid == 701) // float8
-		{
-		    double val;
-		    float8net(val,buf);
-		    boost::put(*feature,name,val);
-		}
-		else if (oid==1042 || oid==1043) //bpchar or varchar
-		{
-		    boost::put(*feature,name,buf);
-		}
-		else 
-		{
-		    boost::put(*feature,name,0);
-		}
-	    }
+                if (oid==23) //int4
+                {
+                    int val = int4net(buf);
+                    boost::put(*feature,name,val);
+                }
+                else if (oid==21) //int2
+                {
+                    int val = int2net(buf);
+                    boost::put(*feature,name,val);
+                }
+                else if (oid == 700) // float4
+                {
+                    float val;
+                    float4net(val,buf);
+                    boost::put(*feature,name,val);
+                }
+                else if (oid == 701) // float8
+                {
+                    double val;
+                    float8net(val,buf);
+                    boost::put(*feature,name,val);
+                }
+                else if (oid==1042 || oid==1043) //bpchar or varchar
+                {
+                    boost::put(*feature,name,buf);
+                }
+                else 
+                {
+                    boost::put(*feature,name,0);
+                }
+            }
             ++count_;
         }
-	return feature;
+        return feature;
     }
     else
     {
         rs_->close();
         std::clog << "totalGeomSize="<<totalGeomSize_<<" bytes"<<std::endl;
         std::clog << "count="<<count_<<std::endl;
-	return feature_ptr();
+        return feature_ptr();
     }
 }
 



From pavlenko at mail.berlios.de  Mon Oct  9 11:52:18 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Mon, 9 Oct 2006 11:52:18 +0200
Subject: [Mapnik-svn] r320 - in trunk: include/mapnik src
Message-ID: <200610090952.k999qIf1009518@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-09 11:52:15 +0200 (Mon, 09 Oct 2006)
New Revision: 320

Modified:
   trunk/include/mapnik/ctrans.hpp
   trunk/include/mapnik/geometry.hpp
   trunk/include/mapnik/vertex_transform.hpp
   trunk/include/mapnik/vertex_vector.hpp
   trunk/src/agg_renderer.cpp
Log:
simplified coord transformation interface.



Modified: trunk/include/mapnik/ctrans.hpp
===================================================================
--- trunk/include/mapnik/ctrans.hpp	2006-10-09 09:45:45 UTC (rev 319)
+++ trunk/include/mapnik/ctrans.hpp	2006-10-09 09:52:15 UTC (rev 320)
@@ -34,21 +34,21 @@
     template <typename Transform,typename Geometry>
     struct MAPNIK_DECL coord_transform
     {
-        coord_transform(Transform const& t,Geometry& geom)
+        coord_transform(Transform const& t, Geometry& geom)
             : t_(t), geom_(geom) {}
-	
+        
         unsigned  vertex(double *x , double *y) const
         {
             unsigned command = geom_.vertex(x,y);
-            *x = t_.forward_x_(x);
-            *y = t_.forward_y_(y);
+            t_.forward(x,y);
             return command;
         }
+        
         void rewind (unsigned pos)
         {
             geom_.rewind(pos);
         }
-	
+        
     private:
         Transform const& t_;
         Geometry& geom_;
@@ -60,13 +60,13 @@
 	    int width;
 	    int height;
 	    double scale_;
-	    Envelope<double> extent;
+	    Envelope<double> extent_;
     public:
         CoordTransform(int width,int height,const Envelope<double>& extent)
-            :width(width),height(height),extent(extent)
+            :width(width),height(height),extent_(extent)
         {
-            double sx=((double)width)/extent.width();
-            double sy=((double)height)/extent.height();
+            double sx=((double)width)/extent_.width();
+            double sy=((double)height)/extent_.height();
             scale_=std::min(sx,sy);
         }
 	
@@ -74,48 +74,29 @@
         {
             return scale_;
         }
-	
-        inline void forward_x(double* x) const 
+        
+        inline void forward(double * x, double * y) const
         {
-            *x = (*x - extent.minx() ) * scale_;   
+            
+            *x = (*x - extent_.minx()) * scale_;
+            *y = (extent_.maxy() - *y) * scale_;
         }
-	
-        inline void forward_y(double* y) const 
+        
+        inline void backward(double * x, double * y) const
         {
-            *y = (extent.maxy() - *y) * scale_;
+            *x = extent_.minx() + *x/scale_;
+            *y = extent_.maxy() - *y/scale_;
         }
-
-        inline double forward_x_(double* x) const 
-        {
-            return (*x - extent.minx() ) * scale_;   
-        }
-	
-        inline double forward_y_(double* y) const 
-        {
-            return (extent.maxy() - *y) * scale_;
-        }
-
-        inline void backward_x(double* x) const
-        {
-            *x = extent.minx() + *x/scale_;
-        }
-	
-        inline void backward_y(double* y) const
-        {
-            *y = extent.maxy() - *y/scale_;
-        }
-	
+        
         inline coord2d& forward(coord2d& c) const
         {
-            forward_x(&c.x);
-            forward_y(&c.y);
+            forward(&c.x,&c.y);
             return c;
         }
 
         inline coord2d& backward(coord2d& c) const
         {
-            backward_x(&c.x);
-            backward_y(&c.y);
+            backward(&c.x,&c.y);
             return c;
         }
 
@@ -125,10 +106,8 @@
             double y0 = e.miny();
             double x1 = e.maxx();
             double y1 = e.maxy();
-            forward_x(&x0);
-            forward_y(&y0);
-            forward_x(&x1);
-            forward_y(&y1);
+            forward(&x0,&y0);
+            forward(&x1,&y1);
             return Envelope<double>(x0,y0,x1,y1);
         }
 
@@ -138,11 +117,8 @@
             double y0 = e.miny();
             double x1 = e.maxx();
             double y1 = e.maxy();
-            backward_x(&x0);
-            backward_y(&y0);
-            backward_x(&x1);
-            backward_y(&y1);
-	    
+            backward(&x0,&y0);
+            backward(&x1,&y1);
             return Envelope<double>(x0,y0,x1,y1);
         }
 

Modified: trunk/include/mapnik/geometry.hpp
===================================================================
--- trunk/include/mapnik/geometry.hpp	2006-10-09 09:45:45 UTC (rev 319)
+++ trunk/include/mapnik/geometry.hpp	2006-10-09 09:52:15 UTC (rev 320)
@@ -31,7 +31,6 @@
 #include <boost/utility.hpp>
 // mapnik
 #include <mapnik/vertex_vector.hpp>
-#include <mapnik/vertex_transform.hpp>
 #include <mapnik/ctrans.hpp>
 #include <mapnik/geom_util.hpp>
 
@@ -83,7 +82,6 @@
         virtual void label_position(double *x, double *y) const=0;
         virtual void move_to(value_type x,value_type y)=0;
         virtual void line_to(value_type x,value_type y)=0;
-        virtual void transform(const mapnik::CoordTransform& t)=0;
         virtual unsigned num_points() const = 0;
         virtual unsigned vertex(double* x, double* y)=0;
         virtual void rewind(unsigned )=0;
@@ -121,13 +119,7 @@
         }
 	
         void line_to(value_type ,value_type ) {}
-	
-        void transform(const mapnik::CoordTransform& t)
-        {
-            t.forward_x(&pt_.x);
-            t.forward_y(&pt_.y);
-        }
-	
+        
         unsigned num_points() const
         {
             return 1;
@@ -193,7 +185,6 @@
             unsigned i,j;
             for (i = size-1,j = 0; j < size; i = j, ++j)
             {
-		
                 cont_.get_vertex(i,&x0,&y0);
                 cont_.get_vertex(j,&x1,&y1);
                 ai = x0 * y1 - x1 * y0;
@@ -221,15 +212,6 @@
             cont_.push_back(x,y,SEG_MOVETO);
         }
 	
-        void transform(mapnik::CoordTransform const& t)
-        {
-            unsigned size = cont_.size();
-            for (unsigned pos=0; pos < size; ++pos)
-            {	
-                cont_.transform_at(pos,t);
-            }
-        }
-	
         unsigned num_points() const
         {
             return cont_.size();
@@ -339,16 +321,7 @@
         {
             cont_.push_back(x,y,SEG_MOVETO);
         }
-	
-        void transform(mapnik::CoordTransform const& t)
-        {
-            unsigned size = cont_.size();
-            for (unsigned pos=0; pos < size; ++pos)
-            {	
-                cont_.transform_at(pos,t);
-            }
-        }
-	
+
         unsigned num_points() const
         {
             return cont_.size();

Modified: trunk/include/mapnik/vertex_transform.hpp
===================================================================
--- trunk/include/mapnik/vertex_transform.hpp	2006-10-09 09:45:45 UTC (rev 319)
+++ trunk/include/mapnik/vertex_transform.hpp	2006-10-09 09:52:15 UTC (rev 320)
@@ -33,34 +33,34 @@
     template <typename T0 ,typename T1,int shift=8>
     struct Shift
     {
-	typedef T0 value_type;
-	typedef T1 return_type;
-	static return_type apply(value_type val)
-	{
-	    return static_cast<return_type>(val*(1<<shift));
-	}
+        typedef T0 value_type;
+        typedef T1 return_type;
+        static return_type apply(value_type val)
+        {
+            return static_cast<return_type>(val*(1<<shift));
+        }
     };
 
     template <typename T0,typename T1>
     struct Shift<T0,T1,0> 
     {
-	typedef T0 value_type;
-	typedef T1 return_type;
-	static return_type apply(value_type val)
-	{
-	    return static_cast<return_type>(val);
-	}
+        typedef T0 value_type;
+        typedef T1 return_type;
+        static return_type apply(value_type val)
+        {
+            return static_cast<return_type>(val);
+        }
     };
 
     template <typename T>
     struct Shift<T,T,0>
     {
-	typedef T value_type;
-	typedef T return_type;
-	static T& apply(T& val)
-	{
-	    return val;
-	}
+        typedef T value_type;
+        typedef T return_type;
+        static T& apply(T& val)
+        {
+            return val;
+        }
     };
 
     typedef Shift<double,double,0> NO_SHIFT;

Modified: trunk/include/mapnik/vertex_vector.hpp
===================================================================
--- trunk/include/mapnik/vertex_vector.hpp	2006-10-09 09:45:45 UTC (rev 319)
+++ trunk/include/mapnik/vertex_vector.hpp	2006-10-09 09:52:15 UTC (rev 320)
@@ -110,19 +110,11 @@
             return commands_[block] [pos & block_mask];
         }
         	
-        void transform_at(unsigned pos,const CoordTransform& t)
-        {
-            if (pos >= pos_) return;
-            unsigned block = pos >> block_shift;
-            value_type* vertex = vertexs_[block] + (( pos & block_mask) << 1);
-            t.forward_x(vertex);
-            ++vertex;
-            t.forward_y(vertex);
-        }
         void set_capacity(size_t)
         {
             //do nothing
         }
+        
     private:
         void allocate_block(unsigned block)
         {
@@ -181,13 +173,6 @@
             return cont_.end();
         }
 
-        void transform_at(unsigned pos,const CoordTransform& t)
-        {
-            if (pos >= cont_.size()) return;
-            vertex_type & c = cont_[pos];
-            t.forward_x(&boost::get<0>(c));
-            t.forward_y(&boost::get<1>(c));
-        }
         void set_capacity(size_t size)
         {
             cont_.reserve(size);

Modified: trunk/src/agg_renderer.cpp
===================================================================
--- trunk/src/agg_renderer.cpp	2006-10-09 09:45:45 UTC (rev 319)
+++ trunk/src/agg_renderer.cpp	2006-10-09 09:52:15 UTC (rev 320)
@@ -96,7 +96,7 @@
     {
         Color const& bg=m.getBackground();
         pixmap_.setBackground(bg);
-        std::clog << "scale="<<m.scale()<<std::endl;
+        std::clog << "scale=" << m.scale() << "\n";
     }
     
     template <typename T>
@@ -172,7 +172,9 @@
         if (geom && geom->num_points() > 1)
         {
             path_type path(t_,*geom);
-            agg::row_ptr_cache<agg::int8u> buf(pixmap_.raw_data(),pixmap_.width(),pixmap_.height(),
+            agg::row_ptr_cache<agg::int8u> buf(pixmap_.raw_data(),
+                                               pixmap_.width(),
+                                               pixmap_.height(),
                                                pixmap_.width()*4);
             agg::pixfmt_rgba32 pixf(buf);
             ren_base renb(pixf);	    
@@ -286,8 +288,7 @@
             if ( data )
             {
                 geom->label_position(&x,&y);
-                t_.forward_x(&x);
-                t_.forward_y(&y);
+                t_.forward(&x,&y);
                 int w = data->width();
                 int h = data->height();
                 int px=int(floor(x - 0.5 * w));
@@ -435,8 +436,7 @@
                 double x;
                 double y;
                 geom->label_position(&x,&y);
-                t_.forward_x(&x);
-                t_.forward_y(&y);
+                t_.forward(&x,&y);
 
                 face_ptr face = font_manager_.get_face("Bitstream Vera Sans Roman");//TODO
                 //face_ptr face = font_manager_.get_face("Times New Roman Regular");//TODO



From pavlenko at mail.berlios.de  Mon Oct  9 12:28:49 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Mon, 9 Oct 2006 12:28:49 +0200
Subject: [Mapnik-svn] r321 - trunk/include/mapnik
Message-ID: <200610091028.k99ASng2013099@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-09 12:28:48 +0200 (Mon, 09 Oct 2006)
New Revision: 321

Modified:
   trunk/include/mapnik/feature_style_processor.hpp
Log:
use boost::shared_ptr<datasource>
 


Modified: trunk/include/mapnik/feature_style_processor.hpp
===================================================================
--- trunk/include/mapnik/feature_style_processor.hpp	2006-10-09 09:52:15 UTC (rev 320)
+++ trunk/include/mapnik/feature_style_processor.hpp	2006-10-09 10:28:48 UTC (rev 321)
@@ -83,7 +83,7 @@
         void apply_to_layer(Layer const& lay,Processor & p)
         {
             p.start_layer_processing(lay);
-            datasource *ds=lay.datasource().get();
+            boost::shared_ptr<datasource> ds=lay.datasource();
             if (ds)
             {
                 Envelope<double> const& bbox=m_.getCurrentExtent();



From pavlenko at mail.berlios.de  Mon Oct  9 12:30:02 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Mon, 9 Oct 2006 12:30:02 +0200
Subject: [Mapnik-svn] r322 - trunk/src
Message-ID: <200610091030.k99AU2Ec013352@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-09 12:29:57 +0200 (Mon, 09 Oct 2006)
New Revision: 322

Modified:
   trunk/src/map.cpp
Log:
in remove_all clear all styles as well!



Modified: trunk/src/map.cpp
===================================================================
--- trunk/src/map.cpp	2006-10-09 10:28:48 UTC (rev 321)
+++ trunk/src/map.cpp	2006-10-09 10:29:57 UTC (rev 322)
@@ -105,6 +105,7 @@
     void Map::remove_all() 
     {
         layers_.clear();
+        styles_.clear();
     }
     
     const Layer& Map::getLayer(size_t index) const
@@ -181,8 +182,10 @@
         coord2d center = currentExtent_.center();
         double w = factor * currentExtent_.width();
         double h = factor * currentExtent_.height();
-        currentExtent_ = Envelope<double>(center.x - 0.5 * w, center.y - 0.5 * h,
-                                          center.x + 0.5 * w, center.y + 0.5 * h);
+        currentExtent_ = Envelope<double>(center.x - 0.5 * w, 
+                                          center.y - 0.5 * h,
+                                          center.x + 0.5 * w, 
+                                          center.y + 0.5 * h);
         fixAspectRatio();
     }
     



From vspader10east at mail.berlios.de  Mon Oct  9 22:09:46 2006
From: vspader10east at mail.berlios.de (vspader10east at BerliOS)
Date: Mon, 9 Oct 2006 22:09:46 +0200
Subject: [Mapnik-svn] r323 - trunk/plugins/input/postgis
Message-ID: <200610092009.k99K9k8o021454@sheep.berlios.de>

Author: vspader10east
Date: 2006-10-09 22:09:46 +0200 (Mon, 09 Oct 2006)
New Revision: 323

Modified:
   trunk/plugins/input/postgis/postgisfs.cpp
Log:
Bugfix for PostGIS plugin.

Modified: trunk/plugins/input/postgis/postgisfs.cpp
===================================================================
--- trunk/plugins/input/postgis/postgisfs.cpp	2006-10-09 10:29:57 UTC (rev 322)
+++ trunk/plugins/input/postgis/postgisfs.cpp	2006-10-09 20:09:46 UTC (rev 323)
@@ -52,7 +52,7 @@
         {
             feature->set_geometry(geom);
             
-            for (unsigned pos=1;pos<num_attrs_;++pos)
+            for (unsigned pos=1;pos<num_attrs_+1;++pos)
             {
                 std::string name = rs_->getFieldName(pos);
                 const char* buf=rs_->getValue(pos);



From pavlenko at mail.berlios.de  Mon Oct  9 22:48:45 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Mon, 9 Oct 2006 22:48:45 +0200
Subject: [Mapnik-svn] r324 - trunk/include/mapnik
Message-ID: <200610092048.k99KmjFF026092@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-09 22:48:42 +0200 (Mon, 09 Oct 2006)
New Revision: 324

Modified:
   trunk/include/mapnik/feature_style_processor.hpp
Log:
just help compiler a little bit 



Modified: trunk/include/mapnik/feature_style_processor.hpp
===================================================================
--- trunk/include/mapnik/feature_style_processor.hpp	2006-10-09 20:09:46 UTC (rev 323)
+++ trunk/include/mapnik/feature_style_processor.hpp	2006-10-09 20:48:42 UTC (rev 324)
@@ -68,15 +68,17 @@
             p.start_map_processing(m_);
 	    
             std::vector<Layer>::const_iterator itr = m_.layers().begin();
-            while (itr != m_.layers().end())
+            std::vector<Layer>::const_iterator end = m_.layers().end();
+            while (itr != end)
             {
                 if (itr->isVisible(m_.scale()) && 
                     itr->envelope().intersects(m_.getCurrentExtent()))
-                {
+                {    
                     apply_to_layer(*itr,p);
                 }
                 ++itr;
             }
+            
             p.end_map_processing(m_);
         }	
     private:



From pavlenko at mail.berlios.de  Mon Oct  9 22:49:58 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Mon, 9 Oct 2006 22:49:58 +0200
Subject: [Mapnik-svn] r325 - trunk/src
Message-ID: <200610092049.k99Knwit026192@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-09 22:49:56 +0200 (Mon, 09 Oct 2006)
New Revision: 325

Modified:
   trunk/src/load_map.cpp
Log:
added <ElseFilter/> tag support in map loader.



Modified: trunk/src/load_map.cpp
===================================================================
--- trunk/src/load_map.cpp	2006-10-09 20:48:42 UTC (rev 324)
+++ trunk/src/load_map.cpp	2006-10-09 20:49:56 UTC (rev 325)
@@ -90,7 +90,13 @@
                         {
                             rule.set_filter(create_filter(*filter_expr));
                         }
-                        
+                        boost::optional<std::string> else_filter = 
+                            rule_tag.second.get_optional<std::string>("ElseFilter");
+                        if (else_filter)
+                        {
+                            rule.set_else(true);
+                        }
+                                                                      
                         boost::optional<double> min_scale = 
                             rule_tag.second.get_optional<double>("MinScaleDenominator");
                         if (min_scale)



From pavlenko at mail.berlios.de  Mon Oct  9 22:57:06 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Mon, 9 Oct 2006 22:57:06 +0200
Subject: [Mapnik-svn] r326 - trunk/plugins/input/postgis
Message-ID: <200610092057.k99Kv6lJ026830@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-09 22:57:04 +0200 (Mon, 09 Oct 2006)
New Revision: 326

Modified:
   trunk/plugins/input/postgis/postgis.cpp
Log:
1. use more precise coord values in SQL statements.
2. added extra parameter 'estimate_extent'. By default, exact extent will be calulated e.g :
    select extent(geom) from table_name;
Sometimes it is more practical (faster!) to use estimated extent
    select estimated_extent('table_name','geom');
but it is somewhere around 95% accurate.
Usage:
     ....   
     params["estimate_extent"]="true";
     ....


 


Modified: trunk/plugins/input/postgis/postgis.cpp
===================================================================
--- trunk/plugins/input/postgis/postgis.cpp	2006-10-09 20:49:56 UTC (rev 325)
+++ trunk/plugins/input/postgis/postgis.cpp	2006-10-09 20:57:04 UTC (rev 326)
@@ -22,16 +22,17 @@
 
 //$Id: postgis.cc 44 2005-04-22 18:53:54Z pavlenko $
 
-#include "postgis.hpp"
 #include <string>
 #include <algorithm>
 #include <set>
 #include <sstream>
+#include <iomanip>
 #include "connection_manager.hpp"
+#include "postgis.hpp"
 
 DATASOURCE_PLUGIN(postgis_datasource)
 
-    const std::string postgis_datasource::GEOMETRY_COLUMNS="geometry_columns";
+const std::string postgis_datasource::GEOMETRY_COLUMNS="geometry_columns";
 const std::string postgis_datasource::SPATIAL_REF_SYS="spatial_ref_system";
 
 using std::clog;
@@ -68,10 +69,10 @@
 	    
             std::ostringstream s;
             s << "select f_geometry_column,srid,type from ";
-            s << GEOMETRY_COLUMNS <<" where f_table_name='"<<table_name<<"'";
-	   
+            s << GEOMETRY_COLUMNS <<" where f_table_name='" << table_name<<"'";
+            
             shared_ptr<ResultSet> rs=conn->executeQuery(s.str());
-	    
+            
             if (rs->next())
             {
                 try 
@@ -88,9 +89,21 @@
             }
             rs->close();
             s.str("");
-            s << "select xmin(ext),ymin(ext),xmax(ext),ymax(ext)";
-            s << " from (select estimated_extent('"<<table_name<<"','"<<geometryColumn_<<"') as ext) as tmp";
-
+            
+            if (params.get("estimate_extent") == "true")
+            {
+                s << "select xmin(ext),ymin(ext),xmax(ext),ymax(ext)"
+                  << " from (select estimated_extent('" 
+                  << table_name <<"','" 
+                  << geometryColumn_ << "') as ext) as tmp";
+            }
+            else 
+            {
+                s << "select xmin(ext),ymin(ext),xmax(ext),ymax(ext)"
+                  << " from (select extent(" <<geometryColumn_<< ") as ext from " 
+                  << table_name << ") as tmp";
+            }
+            
             rs=conn->executeQuery(s.str());
             if (rs->next())
             {
@@ -108,7 +121,7 @@
                 }
             }
             rs->close();
-
+            
             // collect attribute desc
             s.str("");
             s << "select * from "<<table_<<" limit 1";
@@ -204,6 +217,7 @@
             }	
     
             s << " from " << table_<<" where "<<geometryColumn_<<" && setSRID('BOX3D(";
+            s << std::setprecision(16);
             s << box.minx() << " " << box.miny() << ",";
             s << box.maxx() << " " << box.maxy() << ")'::box3d,"<<srid_<<")";
             clog << s.str() << endl;



From pavlenko at mail.berlios.de  Tue Oct 10 00:07:41 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Tue, 10 Oct 2006 00:07:41 +0200
Subject: [Mapnik-svn] r327 - trunk/bindings/python
Message-ID: <200610092207.k99M7fQf001476@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-10 00:07:39 +0200 (Tue, 10 Oct 2006)
New Revision: 327

Modified:
   trunk/bindings/python/mapnik_python.cpp
Log:
check if can extract std::string from dict.



Modified: trunk/bindings/python/mapnik_python.cpp
===================================================================
--- trunk/bindings/python/mapnik_python.cpp	2006-10-09 20:57:04 UTC (rev 326)
+++ trunk/bindings/python/mapnik_python.cpp	2006-10-09 22:07:39 UTC (rev 327)
@@ -80,9 +80,13 @@
         boost::python::list keys=d.keys();
         for (int i=0; i<len(keys); ++i)
         {
-            std::string key=extract<std::string>(keys[i]);
-            std::string value=extract<std::string>(d[key]);
-            params[key] = value;
+            std::string key = extract<std::string>(keys[i]);
+            object obj = d[key];
+            extract<std::string> ex(obj);
+            if (ex.check())
+            {
+                params[key] = ex();
+            }            
         }
         
         return mapnik::datasource_cache::create(params);



From pavlenko at mail.berlios.de  Mon Oct 16 15:31:55 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Mon, 16 Oct 2006 15:31:55 +0200
Subject: [Mapnik-svn] r328 - in trunk: include/mapnik src
Message-ID: <200610161331.k9GDVt22015074@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-16 15:31:52 +0200 (Mon, 16 Oct 2006)
New Revision: 328

Modified:
   trunk/include/mapnik/envelope.hpp
   trunk/src/envelope.cpp
Log:
added operators +,-,*,/ 



Modified: trunk/include/mapnik/envelope.hpp
===================================================================
--- trunk/include/mapnik/envelope.hpp	2006-10-09 22:07:39 UTC (rev 327)
+++ trunk/include/mapnik/envelope.hpp	2006-10-16 13:31:52 UTC (rev 328)
@@ -27,12 +27,18 @@
 
 // stl
 #include <iomanip>
+// boost
+#include <boost/operators.hpp>
 // mapnik
 #include <mapnik/config.hpp>
 #include <mapnik/coord.hpp>
 
 namespace mapnik {
-	template <class T> class MAPNIK_DECL Envelope
+	template <typename T> class MAPNIK_DECL Envelope 
+    : boost::addable<Envelope<T>, 
+      boost::subtractable<Envelope<T>, 
+      boost::dividable2<Envelope<T>, T,
+      boost::multipliable2<Envelope<T>, T > > > >
     {
     public:
         typedef Envelope<T> EnvelopeType;
@@ -68,6 +74,12 @@
         bool operator==(const EnvelopeType &other) const;
         void re_center(T cx,T cy);
         void init(T x0,T y0,T x1,T y1);
+        
+        // define some operators 
+        EnvelopeType& operator+=(EnvelopeType const& other);
+        EnvelopeType& operator-=(EnvelopeType const& other);
+        EnvelopeType& operator*=(T);
+        EnvelopeType& operator/=(T);    
     };
     
     template <class charT,class traits,class T>

Modified: trunk/src/envelope.cpp
===================================================================
--- trunk/src/envelope.cpp	2006-10-09 22:07:39 UTC (rev 327)
+++ trunk/src/envelope.cpp	2006-10-16 13:31:52 UTC (rev 328)
@@ -223,7 +223,41 @@
             miny_=y1;maxy_=y0;
         }
     }
+    
+    template <typename T>
+    Envelope<T>&  Envelope<T>::operator+=(Envelope<T> const& other)
+    {
+        expand_to_include(other);
+        return *this;
+    }
+    
+    template <typename T>    
+    Envelope<T>& Envelope<T>::operator-=(Envelope<T> const& other)
+    {
+        // not sure what to do here. intersect?
+        return *this;
+    }
+    
+    template <typename T>    
+    Envelope<T>& Envelope<T>::operator*=(T t)
+    {
+        minx_ *= t;
+        miny_ *= t;
+        maxx_ *= t;
+        maxy_ *= t;
+        return *this;
+    }
 
+    template <typename T>    
+    Envelope<T>& Envelope<T>::operator/=(T t)
+    {
+        minx_ /= t;
+        miny_ /= t;
+        maxx_ /= t;
+        maxy_ /= t;
+        return *this;
+    }
+    
     template class Envelope<int>;
     template class Envelope<double>;
 }



From pavlenko at mail.berlios.de  Mon Oct 16 15:32:46 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Mon, 16 Oct 2006 15:32:46 +0200
Subject: [Mapnik-svn] r329 - trunk/include/mapnik
Message-ID: <200610161332.k9GDWkhv015222@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-16 15:32:45 +0200 (Mon, 16 Oct 2006)
New Revision: 329

Modified:
   trunk/include/mapnik/coord.hpp
Log:
added operators +,-,*,/



Modified: trunk/include/mapnik/coord.hpp
===================================================================
--- trunk/include/mapnik/coord.hpp	2006-10-16 13:31:52 UTC (rev 328)
+++ trunk/include/mapnik/coord.hpp	2006-10-16 13:32:45 UTC (rev 329)
@@ -27,6 +27,7 @@
 
 #include <iomanip>
 #include <sstream>
+#include <boost/operators.hpp>
 
 namespace mapnik {   
     template <typename T,int dim>
@@ -36,6 +37,13 @@
     
     template <typename T>
     struct coord<T,2> 
+        : boost::addable<coord<T,2>,
+          boost::addable2<coord<T,2>,T,
+          boost::subtractable<coord<T,2>,
+          boost::subtractable2<coord<T,2>,T,
+          boost::dividable2<coord<T,2>, T,
+          boost::multipliable2<coord<T,2>, T > > > > > >
+                    
     {
         typedef T type;
         T x;
@@ -61,6 +69,52 @@
             y=type(rhs.y);
             return *this;
         }
+        template <typename T2>
+        bool operator==(coord<T2,2> const& rhs)
+        {
+            return x == rhs.x && y == rhs.y;
+        }
+
+        coord<T,2>& operator+=(coord<T,2> const& rhs)
+        {
+            x+=rhs.x;
+            y+=rhs.y;
+            return *this;
+        }
+        
+        coord<T,2>& operator+=(T rhs)
+        {
+            x+=rhs;
+            y+=rhs;
+            return *this;
+        }
+        
+        coord<T,2>& operator-=(coord<T,2> const& rhs)
+        {
+            x-=rhs.x;
+            y-=rhs.y;
+            return *this;
+        }
+        
+        coord<T,2>& operator-=(T rhs)
+        {
+            x-=rhs;
+            y-=rhs;
+            return *this;
+        }
+        
+        coord<T,2>& operator*=(T t)
+        {
+            x*=t;
+            y*=t;
+            return *this;
+        }
+        coord<T,2>& operator/=(T t)
+        {
+            x/=t;
+            y/=t;
+            return *this;
+        }
     };
 
     template <typename T>



From pavlenko at mail.berlios.de  Mon Oct 16 15:45:01 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Mon, 16 Oct 2006 15:45:01 +0200
Subject: [Mapnik-svn] r330 - in trunk: . agg bindings/python
	bindings/python/mapnik demo/python include/mapnik src
Message-ID: <200610161345.k9GDj1We016252@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-16 15:44:52 +0200 (Mon, 16 Oct 2006)
New Revision: 330

Added:
   trunk/bindings/python/mapnik_coord.cpp
   trunk/bindings/python/mapnik_datasource.cpp
   trunk/bindings/python/mapnik_projection.cpp
   trunk/include/mapnik/projection.hpp
Modified:
   trunk/SConstruct
   trunk/agg/SConscript
   trunk/bindings/python/mapnik/__init__.py
   trunk/bindings/python/mapnik_envelope.cpp
   trunk/bindings/python/mapnik_layer.cpp
   trunk/bindings/python/mapnik_line_symbolizer.cpp
   trunk/bindings/python/mapnik_map.cpp
   trunk/bindings/python/mapnik_polygon_symbolizer.cpp
   trunk/bindings/python/mapnik_python.cpp
   trunk/bindings/python/mapnik_stroke.cpp
   trunk/demo/python/rundemo.py
   trunk/include/mapnik/agg_renderer.hpp
   trunk/include/mapnik/ctrans.hpp
   trunk/include/mapnik/feature_style_processor.hpp
   trunk/include/mapnik/layer.hpp
   trunk/include/mapnik/map.hpp
   trunk/src/agg_renderer.cpp
   trunk/src/layer.cpp
   trunk/src/load_map.cpp
   trunk/src/map.cpp
Log:
1.added projection transformation support based on proj4 (new dependency!!!)
  Map and Layer objects both have a new parameter 'srs', initialized to "+proj=latlong +datum=WGS84" by default. 
    
  Basic usage (Python):
    p = Projection("+proj=merc +datum=WGS84")
    point = p.forward(Coord(-2,51))
    ...        
2.reflected arithmetic operators for Envelope/Coord into Python
3.altered return policies for python objects
4.modified build system to require proj4 lib and headers



Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2006-10-16 13:32:45 UTC (rev 329)
+++ trunk/SConstruct	2006-10-16 13:44:52 UTC (rev 330)
@@ -45,7 +45,6 @@
 opts.Add(PathOption('PYTHON','Python executable', sys.executable))
 opts.Add(ListOption('INPUT_PLUGINS','Input drivers to include','all',['postgis','shape','raster']))
 opts.Add(ListOption('BINDINGS','Language bindings to build','all',['python']))
-
 opts.Add('DEBUG', 'Compile a debug version of mapnik', '')
 
 env = Environment(ENV=os.environ, options=opts)
@@ -59,14 +58,24 @@
 
 env['CPPPATH'] = ['#agg/include', '#include', '#']
 
-for path in [env['BOOST_INCLUDES'], env['PNG_INCLUDES'], env['JPEG_INCLUDES'], env['TIFF_INCLUDES'], env['PGSQL_INCLUDES'], env['PROJ_INCLUDES']]:
+for path in [env['BOOST_INCLUDES'],
+             env['PNG_INCLUDES'],
+             env['JPEG_INCLUDES'],
+             env['TIFF_INCLUDES'],
+             env['PGSQL_INCLUDES'],
+             env['PROJ_INCLUDES']]:
     if path not in env['CPPPATH']: env['CPPPATH'].append(path)
 
 env['LIBPATH'] = ['#agg', '#src']
 
-for path in [env['BOOST_LIBS'], env['PNG_LIBS'], env['JPEG_LIBS'], env['TIFF_LIBS'], env['PGSQL_LIBS'], env['PROJ_LIBS']]:
+for path in [env['BOOST_LIBS'],
+             env['PNG_LIBS'],
+             env['JPEG_LIBS'],
+             env['TIFF_LIBS'],
+             env['PGSQL_LIBS'],
+             env['PROJ_LIBS']]:
     if path not in env['LIBPATH']: env['LIBPATH'].append(path)
-
+    
 env.ParseConfig(env['FREETYPE_CONFIG'] + ' --libs --cflags')
 
 C_LIBSHEADERS = [
@@ -76,8 +85,8 @@
     ['tiff', 'tiff.h', True],
     ['z', 'zlib.h', True],
     ['jpeg', ['stdio.h', 'jpeglib.h'], True],
-    ['pq', 'libpq-fe.h', False],
-    ['proj', 'proj_api.h', False]
+    ['proj', 'proj_api.h', True],
+    ['pq', 'libpq-fe.h', False]
 ]
 
 BOOST_LIBSHEADERS = [
@@ -130,10 +139,7 @@
 
     SConscript('bindings/python/SConscript')
 
-    if 'proj' in env['LIBS']:
-        SConscript('bindings/python/pyprojection/SConscript')
-        env['LIBS'].remove('proj')
-
+    
 env = conf.Finish()
 
 # Setup the c++ args for our own codebase

Modified: trunk/agg/SConscript
===================================================================
--- trunk/agg/SConscript	2006-10-16 13:32:45 UTC (rev 329)
+++ trunk/agg/SConscript	2006-10-16 13:44:52 UTC (rev 330)
@@ -21,4 +21,4 @@
 
 Import('env')
 
-env.StaticLibrary('agg', glob.glob('./src/' + '*.cpp'), LIBS=[], CPPPATH='./include', CXXFLAGS='-O3 -fPIC ')
+env.StaticLibrary('agg', glob.glob('./src/' + '*.cpp'), LIBS=[], CPPPATH='./include', CXXFLAGS='-O3 -fPIC -DNDEBUG')

Modified: trunk/bindings/python/mapnik/__init__.py
===================================================================
--- trunk/bindings/python/mapnik/__init__.py	2006-10-16 13:32:45 UTC (rev 329)
+++ trunk/bindings/python/mapnik/__init__.py	2006-10-16 13:44:52 UTC (rev 330)
@@ -55,10 +55,16 @@
         return 'Coord(%s,%s)' % (self.x, self.y)
 
 class _Envelope(Envelope,_injector):
-    def __repr__(self):
-        return 'Envelope(%s,%s,%s,%s)' % \
-               (self.minx,self.miny,self.maxx,self.maxy)
+  def __repr__(self):
+    return 'Envelope(%s,%s,%s,%s)' % \
+           (self.minx,self.miny,self.maxx,self.maxy)
 
+class _Projection(Projection,_injector):
+  def forward(self,pt):
+    return forward(pt,self)
+  def inverse(self,pt):
+    return inverse(pt,self)
+    
 def Datasource (**keywords):
     return CreateDatasource(keywords)
 

Added: trunk/bindings/python/mapnik_coord.cpp
===================================================================
--- trunk/bindings/python/mapnik_coord.cpp	2006-10-16 13:32:45 UTC (rev 329)
+++ trunk/bindings/python/mapnik_coord.cpp	2006-10-16 13:44:52 UTC (rev 330)
@@ -0,0 +1,45 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko, Jean-Francois Doyon
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id$
+
+#include <boost/python.hpp>
+#include <mapnik/coord.hpp>
+
+void export_coord()
+{
+    using namespace boost::python;
+    using mapnik::coord;
+    class_<coord<double,2> >("Coord",init<double,double>())
+        .def_readwrite("x", &coord<double,2>::x)
+        .def_readwrite("y", &coord<double,2>::y)
+        .def(self == self) // __eq__
+        .def(self + self) // __add__
+        .def(self + float())
+        .def(float() + self)
+        .def(self - self) // __sub__
+        .def(self - float())
+        .def(self * float()) //__mult__
+        .def(float() * self) 
+        .def(self / float()) // __div__
+        ;
+    
+}

Added: trunk/bindings/python/mapnik_datasource.cpp
===================================================================
--- trunk/bindings/python/mapnik_datasource.cpp	2006-10-16 13:32:45 UTC (rev 329)
+++ trunk/bindings/python/mapnik_datasource.cpp	2006-10-16 13:44:52 UTC (rev 330)
@@ -0,0 +1,68 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko, Jean-Francois Doyon
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id$
+
+#include <boost/python.hpp>
+#include <mapnik/envelope.hpp>
+#include <mapnik/datasource.hpp>
+#include <mapnik/datasource_cache.hpp>
+
+namespace  
+{
+    //user-friendly wrapper that uses Python dictionary
+    using namespace boost::python;
+    boost::shared_ptr<mapnik::datasource> create_datasource(const dict& d)
+    {
+        mapnik::parameters params;
+        boost::python::list keys=d.keys();
+        for (int i=0; i<len(keys); ++i)
+        {
+            std::string key = extract<std::string>(keys[i]);
+            object obj = d[key];
+            extract<std::string> ex(obj);
+            if (ex.check())
+            {
+                params[key] = ex();
+            }            
+        }
+        
+        return mapnik::datasource_cache::create(params);
+    }
+}
+
+void export_datasource()
+{
+    using namespace boost::python;
+    using mapnik::datasource;
+    
+    class_<datasource,boost::shared_ptr<datasource>,
+        boost::noncopyable>("Datasource",no_init)
+        .def("envelope",&datasource::envelope,
+             return_value_policy<copy_const_reference>())
+        .def("features",&datasource::features)
+        .def("params",&datasource::params,return_value_policy<copy_const_reference>(), 
+             "The configuration parameters of the data source. "  
+             "These vary depending on the type of data source.")
+        ;
+    
+    def("CreateDatasource",&create_datasource);
+}

Modified: trunk/bindings/python/mapnik_envelope.cpp
===================================================================
--- trunk/bindings/python/mapnik_envelope.cpp	2006-10-16 13:32:45 UTC (rev 329)
+++ trunk/bindings/python/mapnik_envelope.cpp	2006-10-16 13:44:52 UTC (rev 330)
@@ -85,7 +85,12 @@
         .def("intersects",intersects_p1)
         .def("intersects",intersects_p2)
         .def("intersects",intersects_p3)
-        .def(self == self)
+        .def(self == self) // __eq__
+        .def(self + self)  // __add__
+        .def(self - self)  // __sub__
+        .def(self * float()) // __mult__
+        .def(float() * self) 
+        .def(self / float()) // __div__
         .def_pickle(envelope_pickle_suite())
         ;
 }

Modified: trunk/bindings/python/mapnik_layer.cpp
===================================================================
--- trunk/bindings/python/mapnik_layer.cpp	2006-10-16 13:32:45 UTC (rev 329)
+++ trunk/bindings/python/mapnik_layer.cpp	2006-10-16 13:44:52 UTC (rev 330)
@@ -37,22 +37,27 @@
     	.def(vector_indexing_suite<std::vector<std::string>,true >())
     	;
     
-    class_<Layer>("Layer","A map layer.", init<std::string const&>())
+    class_<Layer>("Layer", "A map layer.", init<std::string const&,optional<std::string const&> >())
         .add_property("name", 
-                      make_function(&Layer::name, return_value_policy<reference_existing_object>()),
+                      make_function(&Layer::name, return_value_policy<copy_const_reference>()),
                       &Layer::set_name,
                       "Get/Set the name of the layer.")
         
         .add_property("title",
-                      make_function(&Layer::title, return_value_policy<reference_existing_object>()),
+                      make_function(&Layer::title, return_value_policy<copy_const_reference>()),
                       &Layer::set_title,
                       "Get/Set the title of the layer.")
  
         .add_property("abstract", 
-                      make_function(&Layer::abstract,return_value_policy<reference_existing_object>()),
+                      make_function(&Layer::abstract,return_value_policy<copy_const_reference>()),
                       &Layer::set_abstract,
                       "Get/Set the abstract of the layer.")
         
+        .add_property("src", 
+                      make_function(&Layer::srs,return_value_policy<copy_const_reference>()),
+                      &Layer::set_srs,
+                      "Get/Set the SRS of the layer.")
+        
         .add_property("minzoom",
                       &Layer::getMinZoom,
                       &Layer::setMinZoom)

Modified: trunk/bindings/python/mapnik_line_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_line_symbolizer.cpp	2006-10-16 13:32:45 UTC (rev 329)
+++ trunk/bindings/python/mapnik_line_symbolizer.cpp	2006-10-16 13:44:52 UTC (rev 330)
@@ -38,7 +38,7 @@
         .def(init<Color const& ,float>())
         .add_property("stroke",make_function
                       (&line_symbolizer::get_stroke,
-                       return_value_policy<reference_existing_object>()),
+                       return_value_policy<copy_const_reference>()),
                       &line_symbolizer::set_stroke)
 	;    
 }

Modified: trunk/bindings/python/mapnik_map.cpp
===================================================================
--- trunk/bindings/python/mapnik_map.cpp	2006-10-16 13:32:45 UTC (rev 329)
+++ trunk/bindings/python/mapnik_map.cpp	2006-10-16 13:44:52 UTC (rev 330)
@@ -40,7 +40,7 @@
     static boost::python::tuple
     getinitargs(const Map& m)
     {
-        return boost::python::make_tuple(m.getWidth(),m.getHeight(),m.srid());
+        return boost::python::make_tuple(m.getWidth(),m.getHeight(),m.srs());
     }
 
     static  boost::python::tuple
@@ -85,10 +85,11 @@
     	.def(vector_indexing_suite<std::vector<Layer> >())
     	;
     
-    class_<Map>("Map","The map object.",init<int,int,boost::python::optional<int> >())
+    class_<Map>("Map","The map object.",init<int,int,optional<std::string const&> >())
         .add_property("width",&Map::getWidth,"The width of the map image.")
         .add_property("height",&Map::getHeight,"The height of the map image.")
-        .add_property("srid",&Map::srid)
+        .add_property("srs",make_function(&Map::srs,return_value_policy<copy_const_reference>()),
+                      &Map::set_srs,"Spatial reference in proj4 format e.g. \"+proj=latlong +datum=WGS84\"")
         .add_property("background",make_function
                       (&Map::getBackground,return_value_policy<copy_const_reference>()),
                       &Map::setBackground, "The background color of the map.")
@@ -102,6 +103,7 @@
         .def("zoom_to_box",&Map::zoomToBox, "Set the geographical extent of the map.")
         .def("pan",&Map::pan)
         .def("zoom",&Map::zoom)
+        .def("zoom_all",&Map::zoom_all)
         .def("pan_and_zoom",&Map::pan_and_zoom)
         .def("append_style",&Map::insert_style)
         .def("remove_style",&Map::remove_style)

Modified: trunk/bindings/python/mapnik_polygon_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_polygon_symbolizer.cpp	2006-10-16 13:32:45 UTC (rev 329)
+++ trunk/bindings/python/mapnik_polygon_symbolizer.cpp	2006-10-16 13:44:52 UTC (rev 330)
@@ -35,7 +35,7 @@
         .def(init<Color const&>("TODO"))
         .add_property("fill",make_function
                       (&polygon_symbolizer::get_fill,
-                       return_value_policy<reference_existing_object>()),
+                       return_value_policy<copy_const_reference>()),
                       &polygon_symbolizer::set_fill)
         .add_property("fill_opacity",
                       &polygon_symbolizer::get_opacity,

Added: trunk/bindings/python/mapnik_projection.cpp
===================================================================
--- trunk/bindings/python/mapnik_projection.cpp	2006-10-16 13:32:45 UTC (rev 329)
+++ trunk/bindings/python/mapnik_projection.cpp	2006-10-16 13:44:52 UTC (rev 330)
@@ -0,0 +1,64 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko, Jean-Francois Doyon
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id$
+
+#include <boost/python.hpp>
+#include <mapnik/coord.hpp>
+#include <mapnik/projection.hpp>
+
+namespace {
+    mapnik::coord2d forward(mapnik::coord2d const& pt, 
+                            mapnik::projection const& prj)
+    {
+        double x = pt.x;
+        double y = pt.y;
+        prj.forward(x,y);
+        return mapnik::coord2d(x,y);
+    }
+    
+    mapnik::coord2d inverse(mapnik::coord2d const& pt, 
+                            mapnik::projection const& prj)
+    {
+        double x = pt.x;
+        double y = pt.y;
+        prj.inverse(x,y);
+        return mapnik::coord2d(x,y);
+    }
+    
+}
+
+void export_projection ()
+{
+    using namespace boost::python; 
+    using mapnik::projection;
+    
+    class_<projection>("Projection", init<optional<std::string const&> >())
+        .def ("forward",&projection::forward)
+        .def ("inverse",&projection::inverse)
+        .def ("params", make_function(&projection::params,
+                                      return_value_policy<copy_const_reference>()))
+        ;
+    
+    def("forward",&forward);
+    def("inverse",&inverse);
+    
+}

Modified: trunk/bindings/python/mapnik_python.cpp
===================================================================
--- trunk/bindings/python/mapnik_python.cpp	2006-10-16 13:32:45 UTC (rev 329)
+++ trunk/bindings/python/mapnik_python.cpp	2006-10-16 13:44:52 UTC (rev 330)
@@ -26,6 +26,7 @@
 #include <boost/python/detail/api_placeholder.hpp>
 
 void export_color();
+void export_coord();
 void export_layer();
 void export_parameters();
 void export_envelope();
@@ -37,6 +38,7 @@
 void export_rule();
 void export_style();
 void export_stroke();
+void export_datasource();
 void export_datasource_cache();
 void export_point_symbolizer();
 void export_line_symbolizer();
@@ -46,6 +48,7 @@
 void export_raster_symbolizer();
 void export_text_symbolizer();
 void export_font_engine();
+void export_projection();
 
 #include <mapnik/map.hpp>
 #include <mapnik/agg_renderer.hpp>
@@ -70,28 +73,6 @@
     ren.apply();
 }
 
-namespace  
-{
-    //user-friendly wrapper that uses Python dictionary
-    using namespace boost::python;
-    boost::shared_ptr<mapnik::datasource> create_datasource(const dict& d)
-    {
-        mapnik::parameters params;
-        boost::python::list keys=d.keys();
-        for (int i=0; i<len(keys); ++i)
-        {
-            std::string key = extract<std::string>(keys[i]);
-            object obj = d[key];
-            extract<std::string> ex(obj);
-            if (ex.check())
-            {
-                params[key] = ex();
-            }            
-        }
-        
-        return mapnik::datasource_cache::create(params);
-    }
-}
 
 BOOST_PYTHON_MODULE(_mapnik)
 {
@@ -109,18 +90,7 @@
     class_<Featureset,featureset_ptr,boost::noncopyable>("FeatureSet",no_init)
       ;
     
-    class_<datasource,boost::shared_ptr<datasource>,
-        boost::noncopyable>("Datasource",no_init)
-        .def("envelope",&datasource::envelope,
-             return_value_policy<reference_existing_object>())
-        .def("features",&datasource::features)
-        .def("params",&datasource::params,return_value_policy<reference_existing_object>(), 
-             "The configuration parameters of the data source. "  
-             "These vary depending on the type of data source.")
-        ;
-    
-    def("CreateDatasource",&create_datasource);
-    
+    export_datasource();
     export_parameters();
     export_color(); 
     export_envelope();   
@@ -139,12 +109,8 @@
     export_raster_symbolizer();
     export_text_symbolizer();
     export_font_engine();
-    
-    class_<coord<double,2> >("Coord",init<double,double>())
-        .def_readwrite("x", &coord<double,2>::x)
-        .def_readwrite("y", &coord<double,2>::y)
-        ;
-    
+    export_projection();
+    export_coord();
     export_map();
     
     def("render_to_file",&render_to_file);

Modified: trunk/bindings/python/mapnik_stroke.cpp
===================================================================
--- trunk/bindings/python/mapnik_stroke.cpp	2006-10-16 13:32:45 UTC (rev 329)
+++ trunk/bindings/python/mapnik_stroke.cpp	2006-10-16 13:44:52 UTC (rev 330)
@@ -45,7 +45,7 @@
     class_<stroke>("Stroke",init<>())
         .def(init<Color,float>())
         .add_property("color",make_function
-                      (&stroke::get_color,return_value_policy<reference_existing_object>()),
+                      (&stroke::get_color,return_value_policy<copy_const_reference>()),
                       &stroke::set_color)
         .add_property("width",&stroke::get_width,&stroke::set_width) 
         .add_property("opacity",&stroke::get_opacity,&stroke::set_opacity)

Modified: trunk/demo/python/rundemo.py
===================================================================
--- trunk/demo/python/rundemo.py	2006-10-16 13:32:45 UTC (rev 329)
+++ trunk/demo/python/rundemo.py	2006-10-16 13:44:52 UTC (rev 330)
@@ -30,7 +30,7 @@
 # Instanciate a map, giving it a width and height. Remember: the word "map" is
 # reserved in Python! :)
 
-m = Map(800,600)
+m = Map(800,600,"+proj=latlong")
 
 # Set its background colour. More on colours later ...
 

Modified: trunk/include/mapnik/agg_renderer.hpp
===================================================================
--- trunk/include/mapnik/agg_renderer.hpp	2006-10-16 13:32:45 UTC (rev 329)
+++ trunk/include/mapnik/agg_renderer.hpp	2006-10-16 13:44:52 UTC (rev 330)
@@ -45,13 +45,27 @@
         void end_map_processing(Map const& map);
         void start_layer_processing(Layer const& lay);
         void end_layer_processing(Layer const& lay);
-        void process(point_symbolizer const& sym,Feature const& feature);
-        void process(line_symbolizer const& sym,Feature const& feature);
-        void process(line_pattern_symbolizer const& sym,Feature const& feature);
-        void process(polygon_symbolizer const& sym,Feature const& feature);
-        void process(polygon_pattern_symbolizer const& sym,Feature const& feature);
-        void process(raster_symbolizer const& sym,Feature const& feature);
-        void process(text_symbolizer const& sym,Feature const& feature);
+        void process(point_symbolizer const& sym,
+                     Feature const& feature,
+                     proj_transform const& prj_trans);
+        void process(line_symbolizer const& sym,
+                     Feature const& feature,
+                     proj_transform const& prj_trans);
+        void process(line_pattern_symbolizer const& sym,
+                     Feature const& feature,
+                     proj_transform const& prj_trans);
+        void process(polygon_symbolizer const& sym,
+                     Feature const& feature,
+                     proj_transform const& prj_trans);
+        void process(polygon_pattern_symbolizer const& sym,
+                     Feature const& feature,
+                     proj_transform const& prj_trans);
+        void process(raster_symbolizer const& sym,
+                     Feature const& feature,
+                     proj_transform const& prj_trans);
+        void process(text_symbolizer const& sym,
+                     Feature const& feature,
+                     proj_transform const& prj_trans);
     private:
         T & pixmap_;
         CoordTransform t_;

Modified: trunk/include/mapnik/ctrans.hpp
===================================================================
--- trunk/include/mapnik/ctrans.hpp	2006-10-16 13:32:45 UTC (rev 329)
+++ trunk/include/mapnik/ctrans.hpp	2006-10-16 13:44:52 UTC (rev 330)
@@ -27,6 +27,7 @@
 
 #include <mapnik/envelope.hpp>
 #include <mapnik/coord_array.hpp>
+#include <mapnik/projection.hpp>
 
 namespace mapnik {
     typedef coord_array<coord2d> CoordinateArray;
@@ -53,7 +54,38 @@
         Transform const& t_;
         Geometry& geom_;
     };
+
+    template <typename Transform,typename Geometry>
+    struct MAPNIK_DECL coord_transform2
+    {
+        coord_transform2(Transform const& t, 
+                         Geometry& geom, 
+                         proj_transform const& prj_trans)
+            : t_(t), 
+              geom_(geom), 
+              prj_trans_(prj_trans)  {}
+        
+        unsigned  vertex(double * x , double  * y) const
+        {
+            unsigned command = geom_.vertex(x,y);
+            double z=0;
+            prj_trans_.backward(*x,*y,z);
+            t_.forward(x,y);
+            return command;
+        }
+        
+        void rewind (unsigned pos)
+        {
+            geom_.rewind(pos);
+        }
+        
+    private:
+        Transform const& t_;
+        Geometry& geom_;
+        proj_transform const& prj_trans_;
+    };
     
+
     class CoordTransform
     {
     private:

Modified: trunk/include/mapnik/feature_style_processor.hpp
===================================================================
--- trunk/include/mapnik/feature_style_processor.hpp	2006-10-16 13:32:45 UTC (rev 329)
+++ trunk/include/mapnik/feature_style_processor.hpp	2006-10-16 13:44:52 UTC (rev 330)
@@ -36,6 +36,7 @@
 #include <mapnik/map.hpp>
 #include <mapnik/attribute_collector.hpp>
 #include <mapnik/utils.hpp>
+#include <mapnik/projection.hpp>
 
 namespace mapnik
 {       
@@ -44,17 +45,22 @@
     {
         struct symbol_dispatch : public boost::static_visitor<>
         {
-            symbol_dispatch (Processor & output,Feature const& f)
-                : output_(output),f_(f) {}
-	    
+            symbol_dispatch (Processor & output,
+                             Feature const& f, 
+                             proj_transform const& prj_trans)
+                : output_(output),
+                  f_(f),
+                  prj_trans_(prj_trans)  {}
+            
             template <typename T>
             void operator () (T const& sym) const
             {
-                output_.process(sym,f_);
+                output_.process(sym,f_,prj_trans_);
             }
-
+            
             Processor & output_;
             Feature const& f_;
+            proj_transform const& prj_trans_;
         };
     public:
         feature_style_processor(Map const& m)
@@ -63,52 +69,82 @@
         void apply()
         {
             boost::progress_timer t;
+            
             Processor & p = static_cast<Processor&>(*this);
-
+            
             p.start_map_processing(m_);
-	    
+            
             std::vector<Layer>::const_iterator itr = m_.layers().begin();
             std::vector<Layer>::const_iterator end = m_.layers().end();
-            while (itr != end)
+            
+            try
             {
-                if (itr->isVisible(m_.scale()) && 
-                    itr->envelope().intersects(m_.getCurrentExtent()))
-                {    
-                    apply_to_layer(*itr,p);
+                projection proj(m_.srs()); // map projection
+                
+                while (itr != end)
+                {
+                    if (itr->isVisible(m_.scale()))// && 
+                        //itr->envelope().intersects(m_.getCurrentExtent())) TODO
+                    {    
+                        apply_to_layer(*itr, p, proj);
+                    }
+                    ++itr;
                 }
-                ++itr;
             }
-            
+            catch (proj_init_error& ex)
+            {
+                std::clog << ex.what() << "\n"; 
+            }
+
             p.end_map_processing(m_);
         }	
     private:
-        void apply_to_layer(Layer const& lay,Processor & p)
+        void apply_to_layer(Layer const& lay, Processor & p, projection const& proj0)
         {
             p.start_layer_processing(lay);
             boost::shared_ptr<datasource> ds=lay.datasource();
             if (ds)
             {
-                Envelope<double> const& bbox=m_.getCurrentExtent();
+                Envelope<double> const& ext=m_.getCurrentExtent();
+              
+                projection proj1(lay.srs());
+                proj_transform prj_trans(proj0,proj1);
+                
+                double x0 = ext.minx();
+                double y0 = ext.miny();
+                double z0 = 0.0;
+                double x1 = ext.maxx();
+                double y1 = ext.maxy();
+                double z1 = 0.0;
+                prj_trans.forward(x0,y0,z0);
+                prj_trans.forward(x1,y1,z1);
+                Envelope<double> bbox(x0,y0,x1,y1);
+                std::clog << bbox << "\n";
+                
                 double scale = m_.scale();
-	
+                
                 std::vector<std::string> const& style_names = lay.styles();
                 std::vector<std::string>::const_iterator stylesIter = style_names.begin();
-                while (stylesIter != style_names.end())
+                std::vector<std::string>::const_iterator stylesEnd = style_names.end();
+                
+                while (stylesIter != stylesEnd)
                 {
                     std::set<std::string> names;
                     attribute_collector<Feature> collector(names);
                     std::vector<rule_type*> if_rules;
                     std::vector<rule_type*> else_rules;
-		
+                    
                     bool active_rules=false;
-		    
+                    
                     feature_type_style const& style=m_.find_style(*stylesIter++);
-		    
+                        
+                    query q(bbox); //BBOX query
+
                     const std::vector<rule_type>& rules=style.get_rules();
                     std::vector<rule_type>::const_iterator ruleIter=rules.begin();
-		    
-                    query q(bbox); //BBOX query
-                    while (ruleIter!=rules.end())
+                    std::vector<rule_type>::const_iterator ruleEnd=rules.end();
+                                        
+                    while (ruleIter!=ruleEnd)
                     {
                         if (ruleIter->active(scale))
                         {
@@ -127,8 +163,10 @@
                         ++ruleIter;
                     }
                     std::set<std::string>::const_iterator namesIter=names.begin();
+                    std::set<std::string>::const_iterator namesEnd =names.end();
+                    
                     // push all property names
-                    while (namesIter!=names.end())
+                    while (namesIter!=namesEnd)
                     {
                         q.add_property_name(*namesIter);
                         ++namesIter;
@@ -143,7 +181,8 @@
                             {		   
                                 bool do_else=true;		    
                                 std::vector<rule_type*>::const_iterator itr=if_rules.begin();
-                                while (itr!=if_rules.end())
+                                std::vector<rule_type*>::const_iterator end=if_rules.end();
+                                while (itr != end)
                                 {
                                     filter_ptr const& filter=(*itr)->get_filter();    
                                     if (filter->pass(*feature))
@@ -151,10 +190,11 @@
                                         do_else=false;
                                         const symbolizers& symbols = (*itr)->get_symbolizers();
                                         symbolizers::const_iterator symIter=symbols.begin();
-                                        while (symIter!=symbols.end())
+                                        symbolizers::const_iterator symEnd =symbols.end();
+                                        while (symIter != symEnd)
                                         {   
                                             boost::apply_visitor
-                                                (symbol_dispatch(p,*feature),*symIter++);
+                                                (symbol_dispatch(p,*feature,prj_trans),*symIter++);
                                         }
                                     }			    
                                     ++itr;
@@ -164,14 +204,19 @@
                                     //else filter
                                     std::vector<rule_type*>::const_iterator itr=
                                         else_rules.begin();
-                                    while (itr != else_rules.end())
+                                    std::vector<rule_type*>::const_iterator end=
+                                        else_rules.end();
+                                    while (itr != end)
                                     {
                                         const symbolizers& symbols = (*itr)->get_symbolizers();
-                                        symbolizers::const_iterator symIter=symbols.begin();
-                                        while (symIter!=symbols.end())
+                                        symbolizers::const_iterator symIter= symbols.begin();
+                                        symbolizers::const_iterator symEnd = symbols.end();
+                                        
+                                        while (symIter!=symEnd)
                                         {
                                             boost::apply_visitor
-                                                (symbol_dispatch(p,*feature),*symIter++);
+                                                (symbol_dispatch(p,*feature,prj_trans),
+                                                 *symIter++);
                                         }
                                         ++itr;
                                     }
@@ -180,10 +225,10 @@
                         }
                     }
                 }
+                
             }
             p.end_layer_processing(lay);
-        }
-	
+        }	
         Map const& m_;
     };
 }

Modified: trunk/include/mapnik/layer.hpp
===================================================================
--- trunk/include/mapnik/layer.hpp	2006-10-16 13:32:45 UTC (rev 329)
+++ trunk/include/mapnik/layer.hpp	2006-10-16 13:44:52 UTC (rev 330)
@@ -38,6 +38,8 @@
         std::string name_;
         std::string title_;
         std::string abstract_;
+        std::string srs_;
+        
         double minZoom_;
         double maxZoom_;
         bool active_;
@@ -49,7 +51,7 @@
         mutable std::vector<boost::shared_ptr<Feature> > selection_;
         
     public:
-        explicit Layer(std::string const& name);
+        explicit Layer(std::string const& name, std::string const& srs="+proj=latlong +datum=WGS84");
         Layer(Layer const& l);
         Layer& operator=(Layer const& l);
         bool operator==(Layer const& other) const;
@@ -59,6 +61,8 @@
         const std::string& title() const;
         void set_abstract(std::string const& abstract);
         const std::string& abstract() const;
+        void set_srs(std::string const& srs);
+        std::string const& srs() const;
         void add_style(std::string const& stylename);
         std::vector<std::string> const& styles() const;
         void selection_style(const std::string& name);

Modified: trunk/include/mapnik/map.hpp
===================================================================
--- trunk/include/mapnik/map.hpp	2006-10-16 13:32:45 UTC (rev 329)
+++ trunk/include/mapnik/map.hpp	2006-10-16 13:44:52 UTC (rev 330)
@@ -36,18 +36,17 @@
         static const unsigned MAX_MAPSIZE=2048;
         unsigned width_;
         unsigned height_;
-        int srid_;
+        std::string  srs_;
         Color background_;
         std::map<std::string,feature_type_style> styles_;
         std::vector<Layer> layers_;
         Envelope<double> currentExtent_;
         
     public:
- 
         typedef std::map<std::string,feature_type_style>::const_iterator style_iterator;
         
         Map();
-        Map(int width,int height,int srid=-1);
+        Map(int width, int height, std::string const& srs="+proj=latlong +datum=WGS84");
         Map(const Map& rhs);
         Map& operator=(const Map& rhs);
         style_iterator begin_styles() const;
@@ -67,7 +66,8 @@
         void setWidth(unsigned width);
         void setHeight(unsigned height);
         void resize(unsigned width,unsigned height);
-        int srid() const;
+        std::string const& srs() const;
+        void set_srs(std::string const& srs);
         void setBackground(const Color& c);
         const Color& getBackground() const;
         void zoom(double zoom);

Added: trunk/include/mapnik/projection.hpp
===================================================================
--- trunk/include/mapnik/projection.hpp	2006-10-16 13:32:45 UTC (rev 329)
+++ trunk/include/mapnik/projection.hpp	2006-10-16 13:44:52 UTC (rev 330)
@@ -0,0 +1,174 @@
+
+#ifndef PROJECTION_HPP
+#define PROJECTION_HPP
+
+#include <string>
+#include <iostream>
+#include <stdexcept>
+#include <boost/utility.hpp>
+
+#include <mapnik/envelope.hpp>
+#include <proj_api.h>
+
+namespace mapnik
+{   
+    class proj_init_error : public std::runtime_error
+    {
+    public:
+        proj_init_error(std::string const& params)
+            : std::runtime_error("failed to initialize projection with:" + params) {}
+    };
+    
+    class projection
+    {
+        friend class proj_transform;
+    public:
+        explicit projection(std::string params = "+proj=latlong +ellps=WGS84")
+            : params_(params)
+        { 
+            init(); //
+        }
+        
+        projection(projection const& rhs)
+            : params_(rhs.params_) 
+        {
+            init(); //
+        }
+        
+        projection& operator=(projection const& rhs) 
+        { 
+            projection tmp(rhs);
+            swap(tmp);
+            return *this;
+        }
+        
+        bool is_initialized() const
+        {
+            return proj_ ? true : false;
+        }
+        
+        std::string const& params() const
+        {
+            return params_;
+        }
+        
+        void forward(double & x, double &y ) const
+        {
+            projUV p;
+            p.u = x * DEG_TO_RAD;
+            p.v = y * DEG_TO_RAD;
+            p = pj_fwd(p,proj_);
+            x = p.u;
+            y = p.v;
+        }
+        
+        void inverse(double & x,double & y) const
+        {
+            projUV p;
+            p.u = x;
+            p.v = y;
+            p = pj_inv(p,proj_);
+            x = RAD_TO_DEG * p.u;
+            y = RAD_TO_DEG * p.v;
+        }
+        
+        ~projection() 
+        {
+            if (proj_) pj_free(proj_);
+        }
+    private:
+        
+        void init()
+        {
+            proj_=pj_init_plus(params_.c_str());
+            if (!proj_) throw proj_init_error(params_);
+        }
+        
+        void swap (projection& rhs)
+        {
+            std::swap(params_,rhs.params_);
+            init ();
+        } 
+        
+    private:
+        std::string params_;
+        projPJ proj_;
+    };
+    
+    class proj_transform : private boost::noncopyable
+    {
+    public:
+        proj_transform(projection const& source, 
+                       projection const& dest)
+            : source_(source),
+              dest_(dest) 
+        {
+            is_source_latlong_ = pj_is_latlong(source_.proj_);
+            is_dest_latlong_ = pj_is_latlong(dest_.proj_);
+        }
+        
+        bool forward (double & x, double & y , double & z) const
+        {
+            if (is_source_latlong_)
+            {
+                x *= DEG_TO_RAD;
+                y *= DEG_TO_RAD;
+            }
+            
+            if (pj_transform( source_.proj_, dest_.proj_, 1, 
+                              0, &x,&y,&z) != 0)
+            {
+                return false;
+            }
+            
+            if (is_dest_latlong_)
+            {
+                x *= RAD_TO_DEG;
+                y *= RAD_TO_DEG;
+            }
+            
+            return true;
+        } 
+        
+        bool forward (Envelope<double> & ext) const
+        {
+            if (is_source_latlong_)
+            {
+                ext = ext.intersect(Envelope<double>(-180,-90,180,90));
+            }
+            // TODO
+            return true;
+        }
+        
+        bool backward (double & x, double & y , double & z) const
+        {
+            if (is_dest_latlong_)
+            {
+                x *= DEG_TO_RAD;
+                y *= DEG_TO_RAD;
+            }
+            
+            if (pj_transform( dest_.proj_, source_.proj_, 1, 
+                              0, &x,&y,&z) != 0)
+            {
+                return false;
+            }
+            
+            if (is_source_latlong_)
+            {
+                x *= RAD_TO_DEG;
+                y *= RAD_TO_DEG;
+            }
+            
+            return true;
+        } 
+        
+    private:
+        projection const& source_;
+        projection const& dest_;
+        bool is_source_latlong_;
+        bool is_dest_latlong_;
+    };
+}
+
+#endif //PROJECTION_HPP

Modified: trunk/src/agg_renderer.cpp
===================================================================
--- trunk/src/agg_renderer.cpp	2006-10-16 13:32:45 UTC (rev 329)
+++ trunk/src/agg_renderer.cpp	2006-10-16 13:44:52 UTC (rev 330)
@@ -126,9 +126,11 @@
     }
     
     template <typename T>	
-    void agg_renderer<T>::process(polygon_symbolizer const& sym,Feature const& feature)
+    void agg_renderer<T>::process(polygon_symbolizer const& sym,
+                                  Feature const& feature,
+                                  proj_transform const& prj_trans)
     {
-        typedef  coord_transform<CoordTransform,geometry_type> path_type;
+        typedef  coord_transform2<CoordTransform,geometry_type> path_type;
         typedef agg::renderer_base<agg::pixfmt_rgba32> ren_base;    
         typedef agg::renderer_scanline_aa_solid<ren_base> renderer;
 	    
@@ -139,7 +141,7 @@
         {
             unsigned width = pixmap_.width();
             unsigned height = pixmap_.height();
-            path_type path(t_,*geom);
+            path_type path(t_,*geom,prj_trans);
             agg::row_ptr_cache<agg::int8u> buf(pixmap_.raw_data(),width,height,width * 4);
             agg::pixfmt_rgba32 pixf(buf);
             ren_base renb(pixf);	    
@@ -147,9 +149,8 @@
             unsigned r=fill_.red();
             unsigned g=fill_.green();
             unsigned b=fill_.blue();
-            //unsigned a=fill_.alpha();
             renderer ren(renb);
-		
+            
             agg::rasterizer_scanline_aa<> ras;
             agg::scanline_u8 sl;
             ras.clip_box(0,0,width,height);
@@ -160,10 +161,12 @@
     }
 
     template <typename T>
-    void agg_renderer<T>::process(line_symbolizer const& sym,Feature const& feature)
+    void agg_renderer<T>::process(line_symbolizer const& sym,
+                                  Feature const& feature,
+                                  proj_transform const& prj_trans)
     {   
         typedef agg::renderer_base<agg::pixfmt_rgba32> ren_base; 
-        typedef coord_transform<CoordTransform,geometry_type> path_type;
+        typedef coord_transform2<CoordTransform,geometry_type> path_type;
         typedef agg::renderer_outline_aa<ren_base> renderer_oaa;
         typedef agg::rasterizer_outline_aa<renderer_oaa> rasterizer_outline_aa;
         typedef agg::renderer_scanline_aa_solid<ren_base> renderer;
@@ -171,7 +174,7 @@
         geometry_ptr const& geom=feature.get_geometry();
         if (geom && geom->num_points() > 1)
         {
-            path_type path(t_,*geom);
+            path_type path(t_,*geom,prj_trans);
             agg::row_ptr_cache<agg::int8u> buf(pixmap_.raw_data(),
                                                pixmap_.width(),
                                                pixmap_.height(),
@@ -277,17 +280,21 @@
     }
 
     template <typename T>
-    void agg_renderer<T>::process(point_symbolizer const& sym,Feature const& feature)
+    void agg_renderer<T>::process(point_symbolizer const& sym,
+                                  Feature const& feature,
+                                  proj_transform const& prj_trans)
     {
         geometry_ptr const& geom=feature.get_geometry();
         if (geom)
         {
             double x;
             double y;
+            double z=0;
             boost::shared_ptr<ImageData32> const& data = sym.get_data();
             if ( data )
             {
                 geom->label_position(&x,&y);
+                prj_trans.backward(x,y,z);
                 t_.forward(&x,&y);
                 int w = data->width();
                 int h = data->height();
@@ -307,9 +314,11 @@
     }
     
     template <typename T>
-    void  agg_renderer<T>::process(line_pattern_symbolizer const& sym,Feature const& feature)
+    void  agg_renderer<T>::process(line_pattern_symbolizer const& sym,
+                                   Feature const& feature,
+                                   proj_transform const& prj_trans)
     {
-        typedef  coord_transform<CoordTransform,geometry_type> path_type;
+        typedef  coord_transform2<CoordTransform,geometry_type> path_type;
         typedef agg::line_image_pattern<agg::pattern_filter_bilinear_rgba8> pattern_type;
         typedef agg::renderer_base<agg::pixfmt_rgba32> renderer_base;
         typedef agg::renderer_outline_image<renderer_base, pattern_type> renderer_type;
@@ -321,7 +330,7 @@
             unsigned width = pixmap_.width();
             unsigned height = pixmap_.height();
             ImageData32 const& pat = sym.get_pattern();
-            path_type path(t_,*geom);
+            path_type path(t_,*geom,prj_trans);
             agg::row_ptr_cache<agg::int8u> buf(pixmap_.raw_data(), width, height,width*4);
             agg::pixfmt_rgba32 pixf(buf);
             renderer_base ren_base(pixf);  
@@ -336,9 +345,11 @@
     }
     
     template <typename T>
-    void agg_renderer<T>::process(polygon_pattern_symbolizer const& sym,Feature const& feature)
+    void agg_renderer<T>::process(polygon_pattern_symbolizer const& sym,
+                                  Feature const& feature,
+                                  proj_transform const& prj_trans)
     {
-        typedef  coord_transform<CoordTransform,geometry_type> path_type;
+        typedef  coord_transform2<CoordTransform,geometry_type> path_type;
         typedef agg::renderer_base<agg::pixfmt_rgba32> ren_base; 
         typedef agg::wrap_mode_repeat wrap_x_type;
         typedef agg::wrap_mode_repeat wrap_y_type;
@@ -358,7 +369,7 @@
 	    
             unsigned width = pixmap_.width();
             unsigned height = pixmap_.height();
-            path_type path(t_,*geom);
+            path_type path(t_,*geom,prj_trans);
 	    
             agg::row_ptr_cache<agg::int8u> buf(pixmap_.raw_data(),width,height,width * 4);
             agg::pixfmt_rgba32 pixf(buf);
@@ -389,7 +400,9 @@
     }
 
     template <typename T>
-    void agg_renderer<T>::process(raster_symbolizer const& ,Feature const& feature)
+    void agg_renderer<T>::process(raster_symbolizer const&,
+                                  Feature const& feature,
+                                  proj_transform const& prj_trans)
     {
         // TODO -- at the moment raster_symbolizer is an empty class 
         // used for type dispatching, but we can have some fancy raster
@@ -405,9 +418,11 @@
     }
     
     template <typename T>
-    void agg_renderer<T>::process(text_symbolizer const& sym ,Feature const& feature)
+    void agg_renderer<T>::process(text_symbolizer const& sym,
+                                  Feature const& feature,
+                                  proj_transform const& prj_trans)
     {
-        typedef  coord_transform<CoordTransform,geometry_type> path_type;
+        typedef  coord_transform2<CoordTransform,geometry_type> path_type;
         geometry_ptr const& geom=feature.get_geometry();
         if (geom)
         {
@@ -416,7 +431,7 @@
                 geom->num_points() > 1)
             {
 	       
-                path_type path(t_,*geom);
+                path_type path(t_,*geom,prj_trans);
                 double x0,y0,x1,y1;
                 path.vertex(&x0,&y0);
                 path.vertex(&x1,&y1);

Modified: trunk/src/layer.cpp
===================================================================
--- trunk/src/layer.cpp	2006-10-16 13:32:45 UTC (rev 329)
+++ trunk/src/layer.cpp	2006-10-16 13:44:52 UTC (rev 330)
@@ -38,10 +38,11 @@
 
 namespace mapnik
 {   
-    Layer::Layer(std::string const& name)
+    Layer::Layer(std::string const& name, std::string const& srs)
         : name_(name),
           title_(""),
           abstract_(""),
+          srs_(srs),
           minZoom_(0),
           maxZoom_(std::numeric_limits<double>::max()),
           active_(true),
@@ -53,6 +54,7 @@
         : name_(rhs.name_),
           title_(rhs.title_),
           abstract_(rhs.abstract_),
+          srs_(rhs.srs_),
           minZoom_(rhs.minZoom_),
           maxZoom_(rhs.maxZoom_),
           active_(rhs.active_),
@@ -119,11 +121,21 @@
         return abstract_;
     }
 
+    void Layer::set_srs(std::string const& srs)
+    {
+        srs_ = srs;
+    }
+    
+    std::string const& Layer::srs() const
+    {
+        return srs_;
+    }
+    
     void Layer::add_style(std::string const& stylename)
     {
         styles_.push_back(stylename);
     }
-
+    
     std::vector<std::string> const& Layer::styles() const
     {
         return styles_;

Modified: trunk/src/load_map.cpp
===================================================================
--- trunk/src/load_map.cpp	2006-10-16 13:32:45 UTC (rev 329)
+++ trunk/src/load_map.cpp	2006-10-16 13:44:52 UTC (rev 330)
@@ -47,19 +47,24 @@
     {
         using boost::property_tree::ptree;
         ptree pt;
-        
         read_xml(filename,pt);
         
         boost::optional<std::string> bgcolor = 
             pt.get_optional<std::string>("Map.<xmlattr>.bgcolor");
-        if ( bgcolor)
+        
+        if (bgcolor)
         {
             Color bg = color_factory::from_string(bgcolor->c_str());
             map.setBackground(bg);
         }
         
+        std::string srs = pt.get<std::string>("Map.<xmlattr>.srs",
+                                           "+proj=latlong +datum=WGS84");
+        map.set_srs(srs);
+        
         ptree::const_iterator itr = pt.get_child("Map").begin();
         ptree::const_iterator end = pt.get_child("Map").end();
+        
         for (; itr != end; ++itr)
         {
             ptree::value_type const& v = *itr;
@@ -284,18 +289,19 @@
             else if (v.first == "Layer")
             {
                 
-                std::string name = v.second.get<std::string>("<xmlattr>.name","");
-                Layer lyr(name);
+                std::string name = v.second.get<std::string>("<xmlattr>.name","Unnamed");
+                std::string srs = v.second.get<std::string>("<xmlattr>.srs","+proj=latlong +datum=WGS84");
                 
+                Layer lyr(name, srs);
+                
                 boost::optional<std::string> status = 
-                    v.second.get<std::string>("<xmlattr>.status");
+                    v.second.get_optional<std::string>("<xmlattr>.status");
                 
                 if (status && *status == "off")
                 {
                     lyr.setActive(false);
                 }
                 
-                
                 ptree::const_iterator itr2 = v.second.begin();
                 ptree::const_iterator end2 = v.second.end();
                 

Modified: trunk/src/map.cpp
===================================================================
--- trunk/src/map.cpp	2006-10-16 13:32:45 UTC (rev 329)
+++ trunk/src/map.cpp	2006-10-16 13:44:52 UTC (rev 330)
@@ -24,6 +24,7 @@
 
 #include <mapnik/style.hpp>
 #include <mapnik/datasource.hpp>
+#include <mapnik/projection.hpp>
 #include <mapnik/layer.hpp>
 #include <mapnik/map.hpp>
 
@@ -32,17 +33,18 @@
     Map::Map()
         : width_(400),
           height_(400),
-          srid_(-1) {}
-    Map::Map(int width,int height,int srid)
+          srs_("+proj=latlong +datum=WGS84") {}
+    
+    Map::Map(int width,int height, std::string const& srs)
         : width_(width),
           height_(height),
-          srid_(srid),
+          srs_(srs),
           background_(Color(255,255,255)) {}
 
     Map::Map(const Map& rhs)
         : width_(rhs.width_),
           height_(rhs.height_),
-          srid_(rhs.srid_),
+          srs_(rhs.srs_),
           background_(rhs.background_),
           styles_(rhs.styles_),
           layers_(rhs.layers_),
@@ -53,12 +55,13 @@
         if (this==&rhs) return *this;
         width_=rhs.width_;
         height_=rhs.height_;
-        srid_=rhs.srid_;
+        srs_=rhs.srs_;
         background_=rhs.background_;
         styles_=rhs.styles_;
         layers_=rhs.layers_;
         return *this;
     }
+    
     Map::style_iterator  Map::begin_styles() const
     {
         return styles_.begin();
@@ -78,10 +81,9 @@
         styles_.erase(name);
     }
     
-    feature_type_style const&  Map::find_style(std::string const& name) const
+    feature_type_style const& Map::find_style(std::string const& name) const
     {
-        std::map<std::string,feature_type_style>::const_iterator itr
-            = styles_.find(name);
+        std::map<std::string,feature_type_style>::const_iterator itr = styles_.find(name);
         if (itr!=styles_.end()) 
             return itr->second;
         static feature_type_style default_style;
@@ -118,7 +120,6 @@
         return layers_[index];
     }
 
-
     std::vector<Layer> const& Map::layers() const
     {
         return layers_;
@@ -151,6 +152,7 @@
             fixAspectRatio();
         }
     }
+    
     void Map::resize(unsigned width,unsigned height)
     {
         if (width >= MIN_MAPSIZE && width <= MAX_MAPSIZE &&
@@ -162,11 +164,16 @@
         }
     }
 
-    int Map::srid() const
+    std::string const&  Map::srs() const
     {
-        return srid_;
+        return srs_;
     }
-
+    
+    void Map::set_srs(std::string const& srs)
+    {
+        srs_ = srs;
+    }
+    
     void Map::setBackground(const Color& c)
     {
         background_=c;
@@ -176,7 +183,7 @@
     {
         return background_;
     }
-
+    
     void Map::zoom(double factor)
     {
         coord2d center = currentExtent_.center();
@@ -191,23 +198,50 @@
     
     void Map::zoom_all() 
     {
-        std::vector<Layer>::const_iterator itr = layers_.begin();
-        Envelope<double> ext;
-        bool first = true;
-        while (itr != layers_.end())
+        try 
         {
-            if (first)
+            projection proj0(srs_);
+            Envelope<double> ext;
+            bool first = true;
+            std::vector<Layer>::const_iterator itr = layers_.begin();
+            std::vector<Layer>::const_iterator end = layers_.end();
+            while (itr != end)
             {
-                ext = itr->envelope();
-                first = false;
+                std::string const& layer_srs = itr->srs();
+                projection proj1(layer_srs);
+                proj_transform prj_trans(proj0,proj1);
+                
+                Envelope<double> layerExt = itr->envelope();
+                double x0 = layerExt.minx();
+                double y0 = layerExt.miny();
+                double z0 = 0.0;
+                double x1 = layerExt.maxx();
+                double y1 = layerExt.maxy();
+                double z1 = 0.0;
+                prj_trans.backward(x0,y0,z0);
+                prj_trans.backward(x1,y1,z1);
+                
+                Envelope<double> layerExt2(x0,y0,x1,y1);
+                std::clog << " layer1 - > " << layerExt << "\n";
+                std::clog << " layer2 - > " << layerExt2 << "\n";
+                
+                if (first)
+                {
+                    ext = layerExt2;
+                    first = false;
+                }
+                else 
+                {
+                    ext.expand_to_include(layerExt2);
+                }
+                ++itr;
             }
-            else 
-            {
-                ext.expand_to_include(itr->envelope());
-            }
-            ++itr;
+            zoomToBox(ext);
         }
-        zoomToBox(ext);
+        catch (proj_init_error & ex)
+        {
+            std::clog << ex.what() << '\n';
+        }
     }
 
     void Map::zoomToBox(const Envelope<double> &box)



From pavlenko at mail.berlios.de  Mon Oct 16 18:04:59 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Mon, 16 Oct 2006 18:04:59 +0200
Subject: [Mapnik-svn] r331 - trunk/include/mapnik
Message-ID: <200610161604.k9GG4xYi030713@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-16 18:04:57 +0200 (Mon, 16 Oct 2006)
New Revision: 331

Modified:
   trunk/include/mapnik/feature_layer_desc.hpp
Log:
removed commented out code



Modified: trunk/include/mapnik/feature_layer_desc.hpp
===================================================================
--- trunk/include/mapnik/feature_layer_desc.hpp	2006-10-16 13:44:52 UTC (rev 330)
+++ trunk/include/mapnik/feature_layer_desc.hpp	2006-10-16 16:04:57 UTC (rev 331)
@@ -183,68 +183,7 @@
         }
         return out;
     }
-    /*    
-          bool layer_descriptor_to_wkb(layer_descriptor const& desc,array<>& wkb)
-          {
-          //srid	
-          int srid = desc.get_srid();
-          wkb.write(&srid,sizeof(int));
 
-          //attribute descriptors
-          vector<attribute_descriptor> const& desc_ar = desc.get_descriptors();
-          vector<attribute_descriptor>::const_iterator itr=desc_ar.begin();
-          size_t num_desc = desc_ar.size();
-          wkb.write(&num_desc,sizeof(int));
-	
-          while (itr != desc_ar.end())
-          {
-          string name = itr->get_name();
-          wkb.write(name.c_str(),name.size()+1);
-	       
-          unsigned type = static_cast<int>(itr->get_type());
-          wkb.write(&type,sizeof(unsigned));
-
-          bool prim_key = itr->is_primary_key();
-          wkb.write(&prim_key,sizeof(bool));
-
-          int size = itr->get_size();
-          wkb.write(&size,sizeof(int));
-            
-          ++itr;
-          }	
-          return true;
-          }
-    
-          bool layer_descriptor_from_wkb(const char* wkb, layer_descriptor &desc)
-          {
-          unsigned pos=0;
-          int srid;
-	
-          memcpy(&srid,wkb+pos,sizeof(int));
-          desc.set_srid(srid);
-          pos+=sizeof(int);
-	
-          int num_desc;
-          memcpy(&num_desc,wkb+pos,sizeof(int));
-          pos+=sizeof(int);
-	
-          for (int i=0;i<num_desc;++i)
-          {
-          string name = wkb+pos;
-          pos += name.size()+1;
-          //std::clog<<"name="<<name<<"\n";
-	    
-          int type;
-          memcpy(&type,wkb+pos,sizeof(int));
-          pos += sizeof(int);
-          attribute_descriptor ad(name,type);
-          desc.add_descriptor(ad);
-          //todo!!!
-          pos += 4+1;
-          }
-          return true;
-          }
-    */    
 }
 
 #endif //FEATURE_LAYER_DESC_HPP



From pavlenko at mail.berlios.de  Mon Oct 16 23:29:57 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Mon, 16 Oct 2006 23:29:57 +0200
Subject: [Mapnik-svn] r332 - trunk/include/mapnik
Message-ID: <200610162129.k9GLTvTG010384@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-16 23:29:54 +0200 (Mon, 16 Oct 2006)
New Revision: 332

Modified:
   trunk/include/mapnik/datasource.hpp
   trunk/include/mapnik/feature_layer_desc.hpp
Log:
1.added features_at_point to datasource interface



Modified: trunk/include/mapnik/datasource.hpp
===================================================================
--- trunk/include/mapnik/datasource.hpp	2006-10-16 16:04:57 UTC (rev 331)
+++ trunk/include/mapnik/datasource.hpp	2006-10-16 21:29:54 UTC (rev 332)
@@ -83,6 +83,7 @@
         
         virtual int type() const=0;
         virtual featureset_ptr features(const query& q) const=0;
+        virtual featureset_ptr features_at_point(coord2d const& pt) const=0;
         virtual Envelope<double> const& envelope() const=0;
         virtual layer_descriptor const& get_descriptor() const=0;
         virtual ~datasource() {};

Modified: trunk/include/mapnik/feature_layer_desc.hpp
===================================================================
--- trunk/include/mapnik/feature_layer_desc.hpp	2006-10-16 16:04:57 UTC (rev 331)
+++ trunk/include/mapnik/feature_layer_desc.hpp	2006-10-16 21:29:54 UTC (rev 332)
@@ -183,7 +183,6 @@
         }
         return out;
     }
-
 }
 
 #endif //FEATURE_LAYER_DESC_HPP



From pavlenko at mail.berlios.de  Mon Oct 16 23:31:03 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Mon, 16 Oct 2006 23:31:03 +0200
Subject: [Mapnik-svn] r333 - in trunk/plugins/input: postgis raster shape
Message-ID: <200610162131.k9GLV35j010716@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-16 23:30:58 +0200 (Mon, 16 Oct 2006)
New Revision: 333

Modified:
   trunk/plugins/input/postgis/postgis.cpp
   trunk/plugins/input/postgis/postgis.hpp
   trunk/plugins/input/raster/raster_datasource.cpp
   trunk/plugins/input/raster/raster_datasource.hpp
   trunk/plugins/input/shape/shape.cpp
   trunk/plugins/input/shape/shape.hpp
Log:
added yet to be implemented features_at_point



Modified: trunk/plugins/input/postgis/postgis.cpp
===================================================================
--- trunk/plugins/input/postgis/postgis.cpp	2006-10-16 21:29:54 UTC (rev 332)
+++ trunk/plugins/input/postgis/postgis.cpp	2006-10-16 21:30:58 UTC (rev 333)
@@ -228,6 +228,11 @@
     return featureset_ptr(fs);
 }
 
+featureset_ptr postgis_datasource::features_at_point(coord2d const& pt) const
+{
+    return featureset_ptr();
+}
+
 const Envelope<double>& postgis_datasource::envelope() const
 {
     return extent_;

Modified: trunk/plugins/input/postgis/postgis.hpp
===================================================================
--- trunk/plugins/input/postgis/postgis.hpp	2006-10-16 21:29:54 UTC (rev 332)
+++ trunk/plugins/input/postgis/postgis.hpp	2006-10-16 21:30:58 UTC (rev 333)
@@ -56,6 +56,7 @@
     static std::string name();
     int type() const;
     featureset_ptr features(const query& q) const;
+    featureset_ptr features_at_point(coord2d const& pt) const;
     mapnik::Envelope<double> const& envelope() const;
     layer_descriptor const& get_descriptor() const;
     postgis_datasource(const parameters &params);

Modified: trunk/plugins/input/raster/raster_datasource.cpp
===================================================================
--- trunk/plugins/input/raster/raster_datasource.cpp	2006-10-16 21:29:54 UTC (rev 332)
+++ trunk/plugins/input/raster/raster_datasource.cpp	2006-10-16 21:30:58 UTC (rev 333)
@@ -92,3 +92,8 @@
 }
 
 
+featureset_ptr raster_datasource::features_at_point(coord2d const&) const
+{
+    return featureset_ptr();
+}
+

Modified: trunk/plugins/input/raster/raster_datasource.hpp
===================================================================
--- trunk/plugins/input/raster/raster_datasource.hpp	2006-10-16 21:29:54 UTC (rev 332)
+++ trunk/plugins/input/raster/raster_datasource.hpp	2006-10-16 21:30:58 UTC (rev 333)
@@ -40,10 +40,11 @@
     static std::string           name_;  
 public:
     raster_datasource(const parameters& params);
-    virtual            ~raster_datasource();
-    int                 type() const;
-    static std::string  name();
-    featureset_ptr      features(const query& q) const;
+    virtual ~raster_datasource();
+    int type() const;
+    static std::string name();
+    featureset_ptr features(const query& q) const;
+    featureset_ptr features_at_point(coord2d const& pt) const;
     mapnik::Envelope<double> const& envelope() const;
     layer_descriptor const& get_descriptor() const;
 private:

Modified: trunk/plugins/input/shape/shape.cpp
===================================================================
--- trunk/plugins/input/shape/shape.cpp	2006-10-16 21:29:54 UTC (rev 332)
+++ trunk/plugins/input/shape/shape.cpp	2006-10-16 21:30:58 UTC (rev 333)
@@ -148,11 +148,18 @@
     filter_in_box filter(q.get_bbox());
     if (indexed_)
     {
-        return featureset_ptr(new shape_index_featureset<filter_in_box>(filter,shape_name_,q.property_names()));
+        return featureset_ptr
+            (new shape_index_featureset<filter_in_box>(filter,shape_name_,q.property_names()));
     }
-    return featureset_ptr(new shape_featureset<filter_in_box>(filter,shape_name_,q.property_names(),file_length_));
+    return featureset_ptr
+        (new shape_featureset<filter_in_box>(filter,shape_name_,q.property_names(),file_length_));
 }
 
+featureset_ptr shape_datasource::features_at_point(coord2d const& pt) const
+{
+    return featureset_ptr();
+}
+
 const Envelope<double>& shape_datasource::envelope() const
 {
     return extent_;

Modified: trunk/plugins/input/shape/shape.hpp
===================================================================
--- trunk/plugins/input/shape/shape.hpp	2006-10-16 21:29:54 UTC (rev 332)
+++ trunk/plugins/input/shape/shape.hpp	2006-10-16 21:30:58 UTC (rev 333)
@@ -41,6 +41,7 @@
     int type() const;
     static std::string name();
     featureset_ptr features(const query& q) const;
+    featureset_ptr features_at_point(coord2d const& pt) const;
     const Envelope<double>& envelope() const;
     layer_descriptor const& get_descriptor() const;   
 private:



From pavlenko at mail.berlios.de  Mon Oct 16 23:34:12 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Mon, 16 Oct 2006 23:34:12 +0200
Subject: [Mapnik-svn] r334 - in trunk/bindings/python: . mapnik
	mapnik/ogcserver
Message-ID: <200610162134.k9GLYCj9011320@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-16 23:34:09 +0200 (Mon, 16 Oct 2006)
New Revision: 334

Modified:
   trunk/bindings/python/mapnik/__init__.py
   trunk/bindings/python/mapnik/ogcserver/common.py
   trunk/bindings/python/mapnik_datasource.cpp
Log:
1.added Describe() to Datasource, return list of attributes/types.
2.modified WMS to work with new Projection



Modified: trunk/bindings/python/mapnik/__init__.py
===================================================================
--- trunk/bindings/python/mapnik/__init__.py	2006-10-16 21:30:58 UTC (rev 333)
+++ trunk/bindings/python/mapnik/__init__.py	2006-10-16 21:34:09 UTC (rev 334)
@@ -64,11 +64,17 @@
     return forward(pt,self)
   def inverse(self,pt):
     return inverse(pt,self)
-    
+
+class _Datasource(Datasource,_injector):
+  def describe(self):
+    return Describe(self)
+
 def Datasource (**keywords):
     return CreateDatasource(keywords)
 
 
+
+
 #register datasources
 from mapnik import DatasourceCache
 DatasourceCache.instance().register_datasources('%s' % inputpluginspath)

Modified: trunk/bindings/python/mapnik/ogcserver/common.py
===================================================================
--- trunk/bindings/python/mapnik/ogcserver/common.py	2006-10-16 21:30:58 UTC (rev 333)
+++ trunk/bindings/python/mapnik/ogcserver/common.py	2006-10-16 21:34:09 UTC (rev 334)
@@ -255,12 +255,12 @@
 
     def Inverse(self, x, y):
         if not self.proj:
-            self.proj = Projection(['init=%s' % str(self).lower()])
+            self.proj = Projection('init=%s' % str(self).lower())
         return self.proj.Inverse(x, y)
 
     def Forward(self, x, y):
         if not self.proj:
-            self.proj = Projection(['init=%s' % str(self).lower()])
+            self.proj = Projection('init=%s' % str(self).lower())
         return self.proj.Forward(x, y)
 
 class CRSFactory:
@@ -379,4 +379,4 @@
         fh = StringIO()
         im.save(fh, PIL_TYPE_MAPPING[params['format']])
         fh.seek(0)
-        return Response(params['format'], fh.read())
\ No newline at end of file
+        return Response(params['format'], fh.read())

Modified: trunk/bindings/python/mapnik_datasource.cpp
===================================================================
--- trunk/bindings/python/mapnik_datasource.cpp	2006-10-16 21:30:58 UTC (rev 333)
+++ trunk/bindings/python/mapnik_datasource.cpp	2006-10-16 21:34:09 UTC (rev 334)
@@ -20,11 +20,15 @@
  *
  *****************************************************************************/
 //$Id$
-
+// stl
+#include <sstream>
+// boost
 #include <boost/python.hpp>
+// mapnik
 #include <mapnik/envelope.hpp>
 #include <mapnik/datasource.hpp>
 #include <mapnik/datasource_cache.hpp>
+#include <mapnik/feature_layer_desc.hpp>
 
 namespace  
 {
@@ -47,6 +51,20 @@
         
         return mapnik::datasource_cache::create(params);
     }
+    
+    std::string describe(boost::shared_ptr<mapnik::datasource> const& ds)
+    {
+        std::stringstream ss;
+        if (ds)
+        {
+            ss << ds->get_descriptor() << "\n";
+        }
+        else
+        {
+            ss << "Null\n";
+        }
+        return ss.str();
+    }
 }
 
 void export_datasource()
@@ -64,5 +82,6 @@
              "These vary depending on the type of data source.")
         ;
     
+    def("Describe",&describe);
     def("CreateDatasource",&create_datasource);
 }



From pavlenko at mail.berlios.de  Mon Oct 16 23:57:29 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Mon, 16 Oct 2006 23:57:29 +0200
Subject: [Mapnik-svn] r335 - trunk/bindings/python
Message-ID: <200610162157.k9GLvT13016985@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-16 23:57:27 +0200 (Mon, 16 Oct 2006)
New Revision: 335

Modified:
   trunk/bindings/python/mapnik_datasource.cpp
Log:
added missing header



Modified: trunk/bindings/python/mapnik_datasource.cpp
===================================================================
--- trunk/bindings/python/mapnik_datasource.cpp	2006-10-16 21:34:09 UTC (rev 334)
+++ trunk/bindings/python/mapnik_datasource.cpp	2006-10-16 21:57:27 UTC (rev 335)
@@ -24,6 +24,7 @@
 #include <sstream>
 // boost
 #include <boost/python.hpp>
+#include <boost/python/detail/api_placeholder.hpp>
 // mapnik
 #include <mapnik/envelope.hpp>
 #include <mapnik/datasource.hpp>



From pavlenko at mail.berlios.de  Tue Oct 17 00:25:13 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Tue, 17 Oct 2006 00:25:13 +0200
Subject: [Mapnik-svn] r336 - in trunk: bindings/python/mapnik demo/python
Message-ID: <200610162225.k9GMPDFV022764@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-17 00:25:11 +0200 (Tue, 17 Oct 2006)
New Revision: 336

Modified:
   trunk/bindings/python/mapnik/__init__.py
   trunk/demo/python/rundemo.py
Log:
1. added convinience factory methods

    ds = Shapefile(file='/../../')
    ds = PostGIS(host='localhost',..)
    ds = Raster(....)

2. Modified rundemo.py accordingly 
    


Modified: trunk/bindings/python/mapnik/__init__.py
===================================================================
--- trunk/bindings/python/mapnik/__init__.py	2006-10-16 21:57:27 UTC (rev 335)
+++ trunk/bindings/python/mapnik/__init__.py	2006-10-16 22:25:11 UTC (rev 336)
@@ -70,11 +70,22 @@
     return Describe(self)
 
 def Datasource (**keywords):
-    return CreateDatasource(keywords)
+  return CreateDatasource(keywords)
 
+# convinience factory methods
 
+def Shapefile(**keywords):
+  keywords['type'] = 'shape'
+  return CreateDatasource(keywords)
 
+def PostGIS(**keywords):
+  keywords['type'] = 'postgis'
+  return CreateDatasource(keywords)
 
+def Raster(**keywords):
+  keywords['type'] = 'raster'
+  return CreateDatasource(keywords)
+
 #register datasources
 from mapnik import DatasourceCache
 DatasourceCache.instance().register_datasources('%s' % inputpluginspath)

Modified: trunk/demo/python/rundemo.py
===================================================================
--- trunk/demo/python/rundemo.py	2006-10-16 21:57:27 UTC (rev 335)
+++ trunk/demo/python/rundemo.py	2006-10-16 22:25:11 UTC (rev 336)
@@ -56,7 +56,7 @@
 #     table= TODO
 
 provpoly_lyr = Layer('Provinces')
-provpoly_lyr.datasource = Datasource(type='shape', file='../data/boundaries')
+provpoly_lyr.datasource = Shapefile(file='../data/boundaries')
 
 # We then define a style for the layer.  A layer can have one or many styles.
 # Styles are named, so they can be shared across different layers.
@@ -121,8 +121,7 @@
 
 qcdrain_lyr = Layer('Quebec Hydrography')
 
-qcdrain_lyr.datasource = Datasource( type='shape',
-                                     file='../data/qcdrainage')
+qcdrain_lyr.datasource = Shapefile(file='../data/qcdrainage')
 
 qcdrain_style = Style()
 qcdrain_rule = Rule()
@@ -139,8 +138,7 @@
 # re-use the style defined in the above layer for the next one.
 
 ondrain_lyr = Layer('Ontario Hydrography')
-ondrain_lyr.datasource = Datasource(type='shape',
-                                    file='../data/ontdrainage')
+ondrain_lyr.datasource = Shapefile(file='../data/ontdrainage')
 
 ondrain_lyr.styles.append('drainage')
 m.layers.append(ondrain_lyr)
@@ -148,8 +146,7 @@
 # Provincial boundaries
 
 provlines_lyr = Layer('Provincial borders')
-provlines_lyr.datasource = Datasource (type='shape',
-                                       file='../data/boundaries_l')
+provlines_lyr.datasource = Shapefile(file='../data/boundaries_l')
 
 # Here we define a "dash dot dot dash" pattern for the provincial boundaries.
 
@@ -172,8 +169,10 @@
 # Roads 3 and 4 (The "grey" roads)
 
 roads34_lyr = Layer('Roads')
-roads34_lyr.datasource = Datasource(type='shape', file='../data/roads')
+# create roads datasource (we're going to re-use it later) 
 
+roads34_lyr.datasource = Shapefile(file='../data/roads')
+
 roads34_style = Style()
 roads34_rule = Rule()
 roads34_rule.filter = Filter('[CLASS] = 3 or [CLASS] = 4')
@@ -203,8 +202,10 @@
 # Roads 2 (The thin yellow ones)
 
 roads2_lyr = Layer('Roads')
-roads2_lyr.datasource = Datasource (type='shape', file='../data/roads')
 
+# Just get a copy from roads34_lyr
+roads2_lyr.datasource = roads34_lyr.datasource 
+
 roads2_style_1 = Style()
 roads2_rule_1 = Rule()
 roads2_rule_1.filter = Filter('[CLASS] = 2')
@@ -237,7 +238,7 @@
 # Roads 1 (The big orange ones, the highways)
 
 roads1_lyr = Layer('Roads')
-roads1_lyr.datasource = Datasource(type='shape', file='../data/roads')
+roads1_lyr.datasource = roads34_lyr.datasource
 
 roads1_style_1 = Style()
 roads1_rule_1 = Rule()
@@ -270,8 +271,7 @@
 # Populated Places
 
 popplaces_lyr = Layer('Populated Places')
-popplaces_lyr.datasource = Datasource (type='shape',
-                                       file='../data/popplaces')
+popplaces_lyr.datasource = Shapefile(file='../data/popplaces')
 
 popplaces_style = Style()
 popplaces_rule = Rule()



From jdoyon at mail.berlios.de  Tue Oct 17 01:25:54 2006
From: jdoyon at mail.berlios.de (jdoyon at BerliOS)
Date: Tue, 17 Oct 2006 01:25:54 +0200
Subject: [Mapnik-svn] r337 - trunk/bindings/python/mapnik/ogcserver
Message-ID: <200610162325.k9GNPses008698@sheep.berlios.de>

Author: jdoyon
Date: 2006-10-17 01:25:54 +0200 (Tue, 17 Oct 2006)
New Revision: 337

Modified:
   trunk/bindings/python/mapnik/ogcserver/WMS.py
   trunk/bindings/python/mapnik/ogcserver/wms111.py
   trunk/bindings/python/mapnik/ogcserver/wms130.py
Log:
layer.name is now a property instead of a method ...

Modified: trunk/bindings/python/mapnik/ogcserver/WMS.py
===================================================================
--- trunk/bindings/python/mapnik/ogcserver/WMS.py	2006-10-16 22:25:11 UTC (rev 336)
+++ trunk/bindings/python/mapnik/ogcserver/WMS.py	2006-10-16 23:25:54 UTC (rev 337)
@@ -43,7 +43,7 @@
         self.aggregatestyles = {}
 
     def register_layer(self, layer, defaultstyle, extrastyles=()):
-        layername = layer.name()
+        layername = layer.name
         if not layername:
             raise ServerConfigurationError('Attempted to register an unnamed layer.')
         if defaultstyle not in self.styles.keys() + self.aggregatestyles.keys():

Modified: trunk/bindings/python/mapnik/ogcserver/wms111.py
===================================================================
--- trunk/bindings/python/mapnik/ogcserver/wms111.py	2006-10-16 22:25:11 UTC (rev 336)
+++ trunk/bindings/python/mapnik/ogcserver/wms111.py	2006-10-16 23:25:54 UTC (rev 337)
@@ -127,7 +127,7 @@
 
         for layer in self.mapfactory.layers.values():
             layername = ElementTree.Element('Name')
-            layername.text = layer.name()
+            layername.text = layer.name
             env = layer.envelope()
             llp = self.crs.Inverse(env.minx, env.miny)
             urp = self.crs.Inverse(env.maxx, env.maxy)
@@ -194,4 +194,4 @@
                 'application/vnd.ogc.se_inimage': BaseExceptionHandler.inimagehandler,
                 'application/vnd.ogc.se_blank': BaseExceptionHandler.blankhandler}
 
-    defaulthandler = 'application/vnd.ogc.se_xml'
\ No newline at end of file
+    defaulthandler = 'application/vnd.ogc.se_xml'

Modified: trunk/bindings/python/mapnik/ogcserver/wms130.py
===================================================================
--- trunk/bindings/python/mapnik/ogcserver/wms130.py	2006-10-16 22:25:11 UTC (rev 336)
+++ trunk/bindings/python/mapnik/ogcserver/wms130.py	2006-10-16 23:25:54 UTC (rev 337)
@@ -133,7 +133,7 @@
 
         for layer in self.mapfactory.layers.values():
             layername = ElementTree.Element('Name')
-            layername.text = layer.name()
+            layername.text = layer.name
             env = layer.envelope()
             layerexgbb = ElementTree.Element('EX_GeographicBoundingBox')
             ll = self.crs.Inverse(env.minx, env.miny)
@@ -212,4 +212,4 @@
                 'INIMAGE': BaseExceptionHandler.inimagehandler,
                 'BLANK': BaseExceptionHandler.blankhandler}
 
-    defaulthandler = 'XML'
\ No newline at end of file
+    defaulthandler = 'XML'



From jdoyon at mail.berlios.de  Tue Oct 17 01:26:58 2006
From: jdoyon at mail.berlios.de (jdoyon at BerliOS)
Date: Tue, 17 Oct 2006 01:26:58 +0200
Subject: [Mapnik-svn] r338 - trunk/bindings/python
Message-ID: <200610162326.k9GNQw3R008945@sheep.berlios.de>

Author: jdoyon
Date: 2006-10-17 01:26:57 +0200 (Tue, 17 Oct 2006)
New Revision: 338

Modified:
   trunk/bindings/python/mapnik_datasource.cpp
Log:
Reorder headers to prevent a warning.

See http://docs.python.org/api/includes.html for details.

Modified: trunk/bindings/python/mapnik_datasource.cpp
===================================================================
--- trunk/bindings/python/mapnik_datasource.cpp	2006-10-16 23:25:54 UTC (rev 337)
+++ trunk/bindings/python/mapnik_datasource.cpp	2006-10-16 23:26:57 UTC (rev 338)
@@ -20,11 +20,11 @@
  *
  *****************************************************************************/
 //$Id$
-// stl
-#include <sstream>
 // boost
 #include <boost/python.hpp>
 #include <boost/python/detail/api_placeholder.hpp>
+// stl
+#include <sstream>
 // mapnik
 #include <mapnik/envelope.hpp>
 #include <mapnik/datasource.hpp>



From jdoyon at mail.berlios.de  Tue Oct 17 03:11:01 2006
From: jdoyon at mail.berlios.de (jdoyon at BerliOS)
Date: Tue, 17 Oct 2006 03:11:01 +0200
Subject: [Mapnik-svn] r339 - in trunk/bindings/python: . mapnik
	mapnik/ogcserver
Message-ID: <200610170111.k9H1B10j000414@sheep.berlios.de>

Author: jdoyon
Date: 2006-10-17 03:11:00 +0200 (Tue, 17 Oct 2006)
New Revision: 339

Removed:
   trunk/bindings/python/pyprojection/
Modified:
   trunk/bindings/python/mapnik/__init__.py
   trunk/bindings/python/mapnik/ogcserver/common.py
   trunk/bindings/python/mapnik/ogcserver/wms130.py
Log:
- Remove the import of pyprojection
- Delete pyprojection
- Modify the WMS to use the new Projection class provided by Mapnik.

Modified: trunk/bindings/python/mapnik/__init__.py
===================================================================
--- trunk/bindings/python/mapnik/__init__.py	2006-10-16 23:26:57 UTC (rev 338)
+++ trunk/bindings/python/mapnik/__init__.py	2006-10-17 01:11:00 UTC (rev 339)
@@ -33,11 +33,6 @@
 from _mapnik import *
 from paths import inputpluginspath, fontscollectionpath
 
-try:
-    from mapnik.Projection import Projection, DEGREES
-except:
-    pass
-
 # The base Boost.Python class
 BoostPythonMetaclass = Coord.__class__
 

Modified: trunk/bindings/python/mapnik/ogcserver/common.py
===================================================================
--- trunk/bindings/python/mapnik/ogcserver/common.py	2006-10-16 23:26:57 UTC (rev 338)
+++ trunk/bindings/python/mapnik/ogcserver/common.py	2006-10-17 01:11:00 UTC (rev 339)
@@ -20,7 +20,7 @@
 # $Id$
 
 from exceptions import OGCException, ServerConfigurationError
-from mapnik import Map, Color, Envelope, render, rawdata, Image, Projection, render_to_file
+from mapnik import Map, Color, Envelope, render, rawdata, Image, Projection, render_to_file, Coord
 from PIL.Image import fromstring, new
 from PIL.ImageDraw import Draw
 from StringIO import StringIO
@@ -253,15 +253,15 @@
             return True
         return False
 
-    def Inverse(self, x, y):
+    def inverse(self, x, y):
         if not self.proj:
-            self.proj = Projection('init=%s' % str(self).lower())
-        return self.proj.Inverse(x, y)
+            self.proj = Projection('+init=%s' % str(self).lower())
+        return self.proj.inverse(Coord(x, y))
 
-    def Forward(self, x, y):
+    def forward(self, x, y):
         if not self.proj:
-            self.proj = Projection('init=%s' % str(self).lower())
-        return self.proj.Forward(x, y)
+            self.proj = Projection('+init=%s' % str(self).lower())
+        return self.proj.forward(Coord(x, y))
 
 class CRSFactory:
 

Modified: trunk/bindings/python/mapnik/ogcserver/wms130.py
===================================================================
--- trunk/bindings/python/mapnik/ogcserver/wms130.py	2006-10-16 23:26:57 UTC (rev 338)
+++ trunk/bindings/python/mapnik/ogcserver/wms130.py	2006-10-17 01:11:00 UTC (rev 339)
@@ -136,19 +136,19 @@
             layername.text = layer.name
             env = layer.envelope()
             layerexgbb = ElementTree.Element('EX_GeographicBoundingBox')
-            ll = self.crs.Inverse(env.minx, env.miny)
-            ur = self.crs.Inverse(env.maxx, env.maxy)
+            ll = self.crs.inverse(env.minx, env.miny)
+            ur = self.crs.inverse(env.maxx, env.maxy)
             exgbb_wbl = ElementTree.Element('westBoundLongitude')
-            exgbb_wbl.text = str(ll[0])
+            exgbb_wbl.text = str(ll.x)
             layerexgbb.append(exgbb_wbl)
             exgbb_ebl = ElementTree.Element('eastBoundLongitude')
-            exgbb_ebl.text = str(ur[0])
+            exgbb_ebl.text = str(ur.x)
             layerexgbb.append(exgbb_ebl)
             exgbb_sbl = ElementTree.Element('southBoundLatitude')
-            exgbb_sbl.text = str(ll[1])
+            exgbb_sbl.text = str(ll.y)
             layerexgbb.append(exgbb_sbl)
             exgbb_nbl = ElementTree.Element('northBoundLatitude')
-            exgbb_nbl.text = str(ur[1])
+            exgbb_nbl.text = str(ur.y)
             layerexgbb.append(exgbb_nbl)
             layerbbox = ElementTree.Element('BoundingBox')
             layerbbox.set('CRS', str(self.crs))
@@ -158,13 +158,13 @@
             layerbbox.set('maxy', str(env.maxy))
             layere = ElementTree.Element('Layer')
             layere.append(layername)
-            if layer.title():
+            if layer.title:
                 layertitle = ElementTree.Element('Title')
-                layertitle.text = layer.title()
+                layertitle.text = layer.title
                 layere.append(layertitle)
-            if layer.abstract():
+            if layer.abstract:
                 layerabstract = ElementTree.Element('Abstract')
-                layerabstract.text = layer.abstract()
+                layerabstract.text = layer.abstract
                 layere.append(layerabstract)
             layere.append(layerexgbb)
             layere.append(layerbbox)



From jdoyon at mail.berlios.de  Tue Oct 17 03:18:54 2006
From: jdoyon at mail.berlios.de (jdoyon at BerliOS)
Date: Tue, 17 Oct 2006 03:18:54 +0200
Subject: [Mapnik-svn] r340 - trunk/bindings/python/mapnik/ogcserver
Message-ID: <200610170118.k9H1Is0N002002@sheep.berlios.de>

Author: jdoyon
Date: 2006-10-17 03:18:54 +0200 (Tue, 17 Oct 2006)
New Revision: 340

Modified:
   trunk/bindings/python/mapnik/ogcserver/wms111.py
Log:
- Apply recent changes to WMS 1.1.1

Modified: trunk/bindings/python/mapnik/ogcserver/wms111.py
===================================================================
--- trunk/bindings/python/mapnik/ogcserver/wms111.py	2006-10-17 01:11:00 UTC (rev 339)
+++ trunk/bindings/python/mapnik/ogcserver/wms111.py	2006-10-17 01:18:54 UTC (rev 340)
@@ -129,13 +129,13 @@
             layername = ElementTree.Element('Name')
             layername.text = layer.name
             env = layer.envelope()
-            llp = self.crs.Inverse(env.minx, env.miny)
-            urp = self.crs.Inverse(env.maxx, env.maxy)
+            llp = self.crs.inverse(env.minx, env.miny)
+            urp = self.crs.inverse(env.maxx, env.maxy)
             latlonbb = ElementTree.Element('LatLonBoundingBox')
-            latlonbb.set('minx', str(llp[0]))
-            latlonbb.set('miny', str(llp[1]))
-            latlonbb.set('maxx', str(urp[0]))
-            latlonbb.set('maxy', str(urp[1]))
+            latlonbb.set('minx', str(llp.x))
+            latlonbb.set('miny', str(llp.y))
+            latlonbb.set('maxx', str(urp.x))
+            latlonbb.set('maxy', str(urp.y))
             layerbbox = ElementTree.Element('BoundingBox')
             layerbbox.set('SRS', str(self.crs))
             layerbbox.set('minx', str(env.minx))
@@ -144,13 +144,13 @@
             layerbbox.set('maxy', str(env.maxy))
             layere = ElementTree.Element('Layer')
             layere.append(layername)
-            if layer.title():
+            if layer.title:
                 layertitle = ElementTree.Element('Title')
-                layertitle.text = layer.title()
+                layertitle.text = layer.title
                 layere.append(layertitle)
-            if layer.abstract():
+            if layer.abstract:
                 layerabstract = ElementTree.Element('Abstract')
-                layerabstract.text = layer.abstract()
+                layerabstract.text = layer.abstract
                 layere.append(layerabstract)
             layere.append(latlonbb)
             layere.append(layerbbox)



From vspader10east at mail.berlios.de  Tue Oct 17 16:12:54 2006
From: vspader10east at mail.berlios.de (vspader10east at BerliOS)
Date: Tue, 17 Oct 2006 16:12:54 +0200
Subject: [Mapnik-svn] r341 - in trunk: bindings/python include/mapnik src
Message-ID: <200610171412.k9HECslI018369@sheep.berlios.de>

Author: vspader10east
Date: 2006-10-17 16:12:53 +0200 (Tue, 17 Oct 2006)
New Revision: 341

Added:
   trunk/bindings/python/mapnik_shield_symbolizer.cpp
   trunk/include/mapnik/placement_finder.hpp
   trunk/include/mapnik/shield_symbolizer.hpp
   trunk/include/mapnik/text_path.hpp
   trunk/src/placement_finder.cpp
   trunk/src/shield_symbolizer.cpp
Modified:
   trunk/bindings/python/mapnik_python.cpp
   trunk/bindings/python/mapnik_rule.cpp
   trunk/bindings/python/mapnik_text_symbolizer.cpp
   trunk/include/mapnik/agg_renderer.hpp
   trunk/include/mapnik/attribute_collector.hpp
   trunk/include/mapnik/font_engine_freetype.hpp
   trunk/include/mapnik/label_collision_detector.hpp
   trunk/include/mapnik/rule.hpp
   trunk/src/SConscript
   trunk/src/agg_renderer.cpp
Log:
1) Added line following labels. Use set_label_placement(POINT_PLACEMENT) or set_label_placement(LINE_PLACEMENT) on a text symbolizer.
2) Added placement_finder class so labels try to avoid each other.
3) Added Shield Symbolizer which is essentially a combined image/text symbolizer.


Modified: trunk/bindings/python/mapnik_python.cpp
===================================================================
--- trunk/bindings/python/mapnik_python.cpp	2006-10-17 01:18:54 UTC (rev 340)
+++ trunk/bindings/python/mapnik_python.cpp	2006-10-17 14:12:53 UTC (rev 341)
@@ -46,6 +46,7 @@
 void export_polygon_symbolizer();
 void export_polygon_pattern_symbolizer();
 void export_raster_symbolizer();
+void export_shield_symbolizer();
 void export_text_symbolizer();
 void export_font_engine();
 void export_projection();
@@ -107,6 +108,7 @@
     export_polygon_symbolizer();
     export_polygon_pattern_symbolizer();
     export_raster_symbolizer();
+    export_shield_symbolizer();
     export_text_symbolizer();
     export_font_engine();
     export_projection();

Modified: trunk/bindings/python/mapnik_rule.cpp
===================================================================
--- trunk/bindings/python/mapnik_rule.cpp	2006-10-17 01:18:54 UTC (rev 340)
+++ trunk/bindings/python/mapnik_rule.cpp	2006-10-17 14:12:53 UTC (rev 341)
@@ -41,6 +41,7 @@
     using mapnik::polygon_symbolizer;
     using mapnik::polygon_pattern_symbolizer;
     using mapnik::raster_symbolizer;
+    using mapnik::shield_symbolizer;
     using mapnik::text_symbolizer;
     using mapnik::symbolizer;
     using mapnik::symbolizers;
@@ -52,6 +53,7 @@
     implicitly_convertible<polygon_symbolizer,symbolizer>();
     implicitly_convertible<polygon_pattern_symbolizer,symbolizer>();
     implicitly_convertible<raster_symbolizer,symbolizer>();
+    implicitly_convertible<shield_symbolizer,symbolizer>();
     implicitly_convertible<text_symbolizer,symbolizer>();
     
     class_<symbolizers>("Symbolizers",init<>("TODO"))

Added: trunk/bindings/python/mapnik_shield_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_shield_symbolizer.cpp	2006-10-17 01:18:54 UTC (rev 340)
+++ trunk/bindings/python/mapnik_shield_symbolizer.cpp	2006-10-17 14:12:53 UTC (rev 341)
@@ -0,0 +1,39 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko, Jean-Francois Doyon
+ * Copyright (C) 2006 10East Corp.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id$
+
+#include <boost/python.hpp>
+#include <mapnik/shield_symbolizer.hpp>
+
+void export_shield_symbolizer()
+{
+    using namespace boost::python;
+    using mapnik::shield_symbolizer;
+    
+    class_<shield_symbolizer>("ShieldSymbolizer",
+                             init<>("Default Shield Symbolizer - 4x4 black square"))
+        .def (init< std::string const&, unsigned, mapnik::Color const&,
+              std::string const&, std::string const&,unsigned,unsigned>("TODO"))
+        ;
+    
+}

Modified: trunk/bindings/python/mapnik_text_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_text_symbolizer.cpp	2006-10-17 01:18:54 UTC (rev 340)
+++ trunk/bindings/python/mapnik_text_symbolizer.cpp	2006-10-17 14:12:53 UTC (rev 341)
@@ -32,6 +32,11 @@
     using mapnik::text_symbolizer;
     using mapnik::Color;
  
+    enum_<mapnik::label_placement_e>("label_placement")
+        .value("LINE_PLACEMENT",mapnik::line_placement)
+        .value("POINT_PLACEMENT",mapnik::point_placement)
+        ;
+
     class_<text_symbolizer>("TextSymbolizer",
 			    init<std::string const&,unsigned,Color const&>())
         .add_property("halo_fill",make_function(
@@ -41,5 +46,7 @@
         .add_property("halo_radius",
                       &text_symbolizer::get_halo_radius, 
                       &text_symbolizer::set_halo_radius)
+        .def("set_label_placement",&text_symbolizer::set_label_placement,
+             "Set the placement of the label")
 	;
 }

Modified: trunk/include/mapnik/agg_renderer.hpp
===================================================================
--- trunk/include/mapnik/agg_renderer.hpp	2006-10-17 01:18:54 UTC (rev 340)
+++ trunk/include/mapnik/agg_renderer.hpp	2006-10-17 14:12:53 UTC (rev 341)
@@ -31,6 +31,7 @@
 #include <mapnik/feature_style_processor.hpp>
 #include <mapnik/font_engine_freetype.hpp>
 #include <mapnik/label_collision_detector.hpp>
+#include <mapnik/placement_finder.hpp>
 #include <mapnik/map.hpp>
 #include <mapnik/config.hpp>
 
@@ -63,6 +64,9 @@
         void process(raster_symbolizer const& sym,
                      Feature const& feature,
                      proj_transform const& prj_trans);
+        void process(shield_symbolizer const& sym,
+                     Feature const& feature,
+                     proj_transform const& prj_trans);
         void process(text_symbolizer const& sym,
                      Feature const& feature,
                      proj_transform const& prj_trans);
@@ -70,7 +74,9 @@
         T & pixmap_;
         CoordTransform t_;
         face_manager<freetype_engine> font_manager_;
-        label_collision_detector2 detector_;
+//        label_collision_detector2 label_detector_;
+        placement_finder finder_;
+        label_collision_detector2 point_detector_; //Note: May want to merge this with placement_finder
     };
 }
 

Modified: trunk/include/mapnik/attribute_collector.hpp
===================================================================
--- trunk/include/mapnik/attribute_collector.hpp	2006-10-17 01:18:54 UTC (rev 340)
+++ trunk/include/mapnik/attribute_collector.hpp	2006-10-17 14:12:53 UTC (rev 341)
@@ -47,6 +47,10 @@
         {
             names_.insert(sym.get_name());
         }
+	void operator () (shield_symbolizer const& sym)
+	{
+	    names_.insert(sym.get_name());
+	}
     private:
         std::set<std::string>& names_;
     };

Modified: trunk/include/mapnik/font_engine_freetype.hpp
===================================================================
--- trunk/include/mapnik/font_engine_freetype.hpp	2006-10-17 01:18:54 UTC (rev 340)
+++ trunk/include/mapnik/font_engine_freetype.hpp	2006-10-17 14:12:53 UTC (rev 341)
@@ -46,7 +46,11 @@
 // mapnik
 #include <mapnik/color.hpp>
 #include <mapnik/utils.hpp>
+#include <mapnik/ctrans.hpp>
+#include <mapnik/geometry.hpp>
 
+#include <mapnik/text_path.hpp>
+
 namespace mapnik
 {
     class font_face : boost::noncopyable
@@ -84,6 +88,7 @@
         {
             if (! FT_Set_Pixel_Sizes( face_, 0, size ))
                 return true;
+            
             return false;
         }
         
@@ -199,7 +204,6 @@
     template <typename T>
     struct text_renderer : private boost::noncopyable
     {
-
         struct glyph_t : boost::noncopyable
         {
             FT_Glyph image;
@@ -216,19 +220,13 @@
               face_(face),
               fill_(0,0,0), 
               halo_fill_(255,255,255),
-              halo_radius_(0),
-              angle_(0.0) {}
+              halo_radius_(0) {}
     
         void set_pixel_size(unsigned size)
         {
             face_->set_pixel_sizes(size);
         }
     
-        void set_angle(float angle)
-        {
-            angle_=angle;
-        }
-
         void set_fill(mapnik::Color const& fill)
         {
             fill_=fill;
@@ -244,7 +242,7 @@
             halo_radius_=radius;
         }
 
-        dimension_t prepare_glyphs(std::string const& text)
+        Envelope<double> prepare_glyphs(text_path *path)
         {
             //clear glyphs
             glyphs_.clear();
@@ -254,43 +252,35 @@
             FT_Error  error;
 	    
             FT_Face face = face_->get_face();
-            FT_GlyphSlot slot = face->glyph;
-            FT_Bool use_kerning;
-            FT_UInt previous = 0;
+//            FT_GlyphSlot slot = face->glyph;
 	    
-            pen.x = 0;
-            pen.y = 0;
-	    
-            use_kerning = FT_HAS_KERNING(face)>0?true:false;
-	    
             FT_BBox bbox;   
             bbox.xMin = bbox.yMin = 32000; 
             bbox.xMax = bbox.yMax = -32000; //hmm?? 
 	    
-            for (std::string::const_iterator i=text.begin();i!=text.end();++i)
+            for (int i = 0; i < path->num_nodes(); i++) 
             {
+                int c;
+                double x, y, angle;
+                
+                path->vertex(&c, &x, &y, &angle);
+
                 FT_BBox glyph_bbox; 
                 FT_Glyph image;
 		
-                matrix.xx = (FT_Fixed)( cos( angle_ ) * 0x10000L ); 
-                matrix.xy = (FT_Fixed)(-sin( angle_ ) * 0x10000L ); 
-                matrix.yx = (FT_Fixed)( sin( angle_ ) * 0x10000L ); 
-                matrix.yy = (FT_Fixed)( cos( angle_ ) * 0x10000L );
+                pen.x = int(x * 64);
+                pen.y = int(y * 64);
 	        	
+                matrix.xx = (FT_Fixed)( cos( angle ) * 0x10000L ); 
+                matrix.xy = (FT_Fixed)(-sin( angle ) * 0x10000L ); 
+                matrix.yx = (FT_Fixed)( sin( angle ) * 0x10000L ); 
+                matrix.yy = (FT_Fixed)( cos( angle ) * 0x10000L );
+		
                 FT_Set_Transform (face,&matrix,&pen);
 		
-                FT_UInt glyph_index = FT_Get_Char_Index( face, unsigned(*i) & 0xff );
+                FT_UInt glyph_index = FT_Get_Char_Index( face, unsigned(c) & 0xff );
 		
-                if ( use_kerning && previous && glyph_index)
-                {
-                    FT_Vector delta;
-                    FT_Get_Kerning(face,previous,glyph_index,
-                                   FT_KERNING_DEFAULT,&delta);
-                    pen.x += delta.x;
-                    pen.y += delta.y;
-                }
-		
-                error = FT_Load_Glyph (face,glyph_index,FT_LOAD_DEFAULT); 
+                error = FT_Load_Glyph (face,glyph_index, FT_LOAD_NO_HINTING); 
                 if ( error )
                     continue;
 		
@@ -316,18 +306,67 @@
                     bbox.yMax = 0; 
                 }
 		
-                pen.x += slot->advance.x;
-                pen.y += slot->advance.y;
-		
-                previous = glyph_index;
                 // take ownership of the glyph
                 glyphs_.push_back(new glyph_t(image));
             }
 	    
-            unsigned string_width = (bbox.xMax - bbox.xMin); 
-            unsigned string_height = (bbox.yMax - bbox.yMin);
-            return dimension_t(string_width,string_height);
+          return Envelope<double>(bbox.xMin, bbox.yMin, bbox.xMax, bbox.yMax);
         }
+      
+        dimension_t character_dimensions(const unsigned c)
+        {
+            FT_Matrix matrix;
+            FT_Vector pen;
+            FT_Error  error;
+            
+            FT_Face face = face_->get_face();
+            FT_GlyphSlot slot = face->glyph;
+            
+            pen.x = 0;
+            pen.y = 0;
+            
+            FT_BBox glyph_bbox; 
+            FT_Glyph image;
+            
+            matrix.xx = (FT_Fixed)( 1 * 0x10000L ); 
+            matrix.xy = (FT_Fixed)( 0 * 0x10000L ); 
+            matrix.yx = (FT_Fixed)( 0 * 0x10000L ); 
+            matrix.yy = (FT_Fixed)( 1 * 0x10000L );
+                    
+            FT_Set_Transform (face,&matrix,&pen);
+            
+            FT_UInt glyph_index = FT_Get_Char_Index( face, c & 0xff );
+            
+            error = FT_Load_Glyph (face,glyph_index,FT_LOAD_NO_HINTING); 
+            if ( error )
+                return dimension_t(0, 0);
+            
+            error = FT_Get_Glyph( face->glyph, &image);
+            if ( error )
+                return dimension_t(0, 0);
+            
+            FT_Glyph_Get_CBox(image,ft_glyph_bbox_pixels, &glyph_bbox); 
+          
+            return dimension_t(slot->advance.x >> 6, glyph_bbox.yMax - glyph_bbox.yMin);
+        }
+        
+        void get_string_info(std::string const& text, string_info *info)
+        {
+            unsigned width = 0;
+            unsigned height = 0;
+          
+            for (std::string::const_iterator i=text.begin();i!=text.end();++i)
+            {
+              dimension_t char_dim = character_dimensions(*i);
+              
+              info->add_info(*i, char_dim.first, char_dim.second);
+              
+              width += char_dim.first;
+              height = char_dim.second > height ? char_dim.second : height;
+            }
+            
+            info->set_dimensions(width, height);
+        }
 	
         void render(double x0, double y0)
         {
@@ -421,12 +460,12 @@
     
         pixmap_type & pixmap_;
         face_ptr face_;
-        Color fill_;
-        Color halo_fill_;
+      mapnik::Color fill_;
+      mapnik::Color halo_fill_;
         int halo_radius_;
-        float angle_;
         glyphs_t glyphs_;
     }; 
 }
 
+
 #endif // FONT_ENGINE_FREETYPE_HPP

Modified: trunk/include/mapnik/label_collision_detector.hpp
===================================================================
--- trunk/include/mapnik/label_collision_detector.hpp	2006-10-17 01:18:54 UTC (rev 340)
+++ trunk/include/mapnik/label_collision_detector.hpp	2006-10-17 14:12:53 UTC (rev 341)
@@ -83,6 +83,38 @@
             return true;
         }	
     };
+    
+    // quad_tree based label collision detector with seperate check/insert
+    class label_collision_detector3 : boost::noncopyable
+    {
+      typedef quad_tree< Envelope<double> > tree_t;
+      tree_t tree_;
+    public:
+	
+      explicit label_collision_detector3(Envelope<double> const& extent)
+          : tree_(extent) {}
+	
+      bool has_placement(Envelope<double> const& box)
+      {
+          tree_t::query_iterator itr = tree_.query_in_box(box);
+          tree_t::query_iterator end = tree_.query_end();
+          
+          for ( ;itr != end; ++itr)
+          {
+            if (itr->intersects(box))
+            {
+                return false;
+            }
+          }
+          
+          return true;
+      }
+
+      void insert(Envelope<double> const& box)
+      {
+        tree_.insert(box, box);
+      }
+    };
 }
 
 #endif 

Added: trunk/include/mapnik/placement_finder.hpp
===================================================================
--- trunk/include/mapnik/placement_finder.hpp	2006-10-17 01:18:54 UTC (rev 340)
+++ trunk/include/mapnik/placement_finder.hpp	2006-10-17 14:12:53 UTC (rev 341)
@@ -0,0 +1,102 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ * Copyright (C) 2006 10East Corp.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef __PLACEMENT_FINDER__
+#define __PLACEMENT_FINDER__
+
+#include <queue>
+
+#include <mapnik/ctrans.hpp>
+#include <mapnik/label_collision_detector.hpp>
+#include <mapnik/text_symbolizer.hpp>
+#include <mapnik/geometry.hpp>
+#include <mapnik/text_path.hpp>
+
+namespace mapnik
+{
+  struct placement
+  {
+    typedef  coord_transform2<CoordTransform,geometry_type> path_type;
+
+    //For shields
+    placement(string_info *info_, CoordTransform *ctrans_, const proj_transform *proj_trans_, geometry_ptr geom_, std::pair<double, double> dimensions_);
+    
+    //For text
+    placement(string_info *info_, CoordTransform *ctrans_, const proj_transform *proj_trans_, geometry_ptr geom_, label_placement_e placement_);
+    
+    ~placement();
+
+    string_info *info;
+    
+    CoordTransform *ctrans;
+    const proj_transform *proj_trans;
+
+    geometry_ptr geom;
+    label_placement_e label_placement;
+    std::pair<double, double> dimensions;
+
+    bool has_dimensions;
+    
+    path_type shape_path;
+    std::queue< Envelope<double> > envelopes;
+    
+    //output
+    double starting_x;
+    double starting_y;
+    
+    text_path path;
+    
+    
+    //helpers
+    std::pair<double, double> get_position_at_distance(double target_distance);
+    double get_total_distance();
+    void placement::clear_envelopes();
+    
+    double total_distance_; //cache for distance
+  };
+  
+  class placement_finder : boost::noncopyable
+  {
+  public:
+    placement_finder(Envelope<double> e);
+  
+    bool find_placement(placement *placement);
+    
+  protected:
+    bool find_placement_follow(placement *p);
+    bool find_placement_horizontal(placement *p);
+
+    bool build_path_follow(placement *p, double target_distance);
+    bool build_path_horizontal(placement *p, double target_distance);
+
+    void update_detector(placement *p);
+  
+    label_collision_detector3 detector_;
+  };
+  
+}
+
+#endif
+

Modified: trunk/include/mapnik/rule.hpp
===================================================================
--- trunk/include/mapnik/rule.hpp	2006-10-17 01:18:54 UTC (rev 340)
+++ trunk/include/mapnik/rule.hpp	2006-10-17 14:12:53 UTC (rev 341)
@@ -35,6 +35,7 @@
 #include <mapnik/polygon_pattern_symbolizer.hpp>
 #include <mapnik/point_symbolizer.hpp>
 #include <mapnik/raster_symbolizer.hpp>
+#include <mapnik/shield_symbolizer.hpp>
 #include <mapnik/text_symbolizer.hpp>
 #include <mapnik/filter.hpp>
 #include <mapnik/filter_visitor.hpp>
@@ -81,12 +82,19 @@
         return (&lhs == &rhs); 
     }
     
+    inline bool operator==(shield_symbolizer const& lhs,
+                           shield_symbolizer const& rhs)
+    {
+        return (&lhs == &rhs); 
+    }
+    
     typedef boost::variant<point_symbolizer,
                            line_symbolizer,
                            line_pattern_symbolizer,
                            polygon_symbolizer,
                            polygon_pattern_symbolizer,
                            raster_symbolizer,
+                           shield_symbolizer,
                            text_symbolizer> symbolizer;
     
         

Added: trunk/include/mapnik/shield_symbolizer.hpp
===================================================================
--- trunk/include/mapnik/shield_symbolizer.hpp	2006-10-17 01:18:54 UTC (rev 340)
+++ trunk/include/mapnik/shield_symbolizer.hpp	2006-10-17 14:12:53 UTC (rev 341)
@@ -0,0 +1,63 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ * Copyright (C) 2006 10East Corp.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id$
+
+#ifndef SHIELD_SYMBOLIZER_HPP
+#define SHIELD_SYMBOLIZER_HPP
+
+#include <boost/shared_ptr.hpp>
+#include <mapnik/graphics.hpp> 
+
+namespace mapnik 
+{   
+    struct MAPNIK_DECL shield_symbolizer
+    {	
+        explicit shield_symbolizer();
+        shield_symbolizer(std::string const& name,
+                          unsigned size,
+                          Color const& fill, 
+                          std::string const& file,
+                          std::string const& type,
+                          unsigned width,unsigned height);
+        shield_symbolizer(shield_symbolizer const& rhs);
+        void set_data (boost::shared_ptr<ImageData32> symbol);
+        boost::shared_ptr<ImageData32> const& get_data() const;
+      
+        std::string const& get_name() const;
+
+        unsigned get_text_size() const;
+        Color const& get_fill() const;
+      
+        void set_allow_overlap(bool overlap);
+        bool get_allow_overlap() const;
+        
+    private:
+        std::string name_;
+        unsigned size_;
+        Color fill_;
+        boost::shared_ptr<ImageData32> symbol_;
+        bool overlap_;
+    };
+}
+
+#endif // SHIELD_SYMBOLIZER_HPP

Added: trunk/include/mapnik/text_path.hpp
===================================================================
--- trunk/include/mapnik/text_path.hpp	2006-10-17 01:18:54 UTC (rev 340)
+++ trunk/include/mapnik/text_path.hpp	2006-10-17 14:12:53 UTC (rev 341)
@@ -0,0 +1,149 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ * Copyright (C) 2006 10East Corp.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef __TEXT_PATH_H__
+#define __TEXT_PATH_H__
+
+#include <boost/utility.hpp>
+
+namespace mapnik
+{
+    struct character_info
+    { 
+      int character;
+      double width, height;
+      
+      character_info() : character(0), width(0), height(0) {}
+      character_info(int c_, double width_, double height_) : character(c_), width(width_), height(height_) {}
+      ~character_info() {}
+        
+      character_info(const character_info &ci)
+        : character(ci.character), width(ci.width), height(ci.height)
+      {
+      }
+          
+    };
+    
+    class string_info : private boost::noncopyable
+    {
+    protected:
+      
+      
+      typedef boost::ptr_vector<character_info> characters_t;
+      
+      characters_t characters_;
+      unsigned itr_;
+
+      double width_;
+      double height_;
+    public:
+      string_info() : itr_(0), width_(0), height_(0) {}
+      
+      void add_info(int c, double width, double height)
+      {
+        characters_.push_back(new character_info(c, width, height));
+      }
+      
+      unsigned num_characters()
+      {
+        return characters_.size();
+      }
+      
+      character_info at(unsigned i)
+      {
+        return characters_[i];
+      }
+      
+      character_info operator[](unsigned i)
+      {
+        return at(i);
+      }
+      
+      void set_dimensions(double width, double height)
+      {
+        width_ = width;
+        height_ = height;
+      }
+      
+      std::pair<double, double> get_dimensions()
+      {
+        return std::pair<double, double>(width_, height_);
+      }
+    };
+    
+    struct text_path : private boost::noncopyable
+    {
+        struct character_node : boost::noncopyable
+        {
+            int c;
+            double x, y, angle;
+            
+            character_node(int c_, double x_, double y_, double angle_) : c(c_), x(x_), y(y_), angle(angle_) {}
+            ~character_node() {}
+
+            void vertex(int *c_, double *x_, double *y_, double *angle_)
+            {
+                *c_ = c;
+                *x_ = x;
+                *y_ = y;
+                *angle_ = angle;
+            }
+        };
+
+        typedef boost::ptr_vector<character_node> character_nodes_t;
+        
+        character_nodes_t nodes_;
+        int itr_;
+        
+        std::pair<unsigned,unsigned> string_dimensions;
+        
+        text_path() :  itr_(0) {} 
+        ~text_path() {}
+          
+        void add_node(int c, double x, double y, double angle)
+        {
+            nodes_.push_back(new character_node(c, x, y, angle));
+        }
+        
+        void vertex(int *c, double *x, double *y, double *angle)
+        {
+            nodes_[itr_++].vertex(c, x, y, angle);
+        }
+        
+        int num_nodes()
+        {
+            return nodes_.size();
+        }
+        
+        void clear()
+        {
+          nodes_.clear();
+        }
+    };
+}
+
+#endif
+
+

Modified: trunk/src/SConscript
===================================================================
--- trunk/src/SConscript	2006-10-17 01:18:54 UTC (rev 340)
+++ trunk/src/SConscript	2006-10-17 14:12:53 UTC (rev 341)
@@ -46,11 +46,13 @@
     map.cpp
     memory.cpp
     params.cpp
+    placement_finder.cpp
     plugin.cpp
     png_reader.cpp
     point_symbolizer.cpp
     polygon_pattern_symbolizer.cpp
     save_map.cpp
+    shield_symbolizer.cpp
     text_symbolizer.cpp
     tiff_reader.cpp
     wkb.cpp

Modified: trunk/src/agg_renderer.cpp
===================================================================
--- trunk/src/agg_renderer.cpp	2006-10-17 01:18:54 UTC (rev 340)
+++ trunk/src/agg_renderer.cpp	2006-10-17 14:12:53 UTC (rev 341)
@@ -59,6 +59,8 @@
 #include <mapnik/image_util.hpp>
 #include <mapnik/agg_renderer.hpp>
 
+#include <mapnik/placement_finder.hpp>
+
 namespace mapnik 
 {
     class pattern_source : private boost::noncopyable
@@ -92,7 +94,8 @@
         : feature_style_processor<agg_renderer>(m),
           pixmap_(pixmap),
           t_(m.getWidth(),m.getHeight(),m.getCurrentExtent()),
-          detector_(Envelope<double>(-64 ,-64, m.getWidth() + 64 ,m.getHeight() + 64))
+          finder_(Envelope<double>(-64 ,-64, m.getWidth() + 64 ,m.getHeight() + 64)),
+          point_detector_(Envelope<double>(-64 ,-64, m.getWidth() + 64 ,m.getHeight() + 64))
     {
         Color const& bg=m.getBackground();
         pixmap_.setBackground(bg);
@@ -302,7 +305,7 @@
                 int py=int(floor(y - 0.5 * h));
                 
                 if (sym.get_allow_overlap() || 
-                    detector_.has_placement(Envelope<double>(floor(x - 0.5 * w),
+                    point_detector_.has_placement(Envelope<double>(floor(x - 0.5 * w),
                                                              floor(y - 0.5 * h),
                                                              ceil (x + 0.5 * w),
                                                              ceil (y + 0.5 * h))))
@@ -314,6 +317,57 @@
     }
     
     template <typename T>
+    void  agg_renderer<T>::process(shield_symbolizer const& sym,
+                                   Feature const& feature,
+                                   proj_transform const& prj_trans)
+    {
+        geometry_ptr const& geom=feature.get_geometry();
+        if (geom)
+        {
+            std::string text = feature[sym.get_name()].to_string();
+            boost::shared_ptr<ImageData32> const& data = sym.get_data();
+            
+            if (text.length() > 0 && data)
+            {
+                face_ptr face = font_manager_.get_face("Bitstream Vera Sans Roman");//TODO
+                if (face)
+                {
+                    int w = data->width();
+                    int h = data->height();
+
+                    text_renderer<mapnik::Image32> ren(pixmap_,face);
+                    ren.set_pixel_size(sym.get_text_size());
+                    ren.set_fill(sym.get_fill());
+
+                    string_info info;
+                    ren.get_string_info(text, &info);
+                 
+                    placement text_placement(&info, &t_, &prj_trans, geom, std::pair<double, double>(w, h) );
+                    
+                    bool found = finder_.find_placement(&text_placement);
+                    if (!found) {
+                      return;
+                    }
+                    
+                    double x = text_placement.starting_x;
+                    double y = text_placement.starting_y;
+                    
+                    int px=int(floor(x - 0.5 * w));
+                    int py=int(floor(y - 0.5 * h));
+                    
+                    pixmap_.set_rectangle_alpha(px,py,*data);
+            
+                    Envelope<double> dim = ren.prepare_glyphs(&text_placement.path);
+                    
+                    //If has_placement 
+                    
+                    ren.render(x,y);
+                }
+            }
+        }
+    }
+    
+    template <typename T>
     void  agg_renderer<T>::process(line_pattern_symbolizer const& sym,
                                    Feature const& feature,
                                    proj_transform const& prj_trans)
@@ -422,37 +476,15 @@
                                   Feature const& feature,
                                   proj_transform const& prj_trans)
     {
-        typedef  coord_transform2<CoordTransform,geometry_type> path_type;
         geometry_ptr const& geom=feature.get_geometry();
+       
         if (geom)
         {
-            double angle = 0.0;	    
-            if (sym.get_label_placement() == line_placement && 
-                geom->num_points() > 1)
-            {
-	       
-                path_type path(t_,*geom,prj_trans);
-                double x0,y0,x1,y1;
-                path.vertex(&x0,&y0);
-                path.vertex(&x1,&y1);
-                double dx = x1 - x0;
-                double dy = ( y1 - y0 > 1e-7 ) ?  y1 - y0 : 1.0;
-	        
-                angle = atan( dx/ dy ) - 0.5 * 3.1459;
-		
-                //TODO!!!!!!!!!!!!!!!!!!!!
-            }   
-	    
             std::string text = feature[sym.get_name()].to_string();
             if (text.length() > 0)
             {
                 Color const& fill  = sym.get_fill();
 	
-                double x;
-                double y;
-                geom->label_position(&x,&y);
-                t_.forward(&x,&y);
-
                 face_ptr face = font_manager_.get_face("Bitstream Vera Sans Roman");//TODO
                 //face_ptr face = font_manager_.get_face("Times New Roman Regular");//TODO
                 if (face)
@@ -462,25 +494,35 @@
                     ren.set_fill(fill);
                     ren.set_halo_fill(sym.get_halo_fill());
                     ren.set_halo_radius(sym.get_halo_radius());
-                    ren.set_angle(float(angle));
 
-                    std::pair<unsigned,unsigned> dim = ren.prepare_glyphs(text);
-                    Envelope<double> text_box(x - 0.5*dim.first,y - 0.5 * dim.second ,
-                                              x + 0.5*dim.first,y + 0.5 * dim.second);
+                    string_info info;
+                  
+                    ren.get_string_info(text, &info);
+                 
+                    placement text_placement(&info, &t_, &prj_trans, geom, sym.get_label_placement());
+                  
+                    bool found = finder_.find_placement(&text_placement);
+                    if (!found) {
+                      return;
+                    }
+                    
+                    double x = text_placement.starting_x;
+                    double y = text_placement.starting_y;
+                    
+                    Envelope<double> dim = ren.prepare_glyphs(&text_placement.path);
+                    
+                    Envelope<double> text_box(x + dim.minx() ,y - dim.maxy(), x + dim.maxx(),y - dim.miny());
 		    
                     if (sym.get_halo_radius() > 0)
                     {
                         text_box.width(text_box.width() + sym.get_halo_radius()*2);
                         text_box.height(text_box.height() + sym.get_halo_radius()*2);
                     }
-
-                    if (detector_.has_placement(text_box))
-                    {
-                        ren.render(x - 0.5 * dim.first,y + 0.5 * dim.second);
-                    }
+                    ren.render(x,y);
                 }
             }  
         }
     }   
+    
     template class agg_renderer<Image32>;
 }

Added: trunk/src/placement_finder.cpp
===================================================================
--- trunk/src/placement_finder.cpp	2006-10-17 01:18:54 UTC (rev 340)
+++ trunk/src/placement_finder.cpp	2006-10-17 14:12:53 UTC (rev 341)
@@ -0,0 +1,434 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ * Copyright (C) 2006 10East Corp.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+//stl
+#include <string>
+#include <vector>
+
+// boost
+#include <boost/shared_ptr.hpp>
+#include <boost/utility.hpp>
+#include <boost/ptr_container/ptr_vector.hpp>
+#include <boost/thread/mutex.hpp>
+
+//mapnik
+#include <mapnik/geometry.hpp>
+#include <mapnik/placement_finder.hpp>
+#include <mapnik/text_path.hpp>
+
+namespace mapnik
+{
+  placement::placement(string_info *info_, CoordTransform *ctrans_, const proj_transform *proj_trans_, geometry_ptr geom_, std::pair<double, double> dimensions_)
+    : info(info_), ctrans(ctrans_), proj_trans(proj_trans_), geom(geom_), label_placement(point_placement), dimensions(dimensions_), has_dimensions(true), shape_path(*ctrans_, *geom_, *proj_trans_), total_distance_(-1.0)
+  {
+  }
+  
+  //For text
+  placement::placement(string_info *info_, CoordTransform *ctrans_, const proj_transform *proj_trans_, geometry_ptr geom_, label_placement_e placement_)
+    : info(info_), ctrans(ctrans_), proj_trans(proj_trans_), geom(geom_), label_placement(placement_), has_dimensions(false), shape_path(*ctrans_, *geom_, *proj_trans_), total_distance_(-1.0)
+  {
+  }
+  
+  placement::~placement()
+  {
+  }
+
+  std::pair<double, double> placement::get_position_at_distance(double target_distance)
+  {
+    double old_x, old_y, new_x, new_y;
+    double x, y;
+    x = y = 0.0;
+    
+    double distance = 0.0;
+    
+    shape_path.rewind(0);
+    shape_path.vertex(&new_x,&new_y);
+    for (unsigned i = 0; i < geom->num_points() - 1; i++)
+    {
+      double dx, dy;
+
+      old_x = new_x;
+      old_y = new_y;
+
+      shape_path.vertex(&new_x,&new_y);
+      
+      dx = new_x - old_x;
+      dy = new_y - old_y;
+      
+      double segment_length = sqrt(dx*dx + dy*dy);
+      
+      distance += segment_length;
+      if (distance > target_distance)
+      {
+          x = new_x - dx*(distance - target_distance)/segment_length;
+          y = new_y - dy*(distance - target_distance)/segment_length;
+
+          break;
+      }
+    }
+    
+    return std::pair<double, double>(x, y);
+  }
+  
+  double placement::get_total_distance()
+  {
+    if (total_distance_ < 0.0)
+    {
+      double old_x, old_y, new_x, new_y;
+      
+      shape_path.rewind(0);
+     
+      shape_path.vertex(&old_x,&old_y);
+
+      total_distance_ = 0.0;
+      
+      for (unsigned i = 0; i < geom->num_points() - 1; i++)
+      {
+          double dx, dy;
+          
+          shape_path.vertex(&new_x,&new_y);
+          
+          dx = new_x - old_x;
+          dy = new_y - old_y;
+          
+          total_distance_ += sqrt(dx*dx + dy*dy);
+          
+          old_x = new_x;
+          old_y = new_y;
+      }
+    }
+    
+    return total_distance_;
+  }
+  
+  void placement::clear_envelopes()
+  {
+    while (!envelopes.empty())
+      envelopes.pop();
+  }
+  
+  
+  
+  placement_finder::placement_finder(Envelope<double> e)
+    : detector_(e)
+  {
+  }
+
+  bool placement_finder::find_placement(placement *p)
+  {
+    if (p->label_placement == point_placement)
+    {
+      return find_placement_horizontal(p);
+    }
+    else if (p->label_placement == line_placement)
+    {
+      return find_placement_follow(p);
+    }
+    
+    return false;
+  }
+
+  bool placement_finder::find_placement_follow(placement *p)
+  {
+    std::pair<double, double> string_dimensions = p->info->get_dimensions();
+    double string_width = string_dimensions.first;
+//    double string_height = string_dimensions.second;
+    
+    double distance = p->get_total_distance();
+    
+    //~ double delta = string_width/distance;
+    double delta = distance/100.0;
+    
+    for (double i = 0; i < (distance - string_width)/2.0; i += delta)
+    {
+      p->clear_envelopes();
+      
+      if ( build_path_follow(p, (distance - string_width)/2.0 + i) ) {
+        update_detector(p);
+        return true;
+      }
+      
+      p->clear_envelopes();
+      
+      if ( build_path_follow(p, (distance - string_width)/2.0 - i) ) {
+        update_detector(p);
+        return true;
+      }
+    }
+    
+    p->starting_x = 0;
+    p->starting_y = 0;
+    
+    return false;
+  }
+  
+  bool placement_finder::find_placement_horizontal(placement *p)
+  {
+    double distance = p->get_total_distance();
+    //~ double delta = string_width/distance;
+    double delta = distance/100.0;
+    
+    for (double i = 0; i < distance/2.0; i += delta)
+    {
+      p->clear_envelopes();
+      
+      if ( build_path_horizontal(p, distance/2.0 + i) ) {
+        update_detector(p);
+        return true;
+      }
+      
+      p->clear_envelopes();
+      
+      if ( build_path_horizontal(p, distance/2.0 - i) ) {
+        update_detector(p);
+        return true;
+      }
+    }
+    
+    p->starting_x = 0;
+    p->starting_y = 0;
+    
+    return false;
+  }
+  
+  void placement_finder::update_detector(placement *p)
+  {
+    while (!p->envelopes.empty())
+    {
+      Envelope<double> e = p->envelopes.front();
+
+      detector_.insert(e);
+
+      p->envelopes.pop();
+    }
+  }
+
+  bool placement_finder::build_path_follow(placement *p, double target_distance)
+  {
+    double new_x, new_y, old_x, old_y;
+    unsigned cur_node = 0;
+
+    double angle = 0.0;
+    int orientation = 0;
+    
+    p->path.clear();
+    
+    double x, y;
+    x = y = 0.0;
+    
+    double distance = 0.0;
+
+    std::pair<double, double> string_dimensions = p->info->get_dimensions();
+//    double string_width = string_dimensions.first;
+    double string_height = string_dimensions.second;
+    
+    p->shape_path.rewind(0);
+    p->shape_path.vertex(&new_x,&new_y);
+    for (unsigned i = 0; i < p->geom->num_points() - 1; i++)
+    {
+        double dx, dy;
+
+        cur_node++;
+        
+        old_x = new_x;
+        old_y = new_y;
+
+        p->shape_path.vertex(&new_x,&new_y);
+        
+        dx = new_x - old_x;
+        dy = new_y - old_y;
+        
+        double segment_length = sqrt(dx*dx + dy*dy);
+        
+        distance += segment_length;
+        if (distance > target_distance)
+        {
+            p->starting_x = new_x - dx*(distance - target_distance)/segment_length;
+            p->starting_y = new_y - dy*(distance - target_distance)/segment_length;
+
+            angle = atan2(-dy, dx);
+
+            if (angle > M_PI/2 || angle <= -M_PI/2) {
+              orientation = -1;
+            }
+            else {
+              orientation = 1;
+            }
+
+            distance -= target_distance;
+            
+            break;
+        }
+    }
+
+    for (unsigned i = 0; i < p->info->num_characters(); i++)
+    {
+        character_info ci;
+        unsigned c;
+      
+        while (distance <= 0) {
+            double dx, dy;
+
+            cur_node++;
+            
+            if (cur_node >= p->geom->num_points()) {
+              break;
+            }
+            
+            old_x = new_x;
+            old_y = new_y;
+
+            p->shape_path.vertex(&new_x,&new_y);
+
+            dx = new_x - old_x;
+            dy = new_y - old_y;
+
+            angle = atan2(-dy, dx );
+            
+            distance += sqrt(dx*dx+dy*dy);
+        }
+
+        if (orientation == -1) {
+            ci = p->info->at(p->info->num_characters() - i - 1);
+        }
+        else
+        {
+            ci = p->info->at(i);
+        }
+        c = ci.character;
+
+        Envelope<double> e;
+        if (p->has_dimensions)
+        {
+            e.init(x, y, x + p->dimensions.first, y + p->dimensions.second);
+        }
+
+        if (orientation == -1) {
+            x = new_x - (distance - ci.width)*cos(angle);
+            y = new_y + (distance - ci.width)*sin(angle);
+
+            //Center the text on the line.
+            x += (((double)string_height/2.0) - 1.0)*cos(angle+M_PI/2);
+            y -= (((double)string_height/2.0) - 1.0)*sin(angle+M_PI/2);
+          
+            if (!p->has_dimensions)
+            {
+              e.init(x, y, x + ci.width*cos(angle+M_PI), y - ci.width*sin(angle+M_PI));
+              e.expand_to_include(x - ci.height*sin(angle+M_PI), y - ci.height*cos(angle+M_PI));
+              e.expand_to_include(x + (ci.width*cos(angle+M_PI) - ci.height*sin(angle+M_PI)), y - (ci.width*sin(angle+M_PI) + ci.height*cos(angle+M_PI)));
+            }
+        }
+        else
+        {
+            x = new_x - distance*cos(angle);
+            y = new_y + distance*sin(angle);
+
+            //Center the text on the line.
+            x += (((double)string_height/2.0) - 1.0)*cos(angle-M_PI/2);
+            y -= (((double)string_height/2.0) - 1.0)*sin(angle-M_PI/2);
+
+            if (!p->has_dimensions)
+            {
+              e.init(x, y, x + ci.width*cos(angle), y - ci.width*sin(angle));
+              e.expand_to_include(x - ci.height*sin(angle), y - ci.height*cos(angle));
+              e.expand_to_include(x + (ci.width*cos(angle) - ci.height*sin(angle)), y - (ci.width*sin(angle) + ci.height*cos(angle)));
+            }
+        }
+        
+        if (!detector_.has_placement(e))
+        {
+          return false;
+        }
+        
+        p->envelopes.push(e);
+        
+        p->path.add_node(c, x - p->starting_x, -y + p->starting_y, (orientation == -1 ? angle + M_PI : angle));
+        
+        distance -= ci.width;
+    }
+    
+    return true;
+  }
+  
+  bool placement_finder::build_path_horizontal(placement *p, double target_distance)
+  {
+    double x, y;
+  
+    p->path.clear();
+    
+    std::pair<double, double> string_dimensions = p->info->get_dimensions();
+    double string_width = string_dimensions.first;
+    double string_height = string_dimensions.second;
+    
+    x = -string_width/2.0;
+    y = -string_height/2.0 + 1.0;
+    
+    if (p->geom->type() == LineString)
+    {
+      std::pair<double, double> starting_pos = p->get_position_at_distance(target_distance);
+      
+      p->starting_x = starting_pos.first;
+      p->starting_y = starting_pos.second;
+    }
+    else
+    {
+      p->geom->label_position(&p->starting_x, &p->starting_y);
+      p->ctrans->forward(&p->starting_x, &p->starting_y);
+    }
+    
+    for (unsigned i = 0; i < p->info->num_characters(); i++)
+    {
+        character_info ci;;
+        ci = p->info->at(i);
+        
+        unsigned c = ci.character;
+      
+        p->path.add_node(c, x, y, 0.0);
+
+        Envelope<double> e;
+        if (p->has_dimensions)
+        {
+            e.init(p->starting_x - (p->dimensions.first/2.0), p->starting_y - (p->dimensions.second/2.0), p->starting_x + (p->dimensions.first/2.0), p->starting_y + (p->dimensions.second/2.0));
+        }
+        else
+        {
+          e.init(p->starting_x + x, p->starting_y - y, p->starting_x + x + ci.width, p->starting_y - y - ci.height);
+        }
+        
+        if (!detector_.has_placement(e))
+        {
+          return false;
+        }
+        
+        p->envelopes.push(e);
+      
+        x += ci.width;
+    }
+    return true;
+  }
+
+  
+}
+

Added: trunk/src/shield_symbolizer.cpp
===================================================================
--- trunk/src/shield_symbolizer.cpp	2006-10-17 01:18:54 UTC (rev 340)
+++ trunk/src/shield_symbolizer.cpp	2006-10-17 14:12:53 UTC (rev 341)
@@ -0,0 +1,111 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ * Copyright (C) 2006 10East Corp.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+// stl
+#include <iostream>
+// boost
+#include <boost/scoped_ptr.hpp>
+// mapnik
+#include <mapnik/shield_symbolizer.hpp>
+#include <mapnik/image_data.hpp>
+#include <mapnik/image_reader.hpp>
+
+namespace mapnik
+{
+    shield_symbolizer::shield_symbolizer()
+        : symbol_(new ImageData32(4,4)),
+          overlap_(false)
+    {
+        //default point symbol is black 4x4px square
+        symbol_->set(0xff000000);
+    }
+    
+    shield_symbolizer::shield_symbolizer(
+                          std::string const& name,
+                          unsigned size,
+                          Color const& fill, 
+                          std::string const& file,
+                          std::string const& type,
+                          unsigned width,unsigned height)
+        : name_(name), size_(size), fill_(fill), symbol_(new ImageData32(width,height))
+    {
+        try 
+        {
+            boost::scoped_ptr<ImageReader> reader(get_image_reader(type,file));
+            if (reader.get())
+            {
+                reader->read(0,0,*symbol_);		
+            }
+        } 
+        catch (...) 
+        {
+            std::clog<<"exception caught..." << std::endl;
+        }
+    }
+    
+    shield_symbolizer::shield_symbolizer(shield_symbolizer const& rhs)
+        : name_(rhs.name_),
+          size_(rhs.size_),
+          fill_(rhs.fill_),
+          symbol_(rhs.symbol_),
+          overlap_(rhs.overlap_)
+    {}
+    
+    void shield_symbolizer::set_data( boost::shared_ptr<ImageData32> symbol)
+    {
+        symbol_ = symbol;
+    }
+
+    boost::shared_ptr<ImageData32> const& shield_symbolizer::get_data() const
+    {
+        return symbol_;
+    }
+    
+    std::string const& shield_symbolizer::get_name() const
+    {
+      return name_;
+    }
+    
+    void shield_symbolizer::set_allow_overlap(bool overlap)
+    {
+        overlap_ = overlap;
+    }
+    
+    bool shield_symbolizer::get_allow_overlap() const
+    {
+        return overlap_;
+    }
+
+    unsigned shield_symbolizer::get_text_size() const
+    {
+        return size_;
+    }
+
+    Color const& shield_symbolizer::get_fill() const
+    {
+        return fill_;
+    }
+}
+



From pavlenko at mail.berlios.de  Tue Oct 17 19:26:41 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Tue, 17 Oct 2006 19:26:41 +0200
Subject: [Mapnik-svn] r342 - in trunk: bindings/python include/mapnik src
	utils/ogcserver
Message-ID: <200610171726.k9HHQfFF031573@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-17 19:26:35 +0200 (Tue, 17 Oct 2006)
New Revision: 342

Added:
   trunk/include/mapnik/proj_transform.hpp
   trunk/src/proj_transform.cpp
   trunk/src/projection.cpp
Modified:
   trunk/bindings/python/mapnik_projection.cpp
   trunk/include/mapnik/ctrans.hpp
   trunk/include/mapnik/projection.hpp
   trunk/src/SConscript
   trunk/src/load_map.cpp
   trunk/utils/ogcserver/ogcserver
Log:
1. refactored proj stuff into separate files
2. added is_geographic property
3. added basic support for text_symbolizer in load_map




Modified: trunk/bindings/python/mapnik_projection.cpp
===================================================================
--- trunk/bindings/python/mapnik_projection.cpp	2006-10-17 14:12:53 UTC (rev 341)
+++ trunk/bindings/python/mapnik_projection.cpp	2006-10-17 17:26:35 UTC (rev 342)
@@ -56,6 +56,7 @@
         .def ("inverse",&projection::inverse)
         .def ("params", make_function(&projection::params,
                                       return_value_policy<copy_const_reference>()))
+        .add_property ("geographic",&projection::is_geographic)
         ;
     
     def("forward",&forward);

Modified: trunk/include/mapnik/ctrans.hpp
===================================================================
--- trunk/include/mapnik/ctrans.hpp	2006-10-17 14:12:53 UTC (rev 341)
+++ trunk/include/mapnik/ctrans.hpp	2006-10-17 17:26:35 UTC (rev 342)
@@ -27,7 +27,7 @@
 
 #include <mapnik/envelope.hpp>
 #include <mapnik/coord_array.hpp>
-#include <mapnik/projection.hpp>
+#include <mapnik/proj_transform.hpp>
 
 namespace mapnik {
     typedef coord_array<coord2d> CoordinateArray;

Added: trunk/include/mapnik/proj_transform.hpp
===================================================================
--- trunk/include/mapnik/proj_transform.hpp	2006-10-17 14:12:53 UTC (rev 341)
+++ trunk/include/mapnik/proj_transform.hpp	2006-10-17 17:26:35 UTC (rev 342)
@@ -0,0 +1,52 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef PROJ_TRANSFORM_HPP
+#define PROJ_TRANSFORM_HPP
+
+// boost
+#include <boost/utility.hpp>
+// mapnik
+#include <mapnik/projection.hpp>
+
+namespace mapnik {
+    
+    class proj_transform : private boost::noncopyable
+    {
+    public:
+        proj_transform(projection const& source, 
+                       projection const& dest);
+        
+        bool forward (double& x, double& y , double& z) const;
+        bool backward (double& x, double& y , double& z) const;
+        
+    private:
+        projection const& source_;
+        projection const& dest_;
+        bool is_source_latlong_;
+        bool is_dest_latlong_;
+    };
+}
+
+#endif // PROJ_TRANSFORM_HPP

Modified: trunk/include/mapnik/projection.hpp
===================================================================
--- trunk/include/mapnik/projection.hpp	2006-10-17 14:12:53 UTC (rev 341)
+++ trunk/include/mapnik/projection.hpp	2006-10-17 17:26:35 UTC (rev 342)
@@ -1,17 +1,41 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
 
+//$Id$
+
 #ifndef PROJECTION_HPP
 #define PROJECTION_HPP
 
+// stl
 #include <string>
 #include <iostream>
 #include <stdexcept>
+// boost
 #include <boost/utility.hpp>
-
+// mapnik
 #include <mapnik/envelope.hpp>
-#include <proj_api.h>
 
-namespace mapnik
-{   
+namespace mapnik {
+    
     class proj_init_error : public std::runtime_error
     {
     public:
@@ -23,152 +47,26 @@
     {
         friend class proj_transform;
     public:
-        explicit projection(std::string params = "+proj=latlong +ellps=WGS84")
-            : params_(params)
-        { 
-            init(); //
-        }
+        explicit projection(std::string params = "+proj=latlong +ellps=WGS84");
+        projection(projection const& rhs);
+        ~projection();
         
-        projection(projection const& rhs)
-            : params_(rhs.params_) 
-        {
-            init(); //
-        }
+        projection& operator=(projection const& rhs);
+        bool is_initialized() const;
+        bool is_geographic() const;
+        std::string const& params() const;
+      
+        void forward(double & x, double &y ) const;
+        void inverse(double & x,double & y) const;
         
-        projection& operator=(projection const& rhs) 
-        { 
-            projection tmp(rhs);
-            swap(tmp);
-            return *this;
-        }
-        
-        bool is_initialized() const
-        {
-            return proj_ ? true : false;
-        }
-        
-        std::string const& params() const
-        {
-            return params_;
-        }
-        
-        void forward(double & x, double &y ) const
-        {
-            projUV p;
-            p.u = x * DEG_TO_RAD;
-            p.v = y * DEG_TO_RAD;
-            p = pj_fwd(p,proj_);
-            x = p.u;
-            y = p.v;
-        }
-        
-        void inverse(double & x,double & y) const
-        {
-            projUV p;
-            p.u = x;
-            p.v = y;
-            p = pj_inv(p,proj_);
-            x = RAD_TO_DEG * p.u;
-            y = RAD_TO_DEG * p.v;
-        }
-        
-        ~projection() 
-        {
-            if (proj_) pj_free(proj_);
-        }
     private:
-        
-        void init()
-        {
-            proj_=pj_init_plus(params_.c_str());
-            if (!proj_) throw proj_init_error(params_);
-        }
-        
-        void swap (projection& rhs)
-        {
-            std::swap(params_,rhs.params_);
-            init ();
-        } 
-        
+        void init(); 
+        void swap (projection& rhs);
+       
     private:
         std::string params_;
-        projPJ proj_;
+        void * proj_;
     };
-    
-    class proj_transform : private boost::noncopyable
-    {
-    public:
-        proj_transform(projection const& source, 
-                       projection const& dest)
-            : source_(source),
-              dest_(dest) 
-        {
-            is_source_latlong_ = pj_is_latlong(source_.proj_);
-            is_dest_latlong_ = pj_is_latlong(dest_.proj_);
-        }
-        
-        bool forward (double & x, double & y , double & z) const
-        {
-            if (is_source_latlong_)
-            {
-                x *= DEG_TO_RAD;
-                y *= DEG_TO_RAD;
-            }
-            
-            if (pj_transform( source_.proj_, dest_.proj_, 1, 
-                              0, &x,&y,&z) != 0)
-            {
-                return false;
-            }
-            
-            if (is_dest_latlong_)
-            {
-                x *= RAD_TO_DEG;
-                y *= RAD_TO_DEG;
-            }
-            
-            return true;
-        } 
-        
-        bool forward (Envelope<double> & ext) const
-        {
-            if (is_source_latlong_)
-            {
-                ext = ext.intersect(Envelope<double>(-180,-90,180,90));
-            }
-            // TODO
-            return true;
-        }
-        
-        bool backward (double & x, double & y , double & z) const
-        {
-            if (is_dest_latlong_)
-            {
-                x *= DEG_TO_RAD;
-                y *= DEG_TO_RAD;
-            }
-            
-            if (pj_transform( dest_.proj_, source_.proj_, 1, 
-                              0, &x,&y,&z) != 0)
-            {
-                return false;
-            }
-            
-            if (is_source_latlong_)
-            {
-                x *= RAD_TO_DEG;
-                y *= RAD_TO_DEG;
-            }
-            
-            return true;
-        } 
-        
-    private:
-        projection const& source_;
-        projection const& dest_;
-        bool is_source_latlong_;
-        bool is_dest_latlong_;
-    };
 }
 
 #endif //PROJECTION_HPP

Modified: trunk/src/SConscript
===================================================================
--- trunk/src/SConscript	2006-10-17 14:12:53 UTC (rev 341)
+++ trunk/src/SConscript	2006-10-17 17:26:35 UTC (rev 342)
@@ -56,6 +56,8 @@
     text_symbolizer.cpp
     tiff_reader.cpp
     wkb.cpp
+    projection.cpp
+    proj_transform.cpp
     """
     )
 

Modified: trunk/src/load_map.cpp
===================================================================
--- trunk/src/load_map.cpp	2006-10-17 14:12:53 UTC (rev 341)
+++ trunk/src/load_map.cpp	2006-10-17 17:26:35 UTC (rev 342)
@@ -127,8 +127,30 @@
                             {
                                 std::cout << sym.first << "\n";
                             } 
-                            else  if ( sym.first == "LineSymbolizer")
+                            else if ( sym.first == "TextSymbolizer")
                             {
+                                std::string name =  
+                                    sym.second.get<std::string>("<xmlattr>.name");                      
+                                unsigned size = 
+                                    sym.second.get<unsigned>("<xmlattr>.size",10);                      
+                                std::string color_str = 
+                                    sym.second.get<std::string>("<xmlattr>.fill","black");
+                                Color c = color_factory::from_string(color_str.c_str());
+                                
+                                text_symbolizer text_symbol(name,size,c);
+                                
+                                std::string placement_str = 
+                                    sym.second.get<std::string>("<xmlattr>.placement","point");
+                                
+                                if (placement_str == "line")
+                                {
+                                    text_symbol.set_label_placement(line_placement);
+                                }
+                                
+                                rule.append(text_symbol);
+                            }
+                            else if ( sym.first == "LineSymbolizer")
+                            {
                                 stroke strk;
                                 ptree::const_iterator cssIter = sym.second.begin();
                                 ptree::const_iterator endCss = sym.second.end();

Added: trunk/src/proj_transform.cpp
===================================================================
--- trunk/src/proj_transform.cpp	2006-10-17 14:12:53 UTC (rev 341)
+++ trunk/src/proj_transform.cpp	2006-10-17 17:26:35 UTC (rev 342)
@@ -0,0 +1,85 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#include <proj_api.h>
+
+#include <mapnik/proj_transform.hpp>
+
+namespace mapnik {
+    
+    proj_transform::proj_transform(projection const& source, 
+                                   projection const& dest)
+            : source_(source),
+              dest_(dest) 
+    {
+        is_source_latlong_ = pj_is_latlong(source_.proj_);
+        is_dest_latlong_ = pj_is_latlong(dest_.proj_);
+    }
+    
+    bool proj_transform::forward (double & x, double & y , double & z) const
+    {
+        if (is_source_latlong_)
+        {
+            x *= DEG_TO_RAD;
+            y *= DEG_TO_RAD;
+        }
+        
+        if (pj_transform( source_.proj_, dest_.proj_, 1, 
+                          0, &x,&y,&z) != 0)
+        {
+            return false;
+        }
+        
+        if (is_dest_latlong_)
+        {
+            x *= RAD_TO_DEG;
+            y *= RAD_TO_DEG;
+        }
+        
+        return true;
+    } 
+        
+    bool proj_transform::backward (double & x, double & y , double & z) const
+    {
+        if (is_dest_latlong_)
+        {
+            x *= DEG_TO_RAD;
+            y *= DEG_TO_RAD;
+        }
+        
+        if (pj_transform( dest_.proj_, source_.proj_, 1, 
+                          0, &x,&y,&z) != 0)
+        {
+            return false;
+        }
+        
+        if (is_source_latlong_)
+        {
+            x *= RAD_TO_DEG;
+            y *= RAD_TO_DEG;
+        }
+        
+        return true;
+    } 
+}

Added: trunk/src/projection.cpp
===================================================================
--- trunk/src/projection.cpp	2006-10-17 14:12:53 UTC (rev 341)
+++ trunk/src/projection.cpp	2006-10-17 17:26:35 UTC (rev 342)
@@ -0,0 +1,101 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+// proj4
+#include <proj_api.h>
+// mapnik
+#include <mapnik/projection.hpp>
+
+namespace mapnik {
+    projection::projection(std::string  params)
+        : params_(params)
+    { 
+        init(); //
+    }
+    
+    projection::projection(projection const& rhs)
+        : params_(rhs.params_) 
+    {
+        init(); //
+    }
+        
+    projection& projection::operator=(projection const& rhs) 
+    { 
+        projection tmp(rhs);
+        swap(tmp);
+        return *this;
+    }
+        
+    bool projection::is_initialized() const
+    {
+        return proj_ ? true : false;
+    }
+    
+    bool projection::is_geographic() const
+    {
+        return pj_is_latlong(proj_);  
+    }
+    
+    std::string const& projection::params() const
+    {
+        return params_;
+    }
+    
+    void projection::forward(double & x, double &y ) const
+    {
+        projUV p;
+        p.u = x * DEG_TO_RAD;
+        p.v = y * DEG_TO_RAD;
+        p = pj_fwd(p,proj_);
+        x = p.u;
+        y = p.v;
+    }
+    
+    void projection::inverse(double & x,double & y) const
+    {
+        projUV p;
+        p.u = x;
+        p.v = y;
+        p = pj_inv(p,proj_);
+        x = RAD_TO_DEG * p.u;
+        y = RAD_TO_DEG * p.v;
+    }
+    
+    projection::~projection() 
+    {
+        if (proj_) pj_free(proj_);
+    }
+    
+    void projection::init()
+    {
+        proj_=pj_init_plus(params_.c_str());
+        if (!proj_) throw proj_init_error(params_);
+    }
+    
+    void projection::swap (projection& rhs)
+    {
+        std::swap(params_,rhs.params_);
+        init ();
+    }
+}

Modified: trunk/utils/ogcserver/ogcserver
===================================================================
--- trunk/utils/ogcserver/ogcserver	2006-10-17 14:12:53 UTC (rev 341)
+++ trunk/utils/ogcserver/ogcserver	2006-10-17 17:26:35 UTC (rev 342)
@@ -1,29 +1,29 @@
-#!/usr/bin/python2.3
-#
-# This file is part of Mapnik (c++ mapping toolkit)
-#
-# Copyright (C) 2006 Jean-Francois Doyon
-#
-# Mapnik is free software; you can redistribute it and/or
-# modify it under the terms of the GNU Lesser General Public
-# License as published by the Free Software Foundation; either
-# version 2.1 of the License, or (at your option) any later version.
-#
-# This library is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-# Lesser General Public License for more details.
-#
-# You should have received a copy of the GNU Lesser General Public
-# License along with this library; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-#
-# $Id$
-
-from mapnik.ogcserver.cgiserver import Handler
-from jon import fcgi
-
-class OGCServerHandler(Handler):
-    configpath = '/etc/ogcserver.conf'
-
-fcgi.Server({fcgi.FCGI_RESPONDER: OGCServerHandler}).run()
+#!/usr/bin/python2.3
+#
+# This file is part of Mapnik (c++ mapping toolkit)
+#
+# Copyright (C) 2006 Jean-Francois Doyon
+#
+# Mapnik is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2.1 of the License, or (at your option) any later version.
+#
+# This library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public
+# License along with this library; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+# $Id$
+
+from mapnik.ogcserver.cgiserver import Handler
+from jon import fcgi
+
+class OGCServerHandler(Handler):
+    configpath = '/etc/ogcserver.conf'
+
+fcgi.Server({fcgi.FCGI_RESPONDER: OGCServerHandler}).run()



From pavlenko at mail.berlios.de  Tue Oct 17 23:36:13 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Tue, 17 Oct 2006 23:36:13 +0200
Subject: [Mapnik-svn] r343 - trunk/plugins/input/postgis
Message-ID: <200610172136.k9HLaDTB032060@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-17 23:36:11 +0200 (Tue, 17 Oct 2006)
New Revision: 343

Modified:
   trunk/plugins/input/postgis/postgisfs.cpp
Log:
treat oid=25 (TEXT) types as string



Modified: trunk/plugins/input/postgis/postgisfs.cpp
===================================================================
--- trunk/plugins/input/postgis/postgisfs.cpp	2006-10-17 17:26:35 UTC (rev 342)
+++ trunk/plugins/input/postgis/postgisfs.cpp	2006-10-17 21:36:11 UTC (rev 343)
@@ -80,12 +80,13 @@
                     float8net(val,buf);
                     boost::put(*feature,name,val);
                 }
-                else if (oid==1042 || oid==1043) //bpchar or varchar
+                else if (oid==25 || oid==1042 || oid==1043) // text or bpchar or varchar
                 {
                     boost::put(*feature,name,buf);
                 }
                 else 
                 {
+                    std::clog << "uknown OID = " << oid << " FIXME \n";
                     boost::put(*feature,name,0);
                 }
             }



From pavlenko at mail.berlios.de  Wed Oct 18 13:42:58 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Wed, 18 Oct 2006 13:42:58 +0200
Subject: [Mapnik-svn] r344 - trunk/include/mapnik
Message-ID: <200610181142.k9IBgwWp030457@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-18 13:42:56 +0200 (Wed, 18 Oct 2006)
New Revision: 344

Modified:
   trunk/include/mapnik/feature_style_processor.hpp
Log:
changed boost::progress_timer to output to std::clog (which defaults to std::cerr)




Modified: trunk/include/mapnik/feature_style_processor.hpp
===================================================================
--- trunk/include/mapnik/feature_style_processor.hpp	2006-10-17 21:36:11 UTC (rev 343)
+++ trunk/include/mapnik/feature_style_processor.hpp	2006-10-18 11:42:56 UTC (rev 344)
@@ -68,7 +68,7 @@
 	
         void apply()
         {
-            boost::progress_timer t;
+            boost::progress_timer t(std::clog);
             
             Processor & p = static_cast<Processor&>(*this);
             



From jdoyon at mail.berlios.de  Thu Oct 19 00:08:37 2006
From: jdoyon at mail.berlios.de (jdoyon at BerliOS)
Date: Thu, 19 Oct 2006 00:08:37 +0200
Subject: [Mapnik-svn] r345 - trunk/include/mapnik
Message-ID: <200610182208.k9IM8bLr003470@sheep.berlios.de>

Author: jdoyon
Date: 2006-10-19 00:08:36 +0200 (Thu, 19 Oct 2006)
New Revision: 345

Modified:
   trunk/include/mapnik/
Log:
ignore .sconsign


Property changes on: trunk/include/mapnik
___________________________________________________________________
Name: svn:ignore
   + .sconsign




From jdoyon at mail.berlios.de  Thu Oct 19 00:09:31 2006
From: jdoyon at mail.berlios.de (jdoyon at BerliOS)
Date: Thu, 19 Oct 2006 00:09:31 +0200
Subject: [Mapnik-svn] r346 - in trunk/boost/property_tree: . detail
Message-ID: <200610182209.k9IM9Val003576@sheep.berlios.de>

Author: jdoyon
Date: 2006-10-19 00:09:30 +0200 (Thu, 19 Oct 2006)
New Revision: 346

Modified:
   trunk/boost/property_tree/
   trunk/boost/property_tree/detail/
Log:
ignore .sconsign


Property changes on: trunk/boost/property_tree
___________________________________________________________________
Name: svn:ignore
   + .sconsign



Property changes on: trunk/boost/property_tree/detail
___________________________________________________________________
Name: svn:ignore
   + .sconsign




From pavlenko at mail.berlios.de  Thu Oct 19 00:44:43 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Thu, 19 Oct 2006 00:44:43 +0200
Subject: [Mapnik-svn] r347 - in trunk: include/mapnik src
Message-ID: <200610182244.k9IMihgj008908@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-19 00:44:37 +0200 (Thu, 19 Oct 2006)
New Revision: 347

Added:
   trunk/include/mapnik/distance.hpp
   trunk/include/mapnik/scale_denominator.hpp
   trunk/src/distance.cpp
   trunk/src/scale_denominator.cpp
Modified:
   trunk/include/mapnik/feature_style_processor.hpp
   trunk/src/SConscript
   trunk/src/layer.cpp
Log:
added scale_denominator calc + great-circle distance
(needs checking with different projections)



Added: trunk/include/mapnik/distance.hpp
===================================================================
--- trunk/include/mapnik/distance.hpp	2006-10-18 22:09:30 UTC (rev 346)
+++ trunk/include/mapnik/distance.hpp	2006-10-18 22:44:37 UTC (rev 347)
@@ -0,0 +1,55 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef DISTANCE_HPP
+#define DISTANCE_HPP
+
+#include <mapnik/coord.hpp>
+
+namespace mapnik
+{
+    class ellipsoid;
+    
+    // great-circle distance 
+    
+    class great_circle_distance
+    {
+    public:
+        double operator() (coord2d const& pt0, coord2d const& pt1) const;
+    };
+    
+    // vincenty distance 
+    /*
+    class vincenty_distance : boost::noncopyble
+    {
+    public:
+        vincenty_distance(ellipsoid const& e);
+        double operator() (coord2d const& pt0, coord2d const& pt1) const;
+    private:
+        ellipsoid & e_;
+    };
+    */
+}
+
+#endif // GEO_UTILS_HPP

Modified: trunk/include/mapnik/feature_style_processor.hpp
===================================================================
--- trunk/include/mapnik/feature_style_processor.hpp	2006-10-18 22:09:30 UTC (rev 346)
+++ trunk/include/mapnik/feature_style_processor.hpp	2006-10-18 22:44:37 UTC (rev 347)
@@ -37,6 +37,7 @@
 #include <mapnik/attribute_collector.hpp>
 #include <mapnik/utils.hpp>
 #include <mapnik/projection.hpp>
+#include <mapnik/scale_denominator.hpp>
 
 namespace mapnik
 {       
@@ -68,25 +69,24 @@
 	
         void apply()
         {
-            boost::progress_timer t(std::clog);
-            
+            boost::progress_timer t(std::clog);            
             Processor & p = static_cast<Processor&>(*this);
-            
             p.start_map_processing(m_);
-            
-            std::vector<Layer>::const_iterator itr = m_.layers().begin();
-            std::vector<Layer>::const_iterator end = m_.layers().end();
-            
+                       
             try
             {
                 projection proj(m_.srs()); // map projection
+                double scale_denom = scale_denominator(m_,proj);
+                std::clog << "scale denominator = " << scale_denom << "\n";
                 
+                std::vector<Layer>::const_iterator itr = m_.layers().begin();
+                std::vector<Layer>::const_iterator end = m_.layers().end();
+            
                 while (itr != end)
                 {
-                    if (itr->isVisible(m_.scale()))// && 
-                        //itr->envelope().intersects(m_.getCurrentExtent())) TODO
-                    {    
-                        apply_to_layer(*itr, p, proj);
+                    if (itr->isVisible(scale_denom))
+                    {
+                        apply_to_layer(*itr, p, proj, scale_denom);
                     }
                     ++itr;
                 }
@@ -99,7 +99,8 @@
             p.end_map_processing(m_);
         }	
     private:
-        void apply_to_layer(Layer const& lay, Processor & p, projection const& proj0)
+        void apply_to_layer(Layer const& lay, Processor & p, 
+                            projection const& proj0,double scale_denom)
         {
             p.start_layer_processing(lay);
             boost::shared_ptr<datasource> ds=lay.datasource();
@@ -121,8 +122,6 @@
                 Envelope<double> bbox(x0,y0,x1,y1);
                 std::clog << bbox << "\n";
                 
-                double scale = m_.scale();
-                
                 std::vector<std::string> const& style_names = lay.styles();
                 std::vector<std::string>::const_iterator stylesIter = style_names.begin();
                 std::vector<std::string>::const_iterator stylesEnd = style_names.end();
@@ -146,7 +145,7 @@
                                         
                     while (ruleIter!=ruleEnd)
                     {
-                        if (ruleIter->active(scale))
+                        if (ruleIter->active(scale_denom))
                         {
                             active_rules=true;
                             ruleIter->accept(collector);

Added: trunk/include/mapnik/scale_denominator.hpp
===================================================================
--- trunk/include/mapnik/scale_denominator.hpp	2006-10-18 22:09:30 UTC (rev 346)
+++ trunk/include/mapnik/scale_denominator.hpp	2006-10-18 22:44:37 UTC (rev 347)
@@ -0,0 +1,30 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+namespace mapnik {
+ 
+    class Map;
+    class projection;
+    double scale_denominator(Map const& map,projection const& prj); 
+}

Modified: trunk/src/SConscript
===================================================================
--- trunk/src/SConscript	2006-10-18 22:09:30 UTC (rev 346)
+++ trunk/src/SConscript	2006-10-18 22:44:37 UTC (rev 347)
@@ -58,6 +58,8 @@
     wkb.cpp
     projection.cpp
     proj_transform.cpp
+    distance.cpp
+    scale_denominator.cpp
     """
     )
 

Added: trunk/src/distance.cpp
===================================================================
--- trunk/src/distance.cpp	2006-10-18 22:09:30 UTC (rev 346)
+++ trunk/src/distance.cpp	2006-10-18 22:44:37 UTC (rev 347)
@@ -0,0 +1,52 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+#include <cmath>
+#include <mapnik/ellipsoid.hpp>
+#include <mapnik/distance.hpp>
+
+namespace mapnik {
+    
+    static const double deg2rad = 0.0174532925199432958;
+    static const double R = 6372795.0; // average great-circle radius of the earth
+    
+    double great_circle_distance::operator() (coord2d const& pt0, 
+                                              coord2d const& pt1) const
+    {
+        double lon0 = pt0.x * deg2rad;
+        double lat0 = pt0.y * deg2rad;
+        double lon1 = pt1.x * deg2rad;
+        double lat1 = pt1.y * deg2rad;
+        
+        double dlat = lat1 - lat0;
+        double dlon = lon1 - lon0;
+        
+        double sin_dlat = sin(0.5 * dlat);
+        double sin_dlon = sin(0.5 * dlon);
+        
+        double a = pow(sin_dlat,2.0) + cos(lat0)*cos(lat1)*pow(sin_dlon,2.0);
+        double c = 2 * atan2(sqrt(a),sqrt(1 - a));
+        return R * c; 
+    }
+    
+}

Modified: trunk/src/layer.cpp
===================================================================
--- trunk/src/layer.cpp	2006-10-18 22:09:30 UTC (rev 346)
+++ trunk/src/layer.cpp	2006-10-18 22:44:37 UTC (rev 347)
@@ -173,7 +173,7 @@
 
     bool Layer::isVisible(double scale) const
     {
-        return isActive() && scale>=minZoom_ && scale<maxZoom_;
+        return isActive() && scale >= minZoom_ && scale < maxZoom_;
     }
 
     void Layer::setSelectable(bool selectable)

Added: trunk/src/scale_denominator.cpp
===================================================================
--- trunk/src/scale_denominator.cpp	2006-10-18 22:09:30 UTC (rev 346)
+++ trunk/src/scale_denominator.cpp	2006-10-18 22:44:37 UTC (rev 347)
@@ -0,0 +1,54 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+#include <cmath>
+#include <mapnik/map.hpp>
+#include <mapnik/projection.hpp>
+#include <mapnik/distance.hpp>
+#include <mapnik/scale_denominator.hpp>
+
+namespace mapnik {
+ 
+    static const double dpi = 90.0; // display resolution
+    
+    double scale_denominator(Map const& map,projection const& prj)
+    {
+        double map_width = map.getWidth();
+        double map_height = map.getHeight();
+        Envelope<double> const& extent = map.getCurrentExtent();
+        double x0 = extent.minx();
+        double y0 = extent.miny();
+        double x1 = extent.maxx();
+        double y1 = extent.maxy();
+        
+        if (!prj.is_geographic())
+        {
+            prj.inverse(x0,y0);
+            prj.inverse(x1,y1); 
+        }
+        great_circle_distance distance;
+        double d1 = distance(coord2d(x0,y0),coord2d(x1, y1));
+        double d0 = sqrt(map_width * map_width + map_height * map_height) / dpi * 0.0254;
+        return d1 / d0;
+    }
+}



From pavlenko at mail.berlios.de  Thu Oct 19 01:03:00 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Thu, 19 Oct 2006 01:03:00 +0200
Subject: [Mapnik-svn] r348 - trunk/include/mapnik
Message-ID: <200610182303.k9IN30PR029664@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-19 01:02:57 +0200 (Thu, 19 Oct 2006)
New Revision: 348

Added:
   trunk/include/mapnik/ellipsoid.hpp
Log:
 ellipsoid 

Added: trunk/include/mapnik/ellipsoid.hpp
===================================================================
--- trunk/include/mapnik/ellipsoid.hpp	2006-10-18 22:44:37 UTC (rev 347)
+++ trunk/include/mapnik/ellipsoid.hpp	2006-10-18 23:02:57 UTC (rev 348)
@@ -0,0 +1,31 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+namespace mapnik {
+    struct ellipsoid
+    {
+        double a; // semi mayor axis  
+        double b; // semi minor axis
+    };
+}



From jdoyon at mail.berlios.de  Thu Oct 19 01:57:44 2006
From: jdoyon at mail.berlios.de (jdoyon at BerliOS)
Date: Thu, 19 Oct 2006 01:57:44 +0200
Subject: [Mapnik-svn] r349 - trunk/bindings/python
Message-ID: <200610182357.k9INvipW024598@sheep.berlios.de>

Author: jdoyon
Date: 2006-10-19 01:57:44 +0200 (Thu, 19 Oct 2006)
New Revision: 349

Modified:
   trunk/bindings/python/mapnik_layer.cpp
Log:
Fix typo src -> srs property.

Modified: trunk/bindings/python/mapnik_layer.cpp
===================================================================
--- trunk/bindings/python/mapnik_layer.cpp	2006-10-18 23:02:57 UTC (rev 348)
+++ trunk/bindings/python/mapnik_layer.cpp	2006-10-18 23:57:44 UTC (rev 349)
@@ -53,7 +53,7 @@
                       &Layer::set_abstract,
                       "Get/Set the abstract of the layer.")
         
-        .add_property("src", 
+        .add_property("srs", 
                       make_function(&Layer::srs,return_value_policy<copy_const_reference>()),
                       &Layer::set_srs,
                       "Get/Set the SRS of the layer.")



From jdoyon at mail.berlios.de  Thu Oct 19 03:25:24 2006
From: jdoyon at mail.berlios.de (jdoyon at BerliOS)
Date: Thu, 19 Oct 2006 03:25:24 +0200
Subject: [Mapnik-svn] r350 - in trunk: bindings/python/mapnik/ogcserver
	docs/ogcserver
Message-ID: <200610190125.k9J1POKc009127@sheep.berlios.de>

Author: jdoyon
Date: 2006-10-19 03:25:24 +0200 (Thu, 19 Oct 2006)
New Revision: 350

Modified:
   trunk/bindings/python/mapnik/ogcserver/WMS.py
   trunk/bindings/python/mapnik/ogcserver/common.py
   trunk/bindings/python/mapnik/ogcserver/wms111.py
   trunk/bindings/python/mapnik/ogcserver/wms130.py
   trunk/docs/ogcserver/readme.txt
Log:
- Add projection support to the WMS server and edit ogcserver readme accordingly.

NOTE: WMS 1.1.1 not tested, WMS 1.3.0 lightly tested.

Modified: trunk/bindings/python/mapnik/ogcserver/WMS.py
===================================================================
--- trunk/bindings/python/mapnik/ogcserver/WMS.py	2006-10-18 23:57:44 UTC (rev 349)
+++ trunk/bindings/python/mapnik/ogcserver/WMS.py	2006-10-19 01:25:24 UTC (rev 350)
@@ -24,6 +24,7 @@
 from wms111 import ServiceHandler as ServiceHandler111
 from wms130 import ServiceHandler as ServiceHandler130
 from mapnik import Style, Layer
+import re
 
 def ServiceHandlerFactory(conf, mapfactory, onlineresource, version):
 
@@ -46,6 +47,8 @@
         layername = layer.name
         if not layername:
             raise ServerConfigurationError('Attempted to register an unnamed layer.')
+        if not re.match('^\+init=epsg:\d+$', layer.srs):
+            raise ServerConfigurationError('Attempted to register a layer without an epsg projection defined.')
         if defaultstyle not in self.styles.keys() + self.aggregatestyles.keys():
             raise ServerConfigurationError('Attempted to register a layer with an non-existent default style.')
         layer.wmsdefaultstyle = defaultstyle

Modified: trunk/bindings/python/mapnik/ogcserver/common.py
===================================================================
--- trunk/bindings/python/mapnik/ogcserver/common.py	2006-10-18 23:57:44 UTC (rev 349)
+++ trunk/bindings/python/mapnik/ogcserver/common.py	2006-10-19 01:25:24 UTC (rev 350)
@@ -20,7 +20,7 @@
 # $Id$
 
 from exceptions import OGCException, ServerConfigurationError
-from mapnik import Map, Color, Envelope, render, rawdata, Image, Projection, render_to_file, Coord
+from mapnik import Map, Color, Envelope, render, rawdata, Image, Projection as MapnikProjection, render_to_file, Coord
 from PIL.Image import fromstring, new
 from PIL.ImageDraw import Draw
 from StringIO import StringIO
@@ -241,7 +241,7 @@
 class CRS:
 
     def __init__(self, namespace, code):
-        self.namespace = namespace
+        self.namespace = namespace.lower()
         self.code = int(code)
         self.proj = None
 
@@ -255,12 +255,12 @@
 
     def inverse(self, x, y):
         if not self.proj:
-            self.proj = Projection('+init=%s' % str(self).lower())
+            self.proj = Projection('+init=%s:%s' % (self.namespace, self.code))
         return self.proj.inverse(Coord(x, y))
 
     def forward(self, x, y):
         if not self.proj:
-            self.proj = Projection('+init=%s' % str(self).lower())
+            self.proj = Projection('+init=%s:%s' % (self.namespace, self.code))        
         return self.proj.forward(Coord(x, y))
 
 class CRSFactory:
@@ -286,7 +286,7 @@
             raise OGCException("BBOX values don't make sense.  miny is greater than maxy.")
         if params.has_key('styles') and len(params['styles']) != len(params['layers']):
             raise OGCException('STYLES length does not match LAYERS length.')
-        m = Map(params['width'], params['height'])
+        m = Map(params['width'], params['height'], '+init=%s' % params['crs'])
         if params.has_key('transparent') and params['transparent'] == 'FALSE':
             m.background = params['bgcolor']
         else:
@@ -380,3 +380,8 @@
         im.save(fh, PIL_TYPE_MAPPING[params['format']])
         fh.seek(0)
         return Response(params['format'], fh.read())
+
+class Projection(MapnikProjection):
+    
+    def epsgstring(self):
+        return self.params().split('=')[1].upper()
\ No newline at end of file

Modified: trunk/bindings/python/mapnik/ogcserver/wms111.py
===================================================================
--- trunk/bindings/python/mapnik/ogcserver/wms111.py	2006-10-18 23:57:44 UTC (rev 349)
+++ trunk/bindings/python/mapnik/ogcserver/wms111.py	2006-10-19 01:25:24 UTC (rev 350)
@@ -21,9 +21,10 @@
 
 from common import ParameterDefinition, Response, Version, ListFactory, \
                    ColorFactory, CRSFactory, WMSBaseServiceHandler, CRS, \
-                   BaseExceptionHandler
+                   BaseExceptionHandler, Projection
 from exceptions import OGCException, ServerConfigurationError
 from lxml import etree as ElementTree
+from mapnik import Coord
 
 class ServiceHandler(WMSBaseServiceHandler):
 
@@ -98,7 +99,6 @@
         <Layer>
           <Title>A Mapnik WMS Server</Title>
           <Abstract>A Mapnik WMS Server</Abstract>
-          <SRS/>
         </Layer>
       </Capability>
     </WMT_MS_Capabilities>
@@ -107,10 +107,10 @@
     def __init__(self, conf, mapfactory, opsonlineresource):
         self.conf = conf
         self.mapfactory = mapfactory
-        if self.conf.has_option('service', 'epsg'):
-            self.crs = CRS('EPSG', self.conf.get('service', 'epsg'))
+        if self.conf.has_option('service', 'allowedepsgcodes'):
+            self.allowedepsgcodes = map(lambda code: 'epsg:%s' % code, self.conf.get('service', 'allowedepsgcodes').split(','))
         else:
-            ServerConfigurationError('EPSG code not properly configured.')
+            raise ServerConfigurationError('Allowed EPSG codes not properly configured.')
 
         capetree = ElementTree.fromstring(self.capabilitiesxmltemplate)
 
@@ -122,22 +122,25 @@
 
         rootlayerelem = capetree.find('{http://www.opengis.net/wms}Capability/{http://www.opengis.net/wms}Layer')
 
-        rootlayersrs = rootlayerelem.find('{http://www.opengis.net/wms}SRS')
-        rootlayersrs.text = str(self.crs)
+        for epsgcode in self.allowedepsgcodes:
+            rootlayercrs = ElementTree.Element('SRS')
+            rootlayercrs.text = epsgcode.upper()
+            rootlayerelem.append(rootlayercrs)
 
         for layer in self.mapfactory.layers.values():
+            layerproj = Projection(layer.srs)
             layername = ElementTree.Element('Name')
             layername.text = layer.name
             env = layer.envelope()
-            llp = self.crs.inverse(env.minx, env.miny)
-            urp = self.crs.inverse(env.maxx, env.maxy)
+            llp = layerproj.inverse(Coord(env.minx, env.miny))
+            urp = layerproj.inverse(Coord(env.maxx, env.maxy))
             latlonbb = ElementTree.Element('LatLonBoundingBox')
             latlonbb.set('minx', str(llp.x))
             latlonbb.set('miny', str(llp.y))
             latlonbb.set('maxx', str(urp.x))
             latlonbb.set('maxy', str(urp.y))
             layerbbox = ElementTree.Element('BoundingBox')
-            layerbbox.set('SRS', str(self.crs))
+            layerbbox.set('SRS', layerproj.epsgstring())
             layerbbox.set('minx', str(env.minx))
             layerbbox.set('miny', str(env.miny))
             layerbbox.set('maxx', str(env.maxx))
@@ -173,8 +176,9 @@
         return response
 
     def GetMap(self, params):
-        if str(params['srs']) != str(self.crs):
-            raise OGCException('Unsupported SRS requested.  Must be "%s" and not "%s".' % (self.crs, params['crs']), 'InvalidCRS')
+        if str(params['srs']) not in self.allowedepsgcodes:
+            raise OGCException('Unsupported SRS "%s" requested.' % str(params['srs']).upper(), 'InvalidSRS')
+        params['crs'] = params['srs']
         return WMSBaseServiceHandler.GetMap(self, params)
 
 class ExceptionHandler(BaseExceptionHandler):

Modified: trunk/bindings/python/mapnik/ogcserver/wms130.py
===================================================================
--- trunk/bindings/python/mapnik/ogcserver/wms130.py	2006-10-18 23:57:44 UTC (rev 349)
+++ trunk/bindings/python/mapnik/ogcserver/wms130.py	2006-10-19 01:25:24 UTC (rev 350)
@@ -21,9 +21,10 @@
 
 from common import ParameterDefinition, Response, Version, ListFactory, \
                    ColorFactory, CRSFactory, CRS, WMSBaseServiceHandler, \
-                   BaseExceptionHandler
+                   BaseExceptionHandler, Projection
 from exceptions import OGCException, ServerConfigurationError
 from lxml import etree as ElementTree
+from mapnik import Coord
 
 class ServiceHandler(WMSBaseServiceHandler):
 
@@ -104,7 +105,6 @@
         <Layer>
           <Title>A Mapnik WMS Server</Title>
           <Abstract>A Mapnik WMS Server</Abstract>
-          <CRS/>
         </Layer>
       </Capability>
     </WMS_Capabilities>
@@ -113,10 +113,10 @@
     def __init__(self, conf, mapfactory, opsonlineresource):
         self.conf = conf
         self.mapfactory = mapfactory
-        if self.conf.has_option('service', 'epsg'):
-            self.crs = CRS('EPSG', self.conf.get('service', 'epsg'))
+        if self.conf.has_option('service', 'allowedepsgcodes'):
+            self.allowedepsgcodes = map(lambda code: 'epsg:%s' % code, self.conf.get('service', 'allowedepsgcodes').split(','))
         else:
-            raise ServerConfigurationError('EPSG code not properly configured.')
+            raise ServerConfigurationError('Allowed EPSG codes not properly configured.')
 
         capetree = ElementTree.fromstring(self.capabilitiesxmltemplate)
 
@@ -128,16 +128,19 @@
 
         rootlayerelem = capetree.find('{http://www.opengis.net/wms}Capability/{http://www.opengis.net/wms}Layer')
 
-        rootlayercrs = rootlayerelem.find('{http://www.opengis.net/wms}CRS')
-        rootlayercrs.text = str(self.crs)
+        for epsgcode in self.allowedepsgcodes:
+            rootlayercrs = ElementTree.Element('CRS')
+            rootlayercrs.text = epsgcode.upper()
+            rootlayerelem.append(rootlayercrs)
 
         for layer in self.mapfactory.layers.values():
+            layerproj = Projection(layer.srs)
             layername = ElementTree.Element('Name')
             layername.text = layer.name
             env = layer.envelope()
             layerexgbb = ElementTree.Element('EX_GeographicBoundingBox')
-            ll = self.crs.inverse(env.minx, env.miny)
-            ur = self.crs.inverse(env.maxx, env.maxy)
+            ll = layerproj.inverse(Coord(env.minx, env.miny))
+            ur = layerproj.inverse(Coord(env.maxx, env.maxy))
             exgbb_wbl = ElementTree.Element('westBoundLongitude')
             exgbb_wbl.text = str(ll.x)
             layerexgbb.append(exgbb_wbl)
@@ -151,7 +154,7 @@
             exgbb_nbl.text = str(ur.y)
             layerexgbb.append(exgbb_nbl)
             layerbbox = ElementTree.Element('BoundingBox')
-            layerbbox.set('CRS', str(self.crs))
+            layerbbox.set('CRS', layerproj.epsgstring())
             layerbbox.set('minx', str(env.minx))
             layerbbox.set('miny', str(env.miny))
             layerbbox.set('maxx', str(env.maxx))
@@ -189,8 +192,8 @@
     def GetMap(self, params):
         if params['width'] > int(self.conf.get('service', 'maxwidth')) or params['height'] > int(self.conf.get('service', 'maxheight')):
             raise OGCException('Requested map size exceeds limits set by this server.')
-        if str(params['crs']) != str(self.crs):
-            raise OGCException('Unsupported CRS requested.  Must be "%s" and not "%s".' % (self.crs, params['crs']), 'InvalidCRS')
+        if str(params['crs']) not in self.allowedepsgcodes:
+            raise OGCException('Unsupported CRS "%s" requested.' % str(params['crs']).upper(), 'InvalidCRS')
         return WMSBaseServiceHandler.GetMap(self, params)
 
 class ExceptionHandler(BaseExceptionHandler):

Modified: trunk/docs/ogcserver/readme.txt
===================================================================
--- trunk/docs/ogcserver/readme.txt	2006-10-18 23:57:44 UTC (rev 349)
+++ trunk/docs/ogcserver/readme.txt	2006-10-19 01:25:24 UTC (rev 350)
@@ -22,8 +22,8 @@
 - JPEG/PNG output
 - XML/INIMAGE/BLANK error handling
 - Multiple named styles support
-- No real layer metadata support yet
-- No re-projection support
+- Reprojection support
+- Supported layer metadata: title, abstract
 - Needs to be able to write to tempfile.gettempdir() (most likely "/tmp")
 
 
@@ -41,22 +41,8 @@
 Installation
 ------------
 
-- Make sure you compile or re-compile Mapnik after installing PROJ.4, if this
-  was not done already.  Mapnik includes a Python API to the PROJ.4 library
-  used by the ogcserver.  The PROJ_INCLUDES and PROJ_LIBS parameters can
-  be passed to mapnik's scons build script to help with this.
-  
-  You can test the availability of the PROJ.4 bindings by trying:
-  
-  $ python
-  Python 2.3.4 (#1, Feb 22 2005, 04:09:37)
-  [GCC 3.4.3 20041212 (Red Hat 3.4.3-9.EL4)] on linux2
-  Type "help", "copyright", "credits" or "license" for more information.
-  >>> from mapnik import Projection
-  registered datasource : raster
-  registered datasource : shape
-  registered datasource : postgis
-  >>>
+- Make sure Mapnik was compiled and linked with PROJ.4 support.  If this isn't
+  the case, recompile Mapnik and make sure it is.
 
 - The executable "ogcserver" in utils/ogcserver will work for both CGI and
   FastCGI operations.  Where to place it will depend on your server's
@@ -92,6 +78,7 @@
 The server needs a python module, with code that looks like this:
 
 from mapnik.ogcserver.WMS import BaseWMSFactory
+from mapnik import Layer, Style
 
 class WMSFactory(BaseWMSFactory):
 
@@ -101,7 +88,9 @@
 		...
 		self.register_style('stylename', sty)
 		
-		lyr = Layer(name='layername', title='Highways', abstract='Highways')
+		lyr = Layer('layername', '+init=epsg:4326')
+		lyr.title = 'Layer title'
+		lyr.abstract = 'Layer abstract'
 		...
 		self.register_layer(lyr, 'stylename')
 		self.finalize()
@@ -111,11 +100,14 @@
 - It MUST be called 'WMSFactory'.
 - It MUST sub-class mapnik.ogcserver.WMS.BaseWMSFactory.
 - The __init__ MUST call the base class'.
-- Layers MUST be named with the 'name' parameter to the constructor.
+- Layers MUST be named with the first parameter to the constructor.
+- Layers MUST define an EPSG projection in the second parameter to the
+  constructor.  This implies that the underlying data must be in an EPSG
+  projection already.
 - style and layer names are meant for machine readability, not human.  Keep
   them short and simple, without spaces or special characters.
-- For human readable info, pass title='' and abstract='' parameters to the
-  Layer() call.
+- For human readable info, set the title and abstract properties on the layer
+  object.
 - DO NOT register styles using layer.styles.append(), instead, provide style
   information to the register_layer() call:
   



From pavlenko at mail.berlios.de  Thu Oct 19 10:46:19 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Thu, 19 Oct 2006 10:46:19 +0200
Subject: [Mapnik-svn] r351 - trunk/include/mapnik
Message-ID: <200610190846.k9J8kJ56001500@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-19 10:46:17 +0200 (Thu, 19 Oct 2006)
New Revision: 351

Modified:
   trunk/include/mapnik/font_engine_freetype.hpp
Log:
call FT_Done_Glyph(image) in character_dimensions 



Modified: trunk/include/mapnik/font_engine_freetype.hpp
===================================================================
--- trunk/include/mapnik/font_engine_freetype.hpp	2006-10-19 01:25:24 UTC (rev 350)
+++ trunk/include/mapnik/font_engine_freetype.hpp	2006-10-19 08:46:17 UTC (rev 351)
@@ -28,9 +28,9 @@
 // freetype2
 extern "C"
 {
-  #include <ft2build.h>
-  #include FT_FREETYPE_H
-  #include FT_GLYPH_H
+#include <ft2build.h>
+#include FT_FREETYPE_H
+#include FT_GLYPH_H
 }
 
 // stl
@@ -252,7 +252,7 @@
             FT_Error  error;
 	    
             FT_Face face = face_->get_face();
-//            FT_GlyphSlot slot = face->glyph;
+            //            FT_GlyphSlot slot = face->glyph;
 	    
             FT_BBox bbox;   
             bbox.xMin = bbox.yMin = 32000; 
@@ -310,7 +310,7 @@
                 glyphs_.push_back(new glyph_t(image));
             }
 	    
-          return Envelope<double>(bbox.xMin, bbox.yMin, bbox.xMax, bbox.yMax);
+            return Envelope<double>(bbox.xMin, bbox.yMin, bbox.xMax, bbox.yMax);
         }
       
         dimension_t character_dimensions(const unsigned c)
@@ -346,7 +346,7 @@
                 return dimension_t(0, 0);
             
             FT_Glyph_Get_CBox(image,ft_glyph_bbox_pixels, &glyph_bbox); 
-          
+            FT_Done_Glyph(image); 
             return dimension_t(slot->advance.x >> 6, glyph_bbox.yMax - glyph_bbox.yMin);
         }
         
@@ -357,12 +357,12 @@
           
             for (std::string::const_iterator i=text.begin();i!=text.end();++i)
             {
-              dimension_t char_dim = character_dimensions(*i);
+                dimension_t char_dim = character_dimensions(*i);
               
-              info->add_info(*i, char_dim.first, char_dim.second);
+                info->add_info(*i, char_dim.first, char_dim.second);
               
-              width += char_dim.first;
-              height = char_dim.second > height ? char_dim.second : height;
+                width += char_dim.first;
+                height = char_dim.second > height ? char_dim.second : height;
             }
             
             info->set_dimensions(width, height);
@@ -460,8 +460,8 @@
     
         pixmap_type & pixmap_;
         face_ptr face_;
-      mapnik::Color fill_;
-      mapnik::Color halo_fill_;
+        mapnik::Color fill_;
+        mapnik::Color halo_fill_;
         int halo_radius_;
         glyphs_t glyphs_;
     }; 



From pavlenko at mail.berlios.de  Thu Oct 19 11:24:29 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Thu, 19 Oct 2006 11:24:29 +0200
Subject: [Mapnik-svn] r352 - in trunk: plugins/input/postgis src
Message-ID: <200610190924.k9J9OTvU006720@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-19 11:24:26 +0200 (Thu, 19 Oct 2006)
New Revision: 352

Modified:
   trunk/plugins/input/postgis/postgis.cpp
   trunk/src/agg_renderer.cpp
Log:
* trim leading and trailing whitespace from all strings before
  rendering them as labels when using the text or shield symbolisers
  (blame my horrible datasets)
* correctly recognise the Postgis "text" data type (it was in
  postgisfs.cpp just not postgis.cpp) - my initial workaround to the
  above was "SELECT trim(from label) AS label ..." which failed
  miserably because it returned a text data type. 

Thanks to Robert Coup for the patch!




Modified: trunk/plugins/input/postgis/postgis.cpp
===================================================================
--- trunk/plugins/input/postgis/postgis.cpp	2006-10-19 08:46:17 UTC (rev 351)
+++ trunk/plugins/input/postgis/postgis.cpp	2006-10-19 09:24:26 UTC (rev 352)
@@ -148,6 +148,7 @@
                         desc_.add_descriptor(attribute_descriptor(fld_name,mapnik::Double,false,length));
                     case 1042:  // bpchar
                     case 1043:  // varchar
+                    case 25:   // text
                         desc_.add_descriptor(attribute_descriptor(fld_name,mapnik::String));
                         break;
                     default: // shouldn't get here

Modified: trunk/src/agg_renderer.cpp
===================================================================
--- trunk/src/agg_renderer.cpp	2006-10-19 08:46:17 UTC (rev 351)
+++ trunk/src/agg_renderer.cpp	2006-10-19 09:24:26 UTC (rev 352)
@@ -25,6 +25,7 @@
 #include <iostream>
 // boost
 #include <boost/utility.hpp>
+#include <boost/algorithm/string.hpp>
 // agg
 #include "agg_basics.h"
 #include "agg_rendering_buffer.h"
@@ -325,6 +326,7 @@
         if (geom)
         {
             std::string text = feature[sym.get_name()].to_string();
+            boost::trim(text);
             boost::shared_ptr<ImageData32> const& data = sym.get_data();
             
             if (text.length() > 0 && data)
@@ -481,6 +483,7 @@
         if (geom)
         {
             std::string text = feature[sym.get_name()].to_string();
+            boost::trim(text);
             if (text.length() > 0)
             {
                 Color const& fill  = sym.get_fill();



From vspader10east at mail.berlios.de  Thu Oct 19 19:11:45 2006
From: vspader10east at mail.berlios.de (vspader10east at BerliOS)
Date: Thu, 19 Oct 2006 19:11:45 +0200
Subject: [Mapnik-svn] r353 - in trunk: bindings/python include/mapnik src
Message-ID: <200610191711.k9JHBjQC010501@sheep.berlios.de>

Author: vspader10east
Date: 2006-10-19 19:11:45 +0200 (Thu, 19 Oct 2006)
New Revision: 353

Modified:
   trunk/bindings/python/mapnik_shield_symbolizer.cpp
   trunk/bindings/python/mapnik_text_symbolizer.cpp
   trunk/include/mapnik/shield_symbolizer.hpp
   trunk/include/mapnik/text_symbolizer.hpp
   trunk/src/agg_renderer.cpp
   trunk/src/load_map.cpp
   trunk/src/shield_symbolizer.cpp
   trunk/src/text_symbolizer.cpp
Log:
Added face_name parameter to text and shield symbolizers,
which specifies the font face to be used for rendering.
New constructor is: text_symbolizer(name, face_name, size, ...)


Modified: trunk/bindings/python/mapnik_shield_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_shield_symbolizer.cpp	2006-10-19 09:24:26 UTC (rev 352)
+++ trunk/bindings/python/mapnik_shield_symbolizer.cpp	2006-10-19 17:11:45 UTC (rev 353)
@@ -32,7 +32,7 @@
     
     class_<shield_symbolizer>("ShieldSymbolizer",
                              init<>("Default Shield Symbolizer - 4x4 black square"))
-        .def (init< std::string const&, unsigned, mapnik::Color const&,
+        .def (init< std::string const&, std::string const&, unsigned, mapnik::Color const&,
               std::string const&, std::string const&,unsigned,unsigned>("TODO"))
         ;
     

Modified: trunk/bindings/python/mapnik_text_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_text_symbolizer.cpp	2006-10-19 09:24:26 UTC (rev 352)
+++ trunk/bindings/python/mapnik_text_symbolizer.cpp	2006-10-19 17:11:45 UTC (rev 353)
@@ -38,7 +38,7 @@
         ;
 
     class_<text_symbolizer>("TextSymbolizer",
-			    init<std::string const&,unsigned,Color const&>())
+			    init<std::string const&,std::string const&, unsigned,Color const&>())
         .add_property("halo_fill",make_function(
                       &text_symbolizer::get_halo_fill,
                       return_value_policy<copy_const_reference>()),

Modified: trunk/include/mapnik/shield_symbolizer.hpp
===================================================================
--- trunk/include/mapnik/shield_symbolizer.hpp	2006-10-19 09:24:26 UTC (rev 352)
+++ trunk/include/mapnik/shield_symbolizer.hpp	2006-10-19 17:11:45 UTC (rev 353)
@@ -34,6 +34,7 @@
     {	
         explicit shield_symbolizer();
         shield_symbolizer(std::string const& name,
+                          std::string const& face_name,
                           unsigned size,
                           Color const& fill, 
                           std::string const& file,
@@ -44,6 +45,7 @@
         boost::shared_ptr<ImageData32> const& get_data() const;
       
         std::string const& get_name() const;
+        std::string const& get_face_name() const;
 
         unsigned get_text_size() const;
         Color const& get_fill() const;
@@ -53,6 +55,7 @@
         
     private:
         std::string name_;
+        std::string face_name_;
         unsigned size_;
         Color fill_;
         boost::shared_ptr<ImageData32> symbol_;

Modified: trunk/include/mapnik/text_symbolizer.hpp
===================================================================
--- trunk/include/mapnik/text_symbolizer.hpp	2006-10-19 09:24:26 UTC (rev 352)
+++ trunk/include/mapnik/text_symbolizer.hpp	2006-10-19 17:11:45 UTC (rev 353)
@@ -38,11 +38,12 @@
     
     struct MAPNIK_DECL text_symbolizer
     {		
-        text_symbolizer(std::string const& name,unsigned size,Color const& fill);	
+	text_symbolizer(std::string const& name,std::string const& face_name, unsigned size,Color const& fill);	
         text_symbolizer(text_symbolizer const& rhs);
         text_symbolizer& operator=(text_symbolizer const& rhs);
         std::string const& get_name() const;
         unsigned get_text_size() const;
+	std::string const& get_face_name() const;
         Color const& get_fill() const;
         void set_halo_fill(Color const& fill);
         Color const& get_halo_fill() const;
@@ -56,6 +57,7 @@
         position const& get_displacement() const;
     private:
         std::string name_;
+  std::string face_name_;
         unsigned size_;
         Color fill_;
         Color halo_fill_;

Modified: trunk/src/agg_renderer.cpp
===================================================================
--- trunk/src/agg_renderer.cpp	2006-10-19 09:24:26 UTC (rev 352)
+++ trunk/src/agg_renderer.cpp	2006-10-19 17:11:45 UTC (rev 353)
@@ -331,7 +331,7 @@
             
             if (text.length() > 0 && data)
             {
-                face_ptr face = font_manager_.get_face("Bitstream Vera Sans Roman");//TODO
+                face_ptr face = font_manager_.get_face(sym.get_face_name());
                 if (face)
                 {
                     int w = data->width();
@@ -488,8 +488,7 @@
             {
                 Color const& fill  = sym.get_fill();
 	
-                face_ptr face = font_manager_.get_face("Bitstream Vera Sans Roman");//TODO
-                //face_ptr face = font_manager_.get_face("Times New Roman Regular");//TODO
+                face_ptr face = font_manager_.get_face(sym.get_face_name());
                 if (face)
                 {
                     text_renderer<mapnik::Image32> ren(pixmap_,face);

Modified: trunk/src/load_map.cpp
===================================================================
--- trunk/src/load_map.cpp	2006-10-19 09:24:26 UTC (rev 352)
+++ trunk/src/load_map.cpp	2006-10-19 17:11:45 UTC (rev 353)
@@ -131,13 +131,15 @@
                             {
                                 std::string name =  
                                     sym.second.get<std::string>("<xmlattr>.name");                      
+                                std::string face_name =  
+                                    sym.second.get<std::string>("<xmlattr>.face_name");                      
                                 unsigned size = 
                                     sym.second.get<unsigned>("<xmlattr>.size",10);                      
                                 std::string color_str = 
                                     sym.second.get<std::string>("<xmlattr>.fill","black");
                                 Color c = color_factory::from_string(color_str.c_str());
                                 
-                                text_symbolizer text_symbol(name,size,c);
+                                text_symbolizer text_symbol(name,face_name, size,c);
                                 
                                 std::string placement_str = 
                                     sym.second.get<std::string>("<xmlattr>.placement","point");

Modified: trunk/src/shield_symbolizer.cpp
===================================================================
--- trunk/src/shield_symbolizer.cpp	2006-10-19 09:24:26 UTC (rev 352)
+++ trunk/src/shield_symbolizer.cpp	2006-10-19 17:11:45 UTC (rev 353)
@@ -44,12 +44,13 @@
     
     shield_symbolizer::shield_symbolizer(
                           std::string const& name,
+                          std::string const& face_name,
                           unsigned size,
                           Color const& fill, 
                           std::string const& file,
                           std::string const& type,
                           unsigned width,unsigned height)
-        : name_(name), size_(size), fill_(fill), symbol_(new ImageData32(width,height))
+        : name_(name), face_name_(face_name), size_(size), fill_(fill), symbol_(new ImageData32(width,height))
     {
         try 
         {
@@ -67,6 +68,7 @@
     
     shield_symbolizer::shield_symbolizer(shield_symbolizer const& rhs)
         : name_(rhs.name_),
+          face_name_(rhs.face_name_),
           size_(rhs.size_),
           fill_(rhs.fill_),
           symbol_(rhs.symbol_),
@@ -88,6 +90,11 @@
       return name_;
     }
     
+    std::string const& shield_symbolizer::get_face_name() const
+    {
+      return face_name_;
+    }
+    
     void shield_symbolizer::set_allow_overlap(bool overlap)
     {
         overlap_ = overlap;

Modified: trunk/src/text_symbolizer.cpp
===================================================================
--- trunk/src/text_symbolizer.cpp	2006-10-19 09:24:26 UTC (rev 352)
+++ trunk/src/text_symbolizer.cpp	2006-10-19 17:11:45 UTC (rev 353)
@@ -26,8 +26,9 @@
 
 namespace mapnik
 {
-    text_symbolizer::text_symbolizer(std::string const& name,unsigned size,Color const& fill)
+    text_symbolizer::text_symbolizer(std::string const& name, std::string const& face_name, unsigned size,Color const& fill)
 	: name_(name),
+    face_name_(face_name),
 	  size_(size),
 	  fill_(fill),
 	  halo_fill_(Color(255,255,255)),
@@ -38,6 +39,7 @@
            
     text_symbolizer::text_symbolizer(text_symbolizer const& rhs)
 	: name_(rhs.name_),
+    face_name_(rhs.face_name_),
 	  size_(rhs.size_),
 	  fill_(rhs.fill_),
 	  halo_fill_(rhs.halo_fill_),
@@ -51,6 +53,7 @@
 	if (this == &other)
 	    return *this;
 	name_ = other.name_;
+  face_name_ = other.face_name_;
 	size_ = other.size_;
 	fill_ = other.fill_;
 	halo_fill_ = other.halo_fill_;
@@ -65,6 +68,11 @@
 	return name_;
     }
     
+    std::string const&  text_symbolizer::get_face_name() const
+    {
+	return face_name_;
+    }
+    
     unsigned  text_symbolizer::get_text_size() const
     {
 	return size_;



From pavlenko at mail.berlios.de  Sat Oct 21 14:16:20 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Sat, 21 Oct 2006 14:16:20 +0200
Subject: [Mapnik-svn] r354 - trunk/src
Message-ID: <200610211216.k9LCGK90018605@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-21 14:16:19 +0200 (Sat, 21 Oct 2006)
New Revision: 354

Modified:
   trunk/src/placement_finder.cpp
Log:
added missing projection transformation for label placement. 
TODO: move to geometry class to always return transformed label position



Modified: trunk/src/placement_finder.cpp
===================================================================
--- trunk/src/placement_finder.cpp	2006-10-19 17:11:45 UTC (rev 353)
+++ trunk/src/placement_finder.cpp	2006-10-21 12:16:19 UTC (rev 354)
@@ -395,6 +395,11 @@
     else
     {
       p->geom->label_position(&p->starting_x, &p->starting_y);
+      //  TODO: 
+      //  We would only want label position in final 'paper' coords.
+      //  Move view and proj transforms to e.g. label_position(x,y,proj_trans,ctrans)?
+      double z=0;  
+      p->proj_trans->backward(p->starting_x, p->starting_y, z);
       p->ctrans->forward(&p->starting_x, &p->starting_y);
     }
     



From pavlenko at mail.berlios.de  Sat Oct 21 14:17:43 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Sat, 21 Oct 2006 14:17:43 +0200
Subject: [Mapnik-svn] r355 - trunk/include/mapnik
Message-ID: <200610211217.k9LCHh60018708@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-21 14:17:41 +0200 (Sat, 21 Oct 2006)
New Revision: 355

Modified:
   trunk/include/mapnik/placement_finder.hpp
Log:
removed extra qualifier (GCC >= 4.1 reports as an error).



Modified: trunk/include/mapnik/placement_finder.hpp
===================================================================
--- trunk/include/mapnik/placement_finder.hpp	2006-10-21 12:16:19 UTC (rev 354)
+++ trunk/include/mapnik/placement_finder.hpp	2006-10-21 12:17:41 UTC (rev 355)
@@ -72,7 +72,7 @@
     //helpers
     std::pair<double, double> get_position_at_distance(double target_distance);
     double get_total_distance();
-    void placement::clear_envelopes();
+    void clear_envelopes();
     
     double total_distance_; //cache for distance
   };



From pavlenko at mail.berlios.de  Thu Oct 26 22:20:43 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Thu, 26 Oct 2006 22:20:43 +0200
Subject: [Mapnik-svn] r356 - trunk/src
Message-ID: <200610262020.k9QKKhv5007601@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-26 22:20:41 +0200 (Thu, 26 Oct 2006)
New Revision: 356

Modified:
   trunk/src/load_map.cpp
Log:
support for ShieldSymbolizer and LinePatternSymbolizer tags



Modified: trunk/src/load_map.cpp
===================================================================
--- trunk/src/load_map.cpp	2006-10-21 12:17:41 UTC (rev 355)
+++ trunk/src/load_map.cpp	2006-10-26 20:20:41 UTC (rev 356)
@@ -27,7 +27,11 @@
 #include <boost/lexical_cast.hpp>
 #include <boost/tokenizer.hpp>
 #include <boost/property_tree/ptree.hpp>
+
+// use tinyxml 
+#define BOOST_PROPERTY_TREE_XML_PARSER_TINYXML
 #include <boost/property_tree/xml_parser.hpp>
+
 // mapnik
 #include <mapnik/color.hpp>
 #include <mapnik/color_factory.hpp>
@@ -127,12 +131,26 @@
                             {
                                 std::cout << sym.first << "\n";
                             } 
+                            else if ( sym.first == "LinePatternSymbolizer")
+                            {
+                                std::string file =  
+                                    sym.second.get<std::string>("<xmlattr>.file"); 
+                                std::string type =  
+                                    sym.second.get<std::string>("<xmlattr>.type");
+                                unsigned width =  
+                                    sym.second.get<unsigned>("<xmlattr>.width");
+                                unsigned height =  
+                                    sym.second.get<unsigned>("<xmlattr>.height");
+                                
+                                rule.append(line_pattern_symbolizer(file,type,width,height));
+                                
+                            }
                             else if ( sym.first == "TextSymbolizer")
                             {
                                 std::string name =  
                                     sym.second.get<std::string>("<xmlattr>.name");                      
                                 std::string face_name =  
-                                    sym.second.get<std::string>("<xmlattr>.face_name");                      
+                                    sym.second.get<std::string>("<xmlattr>.face_name");              
                                 unsigned size = 
                                     sym.second.get<unsigned>("<xmlattr>.size",10);                      
                                 std::string color_str = 
@@ -151,6 +169,32 @@
                                 
                                 rule.append(text_symbol);
                             }
+                            else if ( sym.first == "ShieldSymbolizer")
+                            {
+                                std::string name =  
+                                    sym.second.get<std::string>("<xmlattr>.name");                      
+                                std::string face_name =  
+                                    sym.second.get<std::string>("<xmlattr>.face_name");              
+                                unsigned size = 
+                                    sym.second.get<unsigned>("<xmlattr>.size",10);                      
+                                std::string color_str = 
+                                    sym.second.get<std::string>("<xmlattr>.fill","black");
+                                Color fill = color_factory::from_string(color_str.c_str());
+                                
+                                std::string image_file =
+                                    sym.second.get<std::string>("<xmlattr>.file");
+                                std::string type =
+                                    sym.second.get<std::string>("<xmlattr>.type");
+                                unsigned width =  
+                                    sym.second.get<unsigned>("<xmlattr>.width");
+                                unsigned height =  
+                                    sym.second.get<unsigned>("<xmlattr>.height");
+                                
+                                shield_symbolizer shield_symbol(name,face_name,size,fill,
+                                                                image_file,type,width,height);
+                                
+                                rule.append(shield_symbol);
+                            }
                             else if ( sym.first == "LineSymbolizer")
                             {
                                 stroke strk;



From pavlenko at mail.berlios.de  Thu Oct 26 22:23:14 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Thu, 26 Oct 2006 22:23:14 +0200
Subject: [Mapnik-svn] r357 - trunk/src
Message-ID: <200610262023.k9QKNED1007756@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-26 22:23:12 +0200 (Thu, 26 Oct 2006)
New Revision: 357

Modified:
   trunk/src/image_util.cpp
Log:
added extra check to compile on x86_64 Gentoo.

 && defined(PNG_ASSEMBLER_CODE_SUPPORTED)

Thanks to Vincent Schut! 



Modified: trunk/src/image_util.cpp
===================================================================
--- trunk/src/image_util.cpp	2006-10-26 20:20:41 UTC (rev 356)
+++ trunk/src/image_util.cpp	2006-10-26 20:23:12 UTC (rev 357)
@@ -75,8 +75,8 @@
         if (!png_ptr) return;
         png_set_mem_fn(png_ptr,mem_ptr,malloc_fn,free_fn);
 
-        // switch on optimization
-#if defined(PNG_LIBPNG_VER) && (PNG_LIBPNG_VER >= 10200)
+        // switch on optimization only if supported
+#if defined(PNG_LIBPNG_VER) && (PNG_LIBPNG_VER >= 10200) && defined(PNG_ASSEMBLER_CODE_SUPPORTED)
         png_uint_32 mask, flags;
 
         flags = png_get_asm_flags(png_ptr);



From pavlenko at mail.berlios.de  Fri Oct 27 19:26:06 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Fri, 27 Oct 2006 19:26:06 +0200
Subject: [Mapnik-svn] r358 - in trunk: . tinyxml
Message-ID: <200610271726.k9RHQ6df016049@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-27 19:26:03 +0200 (Fri, 27 Oct 2006)
New Revision: 358

Added:
   trunk/tinyxml/
   trunk/tinyxml/.sconsign
   trunk/tinyxml/tinystr.cpp
   trunk/tinyxml/tinystr.h
   trunk/tinyxml/tinyxml.cpp
   trunk/tinyxml/tinyxml.h
   trunk/tinyxml/tinyxmlerror.cpp
   trunk/tinyxml/tinyxmlparser.cpp
Log:
added tinyxml source

Added: trunk/tinyxml/.sconsign
===================================================================
--- trunk/tinyxml/.sconsign	2006-10-26 20:23:12 UTC (rev 357)
+++ trunk/tinyxml/.sconsign	2006-10-27 17:26:03 UTC (rev 358)
@@ -0,0 +1,8 @@
+}q(Utinyxmlparser.osq(cSCons.Node.FS
+BuildInfo
+qoq}q(UbsigqU 3b15f27196beb6fc8d342079cbb4d105qU	bimplicitq]q	(U/usr/include/ctype.hq
+Utinyxml/tinyxml.hqU/usr/include/bits/types.hqU/usr/include/endian.hqU/usr/include/features.hqU/usr/include/xlocale.hqU/usr/include/assert.hqU/usr/include/stdio.hqU/usr/include/stdlib.hqU/usr/include/string.hqUtinyxml/tinystr.hqU/usr/include/bits/typesizes.hqU/usr/include/bits/wordsize.hqU/usr/include/bits/endian.hqU/usr/include/gnu/stubs.hqU/usr/include/sys/cdefs.hqU/usr/include/bits/stdio-ldbl.hqU/usr/include/bits/stdio.hqU/usr/include/bits/stdio2.hqU/usr/include/bits/stdio_lim.hqU/usr/include/bits/sys_errlist.hqU/usr/include/getopt.hqU/usr/include/libio.hq U/usr/include/alloca.hq!U/usr/include/bits/stdlib-ldbl.hq"U/usr/include/bits/stdlib.hq#U/usr/include/bits/waitflags.hq$U/usr/include/bits/waitstatus.hq%U/usr/include/sys/types.hq&U/usr/include/bits/string.hq'U/usr/include/bits/string2.hq(U/usr/include/bits/string3.hq)U/usr/include/gnu/stubs-32.hq*U/usr/include/gnu/stubs-64.hq+U/usr/include/_G_config.hq,U/usr/inclu!
 de/bits/libio-ldbl.hq-U/usr/include/bits/stdio-lock.hq.U /usr/include/bits/pthreadtypes.hq/U/usr/include/sys/select.hq0U/usr/include/sys/sysmacros.hq1U/usr/include/time.hq2U/usr/include/gconv.hq3U/usr/include/wchar.hq4U/usr/include/bits/libc-lock.hq5U/usr/include/bits/select.hq6U/usr/include/bits/sigset.hq7U/usr/include/bits/time.hq8U/usr/include/bits/wchar-ldbl.hq9U/usr/include/bits/wchar.hq:U/usr/include/bits/wchar2.hq;U/usr/include/wctype.hq<U/usr/include/pthread.hq=U/usr/include/bits/setjmp.hq>U/usr/include/sched.hq?U/usr/include/signal.hq at U/usr/include/bits/sched.hqAU/usr/include/bits/sigaction.hqBU/usr/include/bits/sigcontext.hqCU/usr/include/bits/siginfo.hqDU/usr/include/bits/signum.hqEU/usr/include/bits/sigstack.hqFU/usr/include/bits/sigthread.hqGU/usr/include/sys/ucontext.hqHeUbdependsqI]qJUbdependsigsqK]qLUbactsigqMU 1b5f699029656e4c248928d88a176771qNUbimplicitsigsqO]qP(U 00837daf31513ddb9efcdbe263e308e5qQU 4aecfb7c99af3fbaa13197f8cc1!
 2cc6dqRU c879f7ba4b8895420c23d9906b38ab9aqSU 842fadea2a9f05467!
 65ff04d0
6e62967qTU 414a080c648c4260bcd8142023fa150eqUU 19fdaa6e1408817d208fc02fd290f894qVU cdf2e4e7d7d8cfa02c8b1e1d6bb736c4qWU 3ef14c4f0793fc0aaba4b9c2f1f6f970qXU 6303c8f8a41b3cd547a428b086d3758bqYU 97f4bcf2a68b10df1ed4f542659a00a0qZU cf367876ee833646804f79b5dd331d83q[U af928b23500851e2da8cd3ec56d56edfq\U 30529eb770bdf401a7dc82c1659f4364q]U 93f54525ca894fe9c4f79236cd9b8bf3q^U 326ea516d2af549d9de3f71532c4e4e4q_U fc5d92924ea883f42d365cc93861c9d5q`U 7c11f8933ac7b548a32a01f73c77f421qaU 9e616d743e5168f8702488621bbd71fcqbU ea6cc4a9f17cdab6d6395bea155409e1qcU bc8b1b1d13e5e69133f85c645f7e2a06qdU e7734f693e8e68fcc97d98e790d024a1qeU d8703f5c9901bb223fc702fedfbd8c26qfU 0a85bb56583eaf5fc0a7c463e8f99db6qgU 2cd6c8d99645ffaa331ba97e071bca67qhU bd02283aea53c6987e065658626029aeqiU 7ec95934743cee49027e91666f902d22qjU 655eb29e7f589e68eb1016141f2ffe43qkU 8354b3a67075f5d1707f2ddc0f640057qlU ac5b3da3ea53cf7141c907159c436822qmU 70dede2383ed520334e91a4ced6cce0eqnU 09f0a8c5e15ffcd80e16d06f96ff2611qoU 7107d4!
 68e137449079ccca0c579ff9c0qpU b7a6db7b7113f0fada181c6551ed7628qqU 0e0d4bae163cca7306bbd31d566b1e7eqrU 1f3b5cd1da91bfb14be76d6ae6fa3b73qsU 11692a4c660a6580512982d342df569bqtU 2122e500b4fa13bc1c53a3f7c2b9743aquU b0b16c03afc71a223fe787e1dd60479fqvU 3ac38d7e2f9203f1343788fe7a736c4dqwU 699fc672171b2a03f9e3e6d66d43b46eqxU a701f3f77dc321259da9e5945328f3c5qyU 4f47ba062d4253ea801ef1e341976b8bqzU 956bf16b318fa7b0cb9c74bedde44720q{U 9ea7a1a26a3e1d1bb9e7f4a57ff36d2dq|U bb161dc5a7b233a76c3ac3c389cef8d8q}U 5be4663919ae70a2a63143f4cf3e23c1q~U 39b0c941e291970324de2709f164c3beqU 93ddad90561b2e439cfac383be62bdd0q?U 5410df383b37c676526e62554f9ac274q?U 81302455beb60e076adbb9ee5e79d339q?U 571d50db99ee111540c2efa57c396936q?U 86b69ed9e41beedefa3ae8025bf4087dq?U 569f5de580970655042e7b79f08ca930q?U 1813916f93a067876c1770d20b68bcfcq?U 141cee46916334fafee988d52eeb74abq?U 087f4d86feab2e1d99ecb6b5b4c902c5q?U 7083cc35df3247290d30d008513fef47q?U 186444b0a87c414e012aa8d0f46e7fd9q?U d9aea83a7368b5597a7d79!
 f0075a90f4q?U bc480b97ac477ff40a3ad689a1296f4dq?U 97fdbb81a16c!
 152c9c79
dcbf576edea4q?U 273a1126f9bf268a25be640a9d932c00q?U 73fc6a2a32678895efb9141fc7655e7fq?eUbactq?U?g++ -ansi -Wall -ftemplate-depth-100 -O3 -finline-functions -Wno-inline -pthread -DNDEBUG -DBOOST_PROPERTY_TREE_XML_PARSER_TINYXML -DTIXML_USE_STL -fPIC -c -o tinyxmlparser.os tinyxmlparser.cppq?Ubsourcesq?]q?Utinyxml/tinyxmlparser.cppq?aUbsourcesigsq?]q?U 4e570ff625b08425eea1f59c40808ae7q?aubUtinyxmlerror.cppq?(hoq?}q?(U	timestampq?J??9EUcsigq?U cf5c6f205d9c15967401977bcef750c6q?ubU	tinystr.hq?(hoq?}q?(U	timestampq?J??9EUcsigq?h[ubU
+tinyxml.osq?(hoq?}q?(hU a380edf8aeb71f8efd3613406ff9413aq?h]q?(h
+hhhhhhhhhhhhhhhhhhhhhh h!h"h#h$h%h&h'h(h)h*h+h,h-h.h/h0h1h2h3h4h5h6h7h8h9h:h;h<h=h>h?h at hAhBhChDhEhFhGhHehI]q?hK]q?hMU 7f2b203beaf8579d35cec7dd6cd59e81q?hO]q?(hQhRhShThUhVhWhXhYhZh[h\h]h^h_h`hahbhchdhehfhghhhihjhkhlhmhnhohphqhrhshthuhvhwhxhyhzh{h|h}h~hh?h?h?h?h?h?h?h?h?h?h?h?h?h?h?h?eh?U?g++ -ansi -Wall -ftemplate-depth-100 -O3 -finline-functions -Wno-inline -pthread -DNDEBUG -DBOOST_PROPERTY_TREE_XML_PARSER_TINYXML -DTIXML_USE_STL -fPIC -c -o tinyxml.os tinyxml.cppq?h?]q?Utinyxml/tinyxml.cppq?ah?]q?U 8fbf88d5122928d52e45f2299582a984q?aubUtinyxmlparser.cppq?(hoq?}q?(h?J??9Eh?h?ubUtinystr.cppq?(hoq?}q?(h?J??9Eh?U 0a9fdccb93300c5a9227b1910ae526b5q?ubU	tinyxml.hq?(hoq?}q?(h?J	?9Eh?hRubUtinyxml.cppq?(hoq?}q?(h?JK?9Eh?h?ubUtinyxmlerror.osq?(hoq?}q?(hU 6f65267f8663238c23e597a974c35693q?h]q?(hhh
+hhhhhhhhhhhhhhh h!h"h#h$h%h&h'h(h)hhhhhh,h-h.h/h0h1h2h*h+h3h4h5h6h7h8h9h:h;h<h=h>h?h at hAhBhChDhEhFhGhHehI]q?hK]q?hMU 4aa0234202f972ed28dd7dc18a64299eq?hO]q?(hRhWhQhXhYhZh[hUhShThVhahbhchdhehfhghhhihjhkhlhmhnhohph_h`h\h]h^hshthuhvhwhxhyhqhrhzh{h|h}h~hh?h?h?h?h?h?h?h?h?h?h?h?h?h?h?h?eh?U?g++ -ansi -Wall -ftemplate-depth-100 -O3 -finline-functions -Wno-inline -pthread -DNDEBUG -DBOOST_PROPERTY_TREE_XML_PARSER_TINYXML -DTIXML_USE_STL -fPIC -c -o tinyxmlerror.os tinyxmlerror.cppq?h?]q?Utinyxml/tinyxmlerror.cppq?ah?]q?h?aubU
+tinystr.osq?(hoq?}q?(hU 6050f86723f4e371b343884fb65bf913q?h]q?(hhhhh'h(h)hhhhhhhh*h+hhh!h"h#h$h%h&h/h0h1h2h6h7h8ehI]q?hK]q?hMU 7f275df97bbe6da48749f5fd3cf12691q?hO]q?(h[hWhZhUhnhohphVh_h`hShThYh]hqhrh\h^hhhihjhkhlhmhvhwhxhyh}h~heh?U?g++ -ansi -Wall -ftemplate-depth-100 -O3 -finline-functions -Wno-inline -pthread -DNDEBUG -DBOOST_PROPERTY_TREE_XML_PARSER_TINYXML -DTIXML_USE_STL -fPIC -c -o tinystr.os tinystr.cppq?h?]q?Utinyxml/tinystr.cppq?ah?]q?h?aubu.
\ No newline at end of file

Added: trunk/tinyxml/tinystr.cpp
===================================================================
--- trunk/tinyxml/tinystr.cpp	2006-10-26 20:23:12 UTC (rev 357)
+++ trunk/tinyxml/tinystr.cpp	2006-10-27 17:26:03 UTC (rev 358)
@@ -0,0 +1,116 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original file by Yves Berquin.
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+/*
+ * THIS FILE WAS ALTERED BY Tyge L?vset, 7. April 2005.
+ */
+
+
+#ifndef TIXML_USE_STL
+
+#include "tinystr.h"
+
+// Error value for find primitive
+const TiXmlString::size_type TiXmlString::npos = static_cast< TiXmlString::size_type >(-1);
+
+
+// Null rep.
+TiXmlString::Rep TiXmlString::nullrep_ = { 0, 0, '\0' };
+
+
+void TiXmlString::reserve (size_type cap)
+{
+	if (cap > capacity())
+	{
+		TiXmlString tmp;
+		tmp.init(length(), cap);
+		memcpy(tmp.start(), data(), length());
+		swap(tmp);
+	}
+}
+
+
+TiXmlString& TiXmlString::assign(const char* str, size_type len)
+{
+	size_type cap = capacity();
+	if (len > cap || cap > 3*(len + 8))
+	{
+		TiXmlString tmp;
+		tmp.init(len);
+		memcpy(tmp.start(), str, len);
+		swap(tmp);
+	}
+	else
+	{
+		memmove(start(), str, len);
+		set_size(len);
+	}
+	return *this;
+}
+
+
+TiXmlString& TiXmlString::append(const char* str, size_type len)
+{
+	size_type newsize = length() + len;
+	if (newsize > capacity())
+	{
+		reserve (newsize + capacity());
+	}
+	memmove(finish(), str, len);
+	set_size(newsize);
+	return *this;
+}
+
+
+TiXmlString operator + (const TiXmlString & a, const TiXmlString & b)
+{
+	TiXmlString tmp;
+	tmp.reserve(a.length() + b.length());
+	tmp += a;
+	tmp += b;
+	return tmp;
+}
+
+TiXmlString operator + (const TiXmlString & a, const char* b)
+{
+	TiXmlString tmp;
+	TiXmlString::size_type b_len = static_cast<TiXmlString::size_type>( strlen(b) );
+	tmp.reserve(a.length() + b_len);
+	tmp += a;
+	tmp.append(b, b_len);
+	return tmp;
+}
+
+TiXmlString operator + (const char* a, const TiXmlString & b)
+{
+	TiXmlString tmp;
+	TiXmlString::size_type a_len = static_cast<TiXmlString::size_type>( strlen(a) );
+	tmp.reserve(a_len + b.length());
+	tmp.append(a, a_len);
+	tmp += b;
+	return tmp;
+}
+
+
+#endif	// TIXML_USE_STL

Added: trunk/tinyxml/tinystr.h
===================================================================
--- trunk/tinyxml/tinystr.h	2006-10-26 20:23:12 UTC (rev 357)
+++ trunk/tinyxml/tinystr.h	2006-10-27 17:26:03 UTC (rev 358)
@@ -0,0 +1,319 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original file by Yves Berquin.
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+/*
+ * THIS FILE WAS ALTERED BY Tyge Lovset, 7. April 2005.
+ *
+ * - completely rewritten. compact, clean, and fast implementation.
+ * - sizeof(TiXmlString) = pointer size (4 bytes on 32-bit systems)
+ * - fixed reserve() to work as per specification.
+ * - fixed buggy compares operator==(), operator<(), and operator>()
+ * - fixed operator+=() to take a const ref argument, following spec.
+ * - added "copy" constructor with length, and most compare operators.
+ * - added swap(), clear(), size(), capacity(), operator+().
+ */
+
+#ifndef TIXML_USE_STL
+
+#ifndef TIXML_STRING_INCLUDED
+#define TIXML_STRING_INCLUDED
+
+#include <assert.h>
+#include <string.h>
+
+/*	The support for explicit isn't that universal, and it isn't really
+	required - it is used to check that the TiXmlString class isn't incorrectly
+	used. Be nice to old compilers and macro it here:
+*/
+#if defined(_MSC_VER) && (_MSC_VER >= 1200 )
+	// Microsoft visual studio, version 6 and higher.
+	#define TIXML_EXPLICIT explicit
+#elif defined(__GNUC__) && (__GNUC__ >= 3 )
+	// GCC version 3 and higher.s
+	#define TIXML_EXPLICIT explicit
+#else
+	#define TIXML_EXPLICIT
+#endif
+
+
+/*
+   TiXmlString is an emulation of a subset of the std::string template.
+   Its purpose is to allow compiling TinyXML on compilers with no or poor STL support.
+   Only the member functions relevant to the TinyXML project have been implemented.
+   The buffer allocation is made by a simplistic power of 2 like mechanism : if we increase
+   a string and there's no more room, we allocate a buffer twice as big as we need.
+*/
+class TiXmlString
+{
+  public :
+	// The size type used
+  	typedef size_t size_type;
+
+	// Error value for find primitive
+	static const size_type npos; // = -1;
+
+
+	// TiXmlString empty constructor
+	TiXmlString () : rep_(&nullrep_)
+	{
+	}
+
+	// TiXmlString copy constructor
+	TiXmlString ( const TiXmlString & copy) : rep_(0)
+	{
+		init(copy.length());
+		memcpy(start(), copy.data(), length());
+	}
+
+	// TiXmlString constructor, based on a string
+	TIXML_EXPLICIT TiXmlString ( const char * copy) : rep_(0)
+	{
+		init( static_cast<size_type>( strlen(copy) ));
+		memcpy(start(), copy, length());
+	}
+
+	// TiXmlString constructor, based on a string
+	TIXML_EXPLICIT TiXmlString ( const char * str, size_type len) : rep_(0)
+	{
+		init(len);
+		memcpy(start(), str, len);
+	}
+
+	// TiXmlString destructor
+	~TiXmlString ()
+	{
+		quit();
+	}
+
+	// = operator
+	TiXmlString& operator = (const char * copy)
+	{
+		return assign( copy, (size_type)strlen(copy));
+	}
+
+	// = operator
+	TiXmlString& operator = (const TiXmlString & copy)
+	{
+		return assign(copy.start(), copy.length());
+	}
+
+
+	// += operator. Maps to append
+	TiXmlString& operator += (const char * suffix)
+	{
+		return append(suffix, static_cast<size_type>( strlen(suffix) ));
+	}
+
+	// += operator. Maps to append
+	TiXmlString& operator += (char single)
+	{
+		return append(&single, 1);
+	}
+
+	// += operator. Maps to append
+	TiXmlString& operator += (const TiXmlString & suffix)
+	{
+		return append(suffix.data(), suffix.length());
+	}
+
+
+	// Convert a TiXmlString into a null-terminated char *
+	const char * c_str () const { return rep_->str; }
+
+	// Convert a TiXmlString into a char * (need not be null terminated).
+	const char * data () const { return rep_->str; }
+
+	// Return the length of a TiXmlString
+	size_type length () const { return rep_->size; }
+
+	// Alias for length()
+	size_type size () const { return rep_->size; }
+
+	// Checks if a TiXmlString is empty
+	bool empty () const { return rep_->size == 0; }
+
+	// Return capacity of string
+	size_type capacity () const { return rep_->capacity; }
+
+
+	// single char extraction
+	const char& at (size_type index) const
+	{
+		assert( index < length() );
+		return rep_->str[ index ];
+	}
+
+	// [] operator
+	char& operator [] (size_type index) const
+	{
+		assert( index < length() );
+		return rep_->str[ index ];
+	}
+
+	// find a char in a string. Return TiXmlString::npos if not found
+	size_type find (char lookup) const
+	{
+		return find(lookup, 0);
+	}
+
+	// find a char in a string from an offset. Return TiXmlString::npos if not found
+	size_type find (char tofind, size_type offset) const
+	{
+		if (offset >= length()) return npos;
+
+		for (const char* p = c_str() + offset; *p != '\0'; ++p)
+		{
+		   if (*p == tofind) return static_cast< size_type >( p - c_str() );
+		}
+		return npos;
+	}
+
+	void clear ()
+	{
+		//Lee:
+		//The original was just too strange, though correct:
+		//	TiXmlString().swap(*this);
+		//Instead use the quit & re-init:
+		quit();
+		init(0,0);
+	}
+
+	/*	Function to reserve a big amount of data when we know we'll need it. Be aware that this
+		function DOES NOT clear the content of the TiXmlString if any exists.
+	*/
+	void reserve (size_type cap);
+
+	TiXmlString& assign (const char* str, size_type len);
+
+	TiXmlString& append (const char* str, size_type len);
+
+	void swap (TiXmlString& other)
+	{
+		Rep* r = rep_;
+		rep_ = other.rep_;
+		other.rep_ = r;
+	}
+
+  private:
+
+	void init(size_type sz) { init(sz, sz); }
+	void set_size(size_type sz) { rep_->str[ rep_->size = sz ] = '\0'; }
+	char* start() const { return rep_->str; }
+	char* finish() const { return rep_->str + rep_->size; }
+
+	struct Rep
+	{
+		size_type size, capacity;
+		char str[1];
+	};
+
+	void init(size_type sz, size_type cap)
+	{
+		if (cap)
+		{
+			// Lee: the original form:
+			//	rep_ = static_cast<Rep*>(operator new(sizeof(Rep) + cap));
+			// doesn't work in some cases of new being overloaded. Switching
+			// to the normal allocation, although use an 'int' for systems
+			// that are overly picky about structure alignment.
+			const size_type bytesNeeded = sizeof(Rep) + cap;
+			const size_type intsNeeded = ( bytesNeeded + sizeof(int) - 1 ) / sizeof( int ); 
+			rep_ = reinterpret_cast<Rep*>( new int[ intsNeeded ] );
+
+			rep_->str[ rep_->size = sz ] = '\0';
+			rep_->capacity = cap;
+		}
+		else
+		{
+			rep_ = &nullrep_;
+		}
+	}
+
+	void quit()
+	{
+		if (rep_ != &nullrep_)
+		{
+			// The rep_ is really an array of ints. (see the allocator, above).
+			// Cast it back before delete, so the compiler won't incorrectly call destructors.
+			delete [] ( reinterpret_cast<int*>( rep_ ) );
+		}
+	}
+
+	Rep * rep_;
+	static Rep nullrep_;
+
+} ;
+
+
+inline bool operator == (const TiXmlString & a, const TiXmlString & b)
+{
+	return    ( a.length() == b.length() )				// optimization on some platforms
+	       && ( strcmp(a.c_str(), b.c_str()) == 0 );	// actual compare
+}
+inline bool operator < (const TiXmlString & a, const TiXmlString & b)
+{
+	return strcmp(a.c_str(), b.c_str()) < 0;
+}
+
+inline bool operator != (const TiXmlString & a, const TiXmlString & b) { return !(a == b); }
+inline bool operator >  (const TiXmlString & a, const TiXmlString & b) { return b < a; }
+inline bool operator <= (const TiXmlString & a, const TiXmlString & b) { return !(b < a); }
+inline bool operator >= (const TiXmlString & a, const TiXmlString & b) { return !(a < b); }
+
+inline bool operator == (const TiXmlString & a, const char* b) { return strcmp(a.c_str(), b) == 0; }
+inline bool operator == (const char* a, const TiXmlString & b) { return b == a; }
+inline bool operator != (const TiXmlString & a, const char* b) { return !(a == b); }
+inline bool operator != (const char* a, const TiXmlString & b) { return !(b == a); }
+
+TiXmlString operator + (const TiXmlString & a, const TiXmlString & b);
+TiXmlString operator + (const TiXmlString & a, const char* b);
+TiXmlString operator + (const char* a, const TiXmlString & b);
+
+
+/*
+   TiXmlOutStream is an emulation of std::ostream. It is based on TiXmlString.
+   Only the operators that we need for TinyXML have been developped.
+*/
+class TiXmlOutStream : public TiXmlString
+{
+public :
+
+	// TiXmlOutStream << operator.
+	TiXmlOutStream & operator << (const TiXmlString & in)
+	{
+		*this += in;
+		return *this;
+	}
+
+	// TiXmlOutStream << operator.
+	TiXmlOutStream & operator << (const char * in)
+	{
+		*this += in;
+		return *this;
+	}
+
+} ;
+
+#endif	// TIXML_STRING_INCLUDED
+#endif	// TIXML_USE_STL

Added: trunk/tinyxml/tinyxml.cpp
===================================================================
--- trunk/tinyxml/tinyxml.cpp	2006-10-26 20:23:12 UTC (rev 357)
+++ trunk/tinyxml/tinyxml.cpp	2006-10-27 17:26:03 UTC (rev 358)
@@ -0,0 +1,1866 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original code (2.0 and earlier )copyright (c) 2000-2006 Lee Thomason (www.grinninglizard.com)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+#include <ctype.h>
+
+#ifdef TIXML_USE_STL
+#include <sstream>
+#include <iostream>
+#endif
+
+#include "tinyxml.h"
+
+
+bool TiXmlBase::condenseWhiteSpace = true;
+
+void TiXmlBase::PutString( const TIXML_STRING& str, TIXML_STRING* outString )
+{
+	int i=0;
+
+	while( i<(int)str.length() )
+	{
+		unsigned char c = (unsigned char) str[i];
+
+		if (    c == '&' 
+		     && i < ( (int)str.length() - 2 )
+			 && str[i+1] == '#'
+			 && str[i+2] == 'x' )
+		{
+			// Hexadecimal character reference.
+			// Pass through unchanged.
+			// &#xA9;	-- copyright symbol, for example.
+			//
+			// The -1 is a bug fix from Rob Laveaux. It keeps
+			// an overflow from happening if there is no ';'.
+			// There are actually 2 ways to exit this loop -
+			// while fails (error case) and break (semicolon found).
+			// However, there is no mechanism (currently) for
+			// this function to return an error.
+			while ( i<(int)str.length()-1 )
+			{
+				outString->append( str.c_str() + i, 1 );
+				++i;
+				if ( str[i] == ';' )
+					break;
+			}
+		}
+		else if ( c == '&' )
+		{
+			outString->append( entity[0].str, entity[0].strLength );
+			++i;
+		}
+		else if ( c == '<' )
+		{
+			outString->append( entity[1].str, entity[1].strLength );
+			++i;
+		}
+		else if ( c == '>' )
+		{
+			outString->append( entity[2].str, entity[2].strLength );
+			++i;
+		}
+		else if ( c == '\"' )
+		{
+			outString->append( entity[3].str, entity[3].strLength );
+			++i;
+		}
+		else if ( c == '\'' )
+		{
+			outString->append( entity[4].str, entity[4].strLength );
+			++i;
+		}
+		else if ( c < 32 )
+		{
+			// Easy pass at non-alpha/numeric/symbol
+			// Below 32 is symbolic.
+			char buf[ 32 ];
+			
+			#if defined(TIXML_SNPRINTF)		
+				TIXML_SNPRINTF( buf, sizeof(buf), "&#x%02X;", (unsigned) ( c & 0xff ) );
+			#else
+				sprintf( buf, "&#x%02X;", (unsigned) ( c & 0xff ) );
+			#endif		
+
+			//*ME:	warning C4267: convert 'size_t' to 'int'
+			//*ME:	Int-Cast to make compiler happy ...
+			outString->append( buf, (int)strlen( buf ) );
+			++i;
+		}
+		else
+		{
+			//char realc = (char) c;
+			//outString->append( &realc, 1 );
+			*outString += (char) c;	// somewhat more efficient function call.
+			++i;
+		}
+	}
+}
+
+
+TiXmlNode::TiXmlNode( NodeType _type ) : TiXmlBase()
+{
+	parent = 0;
+	type = _type;
+	firstChild = 0;
+	lastChild = 0;
+	prev = 0;
+	next = 0;
+}
+
+
+TiXmlNode::~TiXmlNode()
+{
+	TiXmlNode* node = firstChild;
+	TiXmlNode* temp = 0;
+
+	while ( node )
+	{
+		temp = node;
+		node = node->next;
+		delete temp;
+	}	
+}
+
+
+void TiXmlNode::CopyTo( TiXmlNode* target ) const
+{
+	target->SetValue (value.c_str() );
+	target->userData = userData; 
+}
+
+
+void TiXmlNode::Clear()
+{
+	TiXmlNode* node = firstChild;
+	TiXmlNode* temp = 0;
+
+	while ( node )
+	{
+		temp = node;
+		node = node->next;
+		delete temp;
+	}	
+
+	firstChild = 0;
+	lastChild = 0;
+}
+
+
+TiXmlNode* TiXmlNode::LinkEndChild( TiXmlNode* node )
+{
+	assert( node->parent == 0 || node->parent == this );
+	assert( node->GetDocument() == 0 || node->GetDocument() == this->GetDocument() );
+
+	if ( node->Type() == TiXmlNode::DOCUMENT )
+	{
+		delete node;
+		if ( GetDocument() ) GetDocument()->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+
+	node->parent = this;
+
+	node->prev = lastChild;
+	node->next = 0;
+
+	if ( lastChild )
+		lastChild->next = node;
+	else
+		firstChild = node;			// it was an empty list.
+
+	lastChild = node;
+	return node;
+}
+
+
+TiXmlNode* TiXmlNode::InsertEndChild( const TiXmlNode& addThis )
+{
+	if ( addThis.Type() == TiXmlNode::DOCUMENT )
+	{
+		if ( GetDocument() ) GetDocument()->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+	TiXmlNode* node = addThis.Clone();
+	if ( !node )
+		return 0;
+
+	return LinkEndChild( node );
+}
+
+
+TiXmlNode* TiXmlNode::InsertBeforeChild( TiXmlNode* beforeThis, const TiXmlNode& addThis )
+{	
+	if ( !beforeThis || beforeThis->parent != this ) {
+		return 0;
+	}
+	if ( addThis.Type() == TiXmlNode::DOCUMENT )
+	{
+		if ( GetDocument() ) GetDocument()->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+
+	TiXmlNode* node = addThis.Clone();
+	if ( !node )
+		return 0;
+	node->parent = this;
+
+	node->next = beforeThis;
+	node->prev = beforeThis->prev;
+	if ( beforeThis->prev )
+	{
+		beforeThis->prev->next = node;
+	}
+	else
+	{
+		assert( firstChild == beforeThis );
+		firstChild = node;
+	}
+	beforeThis->prev = node;
+	return node;
+}
+
+
+TiXmlNode* TiXmlNode::InsertAfterChild( TiXmlNode* afterThis, const TiXmlNode& addThis )
+{
+	if ( !afterThis || afterThis->parent != this ) {
+		return 0;
+	}
+	if ( addThis.Type() == TiXmlNode::DOCUMENT )
+	{
+		if ( GetDocument() ) GetDocument()->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+
+	TiXmlNode* node = addThis.Clone();
+	if ( !node )
+		return 0;
+	node->parent = this;
+
+	node->prev = afterThis;
+	node->next = afterThis->next;
+	if ( afterThis->next )
+	{
+		afterThis->next->prev = node;
+	}
+	else
+	{
+		assert( lastChild == afterThis );
+		lastChild = node;
+	}
+	afterThis->next = node;
+	return node;
+}
+
+
+TiXmlNode* TiXmlNode::ReplaceChild( TiXmlNode* replaceThis, const TiXmlNode& withThis )
+{
+	if ( replaceThis->parent != this )
+		return 0;
+
+	TiXmlNode* node = withThis.Clone();
+	if ( !node )
+		return 0;
+
+	node->next = replaceThis->next;
+	node->prev = replaceThis->prev;
+
+	if ( replaceThis->next )
+		replaceThis->next->prev = node;
+	else
+		lastChild = node;
+
+	if ( replaceThis->prev )
+		replaceThis->prev->next = node;
+	else
+		firstChild = node;
+
+	delete replaceThis;
+	node->parent = this;
+	return node;
+}
+
+
+bool TiXmlNode::RemoveChild( TiXmlNode* removeThis )
+{
+	if ( removeThis->parent != this )
+	{	
+		assert( 0 );
+		return false;
+	}
+
+	if ( removeThis->next )
+		removeThis->next->prev = removeThis->prev;
+	else
+		lastChild = removeThis->prev;
+
+	if ( removeThis->prev )
+		removeThis->prev->next = removeThis->next;
+	else
+		firstChild = removeThis->next;
+
+	delete removeThis;
+	return true;
+}
+
+const TiXmlNode* TiXmlNode::FirstChild( const char * _value ) const
+{
+	const TiXmlNode* node;
+	for ( node = firstChild; node; node = node->next )
+	{
+		if ( strcmp( node->Value(), _value ) == 0 )
+			return node;
+	}
+	return 0;
+}
+
+
+const TiXmlNode* TiXmlNode::LastChild( const char * _value ) const
+{
+	const TiXmlNode* node;
+	for ( node = lastChild; node; node = node->prev )
+	{
+		if ( strcmp( node->Value(), _value ) == 0 )
+			return node;
+	}
+	return 0;
+}
+
+
+const TiXmlNode* TiXmlNode::IterateChildren( const TiXmlNode* previous ) const
+{
+	if ( !previous )
+	{
+		return FirstChild();
+	}
+	else
+	{
+		assert( previous->parent == this );
+		return previous->NextSibling();
+	}
+}
+
+
+const TiXmlNode* TiXmlNode::IterateChildren( const char * val, const TiXmlNode* previous ) const
+{
+	if ( !previous )
+	{
+		return FirstChild( val );
+	}
+	else
+	{
+		assert( previous->parent == this );
+		return previous->NextSibling( val );
+	}
+}
+
+
+const TiXmlNode* TiXmlNode::NextSibling( const char * _value ) const 
+{
+	const TiXmlNode* node;
+	for ( node = next; node; node = node->next )
+	{
+		if ( strcmp( node->Value(), _value ) == 0 )
+			return node;
+	}
+	return 0;
+}
+
+
+const TiXmlNode* TiXmlNode::PreviousSibling( const char * _value ) const
+{
+	const TiXmlNode* node;
+	for ( node = prev; node; node = node->prev )
+	{
+		if ( strcmp( node->Value(), _value ) == 0 )
+			return node;
+	}
+	return 0;
+}
+
+
+void TiXmlElement::RemoveAttribute( const char * name )
+{
+    #ifdef TIXML_USE_STL
+	TIXML_STRING str( name );
+	TiXmlAttribute* node = attributeSet.Find( str );
+	#else
+	TiXmlAttribute* node = attributeSet.Find( name );
+	#endif
+	if ( node )
+	{
+		attributeSet.Remove( node );
+		delete node;
+	}
+}
+
+const TiXmlElement* TiXmlNode::FirstChildElement() const
+{
+	const TiXmlNode* node;
+
+	for (	node = FirstChild();
+			node;
+			node = node->NextSibling() )
+	{
+		if ( node->ToElement() )
+			return node->ToElement();
+	}
+	return 0;
+}
+
+
+const TiXmlElement* TiXmlNode::FirstChildElement( const char * _value ) const
+{
+	const TiXmlNode* node;
+
+	for (	node = FirstChild( _value );
+			node;
+			node = node->NextSibling( _value ) )
+	{
+		if ( node->ToElement() )
+			return node->ToElement();
+	}
+	return 0;
+}
+
+
+const TiXmlElement* TiXmlNode::NextSiblingElement() const
+{
+	const TiXmlNode* node;
+
+	for (	node = NextSibling();
+			node;
+			node = node->NextSibling() )
+	{
+		if ( node->ToElement() )
+			return node->ToElement();
+	}
+	return 0;
+}
+
+
+const TiXmlElement* TiXmlNode::NextSiblingElement( const char * _value ) const
+{
+	const TiXmlNode* node;
+
+	for (	node = NextSibling( _value );
+			node;
+			node = node->NextSibling( _value ) )
+	{
+		if ( node->ToElement() )
+			return node->ToElement();
+	}
+	return 0;
+}
+
+
+const TiXmlDocument* TiXmlNode::GetDocument() const
+{
+	const TiXmlNode* node;
+
+	for( node = this; node; node = node->parent )
+	{
+		if ( node->ToDocument() )
+			return node->ToDocument();
+	}
+	return 0;
+}
+
+
+TiXmlElement::TiXmlElement (const char * _value)
+	: TiXmlNode( TiXmlNode::ELEMENT )
+{
+	firstChild = lastChild = 0;
+	value = _value;
+}
+
+
+#ifdef TIXML_USE_STL
+TiXmlElement::TiXmlElement( const std::string& _value ) 
+	: TiXmlNode( TiXmlNode::ELEMENT )
+{
+	firstChild = lastChild = 0;
+	value = _value;
+}
+#endif
+
+
+TiXmlElement::TiXmlElement( const TiXmlElement& copy)
+	: TiXmlNode( TiXmlNode::ELEMENT )
+{
+	firstChild = lastChild = 0;
+	copy.CopyTo( this );	
+}
+
+
+void TiXmlElement::operator=( const TiXmlElement& base )
+{
+	ClearThis();
+	base.CopyTo( this );
+}
+
+
+TiXmlElement::~TiXmlElement()
+{
+	ClearThis();
+}
+
+
+void TiXmlElement::ClearThis()
+{
+	Clear();
+	while( attributeSet.First() )
+	{
+		TiXmlAttribute* node = attributeSet.First();
+		attributeSet.Remove( node );
+		delete node;
+	}
+}
+
+
+const char* TiXmlElement::Attribute( const char* name ) const
+{
+	const TiXmlAttribute* node = attributeSet.Find( name );
+	if ( node )
+		return node->Value();
+	return 0;
+}
+
+
+#ifdef TIXML_USE_STL
+const std::string* TiXmlElement::Attribute( const std::string& name ) const
+{
+	const TiXmlAttribute* node = attributeSet.Find( name );
+	if ( node )
+		return &node->ValueStr();
+	return 0;
+}
+#endif
+
+
+const char* TiXmlElement::Attribute( const char* name, int* i ) const
+{
+	const char* s = Attribute( name );
+	if ( i )
+	{
+		if ( s ) {
+			*i = atoi( s );
+		}
+		else {
+			*i = 0;
+		}
+	}
+	return s;
+}
+
+
+#ifdef TIXML_USE_STL
+const std::string* TiXmlElement::Attribute( const std::string& name, int* i ) const
+{
+	const std::string* s = Attribute( name );
+	if ( i )
+	{
+		if ( s ) {
+			*i = atoi( s->c_str() );
+		}
+		else {
+			*i = 0;
+		}
+	}
+	return s;
+}
+#endif
+
+
+const char* TiXmlElement::Attribute( const char* name, double* d ) const
+{
+	const char* s = Attribute( name );
+	if ( d )
+	{
+		if ( s ) {
+			*d = atof( s );
+		}
+		else {
+			*d = 0;
+		}
+	}
+	return s;
+}
+
+
+#ifdef TIXML_USE_STL
+const std::string* TiXmlElement::Attribute( const std::string& name, double* d ) const
+{
+	const std::string* s = Attribute( name );
+	if ( d )
+	{
+		if ( s ) {
+			*d = atof( s->c_str() );
+		}
+		else {
+			*d = 0;
+		}
+	}
+	return s;
+}
+#endif
+
+
+int TiXmlElement::QueryIntAttribute( const char* name, int* ival ) const
+{
+	const TiXmlAttribute* node = attributeSet.Find( name );
+	if ( !node )
+		return TIXML_NO_ATTRIBUTE;
+	return node->QueryIntValue( ival );
+}
+
+
+#ifdef TIXML_USE_STL
+int TiXmlElement::QueryIntAttribute( const std::string& name, int* ival ) const
+{
+	const TiXmlAttribute* node = attributeSet.Find( name );
+	if ( !node )
+		return TIXML_NO_ATTRIBUTE;
+	return node->QueryIntValue( ival );
+}
+#endif
+
+
+int TiXmlElement::QueryDoubleAttribute( const char* name, double* dval ) const
+{
+	const TiXmlAttribute* node = attributeSet.Find( name );
+	if ( !node )
+		return TIXML_NO_ATTRIBUTE;
+	return node->QueryDoubleValue( dval );
+}
+
+
+#ifdef TIXML_USE_STL
+int TiXmlElement::QueryDoubleAttribute( const std::string& name, double* dval ) const
+{
+	const TiXmlAttribute* node = attributeSet.Find( name );
+	if ( !node )
+		return TIXML_NO_ATTRIBUTE;
+	return node->QueryDoubleValue( dval );
+}
+#endif
+
+
+void TiXmlElement::SetAttribute( const char * name, int val )
+{	
+	char buf[64];
+	#if defined(TIXML_SNPRINTF)		
+		TIXML_SNPRINTF( buf, sizeof(buf), "%d", val );
+	#else
+		sprintf( buf, "%d", val );
+	#endif
+	SetAttribute( name, buf );
+}
+
+
+#ifdef TIXML_USE_STL
+void TiXmlElement::SetAttribute( const std::string& name, int val )
+{	
+   std::ostringstream oss;
+   oss << val;
+   SetAttribute( name, oss.str() );
+}
+#endif
+
+
+void TiXmlElement::SetDoubleAttribute( const char * name, double val )
+{	
+	char buf[256];
+	#if defined(TIXML_SNPRINTF)		
+		TIXML_SNPRINTF( buf, sizeof(buf), "%f", val );
+	#else
+		sprintf( buf, "%f", val );
+	#endif
+	SetAttribute( name, buf );
+}
+
+
+void TiXmlElement::SetAttribute( const char * cname, const char * cvalue )
+{
+    #ifdef TIXML_USE_STL
+	TIXML_STRING _name( cname );
+	TIXML_STRING _value( cvalue );
+	#else
+	const char* _name = cname;
+	const char* _value = cvalue;
+	#endif
+
+	TiXmlAttribute* node = attributeSet.Find( _name );
+	if ( node )
+	{
+		node->SetValue( _value );
+		return;
+	}
+
+	TiXmlAttribute* attrib = new TiXmlAttribute( cname, cvalue );
+	if ( attrib )
+	{
+		attributeSet.Add( attrib );
+	}
+	else
+	{
+		TiXmlDocument* document = GetDocument();
+		if ( document ) document->SetError( TIXML_ERROR_OUT_OF_MEMORY, 0, 0, TIXML_ENCODING_UNKNOWN );
+	}
+}
+
+
+#ifdef TIXML_USE_STL
+void TiXmlElement::SetAttribute( const std::string& name, const std::string& _value )
+{
+	TiXmlAttribute* node = attributeSet.Find( name );
+	if ( node )
+	{
+		node->SetValue( _value );
+		return;
+	}
+
+	TiXmlAttribute* attrib = new TiXmlAttribute( name, _value );
+	if ( attrib )
+	{
+		attributeSet.Add( attrib );
+	}
+	else
+	{
+		TiXmlDocument* document = GetDocument();
+		if ( document ) document->SetError( TIXML_ERROR_OUT_OF_MEMORY, 0, 0, TIXML_ENCODING_UNKNOWN );
+	}
+}
+#endif
+
+
+void TiXmlElement::Print( FILE* cfile, int depth ) const
+{
+	int i;
+	assert( cfile );
+	for ( i=0; i<depth; i++ ) {
+		fprintf( cfile, "    " );
+	}
+
+	fprintf( cfile, "<%s", value.c_str() );
+
+	const TiXmlAttribute* attrib;
+	for ( attrib = attributeSet.First(); attrib; attrib = attrib->Next() )
+	{
+		fprintf( cfile, " " );
+		attrib->Print( cfile, depth );
+	}
+
+	// There are 3 different formatting approaches:
+	// 1) An element without children is printed as a <foo /> node
+	// 2) An element with only a text child is printed as <foo> text </foo>
+	// 3) An element with children is printed on multiple lines.
+	TiXmlNode* node;
+	if ( !firstChild )
+	{
+		fprintf( cfile, " />" );
+	}
+	else if ( firstChild == lastChild && firstChild->ToText() )
+	{
+		fprintf( cfile, ">" );
+		firstChild->Print( cfile, depth + 1 );
+		fprintf( cfile, "</%s>", value.c_str() );
+	}
+	else
+	{
+		fprintf( cfile, ">" );
+
+		for ( node = firstChild; node; node=node->NextSibling() )
+		{
+			if ( !node->ToText() )
+			{
+				fprintf( cfile, "\n" );
+			}
+			node->Print( cfile, depth+1 );
+		}
+		fprintf( cfile, "\n" );
+		for( i=0; i<depth; ++i ) {
+			fprintf( cfile, "    " );
+		}
+		fprintf( cfile, "</%s>", value.c_str() );
+	}
+}
+
+
+void TiXmlElement::CopyTo( TiXmlElement* target ) const
+{
+	// superclass:
+	TiXmlNode::CopyTo( target );
+
+	// Element class: 
+	// Clone the attributes, then clone the children.
+	const TiXmlAttribute* attribute = 0;
+	for(	attribute = attributeSet.First();
+	attribute;
+	attribute = attribute->Next() )
+	{
+		target->SetAttribute( attribute->Name(), attribute->Value() );
+	}
+
+	TiXmlNode* node = 0;
+	for ( node = firstChild; node; node = node->NextSibling() )
+	{
+		target->LinkEndChild( node->Clone() );
+	}
+}
+
+bool TiXmlElement::Accept( TiXmlVisitor* visitor ) const
+{
+	if ( visitor->VisitEnter( *this, attributeSet.First() ) ) 
+	{
+		for ( const TiXmlNode* node=FirstChild(); node; node=node->NextSibling() )
+		{
+			if ( !node->Accept( visitor ) )
+				break;
+		}
+	}
+	return visitor->VisitExit( *this );
+}
+
+
+TiXmlNode* TiXmlElement::Clone() const
+{
+	TiXmlElement* clone = new TiXmlElement( Value() );
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+const char* TiXmlElement::GetText() const
+{
+	const TiXmlNode* child = this->FirstChild();
+	if ( child ) {
+		const TiXmlText* childText = child->ToText();
+		if ( childText ) {
+			return childText->Value();
+		}
+	}
+	return 0;
+}
+
+
+TiXmlDocument::TiXmlDocument() : TiXmlNode( TiXmlNode::DOCUMENT )
+{
+	tabsize = 4;
+	useMicrosoftBOM = false;
+	ClearError();
+}
+
+TiXmlDocument::TiXmlDocument( const char * documentName ) : TiXmlNode( TiXmlNode::DOCUMENT )
+{
+	tabsize = 4;
+	useMicrosoftBOM = false;
+	value = documentName;
+	ClearError();
+}
+
+
+#ifdef TIXML_USE_STL
+TiXmlDocument::TiXmlDocument( const std::string& documentName ) : TiXmlNode( TiXmlNode::DOCUMENT )
+{
+	tabsize = 4;
+	useMicrosoftBOM = false;
+    value = documentName;
+	ClearError();
+}
+#endif
+
+
+TiXmlDocument::TiXmlDocument( const TiXmlDocument& copy ) : TiXmlNode( TiXmlNode::DOCUMENT )
+{
+	copy.CopyTo( this );
+}
+
+
+void TiXmlDocument::operator=( const TiXmlDocument& copy )
+{
+	Clear();
+	copy.CopyTo( this );
+}
+
+
+bool TiXmlDocument::LoadFile( TiXmlEncoding encoding )
+{
+	// See STL_STRING_BUG below.
+	//StringToBuffer buf( value );
+
+	return LoadFile( Value(), encoding );
+}
+
+
+bool TiXmlDocument::SaveFile() const
+{
+	// See STL_STRING_BUG below.
+//	StringToBuffer buf( value );
+//
+//	if ( buf.buffer && SaveFile( buf.buffer ) )
+//		return true;
+//
+//	return false;
+	return SaveFile( Value() );
+}
+
+bool TiXmlDocument::LoadFile( const char* _filename, TiXmlEncoding encoding )
+{
+	// There was a really terrifying little bug here. The code:
+	//		value = filename
+	// in the STL case, cause the assignment method of the std::string to
+	// be called. What is strange, is that the std::string had the same
+	// address as it's c_str() method, and so bad things happen. Looks
+	// like a bug in the Microsoft STL implementation.
+	// Add an extra string to avoid the crash.
+	TIXML_STRING filename( _filename );
+	value = filename;
+
+	// reading in binary mode so that tinyxml can normalize the EOL
+	FILE* file = fopen( value.c_str (), "rb" );	
+
+	if ( file )
+	{
+		bool result = LoadFile( file, encoding );
+		fclose( file );
+		return result;
+	}
+	else
+	{
+		SetError( TIXML_ERROR_OPENING_FILE, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return false;
+	}
+}
+
+bool TiXmlDocument::LoadFile( FILE* file, TiXmlEncoding encoding )
+{
+	if ( !file ) 
+	{
+		SetError( TIXML_ERROR_OPENING_FILE, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return false;
+	}
+
+	// Delete the existing data:
+	Clear();
+	location.Clear();
+
+	// Get the file size, so we can pre-allocate the string. HUGE speed impact.
+	long length = 0;
+	fseek( file, 0, SEEK_END );
+	length = ftell( file );
+	fseek( file, 0, SEEK_SET );
+
+	// Strange case, but good to handle up front.
+	if ( length == 0 )
+	{
+		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return false;
+	}
+
+	// If we have a file, assume it is all one big XML file, and read it in.
+	// The document parser may decide the document ends sooner than the entire file, however.
+	TIXML_STRING data;
+	data.reserve( length );
+
+	// Subtle bug here. TinyXml did use fgets. But from the XML spec:
+	// 2.11 End-of-Line Handling
+	// <snip>
+	// <quote>
+	// ...the XML processor MUST behave as if it normalized all line breaks in external 
+	// parsed entities (including the document entity) on input, before parsing, by translating 
+	// both the two-character sequence #xD #xA and any #xD that is not followed by #xA to 
+	// a single #xA character.
+	// </quote>
+	//
+	// It is not clear fgets does that, and certainly isn't clear it works cross platform. 
+	// Generally, you expect fgets to translate from the convention of the OS to the c/unix
+	// convention, and not work generally.
+
+	/*
+	while( fgets( buf, sizeof(buf), file ) )
+	{
+		data += buf;
+	}
+	*/
+
+	char* buf = new char[ length+1 ];
+	buf[0] = 0;
+
+	if ( fread( buf, length, 1, file ) != 1 ) {
+		delete [] buf;
+		SetError( TIXML_ERROR_OPENING_FILE, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return false;
+	}
+
+	const char* lastPos = buf;
+	const char* p = buf;
+
+	buf[length] = 0;
+	while( *p ) {
+		assert( p < (buf+length) );
+		if ( *p == 0xa ) {
+			// Newline character. No special rules for this. Append all the characters
+			// since the last string, and include the newline.
+			data.append( lastPos, (p-lastPos+1) );	// append, include the newline
+			++p;									// move past the newline
+			lastPos = p;							// and point to the new buffer (may be 0)
+			assert( p <= (buf+length) );
+		}
+		else if ( *p == 0xd ) {
+			// Carriage return. Append what we have so far, then
+			// handle moving forward in the buffer.
+			if ( (p-lastPos) > 0 ) {
+				data.append( lastPos, p-lastPos );	// do not add the CR
+			}
+			data += (char)0xa;						// a proper newline
+
+			if ( *(p+1) == 0xa ) {
+				// Carriage return - new line sequence
+				p += 2;
+				lastPos = p;
+				assert( p <= (buf+length) );
+			}
+			else {
+				// it was followed by something else...that is presumably characters again.
+				++p;
+				lastPos = p;
+				assert( p <= (buf+length) );
+			}
+		}
+		else {
+			++p;
+		}
+	}
+	// Handle any left over characters.
+	if ( p-lastPos ) {
+		data.append( lastPos, p-lastPos );
+	}		
+	delete [] buf;
+	buf = 0;
+
+	Parse( data.c_str(), 0, encoding );
+
+	if (  Error() )
+        return false;
+    else
+		return true;
+}
+
+
+bool TiXmlDocument::SaveFile( const char * filename ) const
+{
+	// The old c stuff lives on...
+	FILE* fp = fopen( filename, "w" );
+	if ( fp )
+	{
+		bool result = SaveFile( fp );
+		fclose( fp );
+		return result;
+	}
+	return false;
+}
+
+
+bool TiXmlDocument::SaveFile( FILE* fp ) const
+{
+	if ( useMicrosoftBOM ) 
+	{
+		const unsigned char TIXML_UTF_LEAD_0 = 0xefU;
+		const unsigned char TIXML_UTF_LEAD_1 = 0xbbU;
+		const unsigned char TIXML_UTF_LEAD_2 = 0xbfU;
+
+		fputc( TIXML_UTF_LEAD_0, fp );
+		fputc( TIXML_UTF_LEAD_1, fp );
+		fputc( TIXML_UTF_LEAD_2, fp );
+	}
+	Print( fp, 0 );
+	return (ferror(fp) == 0);
+}
+
+
+void TiXmlDocument::CopyTo( TiXmlDocument* target ) const
+{
+	TiXmlNode::CopyTo( target );
+
+	target->error = error;
+	target->errorDesc = errorDesc.c_str ();
+
+	TiXmlNode* node = 0;
+	for ( node = firstChild; node; node = node->NextSibling() )
+	{
+		target->LinkEndChild( node->Clone() );
+	}	
+}
+
+
+TiXmlNode* TiXmlDocument::Clone() const
+{
+	TiXmlDocument* clone = new TiXmlDocument();
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+void TiXmlDocument::Print( FILE* cfile, int depth ) const
+{
+	assert( cfile );
+	for ( const TiXmlNode* node=FirstChild(); node; node=node->NextSibling() )
+	{
+		node->Print( cfile, depth );
+		fprintf( cfile, "\n" );
+	}
+}
+
+
+bool TiXmlDocument::Accept( TiXmlVisitor* visitor ) const
+{
+	if ( visitor->VisitEnter( *this ) )
+	{
+		for ( const TiXmlNode* node=FirstChild(); node; node=node->NextSibling() )
+		{
+			if ( !node->Accept( visitor ) )
+				break;
+		}
+	}
+	return visitor->VisitExit( *this );
+}
+
+
+const TiXmlAttribute* TiXmlAttribute::Next() const
+{
+	// We are using knowledge of the sentinel. The sentinel
+	// have a value or name.
+	if ( next->value.empty() && next->name.empty() )
+		return 0;
+	return next;
+}
+
+/*
+TiXmlAttribute* TiXmlAttribute::Next()
+{
+	// We are using knowledge of the sentinel. The sentinel
+	// have a value or name.
+	if ( next->value.empty() && next->name.empty() )
+		return 0;
+	return next;
+}
+*/
+
+const TiXmlAttribute* TiXmlAttribute::Previous() const
+{
+	// We are using knowledge of the sentinel. The sentinel
+	// have a value or name.
+	if ( prev->value.empty() && prev->name.empty() )
+		return 0;
+	return prev;
+}
+
+/*
+TiXmlAttribute* TiXmlAttribute::Previous()
+{
+	// We are using knowledge of the sentinel. The sentinel
+	// have a value or name.
+	if ( prev->value.empty() && prev->name.empty() )
+		return 0;
+	return prev;
+}
+*/
+
+void TiXmlAttribute::Print( FILE* cfile, int /*depth*/, TIXML_STRING* str ) const
+{
+	TIXML_STRING n, v;
+
+	PutString( name, &n );
+	PutString( value, &v );
+
+	if (value.find ('\"') == TIXML_STRING::npos) {
+		if ( cfile ) {
+		fprintf (cfile, "%s=\"%s\"", n.c_str(), v.c_str() );
+		}
+		if ( str ) {
+			(*str) += n; (*str) += "=\""; (*str) += v; (*str) += "\"";
+		}
+	}
+	else {
+		if ( cfile ) {
+		fprintf (cfile, "%s='%s'", n.c_str(), v.c_str() );
+		}
+		if ( str ) {
+			(*str) += n; (*str) += "='"; (*str) += v; (*str) += "'";
+		}
+	}
+}
+
+
+int TiXmlAttribute::QueryIntValue( int* ival ) const
+{
+	if ( sscanf( value.c_str(), "%d", ival ) == 1 )
+		return TIXML_SUCCESS;
+	return TIXML_WRONG_TYPE;
+}
+
+int TiXmlAttribute::QueryDoubleValue( double* dval ) const
+{
+	if ( sscanf( value.c_str(), "%lf", dval ) == 1 )
+		return TIXML_SUCCESS;
+	return TIXML_WRONG_TYPE;
+}
+
+void TiXmlAttribute::SetIntValue( int _value )
+{
+	char buf [64];
+	#if defined(TIXML_SNPRINTF)		
+		TIXML_SNPRINTF(buf, sizeof(buf), "%d", _value);
+	#else
+		sprintf (buf, "%d", _value);
+	#endif
+	SetValue (buf);
+}
+
+void TiXmlAttribute::SetDoubleValue( double _value )
+{
+	char buf [256];
+	#if defined(TIXML_SNPRINTF)		
+		TIXML_SNPRINTF( buf, sizeof(buf), "%lf", _value);
+	#else
+		sprintf (buf, "%lf", _value);
+	#endif
+	SetValue (buf);
+}
+
+int TiXmlAttribute::IntValue() const
+{
+	return atoi (value.c_str ());
+}
+
+double  TiXmlAttribute::DoubleValue() const
+{
+	return atof (value.c_str ());
+}
+
+
+TiXmlComment::TiXmlComment( const TiXmlComment& copy ) : TiXmlNode( TiXmlNode::COMMENT )
+{
+	copy.CopyTo( this );
+}
+
+
+void TiXmlComment::operator=( const TiXmlComment& base )
+{
+	Clear();
+	base.CopyTo( this );
+}
+
+
+void TiXmlComment::Print( FILE* cfile, int depth ) const
+{
+	assert( cfile );
+	for ( int i=0; i<depth; i++ )
+	{
+		fprintf( cfile,  "    " );
+	}
+	fprintf( cfile, "<!--%s-->", value.c_str() );
+}
+
+
+void TiXmlComment::CopyTo( TiXmlComment* target ) const
+{
+	TiXmlNode::CopyTo( target );
+}
+
+
+bool TiXmlComment::Accept( TiXmlVisitor* visitor ) const
+{
+	return visitor->Visit( *this );
+}
+
+
+TiXmlNode* TiXmlComment::Clone() const
+{
+	TiXmlComment* clone = new TiXmlComment();
+
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+void TiXmlText::Print( FILE* cfile, int depth ) const
+{
+	assert( cfile );
+	if ( cdata )
+	{
+		int i;
+		fprintf( cfile, "\n" );
+		for ( i=0; i<depth; i++ ) {
+			fprintf( cfile, "    " );
+		}
+		fprintf( cfile, "<![CDATA[%s]]>\n", value.c_str() );	// unformatted output
+	}
+	else
+	{
+		TIXML_STRING buffer;
+		PutString( value, &buffer );
+		fprintf( cfile, "%s", buffer.c_str() );
+	}
+}
+
+
+void TiXmlText::CopyTo( TiXmlText* target ) const
+{
+	TiXmlNode::CopyTo( target );
+	target->cdata = cdata;
+}
+
+
+bool TiXmlText::Accept( TiXmlVisitor* visitor ) const
+{
+	return visitor->Visit( *this );
+}
+
+
+TiXmlNode* TiXmlText::Clone() const
+{	
+	TiXmlText* clone = 0;
+	clone = new TiXmlText( "" );
+
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+TiXmlDeclaration::TiXmlDeclaration( const char * _version,
+									const char * _encoding,
+									const char * _standalone )
+	: TiXmlNode( TiXmlNode::DECLARATION )
+{
+	version = _version;
+	encoding = _encoding;
+	standalone = _standalone;
+}
+
+
+#ifdef TIXML_USE_STL
+TiXmlDeclaration::TiXmlDeclaration(	const std::string& _version,
+									const std::string& _encoding,
+									const std::string& _standalone )
+	: TiXmlNode( TiXmlNode::DECLARATION )
+{
+	version = _version;
+	encoding = _encoding;
+	standalone = _standalone;
+}
+#endif
+
+
+TiXmlDeclaration::TiXmlDeclaration( const TiXmlDeclaration& copy )
+	: TiXmlNode( TiXmlNode::DECLARATION )
+{
+	copy.CopyTo( this );	
+}
+
+
+void TiXmlDeclaration::operator=( const TiXmlDeclaration& copy )
+{
+	Clear();
+	copy.CopyTo( this );
+}
+
+
+void TiXmlDeclaration::Print( FILE* cfile, int /*depth*/, TIXML_STRING* str ) const
+{
+	if ( cfile ) fprintf( cfile, "<?xml " );
+	if ( str )	 (*str) += "<?xml ";
+
+	if ( !version.empty() ) {
+		if ( cfile ) fprintf (cfile, "version=\"%s\" ", version.c_str ());
+		if ( str ) { (*str) += "version=\""; (*str) += version; (*str) += "\" "; }
+	}
+	if ( !encoding.empty() ) {
+		if ( cfile ) fprintf (cfile, "encoding=\"%s\" ", encoding.c_str ());
+		if ( str ) { (*str) += "encoding=\""; (*str) += encoding; (*str) += "\" "; }
+	}
+	if ( !standalone.empty() ) {
+		if ( cfile ) fprintf (cfile, "standalone=\"%s\" ", standalone.c_str ());
+		if ( str ) { (*str) += "standalone=\""; (*str) += standalone; (*str) += "\" "; }
+	}
+	if ( cfile ) fprintf( cfile, "?>" );
+	if ( str )	 (*str) += "?>";
+}
+
+
+void TiXmlDeclaration::CopyTo( TiXmlDeclaration* target ) const
+{
+	TiXmlNode::CopyTo( target );
+
+	target->version = version;
+	target->encoding = encoding;
+	target->standalone = standalone;
+}
+
+
+bool TiXmlDeclaration::Accept( TiXmlVisitor* visitor ) const
+{
+	return visitor->Visit( *this );
+}
+
+
+TiXmlNode* TiXmlDeclaration::Clone() const
+{	
+	TiXmlDeclaration* clone = new TiXmlDeclaration();
+
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+void TiXmlUnknown::Print( FILE* cfile, int depth ) const
+{
+	for ( int i=0; i<depth; i++ )
+		fprintf( cfile, "    " );
+	fprintf( cfile, "<%s>", value.c_str() );
+}
+
+
+void TiXmlUnknown::CopyTo( TiXmlUnknown* target ) const
+{
+	TiXmlNode::CopyTo( target );
+}
+
+
+bool TiXmlUnknown::Accept( TiXmlVisitor* visitor ) const
+{
+	return visitor->Visit( *this );
+}
+
+
+TiXmlNode* TiXmlUnknown::Clone() const
+{
+	TiXmlUnknown* clone = new TiXmlUnknown();
+
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+TiXmlAttributeSet::TiXmlAttributeSet()
+{
+	sentinel.next = &sentinel;
+	sentinel.prev = &sentinel;
+}
+
+
+TiXmlAttributeSet::~TiXmlAttributeSet()
+{
+	assert( sentinel.next == &sentinel );
+	assert( sentinel.prev == &sentinel );
+}
+
+
+void TiXmlAttributeSet::Add( TiXmlAttribute* addMe )
+{
+    #ifdef TIXML_USE_STL
+	assert( !Find( TIXML_STRING( addMe->Name() ) ) );	// Shouldn't be multiply adding to the set.
+	#else
+	assert( !Find( addMe->Name() ) );	// Shouldn't be multiply adding to the set.
+	#endif
+
+	addMe->next = &sentinel;
+	addMe->prev = sentinel.prev;
+
+	sentinel.prev->next = addMe;
+	sentinel.prev      = addMe;
+}
+
+void TiXmlAttributeSet::Remove( TiXmlAttribute* removeMe )
+{
+	TiXmlAttribute* node;
+
+	for( node = sentinel.next; node != &sentinel; node = node->next )
+	{
+		if ( node == removeMe )
+		{
+			node->prev->next = node->next;
+			node->next->prev = node->prev;
+			node->next = 0;
+			node->prev = 0;
+			return;
+		}
+	}
+	assert( 0 );		// we tried to remove a non-linked attribute.
+}
+
+
+#ifdef TIXML_USE_STL
+const TiXmlAttribute* TiXmlAttributeSet::Find( const std::string& name ) const
+{
+	for( const TiXmlAttribute* node = sentinel.next; node != &sentinel; node = node->next )
+	{
+		if ( node->name == name )
+			return node;
+	}
+	return 0;
+}
+
+/*
+TiXmlAttribute*	TiXmlAttributeSet::Find( const std::string& name )
+{
+	for( TiXmlAttribute* node = sentinel.next; node != &sentinel; node = node->next )
+	{
+		if ( node->name == name )
+			return node;
+	}
+	return 0;
+}
+*/
+#endif
+
+
+const TiXmlAttribute* TiXmlAttributeSet::Find( const char* name ) const
+{
+	for( const TiXmlAttribute* node = sentinel.next; node != &sentinel; node = node->next )
+	{
+		if ( strcmp( node->name.c_str(), name ) == 0 )
+			return node;
+	}
+	return 0;
+}
+
+/*
+TiXmlAttribute*	TiXmlAttributeSet::Find( const char* name )
+{
+	for( TiXmlAttribute* node = sentinel.next; node != &sentinel; node = node->next )
+	{
+		if ( strcmp( node->name.c_str(), name ) == 0 )
+			return node;
+	}
+	return 0;
+}
+*/
+
+#ifdef TIXML_USE_STL	
+std::istream& operator>> (std::istream & in, TiXmlNode & base)
+{
+	TIXML_STRING tag;
+	tag.reserve( 8 * 1000 );
+	base.StreamIn( &in, &tag );
+
+	base.Parse( tag.c_str(), 0, TIXML_DEFAULT_ENCODING );
+	return in;
+}
+#endif
+
+
+#ifdef TIXML_USE_STL	
+std::ostream& operator<< (std::ostream & out, const TiXmlNode & base)
+{
+	TiXmlPrinter printer;
+	printer.SetStreamPrinting();
+	base.Accept( &printer );
+	out << printer.Str();
+
+	return out;
+}
+
+
+std::string& operator<< (std::string& out, const TiXmlNode& base )
+{
+	TiXmlPrinter printer;
+	printer.SetStreamPrinting();
+	base.Accept( &printer );
+	out.append( printer.Str() );
+
+	return out;
+}
+#endif
+
+
+TiXmlHandle TiXmlHandle::FirstChild() const
+{
+	if ( node )
+	{
+		TiXmlNode* child = node->FirstChild();
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::FirstChild( const char * value ) const
+{
+	if ( node )
+	{
+		TiXmlNode* child = node->FirstChild( value );
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::FirstChildElement() const
+{
+	if ( node )
+	{
+		TiXmlElement* child = node->FirstChildElement();
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::FirstChildElement( const char * value ) const
+{
+	if ( node )
+	{
+		TiXmlElement* child = node->FirstChildElement( value );
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::Child( int count ) const
+{
+	if ( node )
+	{
+		int i;
+		TiXmlNode* child = node->FirstChild();
+		for (	i=0;
+				child && i<count;
+				child = child->NextSibling(), ++i )
+		{
+			// nothing
+		}
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::Child( const char* value, int count ) const
+{
+	if ( node )
+	{
+		int i;
+		TiXmlNode* child = node->FirstChild( value );
+		for (	i=0;
+				child && i<count;
+				child = child->NextSibling( value ), ++i )
+		{
+			// nothing
+		}
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::ChildElement( int count ) const
+{
+	if ( node )
+	{
+		int i;
+		TiXmlElement* child = node->FirstChildElement();
+		for (	i=0;
+				child && i<count;
+				child = child->NextSiblingElement(), ++i )
+		{
+			// nothing
+		}
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::ChildElement( const char* value, int count ) const
+{
+	if ( node )
+	{
+		int i;
+		TiXmlElement* child = node->FirstChildElement( value );
+		for (	i=0;
+				child && i<count;
+				child = child->NextSiblingElement( value ), ++i )
+		{
+			// nothing
+		}
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+bool TiXmlPrinter::VisitEnter( const TiXmlDocument& )
+{
+	return true;
+}
+
+bool TiXmlPrinter::VisitExit( const TiXmlDocument& )
+{
+	return true;
+}
+
+bool TiXmlPrinter::VisitEnter( const TiXmlElement& element, const TiXmlAttribute* firstAttribute )
+{
+	DoIndent();
+	buffer += "<";
+	buffer += element.Value();
+
+	for( const TiXmlAttribute* attrib = firstAttribute; attrib; attrib = attrib->Next() )
+	{
+		buffer += " ";
+		attrib->Print( 0, 0, &buffer );
+	}
+
+	if ( !element.FirstChild() ) 
+	{
+		buffer += " />";
+		DoLineBreak();
+	}
+	else 
+	{
+		buffer += ">";
+		if (    element.FirstChild()->ToText()
+			  && element.LastChild() == element.FirstChild()
+			  && element.FirstChild()->ToText()->CDATA() == false )
+		{
+			simpleTextPrint = true;
+			// no DoLineBreak()!
+		}
+		else
+		{
+			DoLineBreak();
+		}
+	}
+	++depth;	
+	return true;
+}
+
+
+bool TiXmlPrinter::VisitExit( const TiXmlElement& element )
+{
+	--depth;
+	if ( !element.FirstChild() ) 
+	{
+		// nothing.
+	}
+	else 
+	{
+		if ( simpleTextPrint )
+		{
+			simpleTextPrint = false;
+		}
+		else
+		{
+			DoIndent();
+		}
+		buffer += "</";
+		buffer += element.Value();
+		buffer += ">";
+		DoLineBreak();
+	}
+	return true;
+}
+
+
+bool TiXmlPrinter::Visit( const TiXmlText& text )
+{
+	if ( text.CDATA() )
+	{
+		DoIndent();
+		buffer += "<![CDATA[";
+		buffer += text.Value();
+		buffer += "]]>";
+		DoLineBreak();
+	}
+	else if ( simpleTextPrint )
+	{
+		buffer += text.Value();
+	}
+	else
+	{
+		DoIndent();
+		buffer += text.Value();
+		DoLineBreak();
+	}
+	return true;
+}
+
+
+bool TiXmlPrinter::Visit( const TiXmlDeclaration& declaration )
+{
+	DoIndent();
+	declaration.Print( 0, 0, &buffer );
+	DoLineBreak();
+	return true;
+}
+
+
+bool TiXmlPrinter::Visit( const TiXmlComment& comment )
+{
+	DoIndent();
+	buffer += "<!--";
+	buffer += comment.Value();
+	buffer += "-->";
+	DoLineBreak();
+	return true;
+}
+
+
+bool TiXmlPrinter::Visit( const TiXmlUnknown& unknown )
+{
+	DoIndent();
+	buffer += "<";
+	buffer += unknown.Value();
+	buffer += ">";
+	DoLineBreak();
+	return true;
+}
+

Added: trunk/tinyxml/tinyxml.h
===================================================================
--- trunk/tinyxml/tinyxml.h	2006-10-26 20:23:12 UTC (rev 357)
+++ trunk/tinyxml/tinyxml.h	2006-10-27 17:26:03 UTC (rev 358)
@@ -0,0 +1,1776 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original code (2.0 and earlier )copyright (c) 2000-2006 Lee Thomason (www.grinninglizard.com)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+
+#ifndef TINYXML_INCLUDED
+#define TINYXML_INCLUDED
+
+#ifdef _MSC_VER
+#pragma warning( push )
+#pragma warning( disable : 4530 )
+#pragma warning( disable : 4786 )
+#endif
+
+#include <ctype.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+
+// Help out windows:
+#if defined( _DEBUG ) && !defined( DEBUG )
+#define DEBUG
+#endif
+
+#ifdef TIXML_USE_STL
+	#include <string>
+ 	#include <iostream>
+	#include <sstream>
+	#define TIXML_STRING		std::string
+#else
+	#include "tinystr.h"
+	#define TIXML_STRING		TiXmlString
+#endif
+
+// Deprecated library function hell. Compilers want to use the
+// new safe versions. This probably doesn't fully address the problem,
+// but it gets closer. There are too many compilers for me to fully
+// test. If you get compilation troubles, undefine TIXML_SAFE
+#define TIXML_SAFE
+
+#ifdef TIXML_SAFE
+	#if defined(_MSC_VER) && (_MSC_VER >= 1400 )
+		// Microsoft visual studio, version 2005 and higher.
+		#define TIXML_SNPRINTF _snprintf_s
+		#define TIXML_SNSCANF  _snscanf_s
+	#elif defined(_MSC_VER) && (_MSC_VER >= 1200 )
+		// Microsoft visual studio, version 6 and higher.
+		//#pragma message( "Using _sn* functions." )
+		#define TIXML_SNPRINTF _snprintf
+		#define TIXML_SNSCANF  _snscanf
+	#elif defined(__GNUC__) && (__GNUC__ >= 3 )
+		// GCC version 3 and higher.s
+		//#warning( "Using sn* functions." )
+		#define TIXML_SNPRINTF snprintf
+		#define TIXML_SNSCANF  snscanf
+	#endif
+#endif	
+
+class TiXmlDocument;
+class TiXmlElement;
+class TiXmlComment;
+class TiXmlUnknown;
+class TiXmlAttribute;
+class TiXmlText;
+class TiXmlDeclaration;
+class TiXmlParsingData;
+
+const int TIXML_MAJOR_VERSION = 2;
+const int TIXML_MINOR_VERSION = 5;
+const int TIXML_PATCH_VERSION = 2;
+
+/*	Internal structure for tracking location of items 
+	in the XML file.
+*/
+struct TiXmlCursor
+{
+	TiXmlCursor()		{ Clear(); }
+	void Clear()		{ row = col = -1; }
+
+	int row;	// 0 based.
+	int col;	// 0 based.
+};
+
+
+/**
+	If you call the Accept() method, it requires being passed a TiXmlVisitor
+	class to handle callbacks. For nodes that contain other nodes (Document, Element)
+	you will get called with a VisitEnter/VisitExit pair. Nodes that are always leaves
+	are simple called with Visit().
+
+	If you return 'true' from a Visit method, recursive parsing will continue. If you return
+	false, <b>no children of this node or its sibilings</b> will be Visited.
+
+	All flavors of Visit methods have a default implementation that returns 'true' (continue 
+	visiting). You need to only override methods that are interesting to you.
+
+	Generally Accept() is called on the TiXmlDocument, although all nodes suppert Visiting.
+
+	You should never change the document from a callback.
+
+	@sa TiXmlNode::Accept()
+*/
+class TiXmlVisitor
+{
+public:
+	virtual ~TiXmlVisitor() {}
+
+	/// Visit a document.
+	virtual bool VisitEnter( const TiXmlDocument& doc )	{ return true; }
+	/// Visit a document.
+	virtual bool VisitExit( const TiXmlDocument& doc )	{ return true; }
+
+	/// Visit an element.
+	virtual bool VisitEnter( const TiXmlElement& element, const TiXmlAttribute* firstAttribute )	{ return true; }
+	/// Visit an element.
+	virtual bool VisitExit( const TiXmlElement& element )											{ return true; }
+
+	/// Visit a declaration
+	virtual bool Visit( const TiXmlDeclaration& declaration )		{ return true; }
+	/// Visit a text node
+	virtual bool Visit( const TiXmlText& text )						{ return true; }
+	/// Visit a comment node
+	virtual bool Visit( const TiXmlComment& comment )				{ return true; }
+	/// Visit an unknow node
+	virtual bool Visit( const TiXmlUnknown& unknown )				{ return true; }
+};
+
+// Only used by Attribute::Query functions
+enum 
+{ 
+	TIXML_SUCCESS,
+	TIXML_NO_ATTRIBUTE,
+	TIXML_WRONG_TYPE
+};
+
+
+// Used by the parsing routines.
+enum TiXmlEncoding
+{
+	TIXML_ENCODING_UNKNOWN,
+	TIXML_ENCODING_UTF8,
+	TIXML_ENCODING_LEGACY
+};
+
+const TiXmlEncoding TIXML_DEFAULT_ENCODING = TIXML_ENCODING_UNKNOWN;
+
+/** TiXmlBase is a base class for every class in TinyXml.
+	It does little except to establish that TinyXml classes
+	can be printed and provide some utility functions.
+
+	In XML, the document and elements can contain
+	other elements and other types of nodes.
+
+	@verbatim
+	A Document can contain:	Element	(container or leaf)
+							Comment (leaf)
+							Unknown (leaf)
+							Declaration( leaf )
+
+	An Element can contain:	Element (container or leaf)
+							Text	(leaf)
+							Attributes (not on tree)
+							Comment (leaf)
+							Unknown (leaf)
+
+	A Decleration contains: Attributes (not on tree)
+	@endverbatim
+*/
+class TiXmlBase
+{
+	friend class TiXmlNode;
+	friend class TiXmlElement;
+	friend class TiXmlDocument;
+
+public:
+	TiXmlBase()	:	userData(0)		{}
+	virtual ~TiXmlBase()			{}
+
+	/**	All TinyXml classes can print themselves to a filestream
+		or the string class (TiXmlString in non-STL mode, std::string
+		in STL mode.) Either or both cfile and str can be null.
+		
+		This is a formatted print, and will insert 
+		tabs and newlines.
+		
+		(For an unformatted stream, use the << operator.)
+	*/
+	virtual void Print( FILE* cfile, int depth ) const = 0;
+
+	/**	The world does not agree on whether white space should be kept or
+		not. In order to make everyone happy, these global, static functions
+		are provided to set whether or not TinyXml will condense all white space
+		into a single space or not. The default is to condense. Note changing this
+		value is not thread safe.
+	*/
+	static void SetCondenseWhiteSpace( bool condense )		{ condenseWhiteSpace = condense; }
+
+	/// Return the current white space setting.
+	static bool IsWhiteSpaceCondensed()						{ return condenseWhiteSpace; }
+
+	/** Return the position, in the original source file, of this node or attribute.
+		The row and column are 1-based. (That is the first row and first column is
+		1,1). If the returns values are 0 or less, then the parser does not have
+		a row and column value.
+
+		Generally, the row and column value will be set when the TiXmlDocument::Load(),
+		TiXmlDocument::LoadFile(), or any TiXmlNode::Parse() is called. It will NOT be set
+		when the DOM was created from operator>>.
+
+		The values reflect the initial load. Once the DOM is modified programmatically
+		(by adding or changing nodes and attributes) the new values will NOT update to
+		reflect changes in the document.
+
+		There is a minor performance cost to computing the row and column. Computation
+		can be disabled if TiXmlDocument::SetTabSize() is called with 0 as the value.
+
+		@sa TiXmlDocument::SetTabSize()
+	*/
+	int Row() const			{ return location.row + 1; }
+	int Column() const		{ return location.col + 1; }	///< See Row()
+
+	void  SetUserData( void* user )			{ userData = user; }	///< Set a pointer to arbitrary user data.
+	void* GetUserData()						{ return userData; }	///< Get a pointer to arbitrary user data.
+	const void* GetUserData() const 		{ return userData; }	///< Get a pointer to arbitrary user data.
+
+	// Table that returs, for a given lead byte, the total number of bytes
+	// in the UTF-8 sequence.
+	static const int utf8ByteTable[256];
+
+	virtual const char* Parse(	const char* p, 
+								TiXmlParsingData* data, 
+								TiXmlEncoding encoding /*= TIXML_ENCODING_UNKNOWN */ ) = 0;
+
+	enum
+	{
+		TIXML_NO_ERROR = 0,
+		TIXML_ERROR,
+		TIXML_ERROR_OPENING_FILE,
+		TIXML_ERROR_OUT_OF_MEMORY,
+		TIXML_ERROR_PARSING_ELEMENT,
+		TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME,
+		TIXML_ERROR_READING_ELEMENT_VALUE,
+		TIXML_ERROR_READING_ATTRIBUTES,
+		TIXML_ERROR_PARSING_EMPTY,
+		TIXML_ERROR_READING_END_TAG,
+		TIXML_ERROR_PARSING_UNKNOWN,
+		TIXML_ERROR_PARSING_COMMENT,
+		TIXML_ERROR_PARSING_DECLARATION,
+		TIXML_ERROR_DOCUMENT_EMPTY,
+		TIXML_ERROR_EMBEDDED_NULL,
+		TIXML_ERROR_PARSING_CDATA,
+		TIXML_ERROR_DOCUMENT_TOP_ONLY,
+
+		TIXML_ERROR_STRING_COUNT
+	};
+
+protected:
+
+	static const char* SkipWhiteSpace( const char*, TiXmlEncoding encoding );
+	inline static bool IsWhiteSpace( char c )		
+	{ 
+		return ( isspace( (unsigned char) c ) || c == '\n' || c == '\r' ); 
+	}
+	inline static bool IsWhiteSpace( int c )
+	{
+		if ( c < 256 )
+			return IsWhiteSpace( (char) c );
+		return false;	// Again, only truly correct for English/Latin...but usually works.
+	}
+
+	#ifdef TIXML_USE_STL
+	static bool	StreamWhiteSpace( std::istream * in, TIXML_STRING * tag );
+	static bool StreamTo( std::istream * in, int character, TIXML_STRING * tag );
+	#endif
+
+	/*	Reads an XML name into the string provided. Returns
+		a pointer just past the last character of the name,
+		or 0 if the function has an error.
+	*/
+	static const char* ReadName( const char* p, TIXML_STRING* name, TiXmlEncoding encoding );
+
+	/*	Reads text. Returns a pointer past the given end tag.
+		Wickedly complex options, but it keeps the (sensitive) code in one place.
+	*/
+	static const char* ReadText(	const char* in,				// where to start
+									TIXML_STRING* text,			// the string read
+									bool ignoreWhiteSpace,		// whether to keep the white space
+									const char* endTag,			// what ends this text
+									bool ignoreCase,			// whether to ignore case in the end tag
+									TiXmlEncoding encoding );	// the current encoding
+
+	// If an entity has been found, transform it into a character.
+	static const char* GetEntity( const char* in, char* value, int* length, TiXmlEncoding encoding );
+
+	// Get a character, while interpreting entities.
+	// The length can be from 0 to 4 bytes.
+	inline static const char* GetChar( const char* p, char* _value, int* length, TiXmlEncoding encoding )
+	{
+		assert( p );
+		if ( encoding == TIXML_ENCODING_UTF8 )
+		{
+			*length = utf8ByteTable[ *((const unsigned char*)p) ];
+			assert( *length >= 0 && *length < 5 );
+		}
+		else
+		{
+			*length = 1;
+		}
+
+		if ( *length == 1 )
+		{
+			if ( *p == '&' )
+				return GetEntity( p, _value, length, encoding );
+			*_value = *p;
+			return p+1;
+		}
+		else if ( *length )
+		{
+			//strncpy( _value, p, *length );	// lots of compilers don't like this function (unsafe),
+												// and the null terminator isn't needed
+			for( int i=0; p[i] && i<*length; ++i ) {
+				_value[i] = p[i];
+			}
+			return p + (*length);
+		}
+		else
+		{
+			// Not valid text.
+			return 0;
+		}
+	}
+
+	// Puts a string to a stream, expanding entities as it goes.
+	// Note this should not contian the '<', '>', etc, or they will be transformed into entities!
+	static void PutString( const TIXML_STRING& str, TIXML_STRING* out );
+
+	// Return true if the next characters in the stream are any of the endTag sequences.
+	// Ignore case only works for english, and should only be relied on when comparing
+	// to English words: StringEqual( p, "version", true ) is fine.
+	static bool StringEqual(	const char* p,
+								const char* endTag,
+								bool ignoreCase,
+								TiXmlEncoding encoding );
+
+	static const char* errorString[ TIXML_ERROR_STRING_COUNT ];
+
+	TiXmlCursor location;
+
+    /// Field containing a generic user pointer
+	void*			userData;
+	
+	// None of these methods are reliable for any language except English.
+	// Good for approximation, not great for accuracy.
+	static int IsAlpha( unsigned char anyByte, TiXmlEncoding encoding );
+	static int IsAlphaNum( unsigned char anyByte, TiXmlEncoding encoding );
+	inline static int ToLower( int v, TiXmlEncoding encoding )
+	{
+		if ( encoding == TIXML_ENCODING_UTF8 )
+		{
+			if ( v < 128 ) return tolower( v );
+			return v;
+		}
+		else
+		{
+			return tolower( v );
+		}
+	}
+	static void ConvertUTF32ToUTF8( unsigned long input, char* output, int* length );
+
+private:
+	TiXmlBase( const TiXmlBase& );				// not implemented.
+	void operator=( const TiXmlBase& base );	// not allowed.
+
+	struct Entity
+	{
+		const char*     str;
+		unsigned int	strLength;
+		char		    chr;
+	};
+	enum
+	{
+		NUM_ENTITY = 5,
+		MAX_ENTITY_LENGTH = 6
+
+	};
+	static Entity entity[ NUM_ENTITY ];
+	static bool condenseWhiteSpace;
+};
+
+
+/** The parent class for everything in the Document Object Model.
+	(Except for attributes).
+	Nodes have siblings, a parent, and children. A node can be
+	in a document, or stand on its own. The type of a TiXmlNode
+	can be queried, and it can be cast to its more defined type.
+*/
+class TiXmlNode : public TiXmlBase
+{
+	friend class TiXmlDocument;
+	friend class TiXmlElement;
+
+public:
+	#ifdef TIXML_USE_STL	
+
+	    /** An input stream operator, for every class. Tolerant of newlines and
+		    formatting, but doesn't expect them.
+	    */
+	    friend std::istream& operator >> (std::istream& in, TiXmlNode& base);
+
+	    /** An output stream operator, for every class. Note that this outputs
+		    without any newlines or formatting, as opposed to Print(), which
+		    includes tabs and new lines.
+
+		    The operator<< and operator>> are not completely symmetric. Writing
+		    a node to a stream is very well defined. You'll get a nice stream
+		    of output, without any extra whitespace or newlines.
+		    
+		    But reading is not as well defined. (As it always is.) If you create
+		    a TiXmlElement (for example) and read that from an input stream,
+		    the text needs to define an element or junk will result. This is
+		    true of all input streams, but it's worth keeping in mind.
+
+		    A TiXmlDocument will read nodes until it reads a root element, and
+			all the children of that root element.
+	    */	
+	    friend std::ostream& operator<< (std::ostream& out, const TiXmlNode& base);
+
+		/// Appends the XML node or attribute to a std::string.
+		friend std::string& operator<< (std::string& out, const TiXmlNode& base );
+
+	#endif
+
+	/** The types of XML nodes supported by TinyXml. (All the
+			unsupported types are picked up by UNKNOWN.)
+	*/
+	enum NodeType
+	{
+		DOCUMENT,
+		ELEMENT,
+		COMMENT,
+		UNKNOWN,
+		TEXT,
+		DECLARATION,
+		TYPECOUNT
+	};
+
+	virtual ~TiXmlNode();
+
+	/** The meaning of 'value' changes for the specific type of
+		TiXmlNode.
+		@verbatim
+		Document:	filename of the xml file
+		Element:	name of the element
+		Comment:	the comment text
+		Unknown:	the tag contents
+		Text:		the text string
+		@endverbatim
+
+		The subclasses will wrap this function.
+	*/
+	const char *Value() const { return value.c_str (); }
+
+    #ifdef TIXML_USE_STL
+	/** Return Value() as a std::string. If you only use STL,
+	    this is more efficient than calling Value().
+		Only available in STL mode.
+	*/
+	const std::string& ValueStr() const { return value; }
+	#endif
+
+	/** Changes the value of the node. Defined as:
+		@verbatim
+		Document:	filename of the xml file
+		Element:	name of the element
+		Comment:	the comment text
+		Unknown:	the tag contents
+		Text:		the text string
+		@endverbatim
+	*/
+	void SetValue(const char * _value) { value = _value;}
+
+    #ifdef TIXML_USE_STL
+	/// STL std::string form.
+	void SetValue( const std::string& _value )	{ value = _value; }
+	#endif
+
+	/// Delete all the children of this node. Does not affect 'this'.
+	void Clear();
+
+	/// One step up the DOM.
+	TiXmlNode* Parent()							{ return parent; }
+	const TiXmlNode* Parent() const				{ return parent; }
+
+	const TiXmlNode* FirstChild()	const	{ return firstChild; }		///< The first child of this node. Will be null if there are no children.
+	TiXmlNode* FirstChild()					{ return firstChild; }
+	const TiXmlNode* FirstChild( const char * value ) const;			///< The first child of this node with the matching 'value'. Will be null if none found.
+	/// The first child of this node with the matching 'value'. Will be null if none found.
+	TiXmlNode* FirstChild( const char * _value ) {
+		// Call through to the const version - safe since nothing is changed. Exiting syntax: cast this to a const (always safe)
+		// call the method, cast the return back to non-const.
+		return const_cast< TiXmlNode* > ((const_cast< const TiXmlNode* >(this))->FirstChild( _value ));
+	}
+	const TiXmlNode* LastChild() const	{ return lastChild; }		/// The last child of this node. Will be null if there are no children.
+	TiXmlNode* LastChild()	{ return lastChild; }
+	
+	const TiXmlNode* LastChild( const char * value ) const;			/// The last child of this node matching 'value'. Will be null if there are no children.
+	TiXmlNode* LastChild( const char * _value ) {
+		return const_cast< TiXmlNode* > ((const_cast< const TiXmlNode* >(this))->LastChild( _value ));
+	}
+
+    #ifdef TIXML_USE_STL
+	const TiXmlNode* FirstChild( const std::string& _value ) const	{	return FirstChild (_value.c_str ());	}	///< STL std::string form.
+	TiXmlNode* FirstChild( const std::string& _value )				{	return FirstChild (_value.c_str ());	}	///< STL std::string form.
+	const TiXmlNode* LastChild( const std::string& _value ) const	{	return LastChild (_value.c_str ());	}	///< STL std::string form.
+	TiXmlNode* LastChild( const std::string& _value )				{	return LastChild (_value.c_str ());	}	///< STL std::string form.
+	#endif
+
+	/** An alternate way to walk the children of a node.
+		One way to iterate over nodes is:
+		@verbatim
+			for( child = parent->FirstChild(); child; child = child->NextSibling() )
+		@endverbatim
+
+		IterateChildren does the same thing with the syntax:
+		@verbatim
+			child = 0;
+			while( child = parent->IterateChildren( child ) )
+		@endverbatim
+
+		IterateChildren takes the previous child as input and finds
+		the next one. If the previous child is null, it returns the
+		first. IterateChildren will return null when done.
+	*/
+	const TiXmlNode* IterateChildren( const TiXmlNode* previous ) const;
+	TiXmlNode* IterateChildren( const TiXmlNode* previous ) {
+		return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->IterateChildren( previous ) );
+	}
+
+	/// This flavor of IterateChildren searches for children with a particular 'value'
+	const TiXmlNode* IterateChildren( const char * value, const TiXmlNode* previous ) const;
+	TiXmlNode* IterateChildren( const char * _value, const TiXmlNode* previous ) {
+		return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->IterateChildren( _value, previous ) );
+	}
+
+    #ifdef TIXML_USE_STL
+	const TiXmlNode* IterateChildren( const std::string& _value, const TiXmlNode* previous ) const	{	return IterateChildren (_value.c_str (), previous);	}	///< STL std::string form.
+	TiXmlNode* IterateChildren( const std::string& _value, const TiXmlNode* previous ) {	return IterateChildren (_value.c_str (), previous);	}	///< STL std::string form.
+	#endif
+
+	/** Add a new node related to this. Adds a child past the LastChild.
+		Returns a pointer to the new object or NULL if an error occured.
+	*/
+	TiXmlNode* InsertEndChild( const TiXmlNode& addThis );
+
+
+	/** Add a new node related to this. Adds a child past the LastChild.
+
+		NOTE: the node to be added is passed by pointer, and will be
+		henceforth owned (and deleted) by tinyXml. This method is efficient
+		and avoids an extra copy, but should be used with care as it
+		uses a different memory model than the other insert functions.
+
+		@sa InsertEndChild
+	*/
+	TiXmlNode* LinkEndChild( TiXmlNode* addThis );
+
+	/** Add a new node related to this. Adds a child before the specified child.
+		Returns a pointer to the new object or NULL if an error occured.
+	*/
+	TiXmlNode* InsertBeforeChild( TiXmlNode* beforeThis, const TiXmlNode& addThis );
+
+	/** Add a new node related to this. Adds a child after the specified child.
+		Returns a pointer to the new object or NULL if an error occured.
+	*/
+	TiXmlNode* InsertAfterChild(  TiXmlNode* afterThis, const TiXmlNode& addThis );
+
+	/** Replace a child of this node.
+		Returns a pointer to the new object or NULL if an error occured.
+	*/
+	TiXmlNode* ReplaceChild( TiXmlNode* replaceThis, const TiXmlNode& withThis );
+
+	/// Delete a child of this node.
+	bool RemoveChild( TiXmlNode* removeThis );
+
+	/// Navigate to a sibling node.
+	const TiXmlNode* PreviousSibling() const			{ return prev; }
+	TiXmlNode* PreviousSibling()						{ return prev; }
+
+	/// Navigate to a sibling node.
+	const TiXmlNode* PreviousSibling( const char * ) const;
+	TiXmlNode* PreviousSibling( const char *_prev ) {
+		return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->PreviousSibling( _prev ) );
+	}
+
+    #ifdef TIXML_USE_STL
+	const TiXmlNode* PreviousSibling( const std::string& _value ) const	{	return PreviousSibling (_value.c_str ());	}	///< STL std::string form.
+	TiXmlNode* PreviousSibling( const std::string& _value ) 			{	return PreviousSibling (_value.c_str ());	}	///< STL std::string form.
+	const TiXmlNode* NextSibling( const std::string& _value) const		{	return NextSibling (_value.c_str ());	}	///< STL std::string form.
+	TiXmlNode* NextSibling( const std::string& _value) 					{	return NextSibling (_value.c_str ());	}	///< STL std::string form.
+	#endif
+
+	/// Navigate to a sibling node.
+	const TiXmlNode* NextSibling() const				{ return next; }
+	TiXmlNode* NextSibling()							{ return next; }
+
+	/// Navigate to a sibling node with the given 'value'.
+	const TiXmlNode* NextSibling( const char * ) const;
+	TiXmlNode* NextSibling( const char* _next ) {
+		return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->NextSibling( _next ) );
+	}
+
+	/** Convenience function to get through elements.
+		Calls NextSibling and ToElement. Will skip all non-Element
+		nodes. Returns 0 if there is not another element.
+	*/
+	const TiXmlElement* NextSiblingElement() const;
+	TiXmlElement* NextSiblingElement() {
+		return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->NextSiblingElement() );
+	}
+
+	/** Convenience function to get through elements.
+		Calls NextSibling and ToElement. Will skip all non-Element
+		nodes. Returns 0 if there is not another element.
+	*/
+	const TiXmlElement* NextSiblingElement( const char * ) const;
+	TiXmlElement* NextSiblingElement( const char *_next ) {
+		return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->NextSiblingElement( _next ) );
+	}
+
+    #ifdef TIXML_USE_STL
+	const TiXmlElement* NextSiblingElement( const std::string& _value) const	{	return NextSiblingElement (_value.c_str ());	}	///< STL std::string form.
+	TiXmlElement* NextSiblingElement( const std::string& _value)				{	return NextSiblingElement (_value.c_str ());	}	///< STL std::string form.
+	#endif
+
+	/// Convenience function to get through elements.
+	const TiXmlElement* FirstChildElement()	const;
+	TiXmlElement* FirstChildElement() {
+		return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->FirstChildElement() );
+	}
+
+	/// Convenience function to get through elements.
+	const TiXmlElement* FirstChildElement( const char * _value ) const;
+	TiXmlElement* FirstChildElement( const char * _value ) {
+		return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->FirstChildElement( _value ) );
+	}
+
+    #ifdef TIXML_USE_STL
+	const TiXmlElement* FirstChildElement( const std::string& _value ) const	{	return FirstChildElement (_value.c_str ());	}	///< STL std::string form.
+	TiXmlElement* FirstChildElement( const std::string& _value )				{	return FirstChildElement (_value.c_str ());	}	///< STL std::string form.
+	#endif
+
+	/** Query the type (as an enumerated value, above) of this node.
+		The possible types are: DOCUMENT, ELEMENT, COMMENT,
+								UNKNOWN, TEXT, and DECLARATION.
+	*/
+	int Type() const	{ return type; }
+
+	/** Return a pointer to the Document this node lives in.
+		Returns null if not in a document.
+	*/
+	const TiXmlDocument* GetDocument() const;
+	TiXmlDocument* GetDocument() {
+		return const_cast< TiXmlDocument* >( (const_cast< const TiXmlNode* >(this))->GetDocument() );
+	}
+
+	/// Returns true if this node has no children.
+	bool NoChildren() const						{ return !firstChild; }
+
+	virtual const TiXmlDocument*    ToDocument()    const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual const TiXmlElement*     ToElement()     const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual const TiXmlComment*     ToComment()     const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual const TiXmlUnknown*     ToUnknown()     const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual const TiXmlText*        ToText()        const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual const TiXmlDeclaration* ToDeclaration() const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+
+	virtual TiXmlDocument*          ToDocument()    { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual TiXmlElement*           ToElement()	    { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual TiXmlComment*           ToComment()     { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual TiXmlUnknown*           ToUnknown()	    { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual TiXmlText*	            ToText()        { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual TiXmlDeclaration*       ToDeclaration() { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+
+	/** Create an exact duplicate of this node and return it. The memory must be deleted
+		by the caller. 
+	*/
+	virtual TiXmlNode* Clone() const = 0;
+
+	/** Accept a hierchical visit the nodes in the TinyXML DOM. Every node in the 
+		XML tree will be conditionally visited and the host will be called back
+		via the TiXmlVisitor interface.
+
+		This is essentially a SAX interface for TinyXML. (Note however it doesn't re-parse
+		the XML for the callbacks, so the performance of TinyXML is unchanged by using this
+		interface versus any other.)
+
+		The interface has been based on ideas from:
+
+		- http://www.saxproject.org/
+		- http://c2.com/cgi/wiki?HierarchicalVisitorPattern 
+
+		Which are both good references for "visiting".
+
+		An example of using Accept():
+		@verbatim
+		TiXmlPrinter printer;
+		tinyxmlDoc.Accept( &printer );
+		const char* xmlcstr = printer.CStr();
+		@endverbatim
+	*/
+	virtual bool Accept( TiXmlVisitor* visitor ) const = 0;
+
+protected:
+	TiXmlNode( NodeType _type );
+
+	// Copy to the allocated object. Shared functionality between Clone, Copy constructor,
+	// and the assignment operator.
+	void CopyTo( TiXmlNode* target ) const;
+
+	#ifdef TIXML_USE_STL
+	    // The real work of the input operator.
+	virtual void StreamIn( std::istream* in, TIXML_STRING* tag ) = 0;
+	#endif
+
+	// Figure out what is at *p, and parse it. Returns null if it is not an xml node.
+	TiXmlNode* Identify( const char* start, TiXmlEncoding encoding );
+
+	TiXmlNode*		parent;
+	NodeType		type;
+
+	TiXmlNode*		firstChild;
+	TiXmlNode*		lastChild;
+
+	TIXML_STRING	value;
+
+	TiXmlNode*		prev;
+	TiXmlNode*		next;
+
+private:
+	TiXmlNode( const TiXmlNode& );				// not implemented.
+	void operator=( const TiXmlNode& base );	// not allowed.
+};
+
+
+/** An attribute is a name-value pair. Elements have an arbitrary
+	number of attributes, each with a unique name.
+
+	@note The attributes are not TiXmlNodes, since they are not
+		  part of the tinyXML document object model. There are other
+		  suggested ways to look at this problem.
+*/
+class TiXmlAttribute : public TiXmlBase
+{
+	friend class TiXmlAttributeSet;
+
+public:
+	/// Construct an empty attribute.
+	TiXmlAttribute() : TiXmlBase()
+	{
+		document = 0;
+		prev = next = 0;
+	}
+
+	#ifdef TIXML_USE_STL
+	/// std::string constructor.
+	TiXmlAttribute( const std::string& _name, const std::string& _value )
+	{
+		name = _name;
+		value = _value;
+		document = 0;
+		prev = next = 0;
+	}
+	#endif
+
+	/// Construct an attribute with a name and value.
+	TiXmlAttribute( const char * _name, const char * _value )
+	{
+		name = _name;
+		value = _value;
+		document = 0;
+		prev = next = 0;
+	}
+
+	const char*		Name()  const		{ return name.c_str(); }		///< Return the name of this attribute.
+	const char*		Value() const		{ return value.c_str(); }		///< Return the value of this attribute.
+	#ifdef TIXML_USE_STL
+	const std::string& ValueStr() const	{ return value; }				///< Return the value of this attribute.
+	#endif
+	int				IntValue() const;									///< Return the value of this attribute, converted to an integer.
+	double			DoubleValue() const;								///< Return the value of this attribute, converted to a double.
+
+	// Get the tinyxml string representation
+	const TIXML_STRING& NameTStr() const { return name; }
+
+	/** QueryIntValue examines the value string. It is an alternative to the
+		IntValue() method with richer error checking.
+		If the value is an integer, it is stored in 'value' and 
+		the call returns TIXML_SUCCESS. If it is not
+		an integer, it returns TIXML_WRONG_TYPE.
+
+		A specialized but useful call. Note that for success it returns 0,
+		which is the opposite of almost all other TinyXml calls.
+	*/
+	int QueryIntValue( int* _value ) const;
+	/// QueryDoubleValue examines the value string. See QueryIntValue().
+	int QueryDoubleValue( double* _value ) const;
+
+	void SetName( const char* _name )	{ name = _name; }				///< Set the name of this attribute.
+	void SetValue( const char* _value )	{ value = _value; }				///< Set the value.
+
+	void SetIntValue( int _value );										///< Set the value from an integer.
+	void SetDoubleValue( double _value );								///< Set the value from a double.
+
+    #ifdef TIXML_USE_STL
+	/// STL std::string form.
+	void SetName( const std::string& _name )	{ name = _name; }	
+	/// STL std::string form.	
+	void SetValue( const std::string& _value )	{ value = _value; }
+	#endif
+
+	/// Get the next sibling attribute in the DOM. Returns null at end.
+	const TiXmlAttribute* Next() const;
+	TiXmlAttribute* Next() {
+		return const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttribute* >(this))->Next() ); 
+	}
+
+	/// Get the previous sibling attribute in the DOM. Returns null at beginning.
+	const TiXmlAttribute* Previous() const;
+	TiXmlAttribute* Previous() {
+		return const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttribute* >(this))->Previous() ); 
+	}
+
+	bool operator==( const TiXmlAttribute& rhs ) const { return rhs.name == name; }
+	bool operator<( const TiXmlAttribute& rhs )	 const { return name < rhs.name; }
+	bool operator>( const TiXmlAttribute& rhs )  const { return name > rhs.name; }
+
+	/*	Attribute parsing starts: first letter of the name
+						 returns: the next char after the value end quote
+	*/
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	// Prints this Attribute to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const {
+		Print( cfile, depth, 0 );
+	}
+	void Print( FILE* cfile, int depth, TIXML_STRING* str ) const;
+
+	// [internal use]
+	// Set the document pointer so the attribute can report errors.
+	void SetDocument( TiXmlDocument* doc )	{ document = doc; }
+
+private:
+	TiXmlAttribute( const TiXmlAttribute& );				// not implemented.
+	void operator=( const TiXmlAttribute& base );	// not allowed.
+
+	TiXmlDocument*	document;	// A pointer back to a document, for error reporting.
+	TIXML_STRING name;
+	TIXML_STRING value;
+	TiXmlAttribute*	prev;
+	TiXmlAttribute*	next;
+};
+
+
+/*	A class used to manage a group of attributes.
+	It is only used internally, both by the ELEMENT and the DECLARATION.
+	
+	The set can be changed transparent to the Element and Declaration
+	classes that use it, but NOT transparent to the Attribute
+	which has to implement a next() and previous() method. Which makes
+	it a bit problematic and prevents the use of STL.
+
+	This version is implemented with circular lists because:
+		- I like circular lists
+		- it demonstrates some independence from the (typical) doubly linked list.
+*/
+class TiXmlAttributeSet
+{
+public:
+	TiXmlAttributeSet();
+	~TiXmlAttributeSet();
+
+	void Add( TiXmlAttribute* attribute );
+	void Remove( TiXmlAttribute* attribute );
+
+	const TiXmlAttribute* First()	const	{ return ( sentinel.next == &sentinel ) ? 0 : sentinel.next; }
+	TiXmlAttribute* First()					{ return ( sentinel.next == &sentinel ) ? 0 : sentinel.next; }
+	const TiXmlAttribute* Last() const		{ return ( sentinel.prev == &sentinel ) ? 0 : sentinel.prev; }
+	TiXmlAttribute* Last()					{ return ( sentinel.prev == &sentinel ) ? 0 : sentinel.prev; }
+
+	const TiXmlAttribute*	Find( const char* _name ) const;
+	TiXmlAttribute*	Find( const char* _name ) {
+		return const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttributeSet* >(this))->Find( _name ) );
+	}
+	#ifdef TIXML_USE_STL
+	const TiXmlAttribute*	Find( const std::string& _name ) const;
+	TiXmlAttribute*	Find( const std::string& _name ) {
+		return const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttributeSet* >(this))->Find( _name ) );
+	}
+
+	#endif
+
+private:
+	//*ME:	Because of hidden/disabled copy-construktor in TiXmlAttribute (sentinel-element),
+	//*ME:	this class must be also use a hidden/disabled copy-constructor !!!
+	TiXmlAttributeSet( const TiXmlAttributeSet& );	// not allowed
+	void operator=( const TiXmlAttributeSet& );	// not allowed (as TiXmlAttribute)
+
+	TiXmlAttribute sentinel;
+};
+
+
+/** The element is a container class. It has a value, the element name,
+	and can contain other elements, text, comments, and unknowns.
+	Elements also contain an arbitrary number of attributes.
+*/
+class TiXmlElement : public TiXmlNode
+{
+public:
+	/// Construct an element.
+	TiXmlElement (const char * in_value);
+
+	#ifdef TIXML_USE_STL
+	/// std::string constructor.
+	TiXmlElement( const std::string& _value );
+	#endif
+
+	TiXmlElement( const TiXmlElement& );
+
+	void operator=( const TiXmlElement& base );
+
+	virtual ~TiXmlElement();
+
+	/** Given an attribute name, Attribute() returns the value
+		for the attribute of that name, or null if none exists.
+	*/
+	const char* Attribute( const char* name ) const;
+
+	/** Given an attribute name, Attribute() returns the value
+		for the attribute of that name, or null if none exists.
+		If the attribute exists and can be converted to an integer,
+		the integer value will be put in the return 'i', if 'i'
+		is non-null.
+	*/
+	const char* Attribute( const char* name, int* i ) const;
+
+	/** Given an attribute name, Attribute() returns the value
+		for the attribute of that name, or null if none exists.
+		If the attribute exists and can be converted to an double,
+		the double value will be put in the return 'd', if 'd'
+		is non-null.
+	*/
+	const char* Attribute( const char* name, double* d ) const;
+
+	/** QueryIntAttribute examines the attribute - it is an alternative to the
+		Attribute() method with richer error checking.
+		If the attribute is an integer, it is stored in 'value' and 
+		the call returns TIXML_SUCCESS. If it is not
+		an integer, it returns TIXML_WRONG_TYPE. If the attribute
+		does not exist, then TIXML_NO_ATTRIBUTE is returned.
+	*/	
+	int QueryIntAttribute( const char* name, int* _value ) const;
+	/// QueryDoubleAttribute examines the attribute - see QueryIntAttribute().
+	int QueryDoubleAttribute( const char* name, double* _value ) const;
+	/// QueryFloatAttribute examines the attribute - see QueryIntAttribute().
+	int QueryFloatAttribute( const char* name, float* _value ) const {
+		double d;
+		int result = QueryDoubleAttribute( name, &d );
+		if ( result == TIXML_SUCCESS ) {
+			*_value = (float)d;
+		}
+		return result;
+	}
+    #ifdef TIXML_USE_STL
+	/** Template form of the attribute query which will try to read the
+		attribute into the specified type. Very easy, very powerful, but
+		be careful to make sure to call this with the correct type.
+
+		@return TIXML_SUCCESS, TIXML_WRONG_TYPE, or TIXML_NO_ATTRIBUTE
+	*/
+	template< typename T > int QueryValueAttribute( const std::string& name, T* outValue ) const
+	{
+		const TiXmlAttribute* node = attributeSet.Find( name );
+		if ( !node )
+			return TIXML_NO_ATTRIBUTE;
+
+		std::stringstream sstream( node->ValueStr() );
+		sstream >> *outValue;
+		if ( !sstream.fail() )
+			return TIXML_SUCCESS;
+		return TIXML_WRONG_TYPE;
+	}
+	#endif
+
+	/** Sets an attribute of name to a given value. The attribute
+		will be created if it does not exist, or changed if it does.
+	*/
+	void SetAttribute( const char* name, const char * _value );
+
+    #ifdef TIXML_USE_STL
+	const std::string* Attribute( const std::string& name ) const;
+	const std::string* Attribute( const std::string& name, int* i ) const;
+	const std::string* Attribute( const std::string& name, double* d ) const;
+	int QueryIntAttribute( const std::string& name, int* _value ) const;
+	int QueryDoubleAttribute( const std::string& name, double* _value ) const;
+
+	/// STL std::string form.
+	void SetAttribute( const std::string& name, const std::string& _value );
+	///< STL std::string form.
+	void SetAttribute( const std::string& name, int _value );
+	#endif
+
+	/** Sets an attribute of name to a given value. The attribute
+		will be created if it does not exist, or changed if it does.
+	*/
+	void SetAttribute( const char * name, int value );
+
+	/** Sets an attribute of name to a given value. The attribute
+		will be created if it does not exist, or changed if it does.
+	*/
+	void SetDoubleAttribute( const char * name, double value );
+
+	/** Deletes an attribute with the given name.
+	*/
+	void RemoveAttribute( const char * name );
+    #ifdef TIXML_USE_STL
+	void RemoveAttribute( const std::string& name )	{	RemoveAttribute (name.c_str ());	}	///< STL std::string form.
+	#endif
+
+	const TiXmlAttribute* FirstAttribute() const	{ return attributeSet.First(); }		///< Access the first attribute in this element.
+	TiXmlAttribute* FirstAttribute() 				{ return attributeSet.First(); }
+	const TiXmlAttribute* LastAttribute()	const 	{ return attributeSet.Last(); }		///< Access the last attribute in this element.
+	TiXmlAttribute* LastAttribute()					{ return attributeSet.Last(); }
+
+	/** Convenience function for easy access to the text inside an element. Although easy
+		and concise, GetText() is limited compared to getting the TiXmlText child
+		and accessing it directly.
+	
+		If the first child of 'this' is a TiXmlText, the GetText()
+		returns the character string of the Text node, else null is returned.
+
+		This is a convenient method for getting the text of simple contained text:
+		@verbatim
+		<foo>This is text</foo>
+		const char* str = fooElement->GetText();
+		@endverbatim
+
+		'str' will be a pointer to "This is text". 
+		
+		Note that this function can be misleading. If the element foo was created from
+		this XML:
+		@verbatim
+		<foo><b>This is text</b></foo> 
+		@endverbatim
+
+		then the value of str would be null. The first child node isn't a text node, it is
+		another element. From this XML:
+		@verbatim
+		<foo>This is <b>text</b></foo> 
+		@endverbatim
+		GetText() will return "This is ".
+
+		WARNING: GetText() accesses a child node - don't become confused with the 
+				 similarly named TiXmlHandle::Text() and TiXmlNode::ToText() which are 
+				 safe type casts on the referenced node.
+	*/
+	const char* GetText() const;
+
+	/// Creates a new Element and returns it - the returned element is a copy.
+	virtual TiXmlNode* Clone() const;
+	// Print the Element to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const;
+
+	/*	Attribtue parsing starts: next char past '<'
+						 returns: next char past '>'
+	*/
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	virtual const TiXmlElement*     ToElement()     const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+	virtual TiXmlElement*           ToElement()	          { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Walk the XML tree visiting this node and all of its children. 
+	*/
+	virtual bool Accept( TiXmlVisitor* visitor ) const;
+
+protected:
+
+	void CopyTo( TiXmlElement* target ) const;
+	void ClearThis();	// like clear, but initializes 'this' object as well
+
+	// Used to be public [internal use]
+	#ifdef TIXML_USE_STL
+	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
+	#endif
+	/*	[internal use]
+		Reads the "value" of the element -- another element, or text.
+		This should terminate with the current end tag.
+	*/
+	const char* ReadValue( const char* in, TiXmlParsingData* prevData, TiXmlEncoding encoding );
+
+private:
+
+	TiXmlAttributeSet attributeSet;
+};
+
+
+/**	An XML comment.
+*/
+class TiXmlComment : public TiXmlNode
+{
+public:
+	/// Constructs an empty comment.
+	TiXmlComment() : TiXmlNode( TiXmlNode::COMMENT ) {}
+	/// Construct a comment from text.
+	TiXmlComment( const char* _value ) : TiXmlNode( TiXmlNode::COMMENT ) {
+		SetValue( _value );
+	}
+	TiXmlComment( const TiXmlComment& );
+	void operator=( const TiXmlComment& base );
+
+	virtual ~TiXmlComment()	{}
+
+	/// Returns a copy of this Comment.
+	virtual TiXmlNode* Clone() const;
+	// Write this Comment to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const;
+
+	/*	Attribtue parsing starts: at the ! of the !--
+						 returns: next char past '>'
+	*/
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	virtual const TiXmlComment*  ToComment() const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+	virtual TiXmlComment*  ToComment() { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Walk the XML tree visiting this node and all of its children. 
+	*/
+	virtual bool Accept( TiXmlVisitor* visitor ) const;
+
+protected:
+	void CopyTo( TiXmlComment* target ) const;
+
+	// used to be public
+	#ifdef TIXML_USE_STL
+	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
+	#endif
+//	virtual void StreamOut( TIXML_OSTREAM * out ) const;
+
+private:
+
+};
+
+
+/** XML text. A text node can have 2 ways to output the next. "normal" output 
+	and CDATA. It will default to the mode it was parsed from the XML file and
+	you generally want to leave it alone, but you can change the output mode with 
+	SetCDATA() and query it with CDATA().
+*/
+class TiXmlText : public TiXmlNode
+{
+	friend class TiXmlElement;
+public:
+	/** Constructor for text element. By default, it is treated as 
+		normal, encoded text. If you want it be output as a CDATA text
+		element, set the parameter _cdata to 'true'
+	*/
+	TiXmlText (const char * initValue ) : TiXmlNode (TiXmlNode::TEXT)
+	{
+		SetValue( initValue );
+		cdata = false;
+	}
+	virtual ~TiXmlText() {}
+
+	#ifdef TIXML_USE_STL
+	/// Constructor.
+	TiXmlText( const std::string& initValue ) : TiXmlNode (TiXmlNode::TEXT)
+	{
+		SetValue( initValue );
+		cdata = false;
+	}
+	#endif
+
+	TiXmlText( const TiXmlText& copy ) : TiXmlNode( TiXmlNode::TEXT )	{ copy.CopyTo( this ); }
+	void operator=( const TiXmlText& base )							 	{ base.CopyTo( this ); }
+
+	// Write this text object to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const;
+
+	/// Queries whether this represents text using a CDATA section.
+	bool CDATA() const				{ return cdata; }
+	/// Turns on or off a CDATA representation of text.
+	void SetCDATA( bool _cdata )	{ cdata = _cdata; }
+
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	virtual const TiXmlText* ToText() const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+	virtual TiXmlText*       ToText()       { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Walk the XML tree visiting this node and all of its children. 
+	*/
+	virtual bool Accept( TiXmlVisitor* content ) const;
+
+protected :
+	///  [internal use] Creates a new Element and returns it.
+	virtual TiXmlNode* Clone() const;
+	void CopyTo( TiXmlText* target ) const;
+
+	bool Blank() const;	// returns true if all white space and new lines
+	// [internal use]
+	#ifdef TIXML_USE_STL
+	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
+	#endif
+
+private:
+	bool cdata;			// true if this should be input and output as a CDATA style text element
+};
+
+
+/** In correct XML the declaration is the first entry in the file.
+	@verbatim
+		<?xml version="1.0" standalone="yes"?>
+	@endverbatim
+
+	TinyXml will happily read or write files without a declaration,
+	however. There are 3 possible attributes to the declaration:
+	version, encoding, and standalone.
+
+	Note: In this version of the code, the attributes are
+	handled as special cases, not generic attributes, simply
+	because there can only be at most 3 and they are always the same.
+*/
+class TiXmlDeclaration : public TiXmlNode
+{
+public:
+	/// Construct an empty declaration.
+	TiXmlDeclaration()   : TiXmlNode( TiXmlNode::DECLARATION ) {}
+
+#ifdef TIXML_USE_STL
+	/// Constructor.
+	TiXmlDeclaration(	const std::string& _version,
+						const std::string& _encoding,
+						const std::string& _standalone );
+#endif
+
+	/// Construct.
+	TiXmlDeclaration(	const char* _version,
+						const char* _encoding,
+						const char* _standalone );
+
+	TiXmlDeclaration( const TiXmlDeclaration& copy );
+	void operator=( const TiXmlDeclaration& copy );
+
+	virtual ~TiXmlDeclaration()	{}
+
+	/// Version. Will return an empty string if none was found.
+	const char *Version() const			{ return version.c_str (); }
+	/// Encoding. Will return an empty string if none was found.
+	const char *Encoding() const		{ return encoding.c_str (); }
+	/// Is this a standalone document?
+	const char *Standalone() const		{ return standalone.c_str (); }
+
+	/// Creates a copy of this Declaration and returns it.
+	virtual TiXmlNode* Clone() const;
+	// Print this declaration to a FILE stream.
+	virtual void Print( FILE* cfile, int depth, TIXML_STRING* str ) const;
+	virtual void Print( FILE* cfile, int depth ) const {
+		Print( cfile, depth, 0 );
+	}
+
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	virtual const TiXmlDeclaration* ToDeclaration() const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+	virtual TiXmlDeclaration*       ToDeclaration()       { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Walk the XML tree visiting this node and all of its children. 
+	*/
+	virtual bool Accept( TiXmlVisitor* visitor ) const;
+
+protected:
+	void CopyTo( TiXmlDeclaration* target ) const;
+	// used to be public
+	#ifdef TIXML_USE_STL
+	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
+	#endif
+
+private:
+
+	TIXML_STRING version;
+	TIXML_STRING encoding;
+	TIXML_STRING standalone;
+};
+
+
+/** Any tag that tinyXml doesn't recognize is saved as an
+	unknown. It is a tag of text, but should not be modified.
+	It will be written back to the XML, unchanged, when the file
+	is saved.
+
+	DTD tags get thrown into TiXmlUnknowns.
+*/
+class TiXmlUnknown : public TiXmlNode
+{
+public:
+	TiXmlUnknown() : TiXmlNode( TiXmlNode::UNKNOWN )	{}
+	virtual ~TiXmlUnknown() {}
+
+	TiXmlUnknown( const TiXmlUnknown& copy ) : TiXmlNode( TiXmlNode::UNKNOWN )		{ copy.CopyTo( this ); }
+	void operator=( const TiXmlUnknown& copy )										{ copy.CopyTo( this ); }
+
+	/// Creates a copy of this Unknown and returns it.
+	virtual TiXmlNode* Clone() const;
+	// Print this Unknown to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const;
+
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	virtual const TiXmlUnknown*     ToUnknown()     const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+	virtual TiXmlUnknown*           ToUnknown()	    { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Walk the XML tree visiting this node and all of its children. 
+	*/
+	virtual bool Accept( TiXmlVisitor* content ) const;
+
+protected:
+	void CopyTo( TiXmlUnknown* target ) const;
+
+	#ifdef TIXML_USE_STL
+	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
+	#endif
+
+private:
+
+};
+
+
+/** Always the top level node. A document binds together all the
+	XML pieces. It can be saved, loaded, and printed to the screen.
+	The 'value' of a document node is the xml file name.
+*/
+class TiXmlDocument : public TiXmlNode
+{
+public:
+	/// Create an empty document, that has no name.
+	TiXmlDocument();
+	/// Create a document with a name. The name of the document is also the filename of the xml.
+	TiXmlDocument( const char * documentName );
+
+	#ifdef TIXML_USE_STL
+	/// Constructor.
+	TiXmlDocument( const std::string& documentName );
+	#endif
+
+	TiXmlDocument( const TiXmlDocument& copy );
+	void operator=( const TiXmlDocument& copy );
+
+	virtual ~TiXmlDocument() {}
+
+	/** Load a file using the current document value.
+		Returns true if successful. Will delete any existing
+		document data before loading.
+	*/
+	bool LoadFile( TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+	/// Save a file using the current document value. Returns true if successful.
+	bool SaveFile() const;
+	/// Load a file using the given filename. Returns true if successful.
+	bool LoadFile( const char * filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+	/// Save a file using the given filename. Returns true if successful.
+	bool SaveFile( const char * filename ) const;
+	/** Load a file using the given FILE*. Returns true if successful. Note that this method
+		doesn't stream - the entire object pointed at by the FILE*
+		will be interpreted as an XML file. TinyXML doesn't stream in XML from the current
+		file location. Streaming may be added in the future.
+	*/
+	bool LoadFile( FILE*, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+	/// Save a file using the given FILE*. Returns true if successful.
+	bool SaveFile( FILE* ) const;
+
+	#ifdef TIXML_USE_STL
+	bool LoadFile( const std::string& filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING )			///< STL std::string version.
+	{
+//		StringToBuffer f( filename );
+//		return ( f.buffer && LoadFile( f.buffer, encoding ));
+		return LoadFile( filename.c_str(), encoding );
+	}
+	bool SaveFile( const std::string& filename ) const		///< STL std::string version.
+	{
+//		StringToBuffer f( filename );
+//		return ( f.buffer && SaveFile( f.buffer ));
+		return SaveFile( filename.c_str() );
+	}
+	#endif
+
+	/** Parse the given null terminated block of xml data. Passing in an encoding to this
+		method (either TIXML_ENCODING_LEGACY or TIXML_ENCODING_UTF8 will force TinyXml
+		to use that encoding, regardless of what TinyXml might otherwise try to detect.
+	*/
+	virtual const char* Parse( const char* p, TiXmlParsingData* data = 0, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+
+	/** Get the root element -- the only top level element -- of the document.
+		In well formed XML, there should only be one. TinyXml is tolerant of
+		multiple elements at the document level.
+	*/
+	const TiXmlElement* RootElement() const		{ return FirstChildElement(); }
+	TiXmlElement* RootElement()					{ return FirstChildElement(); }
+
+	/** If an error occurs, Error will be set to true. Also,
+		- The ErrorId() will contain the integer identifier of the error (not generally useful)
+		- The ErrorDesc() method will return the name of the error. (very useful)
+		- The ErrorRow() and ErrorCol() will return the location of the error (if known)
+	*/	
+	bool Error() const						{ return error; }
+
+	/// Contains a textual (english) description of the error if one occurs.
+	const char * ErrorDesc() const	{ return errorDesc.c_str (); }
+
+	/** Generally, you probably want the error string ( ErrorDesc() ). But if you
+		prefer the ErrorId, this function will fetch it.
+	*/
+	int ErrorId()	const				{ return errorId; }
+
+	/** Returns the location (if known) of the error. The first column is column 1, 
+		and the first row is row 1. A value of 0 means the row and column wasn't applicable
+		(memory errors, for example, have no row/column) or the parser lost the error. (An
+		error in the error reporting, in that case.)
+
+		@sa SetTabSize, Row, Column
+	*/
+	int ErrorRow() const	{ return errorLocation.row+1; }
+	int ErrorCol() const	{ return errorLocation.col+1; }	///< The column where the error occured. See ErrorRow()
+
+	/** SetTabSize() allows the error reporting functions (ErrorRow() and ErrorCol())
+		to report the correct values for row and column. It does not change the output
+		or input in any way.
+		
+		By calling this method, with a tab size
+		greater than 0, the row and column of each node and attribute is stored
+		when the file is loaded. Very useful for tracking the DOM back in to
+		the source file.
+
+		The tab size is required for calculating the location of nodes. If not
+		set, the default of 4 is used. The tabsize is set per document. Setting
+		the tabsize to 0 disables row/column tracking.
+
+		Note that row and column tracking is not supported when using operator>>.
+
+		The tab size needs to be enabled before the parse or load. Correct usage:
+		@verbatim
+		TiXmlDocument doc;
+		doc.SetTabSize( 8 );
+		doc.Load( "myfile.xml" );
+		@endverbatim
+
+		@sa Row, Column
+	*/
+	void SetTabSize( int _tabsize )		{ tabsize = _tabsize; }
+
+	int TabSize() const	{ return tabsize; }
+
+	/** If you have handled the error, it can be reset with this call. The error
+		state is automatically cleared if you Parse a new XML block.
+	*/
+	void ClearError()						{	error = false; 
+												errorId = 0; 
+												errorDesc = ""; 
+												errorLocation.row = errorLocation.col = 0; 
+												//errorLocation.last = 0; 
+											}
+
+	/** Write the document to standard out using formatted printing ("pretty print"). */
+	void Print() const						{ Print( stdout, 0 ); }
+
+	/* Write the document to a string using formatted printing ("pretty print"). This
+		will allocate a character array (new char[]) and return it as a pointer. The
+		calling code pust call delete[] on the return char* to avoid a memory leak.
+	*/
+	//char* PrintToMemory() const; 
+
+	/// Print this Document to a FILE stream.
+	virtual void Print( FILE* cfile, int depth = 0 ) const;
+	// [internal use]
+	void SetError( int err, const char* errorLocation, TiXmlParsingData* prevData, TiXmlEncoding encoding );
+
+	virtual const TiXmlDocument*    ToDocument()    const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+	virtual TiXmlDocument*          ToDocument()          { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Walk the XML tree visiting this node and all of its children. 
+	*/
+	virtual bool Accept( TiXmlVisitor* content ) const;
+
+protected :
+	// [internal use]
+	virtual TiXmlNode* Clone() const;
+	#ifdef TIXML_USE_STL
+	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
+	#endif
+
+private:
+	void CopyTo( TiXmlDocument* target ) const;
+
+	bool error;
+	int  errorId;
+	TIXML_STRING errorDesc;
+	int tabsize;
+	TiXmlCursor errorLocation;
+	bool useMicrosoftBOM;		// the UTF-8 BOM were found when read. Note this, and try to write.
+};
+
+
+/**
+	A TiXmlHandle is a class that wraps a node pointer with null checks; this is
+	an incredibly useful thing. Note that TiXmlHandle is not part of the TinyXml
+	DOM structure. It is a separate utility class.
+
+	Take an example:
+	@verbatim
+	<Document>
+		<Element attributeA = "valueA">
+			<Child attributeB = "value1" />
+			<Child attributeB = "value2" />
+		</Element>
+	<Document>
+	@endverbatim
+
+	Assuming you want the value of "attributeB" in the 2nd "Child" element, it's very 
+	easy to write a *lot* of code that looks like:
+
+	@verbatim
+	TiXmlElement* root = document.FirstChildElement( "Document" );
+	if ( root )
+	{
+		TiXmlElement* element = root->FirstChildElement( "Element" );
+		if ( element )
+		{
+			TiXmlElement* child = element->FirstChildElement( "Child" );
+			if ( child )
+			{
+				TiXmlElement* child2 = child->NextSiblingElement( "Child" );
+				if ( child2 )
+				{
+					// Finally do something useful.
+	@endverbatim
+
+	And that doesn't even cover "else" cases. TiXmlHandle addresses the verbosity
+	of such code. A TiXmlHandle checks for null	pointers so it is perfectly safe 
+	and correct to use:
+
+	@verbatim
+	TiXmlHandle docHandle( &document );
+	TiXmlElement* child2 = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", 1 ).ToElement();
+	if ( child2 )
+	{
+		// do something useful
+	@endverbatim
+
+	Which is MUCH more concise and useful.
+
+	It is also safe to copy handles - internally they are nothing more than node pointers.
+	@verbatim
+	TiXmlHandle handleCopy = handle;
+	@endverbatim
+
+	What they should not be used for is iteration:
+
+	@verbatim
+	int i=0; 
+	while ( true )
+	{
+		TiXmlElement* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", i ).ToElement();
+		if ( !child )
+			break;
+		// do something
+		++i;
+	}
+	@endverbatim
+
+	It seems reasonable, but it is in fact two embedded while loops. The Child method is 
+	a linear walk to find the element, so this code would iterate much more than it needs 
+	to. Instead, prefer:
+
+	@verbatim
+	TiXmlElement* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).FirstChild( "Child" ).ToElement();
+
+	for( child; child; child=child->NextSiblingElement() )
+	{
+		// do something
+	}
+	@endverbatim
+*/
+class TiXmlHandle
+{
+public:
+	/// Create a handle from any node (at any depth of the tree.) This can be a null pointer.
+	TiXmlHandle( TiXmlNode* _node )					{ this->node = _node; }
+	/// Copy constructor
+	TiXmlHandle( const TiXmlHandle& ref )			{ this->node = ref.node; }
+	TiXmlHandle operator=( const TiXmlHandle& ref ) { this->node = ref.node; return *this; }
+
+	/// Return a handle to the first child node.
+	TiXmlHandle FirstChild() const;
+	/// Return a handle to the first child node with the given name.
+	TiXmlHandle FirstChild( const char * value ) const;
+	/// Return a handle to the first child element.
+	TiXmlHandle FirstChildElement() const;
+	/// Return a handle to the first child element with the given name.
+	TiXmlHandle FirstChildElement( const char * value ) const;
+
+	/** Return a handle to the "index" child with the given name. 
+		The first child is 0, the second 1, etc.
+	*/
+	TiXmlHandle Child( const char* value, int index ) const;
+	/** Return a handle to the "index" child. 
+		The first child is 0, the second 1, etc.
+	*/
+	TiXmlHandle Child( int index ) const;
+	/** Return a handle to the "index" child element with the given name. 
+		The first child element is 0, the second 1, etc. Note that only TiXmlElements
+		are indexed: other types are not counted.
+	*/
+	TiXmlHandle ChildElement( const char* value, int index ) const;
+	/** Return a handle to the "index" child element. 
+		The first child element is 0, the second 1, etc. Note that only TiXmlElements
+		are indexed: other types are not counted.
+	*/
+	TiXmlHandle ChildElement( int index ) const;
+
+	#ifdef TIXML_USE_STL
+	TiXmlHandle FirstChild( const std::string& _value ) const				{ return FirstChild( _value.c_str() ); }
+	TiXmlHandle FirstChildElement( const std::string& _value ) const		{ return FirstChildElement( _value.c_str() ); }
+
+	TiXmlHandle Child( const std::string& _value, int index ) const			{ return Child( _value.c_str(), index ); }
+	TiXmlHandle ChildElement( const std::string& _value, int index ) const	{ return ChildElement( _value.c_str(), index ); }
+	#endif
+
+	/** Return the handle as a TiXmlNode. This may return null.
+	*/
+	TiXmlNode* ToNode() const			{ return node; } 
+	/** Return the handle as a TiXmlElement. This may return null.
+	*/
+	TiXmlElement* ToElement() const		{ return ( ( node && node->ToElement() ) ? node->ToElement() : 0 ); }
+	/**	Return the handle as a TiXmlText. This may return null.
+	*/
+	TiXmlText* ToText() const			{ return ( ( node && node->ToText() ) ? node->ToText() : 0 ); }
+	/** Return the handle as a TiXmlUnknown. This may return null.
+	*/
+	TiXmlUnknown* ToUnknown() const		{ return ( ( node && node->ToUnknown() ) ? node->ToUnknown() : 0 ); }
+
+	/** @deprecated use ToNode. 
+		Return the handle as a TiXmlNode. This may return null.
+	*/
+	TiXmlNode* Node() const			{ return ToNode(); } 
+	/** @deprecated use ToElement. 
+		Return the handle as a TiXmlElement. This may return null.
+	*/
+	TiXmlElement* Element() const	{ return ToElement(); }
+	/**	@deprecated use ToText()
+		Return the handle as a TiXmlText. This may return null.
+	*/
+	TiXmlText* Text() const			{ return ToText(); }
+	/** @deprecated use ToUnknown()
+		Return the handle as a TiXmlUnknown. This may return null.
+	*/
+	TiXmlUnknown* Unknown() const	{ return ToUnknown(); }
+
+private:
+	TiXmlNode* node;
+};
+
+
+/** Print to memory functionality. The TiXmlPrinter is useful when you need to:
+
+	-# Print to memory (especially in non-STL mode)
+	-# Control formatting (line endings, etc.)
+
+	When constructed, the TiXmlPrinter is in its default "pretty printing" mode.
+	Before calling Accept() you can call methods to control the printing
+	of the XML document. After TiXmlNode::Accept() is called, the printed document can
+	be accessed via the CStr(), Str(), and Size() methods.
+
+	TiXmlPrinter uses the Visitor API.
+	@verbatim
+	TiXmlPrinter printer;
+	printer.SetIndent( "\t" );
+
+	doc.Accept( &printer );
+	fprintf( stdout, "%s", printer.CStr() );
+	@endverbatim
+*/
+class TiXmlPrinter : public TiXmlVisitor
+{
+public:
+	TiXmlPrinter() : depth( 0 ), simpleTextPrint( false ),
+					 buffer(), indent( "    " ), lineBreak( "\n" ) {}
+
+	virtual bool VisitEnter( const TiXmlDocument& doc );
+	virtual bool VisitExit( const TiXmlDocument& doc );
+
+	virtual bool VisitEnter( const TiXmlElement& element, const TiXmlAttribute* firstAttribute );
+	virtual bool VisitExit( const TiXmlElement& element );
+
+	virtual bool Visit( const TiXmlDeclaration& declaration );
+	virtual bool Visit( const TiXmlText& text );
+	virtual bool Visit( const TiXmlComment& comment );
+	virtual bool Visit( const TiXmlUnknown& unknown );
+
+	/** Set the indent characters for printing. By default 4 spaces
+		but tab (\t) is also useful, or null/empty string for no indentation.
+	*/
+	void SetIndent( const char* _indent )			{ indent = _indent ? _indent : "" ; }
+	/// Query the indention string.
+	const char* Indent()							{ return indent.c_str(); }
+	/** Set the line breaking string. By default set to newline (\n). 
+		Some operating systems prefer other characters, or can be
+		set to the null/empty string for no indenation.
+	*/
+	void SetLineBreak( const char* _lineBreak )		{ lineBreak = _lineBreak ? _lineBreak : ""; }
+	/// Query the current line breaking string.
+	const char* LineBreak()							{ return lineBreak.c_str(); }
+
+	/** Switch over to "stream printing" which is the most dense formatting without 
+		linebreaks. Common when the XML is needed for network transmission.
+	*/
+	void SetStreamPrinting()						{ indent = "";
+													  lineBreak = "";
+													}	
+	/// Return the result.
+	const char* CStr()								{ return buffer.c_str(); }
+	/// Return the length of the result string.
+	size_t Size()									{ return buffer.size(); }
+
+	#ifdef TIXML_USE_STL
+	/// Return the result.
+	const std::string& Str()						{ return buffer; }
+	#endif
+
+private:
+	void DoIndent()	{
+		for( int i=0; i<depth; ++i )
+			buffer += indent;
+	}
+	void DoLineBreak() {
+		buffer += lineBreak;
+	}
+
+	int depth;
+	bool simpleTextPrint;
+	TIXML_STRING buffer;
+	TIXML_STRING indent;
+	TIXML_STRING lineBreak;
+};
+
+
+#ifdef _MSC_VER
+#pragma warning( pop )
+#endif
+
+#endif
+

Added: trunk/tinyxml/tinyxmlerror.cpp
===================================================================
--- trunk/tinyxml/tinyxmlerror.cpp	2006-10-26 20:23:12 UTC (rev 357)
+++ trunk/tinyxml/tinyxmlerror.cpp	2006-10-27 17:26:03 UTC (rev 358)
@@ -0,0 +1,53 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original code (2.0 and earlier )copyright (c) 2000-2006 Lee Thomason (www.grinninglizard.com)
+
+This software is provided 'as-is', without any express or implied 
+warranty. In no event will the authors be held liable for any 
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any 
+purpose, including commercial applications, and to alter it and 
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+#include "tinyxml.h"
+
+// The goal of the seperate error file is to make the first
+// step towards localization. tinyxml (currently) only supports
+// english error messages, but the could now be translated.
+//
+// It also cleans up the code a bit.
+//
+
+const char* TiXmlBase::errorString[ TIXML_ERROR_STRING_COUNT ] =
+{
+	"No error",
+	"Error",
+	"Failed to open file",
+	"Memory allocation failed.",
+	"Error parsing Element.",
+	"Failed to read Element name",
+	"Error reading Element value.",
+	"Error reading Attributes.",
+	"Error: empty tag.",
+	"Error reading end tag.",
+	"Error parsing Unknown.",
+	"Error parsing Comment.",
+	"Error parsing Declaration.",
+	"Error document empty.",
+	"Error null (0) or unexpected EOF found in input stream.",
+	"Error parsing CDATA.",
+	"Error when TiXmlDocument added to document, because TiXmlDocument can only be at the root.",
+};

Added: trunk/tinyxml/tinyxmlparser.cpp
===================================================================
--- trunk/tinyxml/tinyxmlparser.cpp	2006-10-26 20:23:12 UTC (rev 357)
+++ trunk/tinyxml/tinyxmlparser.cpp	2006-10-27 17:26:03 UTC (rev 358)
@@ -0,0 +1,1606 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original code (2.0 and earlier )copyright (c) 2000-2002 Lee Thomason (www.grinninglizard.com)
+
+This software is provided 'as-is', without any express or implied 
+warranty. In no event will the authors be held liable for any 
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any 
+purpose, including commercial applications, and to alter it and 
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must 
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and 
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source 
+distribution.
+*/
+
+#include <ctype.h>
+#include <stddef.h>
+
+#include "tinyxml.h"
+
+//#define DEBUG_PARSER
+#if defined( DEBUG_PARSER )
+#	if defined( DEBUG ) && defined( _MSC_VER )
+#		include <windows.h>
+#		define TIXML_LOG OutputDebugString
+#	else
+#		define TIXML_LOG printf
+#	endif
+#endif
+
+// Note tha "PutString" hardcodes the same list. This
+// is less flexible than it appears. Changing the entries
+// or order will break putstring.	
+TiXmlBase::Entity TiXmlBase::entity[ NUM_ENTITY ] = 
+{
+	{ "&amp;",  5, '&' },
+	{ "&lt;",   4, '<' },
+	{ "&gt;",   4, '>' },
+	{ "&quot;", 6, '\"' },
+	{ "&apos;", 6, '\'' }
+};
+
+// Bunch of unicode info at:
+//		http://www.unicode.org/faq/utf_bom.html
+// Including the basic of this table, which determines the #bytes in the
+// sequence from the lead byte. 1 placed for invalid sequences --
+// although the result will be junk, pass it through as much as possible.
+// Beware of the non-characters in UTF-8:	
+//				ef bb bf (Microsoft "lead bytes")
+//				ef bf be
+//				ef bf bf 
+
+const unsigned char TIXML_UTF_LEAD_0 = 0xefU;
+const unsigned char TIXML_UTF_LEAD_1 = 0xbbU;
+const unsigned char TIXML_UTF_LEAD_2 = 0xbfU;
+
+const int TiXmlBase::utf8ByteTable[256] = 
+{
+	//	0	1	2	3	4	5	6	7	8	9	a	b	c	d	e	f
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x00
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x10
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x20
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x30
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x40
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x50
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x60
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x70	End of ASCII range
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x80 0x80 to 0xc1 invalid
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x90 
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0xa0 
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0xb0 
+		1,	1,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	// 0xc0 0xc2 to 0xdf 2 byte
+		2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	// 0xd0
+		3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	// 0xe0 0xe0 to 0xef 3 byte
+		4,	4,	4,	4,	4,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1	// 0xf0 0xf0 to 0xf4 4 byte, 0xf5 and higher invalid
+};
+
+
+void TiXmlBase::ConvertUTF32ToUTF8( unsigned long input, char* output, int* length )
+{
+	const unsigned long BYTE_MASK = 0xBF;
+	const unsigned long BYTE_MARK = 0x80;
+	const unsigned long FIRST_BYTE_MARK[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
+
+	if (input < 0x80) 
+		*length = 1;
+	else if ( input < 0x800 )
+		*length = 2;
+	else if ( input < 0x10000 )
+		*length = 3;
+	else if ( input < 0x200000 )
+		*length = 4;
+	else
+		{ *length = 0; return; }	// This code won't covert this correctly anyway.
+
+	output += *length;
+
+	// Scary scary fall throughs.
+	switch (*length) 
+	{
+		case 4:
+			--output; 
+			*output = (char)((input | BYTE_MARK) & BYTE_MASK); 
+			input >>= 6;
+		case 3:
+			--output; 
+			*output = (char)((input | BYTE_MARK) & BYTE_MASK); 
+			input >>= 6;
+		case 2:
+			--output; 
+			*output = (char)((input | BYTE_MARK) & BYTE_MASK); 
+			input >>= 6;
+		case 1:
+			--output; 
+			*output = (char)(input | FIRST_BYTE_MARK[*length]);
+	}
+}
+
+
+/*static*/ int TiXmlBase::IsAlpha( unsigned char anyByte, TiXmlEncoding /*encoding*/ )
+{
+	// This will only work for low-ascii, everything else is assumed to be a valid
+	// letter. I'm not sure this is the best approach, but it is quite tricky trying
+	// to figure out alhabetical vs. not across encoding. So take a very 
+	// conservative approach.
+
+//	if ( encoding == TIXML_ENCODING_UTF8 )
+//	{
+		if ( anyByte < 127 )
+			return isalpha( anyByte );
+		else
+			return 1;	// What else to do? The unicode set is huge...get the english ones right.
+//	}
+//	else
+//	{
+//		return isalpha( anyByte );
+//	}
+}
+
+
+/*static*/ int TiXmlBase::IsAlphaNum( unsigned char anyByte, TiXmlEncoding /*encoding*/ )
+{
+	// This will only work for low-ascii, everything else is assumed to be a valid
+	// letter. I'm not sure this is the best approach, but it is quite tricky trying
+	// to figure out alhabetical vs. not across encoding. So take a very 
+	// conservative approach.
+
+//	if ( encoding == TIXML_ENCODING_UTF8 )
+//	{
+		if ( anyByte < 127 )
+			return isalnum( anyByte );
+		else
+			return 1;	// What else to do? The unicode set is huge...get the english ones right.
+//	}
+//	else
+//	{
+//		return isalnum( anyByte );
+//	}
+}
+
+
+class TiXmlParsingData
+{
+	friend class TiXmlDocument;
+  public:
+	void Stamp( const char* now, TiXmlEncoding encoding );
+
+	const TiXmlCursor& Cursor()	{ return cursor; }
+
+  private:
+	// Only used by the document!
+	TiXmlParsingData( const char* start, int _tabsize, int row, int col )
+	{
+		assert( start );
+		stamp = start;
+		tabsize = _tabsize;
+		cursor.row = row;
+		cursor.col = col;
+	}
+
+	TiXmlCursor		cursor;
+	const char*		stamp;
+	int				tabsize;
+};
+
+
+void TiXmlParsingData::Stamp( const char* now, TiXmlEncoding encoding )
+{
+	assert( now );
+
+	// Do nothing if the tabsize is 0.
+	if ( tabsize < 1 )
+	{
+		return;
+	}
+
+	// Get the current row, column.
+	int row = cursor.row;
+	int col = cursor.col;
+	const char* p = stamp;
+	assert( p );
+
+	while ( p < now )
+	{
+		// Treat p as unsigned, so we have a happy compiler.
+		const unsigned char* pU = (const unsigned char*)p;
+
+		// Code contributed by Fletcher Dunn: (modified by lee)
+		switch (*pU) {
+			case 0:
+				// We *should* never get here, but in case we do, don't
+				// advance past the terminating null character, ever
+				return;
+
+			case '\r':
+				// bump down to the next line
+				++row;
+				col = 0;				
+				// Eat the character
+				++p;
+
+				// Check for \r\n sequence, and treat this as a single character
+				if (*p == '\n') {
+					++p;
+				}
+				break;
+
+			case '\n':
+				// bump down to the next line
+				++row;
+				col = 0;
+
+				// Eat the character
+				++p;
+
+				// Check for \n\r sequence, and treat this as a single
+				// character.  (Yes, this bizarre thing does occur still
+				// on some arcane platforms...)
+				if (*p == '\r') {
+					++p;
+				}
+				break;
+
+			case '\t':
+				// Eat the character
+				++p;
+
+				// Skip to next tab stop
+				col = (col / tabsize + 1) * tabsize;
+				break;
+
+			case TIXML_UTF_LEAD_0:
+				if ( encoding == TIXML_ENCODING_UTF8 )
+				{
+					if ( *(p+1) && *(p+2) )
+					{
+						// In these cases, don't advance the column. These are
+						// 0-width spaces.
+						if ( *(pU+1)==TIXML_UTF_LEAD_1 && *(pU+2)==TIXML_UTF_LEAD_2 )
+							p += 3;	
+						else if ( *(pU+1)==0xbfU && *(pU+2)==0xbeU )
+							p += 3;	
+						else if ( *(pU+1)==0xbfU && *(pU+2)==0xbfU )
+							p += 3;	
+						else
+							{ p +=3; ++col; }	// A normal character.
+					}
+				}
+				else
+				{
+					++p;
+					++col;
+				}
+				break;
+
+			default:
+				if ( encoding == TIXML_ENCODING_UTF8 )
+				{
+					// Eat the 1 to 4 byte utf8 character.
+					int step = TiXmlBase::utf8ByteTable[*((const unsigned char*)p)];
+					if ( step == 0 )
+						step = 1;		// Error case from bad encoding, but handle gracefully.
+					p += step;
+
+					// Just advance one column, of course.
+					++col;
+				}
+				else
+				{
+					++p;
+					++col;
+				}
+				break;
+		}
+	}
+	cursor.row = row;
+	cursor.col = col;
+	assert( cursor.row >= -1 );
+	assert( cursor.col >= -1 );
+	stamp = p;
+	assert( stamp );
+}
+
+
+const char* TiXmlBase::SkipWhiteSpace( const char* p, TiXmlEncoding encoding )
+{
+	if ( !p || !*p )
+	{
+		return 0;
+	}
+	if ( encoding == TIXML_ENCODING_UTF8 )
+	{
+		while ( *p )
+		{
+			const unsigned char* pU = (const unsigned char*)p;
+			
+			// Skip the stupid Microsoft UTF-8 Byte order marks
+			if (	*(pU+0)==TIXML_UTF_LEAD_0
+				 && *(pU+1)==TIXML_UTF_LEAD_1 
+				 && *(pU+2)==TIXML_UTF_LEAD_2 )
+			{
+				p += 3;
+				continue;
+			}
+			else if(*(pU+0)==TIXML_UTF_LEAD_0
+				 && *(pU+1)==0xbfU
+				 && *(pU+2)==0xbeU )
+			{
+				p += 3;
+				continue;
+			}
+			else if(*(pU+0)==TIXML_UTF_LEAD_0
+				 && *(pU+1)==0xbfU
+				 && *(pU+2)==0xbfU )
+			{
+				p += 3;
+				continue;
+			}
+
+			if ( IsWhiteSpace( *p ) || *p == '\n' || *p =='\r' )		// Still using old rules for white space.
+				++p;
+			else
+				break;
+		}
+	}
+	else
+	{
+		while ( *p && IsWhiteSpace( *p ) || *p == '\n' || *p =='\r' )
+			++p;
+	}
+
+	return p;
+}
+
+#ifdef TIXML_USE_STL
+/*static*/ bool TiXmlBase::StreamWhiteSpace( std::istream * in, TIXML_STRING * tag )
+{
+	for( ;; )
+	{
+		if ( !in->good() ) return false;
+
+		int c = in->peek();
+		// At this scope, we can't get to a document. So fail silently.
+		if ( !IsWhiteSpace( c ) || c <= 0 )
+			return true;
+
+		*tag += (char) in->get();
+	}
+}
+
+/*static*/ bool TiXmlBase::StreamTo( std::istream * in, int character, TIXML_STRING * tag )
+{
+	//assert( character > 0 && character < 128 );	// else it won't work in utf-8
+	while ( in->good() )
+	{
+		int c = in->peek();
+		if ( c == character )
+			return true;
+		if ( c <= 0 )		// Silent failure: can't get document at this scope
+			return false;
+
+		in->get();
+		*tag += (char) c;
+	}
+	return false;
+}
+#endif
+
+// One of TinyXML's more performance demanding functions. Try to keep the memory overhead down. The
+// "assign" optimization removes over 10% of the execution time.
+//
+const char* TiXmlBase::ReadName( const char* p, TIXML_STRING * name, TiXmlEncoding encoding )
+{
+	// Oddly, not supported on some comilers,
+	//name->clear();
+	// So use this:
+	*name = "";
+	assert( p );
+
+	// Names start with letters or underscores.
+	// Of course, in unicode, tinyxml has no idea what a letter *is*. The
+	// algorithm is generous.
+	//
+	// After that, they can be letters, underscores, numbers,
+	// hyphens, or colons. (Colons are valid ony for namespaces,
+	// but tinyxml can't tell namespaces from names.)
+	if (    p && *p 
+		 && ( IsAlpha( (unsigned char) *p, encoding ) || *p == '_' ) )
+	{
+		const char* start = p;
+		while(		p && *p
+				&&	(		IsAlphaNum( (unsigned char ) *p, encoding ) 
+						 || *p == '_'
+						 || *p == '-'
+						 || *p == '.'
+						 || *p == ':' ) )
+		{
+			//(*name) += *p; // expensive
+			++p;
+		}
+		if ( p-start > 0 ) {
+			name->assign( start, p-start );
+		}
+		return p;
+	}
+	return 0;
+}
+
+const char* TiXmlBase::GetEntity( const char* p, char* value, int* length, TiXmlEncoding encoding )
+{
+	// Presume an entity, and pull it out.
+    TIXML_STRING ent;
+	int i;
+	*length = 0;
+
+	if ( *(p+1) && *(p+1) == '#' && *(p+2) )
+	{
+		unsigned long ucs = 0;
+		ptrdiff_t delta = 0;
+		unsigned mult = 1;
+
+		if ( *(p+2) == 'x' )
+		{
+			// Hexadecimal.
+			if ( !*(p+3) ) return 0;
+
+			const char* q = p+3;
+			q = strchr( q, ';' );
+
+			if ( !q || !*q ) return 0;
+
+			delta = q-p;
+			--q;
+
+			while ( *q != 'x' )
+			{
+				if ( *q >= '0' && *q <= '9' )
+					ucs += mult * (*q - '0');
+				else if ( *q >= 'a' && *q <= 'f' )
+					ucs += mult * (*q - 'a' + 10);
+				else if ( *q >= 'A' && *q <= 'F' )
+					ucs += mult * (*q - 'A' + 10 );
+				else 
+					return 0;
+				mult *= 16;
+				--q;
+			}
+		}
+		else
+		{
+			// Decimal.
+			if ( !*(p+2) ) return 0;
+
+			const char* q = p+2;
+			q = strchr( q, ';' );
+
+			if ( !q || !*q ) return 0;
+
+			delta = q-p;
+			--q;
+
+			while ( *q != '#' )
+			{
+				if ( *q >= '0' && *q <= '9' )
+					ucs += mult * (*q - '0');
+				else 
+					return 0;
+				mult *= 10;
+				--q;
+			}
+		}
+		if ( encoding == TIXML_ENCODING_UTF8 )
+		{
+			// convert the UCS to UTF-8
+			ConvertUTF32ToUTF8( ucs, value, length );
+		}
+		else
+		{
+			*value = (char)ucs;
+			*length = 1;
+		}
+		return p + delta + 1;
+	}
+
+	// Now try to match it.
+	for( i=0; i<NUM_ENTITY; ++i )
+	{
+		if ( strncmp( entity[i].str, p, entity[i].strLength ) == 0 )
+		{
+			assert( strlen( entity[i].str ) == entity[i].strLength );
+			*value = entity[i].chr;
+			*length = 1;
+			return ( p + entity[i].strLength );
+		}
+	}
+
+	// So it wasn't an entity, its unrecognized, or something like that.
+	*value = *p;	// Don't put back the last one, since we return it!
+	//*length = 1;	// Leave unrecognized entities - this doesn't really work.
+					// Just writes strange XML.
+	return p+1;
+}
+
+
+bool TiXmlBase::StringEqual( const char* p,
+							 const char* tag,
+							 bool ignoreCase,
+							 TiXmlEncoding encoding )
+{
+	assert( p );
+	assert( tag );
+	if ( !p || !*p )
+	{
+		assert( 0 );
+		return false;
+	}
+
+	const char* q = p;
+
+	if ( ignoreCase )
+	{
+		while ( *q && *tag && ToLower( *q, encoding ) == ToLower( *tag, encoding ) )
+		{
+			++q;
+			++tag;
+		}
+
+		if ( *tag == 0 )
+			return true;
+	}
+	else
+	{
+		while ( *q && *tag && *q == *tag )
+		{
+			++q;
+			++tag;
+		}
+
+		if ( *tag == 0 )		// Have we found the end of the tag, and everything equal?
+			return true;
+	}
+	return false;
+}
+
+const char* TiXmlBase::ReadText(	const char* p, 
+									TIXML_STRING * text, 
+									bool trimWhiteSpace, 
+									const char* endTag, 
+									bool caseInsensitive,
+									TiXmlEncoding encoding )
+{
+    *text = "";
+	if (    !trimWhiteSpace			// certain tags always keep whitespace
+		 || !condenseWhiteSpace )	// if true, whitespace is always kept
+	{
+		// Keep all the white space.
+		while (	   p && *p
+				&& !StringEqual( p, endTag, caseInsensitive, encoding )
+			  )
+		{
+			int len;
+			char cArr[4] = { 0, 0, 0, 0 };
+			p = GetChar( p, cArr, &len, encoding );
+			text->append( cArr, len );
+		}
+	}
+	else
+	{
+		bool whitespace = false;
+
+		// Remove leading white space:
+		p = SkipWhiteSpace( p, encoding );
+		while (	   p && *p
+				&& !StringEqual( p, endTag, caseInsensitive, encoding ) )
+		{
+			if ( *p == '\r' || *p == '\n' )
+			{
+				whitespace = true;
+				++p;
+			}
+			else if ( IsWhiteSpace( *p ) )
+			{
+				whitespace = true;
+				++p;
+			}
+			else
+			{
+				// If we've found whitespace, add it before the
+				// new character. Any whitespace just becomes a space.
+				if ( whitespace )
+				{
+					(*text) += ' ';
+					whitespace = false;
+				}
+				int len;
+				char cArr[4] = { 0, 0, 0, 0 };
+				p = GetChar( p, cArr, &len, encoding );
+				if ( len == 1 )
+					(*text) += cArr[0];	// more efficient
+				else
+					text->append( cArr, len );
+			}
+		}
+	}
+	if ( p ) 
+		p += strlen( endTag );
+	return p;
+}
+
+#ifdef TIXML_USE_STL
+
+void TiXmlDocument::StreamIn( std::istream * in, TIXML_STRING * tag )
+{
+	// The basic issue with a document is that we don't know what we're
+	// streaming. Read something presumed to be a tag (and hope), then
+	// identify it, and call the appropriate stream method on the tag.
+	//
+	// This "pre-streaming" will never read the closing ">" so the
+	// sub-tag can orient itself.
+
+	if ( !StreamTo( in, '<', tag ) ) 
+	{
+		SetError( TIXML_ERROR_PARSING_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return;
+	}
+
+	while ( in->good() )
+	{
+		int tagIndex = (int) tag->length();
+		while ( in->good() && in->peek() != '>' )
+		{
+			int c = in->get();
+			if ( c <= 0 )
+			{
+				SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+				break;
+			}
+			(*tag) += (char) c;
+		}
+
+		if ( in->good() )
+		{
+			// We now have something we presume to be a node of 
+			// some sort. Identify it, and call the node to
+			// continue streaming.
+			TiXmlNode* node = Identify( tag->c_str() + tagIndex, TIXML_DEFAULT_ENCODING );
+
+			if ( node )
+			{
+				node->StreamIn( in, tag );
+				bool isElement = node->ToElement() != 0;
+				delete node;
+				node = 0;
+
+				// If this is the root element, we're done. Parsing will be
+				// done by the >> operator.
+				if ( isElement )
+				{
+					return;
+				}
+			}
+			else
+			{
+				SetError( TIXML_ERROR, 0, 0, TIXML_ENCODING_UNKNOWN );
+				return;
+			}
+		}
+	}
+	// We should have returned sooner.
+	SetError( TIXML_ERROR, 0, 0, TIXML_ENCODING_UNKNOWN );
+}
+
+#endif
+
+const char* TiXmlDocument::Parse( const char* p, TiXmlParsingData* prevData, TiXmlEncoding encoding )
+{
+	ClearError();
+
+	// Parse away, at the document level. Since a document
+	// contains nothing but other tags, most of what happens
+	// here is skipping white space.
+	if ( !p || !*p )
+	{
+		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+
+	// Note that, for a document, this needs to come
+	// before the while space skip, so that parsing
+	// starts from the pointer we are given.
+	location.Clear();
+	if ( prevData )
+	{
+		location.row = prevData->cursor.row;
+		location.col = prevData->cursor.col;
+	}
+	else
+	{
+		location.row = 0;
+		location.col = 0;
+	}
+	TiXmlParsingData data( p, TabSize(), location.row, location.col );
+	location = data.Cursor();
+
+	if ( encoding == TIXML_ENCODING_UNKNOWN )
+	{
+		// Check for the Microsoft UTF-8 lead bytes.
+		const unsigned char* pU = (const unsigned char*)p;
+		if (	*(pU+0) && *(pU+0) == TIXML_UTF_LEAD_0
+			 && *(pU+1) && *(pU+1) == TIXML_UTF_LEAD_1
+			 && *(pU+2) && *(pU+2) == TIXML_UTF_LEAD_2 )
+		{
+			encoding = TIXML_ENCODING_UTF8;
+			useMicrosoftBOM = true;
+		}
+	}
+
+    p = SkipWhiteSpace( p, encoding );
+	if ( !p )
+	{
+		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+
+	while ( p && *p )
+	{
+		TiXmlNode* node = Identify( p, encoding );
+		if ( node )
+		{
+			p = node->Parse( p, &data, encoding );
+			LinkEndChild( node );
+		}
+		else
+		{
+			break;
+		}
+
+		// Did we get encoding info?
+		if (    encoding == TIXML_ENCODING_UNKNOWN
+			 && node->ToDeclaration() )
+		{
+			TiXmlDeclaration* dec = node->ToDeclaration();
+			const char* enc = dec->Encoding();
+			assert( enc );
+
+			if ( *enc == 0 )
+				encoding = TIXML_ENCODING_UTF8;
+			else if ( StringEqual( enc, "UTF-8", true, TIXML_ENCODING_UNKNOWN ) )
+				encoding = TIXML_ENCODING_UTF8;
+			else if ( StringEqual( enc, "UTF8", true, TIXML_ENCODING_UNKNOWN ) )
+				encoding = TIXML_ENCODING_UTF8;	// incorrect, but be nice
+			else 
+				encoding = TIXML_ENCODING_LEGACY;
+		}
+
+		p = SkipWhiteSpace( p, encoding );
+	}
+
+	// Was this empty?
+	if ( !firstChild ) {
+		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, encoding );
+		return 0;
+	}
+
+	// All is well.
+	return p;
+}
+
+void TiXmlDocument::SetError( int err, const char* pError, TiXmlParsingData* data, TiXmlEncoding encoding )
+{	
+	// The first error in a chain is more accurate - don't set again!
+	if ( error )
+		return;
+
+	assert( err > 0 && err < TIXML_ERROR_STRING_COUNT );
+	error   = true;
+	errorId = err;
+	errorDesc = errorString[ errorId ];
+
+	errorLocation.Clear();
+	if ( pError && data )
+	{
+		data->Stamp( pError, encoding );
+		errorLocation = data->Cursor();
+	}
+}
+
+
+TiXmlNode* TiXmlNode::Identify( const char* p, TiXmlEncoding encoding )
+{
+	TiXmlNode* returnNode = 0;
+
+	p = SkipWhiteSpace( p, encoding );
+	if( !p || !*p || *p != '<' )
+	{
+		return 0;
+	}
+
+	TiXmlDocument* doc = GetDocument();
+	p = SkipWhiteSpace( p, encoding );
+
+	if ( !p || !*p )
+	{
+		return 0;
+	}
+
+	// What is this thing? 
+	// - Elements start with a letter or underscore, but xml is reserved.
+	// - Comments: <!--
+	// - Decleration: <?xml
+	// - Everthing else is unknown to tinyxml.
+	//
+
+	const char* xmlHeader = { "<?xml" };
+	const char* commentHeader = { "<!--" };
+	const char* dtdHeader = { "<!" };
+	const char* cdataHeader = { "<![CDATA[" };
+
+	if ( StringEqual( p, xmlHeader, true, encoding ) )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Declaration\n" );
+		#endif
+		returnNode = new TiXmlDeclaration();
+	}
+	else if ( StringEqual( p, commentHeader, false, encoding ) )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Comment\n" );
+		#endif
+		returnNode = new TiXmlComment();
+	}
+	else if ( StringEqual( p, cdataHeader, false, encoding ) )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing CDATA\n" );
+		#endif
+		TiXmlText* text = new TiXmlText( "" );
+		text->SetCDATA( true );
+		returnNode = text;
+	}
+	else if ( StringEqual( p, dtdHeader, false, encoding ) )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Unknown(1)\n" );
+		#endif
+		returnNode = new TiXmlUnknown();
+	}
+	else if (    IsAlpha( *(p+1), encoding )
+			  || *(p+1) == '_' )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Element\n" );
+		#endif
+		returnNode = new TiXmlElement( "" );
+	}
+	else
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Unknown(2)\n" );
+		#endif
+		returnNode = new TiXmlUnknown();
+	}
+
+	if ( returnNode )
+	{
+		// Set the parent, so it can report errors
+		returnNode->parent = this;
+	}
+	else
+	{
+		if ( doc )
+			doc->SetError( TIXML_ERROR_OUT_OF_MEMORY, 0, 0, TIXML_ENCODING_UNKNOWN );
+	}
+	return returnNode;
+}
+
+#ifdef TIXML_USE_STL
+
+void TiXmlElement::StreamIn (std::istream * in, TIXML_STRING * tag)
+{
+	// We're called with some amount of pre-parsing. That is, some of "this"
+	// element is in "tag". Go ahead and stream to the closing ">"
+	while( in->good() )
+	{
+		int c = in->get();
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+		(*tag) += (char) c ;
+		
+		if ( c == '>' )
+			break;
+	}
+
+	if ( tag->length() < 3 ) return;
+
+	// Okay...if we are a "/>" tag, then we're done. We've read a complete tag.
+	// If not, identify and stream.
+
+	if (    tag->at( tag->length() - 1 ) == '>' 
+		 && tag->at( tag->length() - 2 ) == '/' )
+	{
+		// All good!
+		return;
+	}
+	else if ( tag->at( tag->length() - 1 ) == '>' )
+	{
+		// There is more. Could be:
+		//		text
+		//		cdata text (which looks like another node)
+		//		closing tag
+		//		another node.
+		for ( ;; )
+		{
+			StreamWhiteSpace( in, tag );
+
+			// Do we have text?
+			if ( in->good() && in->peek() != '<' ) 
+			{
+				// Yep, text.
+				TiXmlText text( "" );
+				text.StreamIn( in, tag );
+
+				// What follows text is a closing tag or another node.
+				// Go around again and figure it out.
+				continue;
+			}
+
+			// We now have either a closing tag...or another node.
+			// We should be at a "<", regardless.
+			if ( !in->good() ) return;
+			assert( in->peek() == '<' );
+			int tagIndex = (int) tag->length();
+
+			bool closingTag = false;
+			bool firstCharFound = false;
+
+			for( ;; )
+			{
+				if ( !in->good() )
+					return;
+
+				int c = in->peek();
+				if ( c <= 0 )
+				{
+					TiXmlDocument* document = GetDocument();
+					if ( document )
+						document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+					return;
+				}
+				
+				if ( c == '>' )
+					break;
+
+				*tag += (char) c;
+				in->get();
+
+				// Early out if we find the CDATA id.
+				if ( c == '[' && tag->size() >= 9 )
+				{
+					size_t len = tag->size();
+					const char* start = tag->c_str() + len - 9;
+					if ( strcmp( start, "<![CDATA[" ) == 0 ) {
+						assert( !closingTag );
+						break;
+					}
+				}
+
+				if ( !firstCharFound && c != '<' && !IsWhiteSpace( c ) )
+				{
+					firstCharFound = true;
+					if ( c == '/' )
+						closingTag = true;
+				}
+			}
+			// If it was a closing tag, then read in the closing '>' to clean up the input stream.
+			// If it was not, the streaming will be done by the tag.
+			if ( closingTag )
+			{
+				if ( !in->good() )
+					return;
+
+				int c = in->get();
+				if ( c <= 0 )
+				{
+					TiXmlDocument* document = GetDocument();
+					if ( document )
+						document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+					return;
+				}
+				assert( c == '>' );
+				*tag += (char) c;
+
+				// We are done, once we've found our closing tag.
+				return;
+			}
+			else
+			{
+				// If not a closing tag, id it, and stream.
+				const char* tagloc = tag->c_str() + tagIndex;
+				TiXmlNode* node = Identify( tagloc, TIXML_DEFAULT_ENCODING );
+				if ( !node )
+					return;
+				node->StreamIn( in, tag );
+				delete node;
+				node = 0;
+
+				// No return: go around from the beginning: text, closing tag, or node.
+			}
+		}
+	}
+}
+#endif
+
+const char* TiXmlElement::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	p = SkipWhiteSpace( p, encoding );
+	TiXmlDocument* document = GetDocument();
+
+	if ( !p || !*p )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, 0, 0, encoding );
+		return 0;
+	}
+
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+
+	if ( *p != '<' )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, p, data, encoding );
+		return 0;
+	}
+
+	p = SkipWhiteSpace( p+1, encoding );
+
+	// Read the name.
+	const char* pErr = p;
+
+    p = ReadName( p, &value, encoding );
+	if ( !p || !*p )
+	{
+		if ( document )	document->SetError( TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME, pErr, data, encoding );
+		return 0;
+	}
+
+    TIXML_STRING endTag ("</");
+	endTag += value;
+	endTag += ">";
+
+	// Check for and read attributes. Also look for an empty
+	// tag or an end tag.
+	while ( p && *p )
+	{
+		pErr = p;
+		p = SkipWhiteSpace( p, encoding );
+		if ( !p || !*p )
+		{
+			if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, pErr, data, encoding );
+			return 0;
+		}
+		if ( *p == '/' )
+		{
+			++p;
+			// Empty tag.
+			if ( *p  != '>' )
+			{
+				if ( document ) document->SetError( TIXML_ERROR_PARSING_EMPTY, p, data, encoding );		
+				return 0;
+			}
+			return (p+1);
+		}
+		else if ( *p == '>' )
+		{
+			// Done with attributes (if there were any.)
+			// Read the value -- which can include other
+			// elements -- read the end tag, and return.
+			++p;
+			p = ReadValue( p, data, encoding );		// Note this is an Element method, and will set the error if one happens.
+			if ( !p || !*p )
+				return 0;
+
+			// We should find the end tag now
+			if ( StringEqual( p, endTag.c_str(), false, encoding ) )
+			{
+				p += endTag.length();
+				return p;
+			}
+			else
+			{
+				if ( document ) document->SetError( TIXML_ERROR_READING_END_TAG, p, data, encoding );
+				return 0;
+			}
+		}
+		else
+		{
+			// Try to read an attribute:
+			TiXmlAttribute* attrib = new TiXmlAttribute();
+			if ( !attrib )
+			{
+				if ( document ) document->SetError( TIXML_ERROR_OUT_OF_MEMORY, pErr, data, encoding );
+				return 0;
+			}
+
+			attrib->SetDocument( document );
+			pErr = p;
+			p = attrib->Parse( p, data, encoding );
+
+			if ( !p || !*p )
+			{
+				if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, pErr, data, encoding );
+				delete attrib;
+				return 0;
+			}
+
+			// Handle the strange case of double attributes:
+			#ifdef TIXML_USE_STL
+			TiXmlAttribute* node = attributeSet.Find( attrib->NameTStr() );
+			#else
+			TiXmlAttribute* node = attributeSet.Find( attrib->Name() );
+			#endif
+			if ( node )
+			{
+				node->SetValue( attrib->Value() );
+				delete attrib;
+				return 0;
+			}
+
+			attributeSet.Add( attrib );
+		}
+	}
+	return p;
+}
+
+
+const char* TiXmlElement::ReadValue( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	TiXmlDocument* document = GetDocument();
+
+	// Read in text and elements in any order.
+	const char* pWithWhiteSpace = p;
+	p = SkipWhiteSpace( p, encoding );
+
+	while ( p && *p )
+	{
+		if ( *p != '<' )
+		{
+			// Take what we have, make a text element.
+			TiXmlText* textNode = new TiXmlText( "" );
+
+			if ( !textNode )
+			{
+				if ( document ) document->SetError( TIXML_ERROR_OUT_OF_MEMORY, 0, 0, encoding );
+				    return 0;
+			}
+
+			if ( TiXmlBase::IsWhiteSpaceCondensed() )
+			{
+				p = textNode->Parse( p, data, encoding );
+			}
+			else
+			{
+				// Special case: we want to keep the white space
+				// so that leading spaces aren't removed.
+				p = textNode->Parse( pWithWhiteSpace, data, encoding );
+			}
+
+			if ( !textNode->Blank() )
+				LinkEndChild( textNode );
+			else
+				delete textNode;
+		} 
+		else 
+		{
+			// We hit a '<'
+			// Have we hit a new element or an end tag? This could also be
+			// a TiXmlText in the "CDATA" style.
+			if ( StringEqual( p, "</", false, encoding ) )
+			{
+				return p;
+			}
+			else
+			{
+				TiXmlNode* node = Identify( p, encoding );
+				if ( node )
+				{
+					p = node->Parse( p, data, encoding );
+					LinkEndChild( node );
+				}				
+				else
+				{
+					return 0;
+				}
+			}
+		}
+		pWithWhiteSpace = p;
+		p = SkipWhiteSpace( p, encoding );
+	}
+
+	if ( !p )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_READING_ELEMENT_VALUE, 0, 0, encoding );
+	}	
+	return p;
+}
+
+
+#ifdef TIXML_USE_STL
+void TiXmlUnknown::StreamIn( std::istream * in, TIXML_STRING * tag )
+{
+	while ( in->good() )
+	{
+		int c = in->get();	
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+		(*tag) += (char) c;
+
+		if ( c == '>' )
+		{
+			// All is well.
+			return;		
+		}
+	}
+}
+#endif
+
+
+const char* TiXmlUnknown::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	TiXmlDocument* document = GetDocument();
+	p = SkipWhiteSpace( p, encoding );
+
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+	if ( !p || !*p || *p != '<' )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_PARSING_UNKNOWN, p, data, encoding );
+		return 0;
+	}
+	++p;
+    value = "";
+
+	while ( p && *p && *p != '>' )
+	{
+		value += *p;
+		++p;
+	}
+
+	if ( !p )
+	{
+		if ( document )	document->SetError( TIXML_ERROR_PARSING_UNKNOWN, 0, 0, encoding );
+	}
+	if ( *p == '>' )
+		return p+1;
+	return p;
+}
+
+#ifdef TIXML_USE_STL
+void TiXmlComment::StreamIn( std::istream * in, TIXML_STRING * tag )
+{
+	while ( in->good() )
+	{
+		int c = in->get();	
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+
+		(*tag) += (char) c;
+
+		if ( c == '>' 
+			 && tag->at( tag->length() - 2 ) == '-'
+			 && tag->at( tag->length() - 3 ) == '-' )
+		{
+			// All is well.
+			return;		
+		}
+	}
+}
+#endif
+
+
+const char* TiXmlComment::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	TiXmlDocument* document = GetDocument();
+	value = "";
+
+	p = SkipWhiteSpace( p, encoding );
+
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+	const char* startTag = "<!--";
+	const char* endTag   = "-->";
+
+	if ( !StringEqual( p, startTag, false, encoding ) )
+	{
+		document->SetError( TIXML_ERROR_PARSING_COMMENT, p, data, encoding );
+		return 0;
+	}
+	p += strlen( startTag );
+	p = ReadText( p, &value, false, endTag, false, encoding );
+	return p;
+}
+
+
+const char* TiXmlAttribute::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	p = SkipWhiteSpace( p, encoding );
+	if ( !p || !*p ) return 0;
+
+//	int tabsize = 4;
+//	if ( document )
+//		tabsize = document->TabSize();
+
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+	// Read the name, the '=' and the value.
+	const char* pErr = p;
+	p = ReadName( p, &name, encoding );
+	if ( !p || !*p )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, pErr, data, encoding );
+		return 0;
+	}
+	p = SkipWhiteSpace( p, encoding );
+	if ( !p || !*p || *p != '=' )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );
+		return 0;
+	}
+
+	++p;	// skip '='
+	p = SkipWhiteSpace( p, encoding );
+	if ( !p || !*p )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );
+		return 0;
+	}
+	
+	const char* end;
+	const char SINGLE_QUOTE = '\'';
+	const char DOUBLE_QUOTE = '\"';
+
+	if ( *p == SINGLE_QUOTE )
+	{
+		++p;
+		end = "\'";		// single quote in string
+		p = ReadText( p, &value, false, end, false, encoding );
+	}
+	else if ( *p == DOUBLE_QUOTE )
+	{
+		++p;
+		end = "\"";		// double quote in string
+		p = ReadText( p, &value, false, end, false, encoding );
+	}
+	else
+	{
+		// All attribute values should be in single or double quotes.
+		// But this is such a common error that the parser will try
+		// its best, even without them.
+		value = "";
+		while (    p && *p											// existence
+				&& !IsWhiteSpace( *p ) && *p != '\n' && *p != '\r'	// whitespace
+				&& *p != '/' && *p != '>' )							// tag end
+		{
+			if ( *p == SINGLE_QUOTE || *p == DOUBLE_QUOTE ) {
+				// [ 1451649 ] Attribute values with trailing quotes not handled correctly
+				// We did not have an opening quote but seem to have a 
+				// closing one. Give up and throw an error.
+				if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );
+				return 0;
+			}
+			value += *p;
+			++p;
+		}
+	}
+	return p;
+}
+
+#ifdef TIXML_USE_STL
+void TiXmlText::StreamIn( std::istream * in, TIXML_STRING * tag )
+{
+	while ( in->good() )
+	{
+		int c = in->peek();	
+		if ( !cdata && (c == '<' ) ) 
+		{
+			return;
+		}
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+
+		(*tag) += (char) c;
+		in->get();	// "commits" the peek made above
+
+		if ( cdata && c == '>' && tag->size() >= 3 ) {
+			size_t len = tag->size();
+			if ( (*tag)[len-2] == ']' && (*tag)[len-3] == ']' ) {
+				// terminator of cdata.
+				return;
+			}
+		}    
+	}
+}
+#endif
+
+const char* TiXmlText::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	value = "";
+	TiXmlDocument* document = GetDocument();
+
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+
+	const char* const startTag = "<![CDATA[";
+	const char* const endTag   = "]]>";
+
+	if ( cdata || StringEqual( p, startTag, false, encoding ) )
+	{
+		cdata = true;
+
+		if ( !StringEqual( p, startTag, false, encoding ) )
+		{
+			document->SetError( TIXML_ERROR_PARSING_CDATA, p, data, encoding );
+			return 0;
+		}
+		p += strlen( startTag );
+
+		// Keep all the white space, ignore the encoding, etc.
+		while (	   p && *p
+				&& !StringEqual( p, endTag, false, encoding )
+			  )
+		{
+			value += *p;
+			++p;
+		}
+
+		TIXML_STRING dummy; 
+		p = ReadText( p, &dummy, false, endTag, false, encoding );
+		return p;
+	}
+	else
+	{
+		bool ignoreWhite = true;
+
+		const char* end = "<";
+		p = ReadText( p, &value, ignoreWhite, end, false, encoding );
+		if ( p )
+			return p-1;	// don't truncate the '<'
+		return 0;
+	}
+}
+
+#ifdef TIXML_USE_STL
+void TiXmlDeclaration::StreamIn( std::istream * in, TIXML_STRING * tag )
+{
+	while ( in->good() )
+	{
+		int c = in->get();
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+		(*tag) += (char) c;
+
+		if ( c == '>' )
+		{
+			// All is well.
+			return;
+		}
+	}
+}
+#endif
+
+const char* TiXmlDeclaration::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding _encoding )
+{
+	p = SkipWhiteSpace( p, _encoding );
+	// Find the beginning, find the end, and look for
+	// the stuff in-between.
+	TiXmlDocument* document = GetDocument();
+	if ( !p || !*p || !StringEqual( p, "<?xml", true, _encoding ) )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_PARSING_DECLARATION, 0, 0, _encoding );
+		return 0;
+	}
+	if ( data )
+	{
+		data->Stamp( p, _encoding );
+		location = data->Cursor();
+	}
+	p += 5;
+
+	version = "";
+	encoding = "";
+	standalone = "";
+
+	while ( p && *p )
+	{
+		if ( *p == '>' )
+		{
+			++p;
+			return p;
+		}
+
+		p = SkipWhiteSpace( p, _encoding );
+		if ( StringEqual( p, "version", true, _encoding ) )
+		{
+			TiXmlAttribute attrib;
+			p = attrib.Parse( p, data, _encoding );		
+			version = attrib.Value();
+		}
+		else if ( StringEqual( p, "encoding", true, _encoding ) )
+		{
+			TiXmlAttribute attrib;
+			p = attrib.Parse( p, data, _encoding );		
+			encoding = attrib.Value();
+		}
+		else if ( StringEqual( p, "standalone", true, _encoding ) )
+		{
+			TiXmlAttribute attrib;
+			p = attrib.Parse( p, data, _encoding );		
+			standalone = attrib.Value();
+		}
+		else
+		{
+			// Read over whatever it is.
+			while( p && *p && *p != '>' && !IsWhiteSpace( *p ) )
+				++p;
+		}
+	}
+	return 0;
+}
+
+bool TiXmlText::Blank() const
+{
+	for ( unsigned i=0; i<value.length(); i++ )
+		if ( !IsWhiteSpace( value[i] ) )
+			return false;
+	return true;
+}
+



From pavlenko at mail.berlios.de  Fri Oct 27 19:26:46 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Fri, 27 Oct 2006 19:26:46 +0200
Subject: [Mapnik-svn] r359 - trunk/tinyxml
Message-ID: <200610271726.k9RHQksQ016238@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-27 19:26:45 +0200 (Fri, 27 Oct 2006)
New Revision: 359

Removed:
   trunk/tinyxml/.sconsign
Log:
dont need those

Deleted: trunk/tinyxml/.sconsign
===================================================================
--- trunk/tinyxml/.sconsign	2006-10-27 17:26:03 UTC (rev 358)
+++ trunk/tinyxml/.sconsign	2006-10-27 17:26:45 UTC (rev 359)
@@ -1,8 +0,0 @@
-}q(Utinyxmlparser.osq(cSCons.Node.FS
-BuildInfo
-qoq}q(UbsigqU 3b15f27196beb6fc8d342079cbb4d105qU	bimplicitq]q	(U/usr/include/ctype.hq
-Utinyxml/tinyxml.hqU/usr/include/bits/types.hqU/usr/include/endian.hqU/usr/include/features.hqU/usr/include/xlocale.hqU/usr/include/assert.hqU/usr/include/stdio.hqU/usr/include/stdlib.hqU/usr/include/string.hqUtinyxml/tinystr.hqU/usr/include/bits/typesizes.hqU/usr/include/bits/wordsize.hqU/usr/include/bits/endian.hqU/usr/include/gnu/stubs.hqU/usr/include/sys/cdefs.hqU/usr/include/bits/stdio-ldbl.hqU/usr/include/bits/stdio.hqU/usr/include/bits/stdio2.hqU/usr/include/bits/stdio_lim.hqU/usr/include/bits/sys_errlist.hqU/usr/include/getopt.hqU/usr/include/libio.hq U/usr/include/alloca.hq!U/usr/include/bits/stdlib-ldbl.hq"U/usr/include/bits/stdlib.hq#U/usr/include/bits/waitflags.hq$U/usr/include/bits/waitstatus.hq%U/usr/include/sys/types.hq&U/usr/include/bits/string.hq'U/usr/include/bits/string2.hq(U/usr/include/bits/string3.hq)U/usr/include/gnu/stubs-32.hq*U/usr/include/gnu/stubs-64.hq+U/usr/include/_G_config.hq,U/usr/inclu!
 de/bits/libio-ldbl.hq-U/usr/include/bits/stdio-lock.hq.U /usr/include/bits/pthreadtypes.hq/U/usr/include/sys/select.hq0U/usr/include/sys/sysmacros.hq1U/usr/include/time.hq2U/usr/include/gconv.hq3U/usr/include/wchar.hq4U/usr/include/bits/libc-lock.hq5U/usr/include/bits/select.hq6U/usr/include/bits/sigset.hq7U/usr/include/bits/time.hq8U/usr/include/bits/wchar-ldbl.hq9U/usr/include/bits/wchar.hq:U/usr/include/bits/wchar2.hq;U/usr/include/wctype.hq<U/usr/include/pthread.hq=U/usr/include/bits/setjmp.hq>U/usr/include/sched.hq?U/usr/include/signal.hq at U/usr/include/bits/sched.hqAU/usr/include/bits/sigaction.hqBU/usr/include/bits/sigcontext.hqCU/usr/include/bits/siginfo.hqDU/usr/include/bits/signum.hqEU/usr/include/bits/sigstack.hqFU/usr/include/bits/sigthread.hqGU/usr/include/sys/ucontext.hqHeUbdependsqI]qJUbdependsigsqK]qLUbactsigqMU 1b5f699029656e4c248928d88a176771qNUbimplicitsigsqO]qP(U 00837daf31513ddb9efcdbe263e308e5qQU 4aecfb7c99af3fbaa13197f8cc1!
 2cc6dqRU c879f7ba4b8895420c23d9906b38ab9aqSU 842fadea2a9f05467!
 65ff04d0
6e62967qTU 414a080c648c4260bcd8142023fa150eqUU 19fdaa6e1408817d208fc02fd290f894qVU cdf2e4e7d7d8cfa02c8b1e1d6bb736c4qWU 3ef14c4f0793fc0aaba4b9c2f1f6f970qXU 6303c8f8a41b3cd547a428b086d3758bqYU 97f4bcf2a68b10df1ed4f542659a00a0qZU cf367876ee833646804f79b5dd331d83q[U af928b23500851e2da8cd3ec56d56edfq\U 30529eb770bdf401a7dc82c1659f4364q]U 93f54525ca894fe9c4f79236cd9b8bf3q^U 326ea516d2af549d9de3f71532c4e4e4q_U fc5d92924ea883f42d365cc93861c9d5q`U 7c11f8933ac7b548a32a01f73c77f421qaU 9e616d743e5168f8702488621bbd71fcqbU ea6cc4a9f17cdab6d6395bea155409e1qcU bc8b1b1d13e5e69133f85c645f7e2a06qdU e7734f693e8e68fcc97d98e790d024a1qeU d8703f5c9901bb223fc702fedfbd8c26qfU 0a85bb56583eaf5fc0a7c463e8f99db6qgU 2cd6c8d99645ffaa331ba97e071bca67qhU bd02283aea53c6987e065658626029aeqiU 7ec95934743cee49027e91666f902d22qjU 655eb29e7f589e68eb1016141f2ffe43qkU 8354b3a67075f5d1707f2ddc0f640057qlU ac5b3da3ea53cf7141c907159c436822qmU 70dede2383ed520334e91a4ced6cce0eqnU 09f0a8c5e15ffcd80e16d06f96ff2611qoU 7107d4!
 68e137449079ccca0c579ff9c0qpU b7a6db7b7113f0fada181c6551ed7628qqU 0e0d4bae163cca7306bbd31d566b1e7eqrU 1f3b5cd1da91bfb14be76d6ae6fa3b73qsU 11692a4c660a6580512982d342df569bqtU 2122e500b4fa13bc1c53a3f7c2b9743aquU b0b16c03afc71a223fe787e1dd60479fqvU 3ac38d7e2f9203f1343788fe7a736c4dqwU 699fc672171b2a03f9e3e6d66d43b46eqxU a701f3f77dc321259da9e5945328f3c5qyU 4f47ba062d4253ea801ef1e341976b8bqzU 956bf16b318fa7b0cb9c74bedde44720q{U 9ea7a1a26a3e1d1bb9e7f4a57ff36d2dq|U bb161dc5a7b233a76c3ac3c389cef8d8q}U 5be4663919ae70a2a63143f4cf3e23c1q~U 39b0c941e291970324de2709f164c3beqU 93ddad90561b2e439cfac383be62bdd0q?U 5410df383b37c676526e62554f9ac274q?U 81302455beb60e076adbb9ee5e79d339q?U 571d50db99ee111540c2efa57c396936q?U 86b69ed9e41beedefa3ae8025bf4087dq?U 569f5de580970655042e7b79f08ca930q?U 1813916f93a067876c1770d20b68bcfcq?U 141cee46916334fafee988d52eeb74abq?U 087f4d86feab2e1d99ecb6b5b4c902c5q?U 7083cc35df3247290d30d008513fef47q?U 186444b0a87c414e012aa8d0f46e7fd9q?U d9aea83a7368b5597a7d79!
 f0075a90f4q?U bc480b97ac477ff40a3ad689a1296f4dq?U 97fdbb81a16c!
 152c9c79
dcbf576edea4q?U 273a1126f9bf268a25be640a9d932c00q?U 73fc6a2a32678895efb9141fc7655e7fq?eUbactq?U?g++ -ansi -Wall -ftemplate-depth-100 -O3 -finline-functions -Wno-inline -pthread -DNDEBUG -DBOOST_PROPERTY_TREE_XML_PARSER_TINYXML -DTIXML_USE_STL -fPIC -c -o tinyxmlparser.os tinyxmlparser.cppq?Ubsourcesq?]q?Utinyxml/tinyxmlparser.cppq?aUbsourcesigsq?]q?U 4e570ff625b08425eea1f59c40808ae7q?aubUtinyxmlerror.cppq?(hoq?}q?(U	timestampq?J??9EUcsigq?U cf5c6f205d9c15967401977bcef750c6q?ubU	tinystr.hq?(hoq?}q?(U	timestampq?J??9EUcsigq?h[ubU
-tinyxml.osq?(hoq?}q?(hU a380edf8aeb71f8efd3613406ff9413aq?h]q?(h
-hhhhhhhhhhhhhhhhhhhhhh h!h"h#h$h%h&h'h(h)h*h+h,h-h.h/h0h1h2h3h4h5h6h7h8h9h:h;h<h=h>h?h at hAhBhChDhEhFhGhHehI]q?hK]q?hMU 7f2b203beaf8579d35cec7dd6cd59e81q?hO]q?(hQhRhShThUhVhWhXhYhZh[h\h]h^h_h`hahbhchdhehfhghhhihjhkhlhmhnhohphqhrhshthuhvhwhxhyhzh{h|h}h~hh?h?h?h?h?h?h?h?h?h?h?h?h?h?h?h?eh?U?g++ -ansi -Wall -ftemplate-depth-100 -O3 -finline-functions -Wno-inline -pthread -DNDEBUG -DBOOST_PROPERTY_TREE_XML_PARSER_TINYXML -DTIXML_USE_STL -fPIC -c -o tinyxml.os tinyxml.cppq?h?]q?Utinyxml/tinyxml.cppq?ah?]q?U 8fbf88d5122928d52e45f2299582a984q?aubUtinyxmlparser.cppq?(hoq?}q?(h?J??9Eh?h?ubUtinystr.cppq?(hoq?}q?(h?J??9Eh?U 0a9fdccb93300c5a9227b1910ae526b5q?ubU	tinyxml.hq?(hoq?}q?(h?J	?9Eh?hRubUtinyxml.cppq?(hoq?}q?(h?JK?9Eh?h?ubUtinyxmlerror.osq?(hoq?}q?(hU 6f65267f8663238c23e597a974c35693q?h]q?(hhh
-hhhhhhhhhhhhhhh h!h"h#h$h%h&h'h(h)hhhhhh,h-h.h/h0h1h2h*h+h3h4h5h6h7h8h9h:h;h<h=h>h?h at hAhBhChDhEhFhGhHehI]q?hK]q?hMU 4aa0234202f972ed28dd7dc18a64299eq?hO]q?(hRhWhQhXhYhZh[hUhShThVhahbhchdhehfhghhhihjhkhlhmhnhohph_h`h\h]h^hshthuhvhwhxhyhqhrhzh{h|h}h~hh?h?h?h?h?h?h?h?h?h?h?h?h?h?h?h?eh?U?g++ -ansi -Wall -ftemplate-depth-100 -O3 -finline-functions -Wno-inline -pthread -DNDEBUG -DBOOST_PROPERTY_TREE_XML_PARSER_TINYXML -DTIXML_USE_STL -fPIC -c -o tinyxmlerror.os tinyxmlerror.cppq?h?]q?Utinyxml/tinyxmlerror.cppq?ah?]q?h?aubU
-tinystr.osq?(hoq?}q?(hU 6050f86723f4e371b343884fb65bf913q?h]q?(hhhhh'h(h)hhhhhhhh*h+hhh!h"h#h$h%h&h/h0h1h2h6h7h8ehI]q?hK]q?hMU 7f275df97bbe6da48749f5fd3cf12691q?hO]q?(h[hWhZhUhnhohphVh_h`hShThYh]hqhrh\h^hhhihjhkhlhmhvhwhxhyh}h~heh?U?g++ -ansi -Wall -ftemplate-depth-100 -O3 -finline-functions -Wno-inline -pthread -DNDEBUG -DBOOST_PROPERTY_TREE_XML_PARSER_TINYXML -DTIXML_USE_STL -fPIC -c -o tinystr.os tinystr.cppq?h?]q?Utinyxml/tinystr.cppq?ah?]q?h?aubu.
\ No newline at end of file



From pavlenko at mail.berlios.de  Fri Oct 27 19:29:45 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Fri, 27 Oct 2006 19:29:45 +0200
Subject: [Mapnik-svn] r360 - in trunk: bindings/python include/mapnik src
Message-ID: <200610271729.k9RHTjDb016525@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-27 19:29:39 +0200 (Fri, 27 Oct 2006)
New Revision: 360

Modified:
   trunk/bindings/python/mapnik_map.cpp
   trunk/bindings/python/mapnik_text_symbolizer.cpp
   trunk/include/mapnik/font_engine_freetype.hpp
   trunk/include/mapnik/line_pattern_symbolizer.hpp
   trunk/include/mapnik/placement_finder.hpp
   trunk/include/mapnik/text_symbolizer.hpp
   trunk/src/SConscript
   trunk/src/agg_renderer.cpp
   trunk/src/load_map.cpp
   trunk/src/placement_finder.cpp
   trunk/src/text_symbolizer.cpp
Log:
1. applied text-wrap patch from Robert Coup. Thanks! 
2. by default use tinyxml as a property_tree parser
3. modified load_map.cpp to allow to test new features



Modified: trunk/bindings/python/mapnik_map.cpp
===================================================================
--- trunk/bindings/python/mapnik_map.cpp	2006-10-27 17:26:45 UTC (rev 359)
+++ trunk/bindings/python/mapnik_map.cpp	2006-10-27 17:29:39 UTC (rev 360)
@@ -110,6 +110,7 @@
         .add_property("layers",make_function
                       (&Map::layers,return_value_policy<reference_existing_object>()), 
                       "Get the list of layers in this map.")
+        .def("find_style",&Map::find_style,return_value_policy<copy_const_reference>())
         .def_pickle(map_pickle_suite())
         ;
 }

Modified: trunk/bindings/python/mapnik_text_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_text_symbolizer.cpp	2006-10-27 17:26:45 UTC (rev 359)
+++ trunk/bindings/python/mapnik_text_symbolizer.cpp	2006-10-27 17:29:39 UTC (rev 360)
@@ -36,13 +36,19 @@
         .value("LINE_PLACEMENT",mapnik::line_placement)
         .value("POINT_PLACEMENT",mapnik::point_placement)
         ;
-
+    
     class_<text_symbolizer>("TextSymbolizer",
 			    init<std::string const&,std::string const&, unsigned,Color const&>())
         .add_property("halo_fill",make_function(
                       &text_symbolizer::get_halo_fill,
                       return_value_policy<copy_const_reference>()),
                       &text_symbolizer::set_halo_fill)
+        .add_property("wrap_width",
+                      &text_symbolizer::get_wrap_width,
+                      &text_symbolizer::set_wrap_width)
+        .add_property("text_ratio",
+                      &text_symbolizer::get_text_ratio,
+                      &text_symbolizer::set_text_ratio)
         .add_property("halo_radius",
                       &text_symbolizer::get_halo_radius, 
                       &text_symbolizer::set_halo_radius)

Modified: trunk/include/mapnik/font_engine_freetype.hpp
===================================================================
--- trunk/include/mapnik/font_engine_freetype.hpp	2006-10-27 17:26:45 UTC (rev 359)
+++ trunk/include/mapnik/font_engine_freetype.hpp	2006-10-27 17:29:39 UTC (rev 360)
@@ -264,7 +264,9 @@
                 double x, y, angle;
                 
                 path->vertex(&c, &x, &y, &angle);
+//                std::clog << "   prepare_glyph: " << (unsigned char)c << "," << x << "," << y << "," << angle << std::endl;
 
+
                 FT_BBox glyph_bbox; 
                 FT_Glyph image;
 		
@@ -363,8 +365,8 @@
               
                 width += char_dim.first;
                 height = char_dim.second > height ? char_dim.second : height;
+                
             }
-            
             info->set_dimensions(width, height);
         }
 	
@@ -376,10 +378,14 @@
 	    
             start.x = unsigned(x0 * (1 << 6)); 
             start.y = unsigned((height - y0) * (1 << 6));
+
+//            std::clog << "Render text at: " << x0 << "," << y0 << " " << start.x << "," << start.y << std::endl;
+
             // now render transformed glyphs
             typename glyphs_t::iterator pos;
-
-            if (halo_radius_ > 0)
+            
+            //make sure we've got reasonable values.
+            if (halo_radius_ > 0 && halo_radius_ < 256)
             {
                 //render halo 
                 for ( pos = glyphs_.begin(); pos != glyphs_.end();++pos)
@@ -463,6 +469,8 @@
         mapnik::Color fill_;
         mapnik::Color halo_fill_;
         int halo_radius_;
+        unsigned text_ratio_;
+        unsigned wrap_width_;
         glyphs_t glyphs_;
     }; 
 }

Modified: trunk/include/mapnik/line_pattern_symbolizer.hpp
===================================================================
--- trunk/include/mapnik/line_pattern_symbolizer.hpp	2006-10-27 17:26:45 UTC (rev 359)
+++ trunk/include/mapnik/line_pattern_symbolizer.hpp	2006-10-27 17:29:39 UTC (rev 360)
@@ -34,7 +34,7 @@
         line_pattern_symbolizer(std::string const& file,
                                 std::string const& type,
                                 unsigned width,unsigned height);
-
+        
         line_pattern_symbolizer(line_pattern_symbolizer const& rhs);
         ImageData32 const& get_pattern() const;
     private:

Modified: trunk/include/mapnik/placement_finder.hpp
===================================================================
--- trunk/include/mapnik/placement_finder.hpp	2006-10-27 17:26:45 UTC (rev 359)
+++ trunk/include/mapnik/placement_finder.hpp	2006-10-27 17:29:39 UTC (rev 360)
@@ -67,14 +67,17 @@
     double starting_y;
     
     text_path path;
+
     
-    
     //helpers
     std::pair<double, double> get_position_at_distance(double target_distance);
     double get_total_distance();
     void clear_envelopes();
     
     double total_distance_; //cache for distance
+    
+    int wrap_width;
+    int text_ratio;
   };
   
   class placement_finder : boost::noncopyable

Modified: trunk/include/mapnik/text_symbolizer.hpp
===================================================================
--- trunk/include/mapnik/text_symbolizer.hpp	2006-10-27 17:26:45 UTC (rev 359)
+++ trunk/include/mapnik/text_symbolizer.hpp	2006-10-27 17:29:39 UTC (rev 360)
@@ -38,12 +38,17 @@
     
     struct MAPNIK_DECL text_symbolizer
     {		
-	text_symbolizer(std::string const& name,std::string const& face_name, unsigned size,Color const& fill);	
+        text_symbolizer(std::string const& name,std::string const& face_name, 
+                        unsigned size,Color const& fill);	
         text_symbolizer(text_symbolizer const& rhs);
         text_symbolizer& operator=(text_symbolizer const& rhs);
         std::string const& get_name() const;
+        unsigned get_text_ratio() const; // target ratio for text bounding box in pixels
+        void set_text_ratio(unsigned ratio);
+        unsigned get_wrap_width() const; // target ratio for text bounding box in pixels
+        void set_wrap_width(unsigned ratio);
         unsigned get_text_size() const;
-	std::string const& get_face_name() const;
+        std::string const& get_face_name() const;
         Color const& get_fill() const;
         void set_halo_fill(Color const& fill);
         Color const& get_halo_fill() const;
@@ -57,8 +62,10 @@
         position const& get_displacement() const;
     private:
         std::string name_;
-  std::string face_name_;
+        std::string face_name_;
         unsigned size_;
+        unsigned text_ratio_;
+        unsigned wrap_width_;
         Color fill_;
         Color halo_fill_;
         unsigned halo_radius_;

Modified: trunk/src/SConscript
===================================================================
--- trunk/src/SConscript	2006-10-27 17:26:45 UTC (rev 359)
+++ trunk/src/SConscript	2006-10-27 17:29:39 UTC (rev 360)
@@ -62,9 +62,16 @@
     scale_denominator.cpp
     """
     )
+source += Split(
+    """
+    ../tinyxml/tinystr.cpp
+    ../tinyxml/tinyxml.cpp
+    ../tinyxml/tinyxmlerror.cpp
+    ../tinyxml/tinyxmlparser.cpp
+    """)
 
 mapnik = env.SharedLibrary('mapnik', source, LIBS=libraries, LINKFLAGS=linkflags)
 
 env.Alias(target='install', source=env.Install(prefix + '/' + env['LIBDIR_SCHEMA'], mapnik))
-includes = glob.glob('../include/mapnik' + '/*.hpp')
+includes = glob.glob('../include/mapnik/*.hpp')
 env.Alias(target='install', source=env.Install(prefix+'/include/mapnik', includes))

Modified: trunk/src/agg_renderer.cpp
===================================================================
--- trunk/src/agg_renderer.cpp	2006-10-27 17:26:45 UTC (rev 359)
+++ trunk/src/agg_renderer.cpp	2006-10-27 17:29:39 UTC (rev 360)
@@ -502,6 +502,8 @@
                     ren.get_string_info(text, &info);
                  
                     placement text_placement(&info, &t_, &prj_trans, geom, sym.get_label_placement());
+                    text_placement.text_ratio = sym.get_text_ratio();
+                    text_placement.wrap_width = sym.get_wrap_width();
                   
                     bool found = finder_.find_placement(&text_placement);
                     if (!found) {

Modified: trunk/src/load_map.cpp
===================================================================
--- trunk/src/load_map.cpp	2006-10-27 17:26:45 UTC (rev 359)
+++ trunk/src/load_map.cpp	2006-10-27 17:29:39 UTC (rev 360)
@@ -27,9 +27,6 @@
 #include <boost/lexical_cast.hpp>
 #include <boost/tokenizer.hpp>
 #include <boost/property_tree/ptree.hpp>
-
-// use tinyxml 
-#define BOOST_PROPERTY_TREE_XML_PARSER_TINYXML
 #include <boost/property_tree/xml_parser.hpp>
 
 // mapnik
@@ -166,7 +163,38 @@
                                 {
                                     text_symbol.set_label_placement(line_placement);
                                 }
+                                // halo fill and radius
+                                boost::optional<std::string> halo_fill = 
+                                    sym.second.get_optional<std::string>("<xmlattr>.halo_fill");
                                 
+                                if (halo_fill)
+                                {
+                                    text_symbol.set_halo_fill
+                                        (color_factory::from_string(halo_fill->c_str()));
+                                }
+                                boost::optional<unsigned> halo_radius = 
+                                    sym.second.get_optional<unsigned>("<xmlattr>.halo_radius");
+                                if (halo_radius)
+                                {
+                                    text_symbol.set_halo_radius(*halo_radius);
+                                }
+                                
+                                // text ratio and wrap width
+                                boost::optional<unsigned> text_ratio = 
+                                    sym.second.get_optional<unsigned>("<xmlattr>.text_ratio");
+                                
+                                if (text_ratio)
+                                {
+                                    text_symbol.set_text_ratio(*text_ratio);
+                                }
+                                
+                                boost::optional<unsigned> wrap_width = 
+                                    sym.second.get_optional<unsigned>("<xmlattr>.wrap_width");
+                                if (wrap_width)
+                                {
+                                    text_symbol.set_wrap_width(*wrap_width);
+                                }
+                                
                                 rule.append(text_symbol);
                             }
                             else if ( sym.first == "ShieldSymbolizer")

Modified: trunk/src/placement_finder.cpp
===================================================================
--- trunk/src/placement_finder.cpp	2006-10-27 17:26:45 UTC (rev 359)
+++ trunk/src/placement_finder.cpp	2006-10-27 17:29:39 UTC (rev 360)
@@ -40,339 +40,340 @@
 
 namespace mapnik
 {
-  placement::placement(string_info *info_, CoordTransform *ctrans_, const proj_transform *proj_trans_, geometry_ptr geom_, std::pair<double, double> dimensions_)
-    : info(info_), ctrans(ctrans_), proj_trans(proj_trans_), geom(geom_), label_placement(point_placement), dimensions(dimensions_), has_dimensions(true), shape_path(*ctrans_, *geom_, *proj_trans_), total_distance_(-1.0)
-  {
-  }
+    placement::placement(string_info *info_, CoordTransform *ctrans_, const proj_transform *proj_trans_, geometry_ptr geom_, std::pair<double, double> dimensions_)
+        : info(info_), ctrans(ctrans_), proj_trans(proj_trans_), geom(geom_), label_placement(point_placement), dimensions(dimensions_), has_dimensions(true), shape_path(*ctrans_, *geom_, *proj_trans_), total_distance_(-1.0), wrap_width(0), text_ratio(0)
+    {
+    }
   
-  //For text
-  placement::placement(string_info *info_, CoordTransform *ctrans_, const proj_transform *proj_trans_, geometry_ptr geom_, label_placement_e placement_)
-    : info(info_), ctrans(ctrans_), proj_trans(proj_trans_), geom(geom_), label_placement(placement_), has_dimensions(false), shape_path(*ctrans_, *geom_, *proj_trans_), total_distance_(-1.0)
-  {
-  }
+    //For text
+    placement::placement(string_info *info_, CoordTransform *ctrans_, const proj_transform *proj_trans_, geometry_ptr geom_, label_placement_e placement_)
+        : info(info_), ctrans(ctrans_), proj_trans(proj_trans_), geom(geom_), label_placement(placement_), has_dimensions(false), shape_path(*ctrans_, *geom_, *proj_trans_), total_distance_(-1.0), wrap_width(0), text_ratio(0)
+    {
+    }
   
-  placement::~placement()
-  {
-  }
+    placement::~placement()
+    {
+    }
 
-  std::pair<double, double> placement::get_position_at_distance(double target_distance)
-  {
-    double old_x, old_y, new_x, new_y;
-    double x, y;
-    x = y = 0.0;
+    std::pair<double, double> placement::get_position_at_distance(double target_distance)
+    {
+        double old_x, old_y, new_x, new_y;
+        double x, y;
+        x = y = 0.0;
     
-    double distance = 0.0;
+        double distance = 0.0;
     
-    shape_path.rewind(0);
-    shape_path.vertex(&new_x,&new_y);
-    for (unsigned i = 0; i < geom->num_points() - 1; i++)
-    {
-      double dx, dy;
+        shape_path.rewind(0);
+        shape_path.vertex(&new_x,&new_y);
+        for (unsigned i = 0; i < geom->num_points() - 1; i++)
+        {
+            double dx, dy;
 
-      old_x = new_x;
-      old_y = new_y;
+            old_x = new_x;
+            old_y = new_y;
 
-      shape_path.vertex(&new_x,&new_y);
+            shape_path.vertex(&new_x,&new_y);
       
-      dx = new_x - old_x;
-      dy = new_y - old_y;
+            dx = new_x - old_x;
+            dy = new_y - old_y;
       
-      double segment_length = sqrt(dx*dx + dy*dy);
+            double segment_length = sqrt(dx*dx + dy*dy);
       
-      distance += segment_length;
-      if (distance > target_distance)
-      {
-          x = new_x - dx*(distance - target_distance)/segment_length;
-          y = new_y - dy*(distance - target_distance)/segment_length;
+            distance += segment_length;
+            if (distance > target_distance)
+            {
+                x = new_x - dx*(distance - target_distance)/segment_length;
+                y = new_y - dy*(distance - target_distance)/segment_length;
 
-          break;
-      }
+                break;
+            }
+        }
+    
+        return std::pair<double, double>(x, y);
     }
-    
-    return std::pair<double, double>(x, y);
-  }
   
-  double placement::get_total_distance()
-  {
-    if (total_distance_ < 0.0)
+    double placement::get_total_distance()
     {
-      double old_x, old_y, new_x, new_y;
+        if (total_distance_ < 0.0)
+        {
+            double old_x, old_y, new_x, new_y;
       
-      shape_path.rewind(0);
+            shape_path.rewind(0);
      
-      shape_path.vertex(&old_x,&old_y);
+            shape_path.vertex(&old_x,&old_y);
 
-      total_distance_ = 0.0;
+            total_distance_ = 0.0;
       
-      for (unsigned i = 0; i < geom->num_points() - 1; i++)
-      {
-          double dx, dy;
+            for (unsigned i = 0; i < geom->num_points() - 1; i++)
+            {
+                double dx, dy;
           
-          shape_path.vertex(&new_x,&new_y);
+                shape_path.vertex(&new_x,&new_y);
           
-          dx = new_x - old_x;
-          dy = new_y - old_y;
+                dx = new_x - old_x;
+                dy = new_y - old_y;
           
-          total_distance_ += sqrt(dx*dx + dy*dy);
+                total_distance_ += sqrt(dx*dx + dy*dy);
           
-          old_x = new_x;
-          old_y = new_y;
-      }
+                old_x = new_x;
+                old_y = new_y;
+            }
+        }
+    
+        return total_distance_;
     }
-    
-    return total_distance_;
-  }
   
-  void placement::clear_envelopes()
-  {
-    while (!envelopes.empty())
-      envelopes.pop();
-  }
+    void placement::clear_envelopes()
+    {
+        while (!envelopes.empty())
+            envelopes.pop();
+    }
   
   
   
-  placement_finder::placement_finder(Envelope<double> e)
-    : detector_(e)
-  {
-  }
-
-  bool placement_finder::find_placement(placement *p)
-  {
-    if (p->label_placement == point_placement)
+    placement_finder::placement_finder(Envelope<double> e)
+        : detector_(e)
     {
-      return find_placement_horizontal(p);
     }
-    else if (p->label_placement == line_placement)
+
+    bool placement_finder::find_placement(placement *p)
     {
-      return find_placement_follow(p);
+        if (p->label_placement == point_placement)
+        {
+            return find_placement_horizontal(p);
+        }
+        else if (p->label_placement == line_placement)
+        {
+            return find_placement_follow(p);
+        }
+    
+        return false;
     }
-    
-    return false;
-  }
 
-  bool placement_finder::find_placement_follow(placement *p)
-  {
-    std::pair<double, double> string_dimensions = p->info->get_dimensions();
-    double string_width = string_dimensions.first;
-//    double string_height = string_dimensions.second;
+    bool placement_finder::find_placement_follow(placement *p)
+    {
+        std::pair<double, double> string_dimensions = p->info->get_dimensions();
+        double string_width = string_dimensions.first;
+        //    double string_height = string_dimensions.second;
     
-    double distance = p->get_total_distance();
+        double distance = p->get_total_distance();
     
-    //~ double delta = string_width/distance;
-    double delta = distance/100.0;
+        //~ double delta = string_width/distance;
+        double delta = distance/100.0;
     
-    for (double i = 0; i < (distance - string_width)/2.0; i += delta)
-    {
-      p->clear_envelopes();
+        for (double i = 0; i < (distance - string_width)/2.0; i += delta)
+        {
+            p->clear_envelopes();
       
-      if ( build_path_follow(p, (distance - string_width)/2.0 + i) ) {
-        update_detector(p);
-        return true;
-      }
+            if ( build_path_follow(p, (distance - string_width)/2.0 + i) ) {
+                update_detector(p);
+                return true;
+            }
       
-      p->clear_envelopes();
+            p->clear_envelopes();
       
-      if ( build_path_follow(p, (distance - string_width)/2.0 - i) ) {
-        update_detector(p);
-        return true;
-      }
-    }
+            if ( build_path_follow(p, (distance - string_width)/2.0 - i) ) {
+                update_detector(p);
+                return true;
+            }
+        }
     
-    p->starting_x = 0;
-    p->starting_y = 0;
+        p->starting_x = 0;
+        p->starting_y = 0;
     
-    return false;
-  }
+        return false;
+    }
   
-  bool placement_finder::find_placement_horizontal(placement *p)
-  {
-    double distance = p->get_total_distance();
-    //~ double delta = string_width/distance;
-    double delta = distance/100.0;
+    bool placement_finder::find_placement_horizontal(placement *p)
+    {
+        double distance = p->get_total_distance();
+        //~ double delta = string_width/distance;
+        double delta = distance/100.0;
     
-    for (double i = 0; i < distance/2.0; i += delta)
-    {
-      p->clear_envelopes();
+        for (double i = 0; i < distance/2.0; i += delta)
+        {
+            p->clear_envelopes();
       
-      if ( build_path_horizontal(p, distance/2.0 + i) ) {
-        update_detector(p);
-        return true;
-      }
+            if ( build_path_horizontal(p, distance/2.0 + i) ) {
+                update_detector(p);
+                return true;
+            }
       
-      p->clear_envelopes();
+            p->clear_envelopes();
       
-      if ( build_path_horizontal(p, distance/2.0 - i) ) {
-        update_detector(p);
-        return true;
-      }
-    }
+            if ( build_path_horizontal(p, distance/2.0 - i) ) {
+                update_detector(p);
+                return true;
+            }
+        }
     
-    p->starting_x = 0;
-    p->starting_y = 0;
+        p->starting_x = 0;
+        p->starting_y = 0;
     
-    return false;
-  }
+        return false;
+    }
   
-  void placement_finder::update_detector(placement *p)
-  {
-    while (!p->envelopes.empty())
+    void placement_finder::update_detector(placement *p)
     {
-      Envelope<double> e = p->envelopes.front();
+        while (!p->envelopes.empty())
+        {
+            Envelope<double> e = p->envelopes.front();
 
-      detector_.insert(e);
+            detector_.insert(e);
 
-      p->envelopes.pop();
+            p->envelopes.pop();
+        }
     }
-  }
 
-  bool placement_finder::build_path_follow(placement *p, double target_distance)
-  {
-    double new_x, new_y, old_x, old_y;
-    unsigned cur_node = 0;
+    bool placement_finder::build_path_follow(placement *p, double target_distance)
+    {
+        double new_x, new_y, old_x, old_y;
+        unsigned cur_node = 0;
 
-    double angle = 0.0;
-    int orientation = 0;
+        double angle = 0.0;
+        int orientation = 0;
     
-    p->path.clear();
+        p->path.clear();
     
-    double x, y;
-    x = y = 0.0;
+        double x, y;
+        x = y = 0.0;
     
-    double distance = 0.0;
+        double distance = 0.0;
 
-    std::pair<double, double> string_dimensions = p->info->get_dimensions();
-//    double string_width = string_dimensions.first;
-    double string_height = string_dimensions.second;
+        std::pair<double, double> string_dimensions = p->info->get_dimensions();
+        //    double string_width = string_dimensions.first;
+        double string_height = string_dimensions.second;
     
-    p->shape_path.rewind(0);
-    p->shape_path.vertex(&new_x,&new_y);
-    for (unsigned i = 0; i < p->geom->num_points() - 1; i++)
-    {
-        double dx, dy;
+        p->shape_path.rewind(0);
+        p->shape_path.vertex(&new_x,&new_y);
+        for (unsigned i = 0; i < p->geom->num_points() - 1; i++)
+        {
+            double dx, dy;
 
-        cur_node++;
+            cur_node++;
         
-        old_x = new_x;
-        old_y = new_y;
+            old_x = new_x;
+            old_y = new_y;
 
-        p->shape_path.vertex(&new_x,&new_y);
+            p->shape_path.vertex(&new_x,&new_y);
         
-        dx = new_x - old_x;
-        dy = new_y - old_y;
+            dx = new_x - old_x;
+            dy = new_y - old_y;
         
-        double segment_length = sqrt(dx*dx + dy*dy);
+            double segment_length = sqrt(dx*dx + dy*dy);
         
-        distance += segment_length;
-        if (distance > target_distance)
-        {
-            p->starting_x = new_x - dx*(distance - target_distance)/segment_length;
-            p->starting_y = new_y - dy*(distance - target_distance)/segment_length;
+            distance += segment_length;
+            if (distance > target_distance)
+            {
+                p->starting_x = new_x - dx*(distance - target_distance)/segment_length;
+                p->starting_y = new_y - dy*(distance - target_distance)/segment_length;
 
-            angle = atan2(-dy, dx);
+                angle = atan2(-dy, dx);
 
-            if (angle > M_PI/2 || angle <= -M_PI/2) {
-              orientation = -1;
-            }
-            else {
-              orientation = 1;
-            }
+                if (angle > M_PI/2 || angle <= -M_PI/2) {
+                    orientation = -1;
+                }
+                else {
+                    orientation = 1;
+                }
 
-            distance -= target_distance;
+                distance -= target_distance;
             
-            break;
+                break;
+            }
         }
-    }
 
-    for (unsigned i = 0; i < p->info->num_characters(); i++)
-    {
-        character_info ci;
-        unsigned c;
+        for (unsigned i = 0; i < p->info->num_characters(); i++)
+        {
+            character_info ci;
+            unsigned c;
       
-        while (distance <= 0) {
-            double dx, dy;
+            while (distance <= 0) {
+                double dx, dy;
 
-            cur_node++;
+                cur_node++;
             
-            if (cur_node >= p->geom->num_points()) {
-              break;
-            }
+                if (cur_node >= p->geom->num_points()) {
+                    break;
+                }
             
-            old_x = new_x;
-            old_y = new_y;
+                old_x = new_x;
+                old_y = new_y;
 
-            p->shape_path.vertex(&new_x,&new_y);
+                p->shape_path.vertex(&new_x,&new_y);
 
-            dx = new_x - old_x;
-            dy = new_y - old_y;
+                dx = new_x - old_x;
+                dy = new_y - old_y;
 
-            angle = atan2(-dy, dx );
+                angle = atan2(-dy, dx );
             
-            distance += sqrt(dx*dx+dy*dy);
-        }
+                distance += sqrt(dx*dx+dy*dy);
+            }
 
-        if (orientation == -1) {
-            ci = p->info->at(p->info->num_characters() - i - 1);
-        }
-        else
-        {
-            ci = p->info->at(i);
-        }
-        c = ci.character;
+            if (orientation == -1) {
+                ci = p->info->at(p->info->num_characters() - i - 1);
+            }
+            else
+            {
+                ci = p->info->at(i);
+            }
+            c = ci.character;
 
-        Envelope<double> e;
-        if (p->has_dimensions)
-        {
-            e.init(x, y, x + p->dimensions.first, y + p->dimensions.second);
-        }
+            Envelope<double> e;
+            if (p->has_dimensions)
+            {
+                e.init(x, y, x + p->dimensions.first, y + p->dimensions.second);
+            }
 
-        if (orientation == -1) {
-            x = new_x - (distance - ci.width)*cos(angle);
-            y = new_y + (distance - ci.width)*sin(angle);
+            if (orientation == -1) {
+                x = new_x - (distance - ci.width)*cos(angle);
+                y = new_y + (distance - ci.width)*sin(angle);
 
-            //Center the text on the line.
-            x += (((double)string_height/2.0) - 1.0)*cos(angle+M_PI/2);
-            y -= (((double)string_height/2.0) - 1.0)*sin(angle+M_PI/2);
+                //Center the text on the line.
+                x += (((double)string_height/2.0) - 1.0)*cos(angle+M_PI/2);
+                y -= (((double)string_height/2.0) - 1.0)*sin(angle+M_PI/2);
           
-            if (!p->has_dimensions)
+                if (!p->has_dimensions)
+                {
+                    e.init(x, y, x + ci.width*cos(angle+M_PI), y - ci.width*sin(angle+M_PI));
+                    e.expand_to_include(x - ci.height*sin(angle+M_PI), y - ci.height*cos(angle+M_PI));
+                    e.expand_to_include(x + (ci.width*cos(angle+M_PI) - ci.height*sin(angle+M_PI)), y - (ci.width*sin(angle+M_PI) + ci.height*cos(angle+M_PI)));
+                }
+            }
+            else
             {
-              e.init(x, y, x + ci.width*cos(angle+M_PI), y - ci.width*sin(angle+M_PI));
-              e.expand_to_include(x - ci.height*sin(angle+M_PI), y - ci.height*cos(angle+M_PI));
-              e.expand_to_include(x + (ci.width*cos(angle+M_PI) - ci.height*sin(angle+M_PI)), y - (ci.width*sin(angle+M_PI) + ci.height*cos(angle+M_PI)));
-            }
-        }
-        else
-        {
-            x = new_x - distance*cos(angle);
-            y = new_y + distance*sin(angle);
+                x = new_x - distance*cos(angle);
+                y = new_y + distance*sin(angle);
 
-            //Center the text on the line.
-            x += (((double)string_height/2.0) - 1.0)*cos(angle-M_PI/2);
-            y -= (((double)string_height/2.0) - 1.0)*sin(angle-M_PI/2);
+                //Center the text on the line.
+                x += (((double)string_height/2.0) - 1.0)*cos(angle-M_PI/2);
+                y -= (((double)string_height/2.0) - 1.0)*sin(angle-M_PI/2);
 
-            if (!p->has_dimensions)
+                if (!p->has_dimensions)
+                {
+                    e.init(x, y, x + ci.width*cos(angle), y - ci.width*sin(angle));
+                    e.expand_to_include(x - ci.height*sin(angle), y - ci.height*cos(angle));
+                    e.expand_to_include(x + (ci.width*cos(angle) - ci.height*sin(angle)), y - (ci.width*sin(angle) + ci.height*cos(angle)));
+                }
+            }
+        
+            if (!detector_.has_placement(e))
             {
-              e.init(x, y, x + ci.width*cos(angle), y - ci.width*sin(angle));
-              e.expand_to_include(x - ci.height*sin(angle), y - ci.height*cos(angle));
-              e.expand_to_include(x + (ci.width*cos(angle) - ci.height*sin(angle)), y - (ci.width*sin(angle) + ci.height*cos(angle)));
+                return false;
             }
-        }
         
-        if (!detector_.has_placement(e))
-        {
-          return false;
-        }
+            p->envelopes.push(e);
         
-        p->envelopes.push(e);
+            p->path.add_node(c, x - p->starting_x, -y + p->starting_y, (orientation == -1 ? angle + M_PI : angle));
         
-        p->path.add_node(c, x - p->starting_x, -y + p->starting_y, (orientation == -1 ? angle + M_PI : angle));
-        
-        distance -= ci.width;
+            distance -= ci.width;
+        }
+    
+        return true;
     }
-    
-    return true;
-  }
-  
-  bool placement_finder::build_path_horizontal(placement *p, double target_distance)
+
+    /*
+   bool placement_finder::build_path_horizontal(placement *p, double target_distance)
   {
     double x, y;
   
@@ -433,7 +434,159 @@
     }
     return true;
   }
+    */
+    
+    bool placement_finder::build_path_horizontal(placement *p, double target_distance)
+    {
+    
+        p->path.clear();
+    
+        std::pair<double, double> string_dimensions = p->info->get_dimensions();
+        double string_width = string_dimensions.first;
+        double string_height = string_dimensions.second;
+    
+        // check if we need to wrap the string
+        double wrap_at = string_width + 1;
+        if (p->wrap_width && string_width > p->wrap_width)
+        {
+            if (p->text_ratio)
+                for (int i = 1; ((wrap_at = string_width/i)/(string_height*i)) > p->text_ratio && (string_width/i) > p->wrap_width; ++i);
+            else
+                wrap_at = p->wrap_width;
+            //std::clog << "Wrapping string at" << wrap_at << std::endl;
+        }
 
-  
+        // work out where our line breaks need to be
+        std::vector<int> line_breaks;
+        std::vector<double> line_widths;
+        if (wrap_at < string_width && p->info->num_characters() > 0)
+        {
+            int line_count=0; 
+            int last_space = 0;
+            string_width = 0;
+            string_height = 0;
+            double line_width = 0;
+            double line_height = 0;
+            double word_width = 0;
+            double word_height = 0;
+            for (unsigned int ii = 0; ii < p->info->num_characters(); ii++)
+            {
+                character_info ci;
+                ci = p->info->at(ii);
+            
+                unsigned c = ci.character;
+                word_width += ci.width;
+                word_height = word_height > ci.height ? word_height : ci.height;
+                ++line_count;
+    
+                if (c == ' ')
+                {
+                    last_space = ii;
+                    line_width += word_width;
+                    line_height = line_height > word_height ? line_height : word_height;
+                    word_width = 0;
+                    word_height = 0;
+                }
+                if (line_width > 0 && line_width > wrap_at)
+                {
+                    string_width = string_width > line_width ? string_width : line_width;
+                    string_height += line_height;
+                    line_breaks.push_back(last_space);
+                    line_widths.push_back(line_width);
+                    ii = last_space;
+                    line_count = 0;
+                    line_width = 0;
+                    line_height = 0;
+                    word_width = 0;
+                    word_height = 0;
+                }
+            }
+            line_width += word_width;
+            string_width = string_width > line_width ? string_width : line_width;
+            line_breaks.push_back(p->info->num_characters() + 1);
+            line_widths.push_back(line_width);
+        }
+        if (line_breaks.size() == 0)
+        {
+            line_breaks.push_back(p->info->num_characters() + 1);
+            line_widths.push_back(string_width);
+        }
+
+        p->info->set_dimensions(string_width, string_height);
+    
+        if (p->geom->type() == LineString)
+        {
+            std::pair<double, double> starting_pos = p->get_position_at_distance(target_distance);
+      
+            p->starting_x = starting_pos.first;
+            p->starting_y = starting_pos.second;
+        }
+        else
+        {
+            p->geom->label_position(&p->starting_x, &p->starting_y);
+            //  TODO: 
+            //  We would only want label position in final 'paper' coords.
+            //  Move view and proj transforms to e.g. label_position(x,y,proj_trans,ctrans)?
+            double z=0;  
+            p->proj_trans->backward(p->starting_x, p->starting_y, z);
+            p->ctrans->forward(&p->starting_x, &p->starting_y);
+        }
+    
+        double line_height = 0;
+        unsigned int line_number = 0;
+        unsigned int index_to_wrap_at = line_breaks[line_number];
+        double line_width = line_widths[line_number];
+
+        double x = -line_width/2.0;
+        double y = -string_height/2.0 + 1.0;
+    
+        for (unsigned i = 0; i < p->info->num_characters(); i++)
+        {
+            character_info ci;
+            ci = p->info->at(i);
+        
+            unsigned c = ci.character;
+      
+            if (i == index_to_wrap_at)
+            {
+                index_to_wrap_at = line_breaks[++line_number];
+                line_width = line_widths[line_number];
+                y -= line_height;
+                x = -line_width/2.0;
+                line_height = 0;
+                continue;
+            }
+            else
+            {
+                p->path.add_node(c, x, y, 0.0);
+
+                Envelope<double> e;
+                if (p->has_dimensions)
+                {
+                    e.init(p->starting_x - (p->dimensions.first/2.0), 
+                           p->starting_y - (p->dimensions.second/2.0), 
+                           p->starting_x + (p->dimensions.first/2.0), 
+                           p->starting_y + (p->dimensions.second/2.0));
+                }
+                else
+                {
+                    e.init(p->starting_x + x, 
+                           p->starting_y - y, 
+                           p->starting_x + x + ci.width, 
+                           p->starting_y - y - ci.height);
+                }
+            
+                if (!detector_.has_placement(e))
+                {
+                    return false;
+                }
+            
+                p->envelopes.push(e);
+            }
+            x += ci.width;
+            line_height = line_height > ci.height ? line_height : ci.height;
+        }
+        return true;
+    }
 }
 

Modified: trunk/src/text_symbolizer.cpp
===================================================================
--- trunk/src/text_symbolizer.cpp	2006-10-27 17:26:45 UTC (rev 359)
+++ trunk/src/text_symbolizer.cpp	2006-10-27 17:29:39 UTC (rev 360)
@@ -22,113 +22,143 @@
 
 //$Id$
 
+
+#include <iostream>
+
 #include <mapnik/text_symbolizer.hpp>
 
 namespace mapnik
 {
     text_symbolizer::text_symbolizer(std::string const& name, std::string const& face_name, unsigned size,Color const& fill)
-	: name_(name),
-    face_name_(face_name),
-	  size_(size),
-	  fill_(fill),
-	  halo_fill_(Color(255,255,255)),
-	  halo_radius_(0),
-	  label_p_(point_placement),
-	  anchor_(0.0,0.5),
-	  displacement_(0.0,0.0)  {}
+        : name_(name),
+          face_name_(face_name),
+          size_(size),
+          text_ratio_(0),
+          wrap_width_(0),
+          fill_(fill),
+          halo_fill_(Color(255,255,255)),
+          halo_radius_(0),
+          label_p_(point_placement),
+          anchor_(0.0,0.5),
+          displacement_(0.0,0.0)  {}
            
     text_symbolizer::text_symbolizer(text_symbolizer const& rhs)
-	: name_(rhs.name_),
-    face_name_(rhs.face_name_),
-	  size_(rhs.size_),
-	  fill_(rhs.fill_),
-	  halo_fill_(rhs.halo_fill_),
-	  halo_radius_(rhs.halo_radius_),
-	  label_p_(rhs.label_p_),
-	  anchor_(rhs.anchor_),
-	  displacement_(rhs.displacement_) {}
+        : name_(rhs.name_),
+          face_name_(rhs.face_name_),
+          size_(rhs.size_),
+          text_ratio_(rhs.text_ratio_),
+          wrap_width_(rhs.wrap_width_),
+          fill_(rhs.fill_),
+          halo_fill_(rhs.halo_fill_),
+          halo_radius_(rhs.halo_radius_),
+          label_p_(rhs.label_p_),
+          anchor_(rhs.anchor_),
+          displacement_(rhs.displacement_) {}
 
     text_symbolizer& text_symbolizer::operator=(text_symbolizer const& other)
     {
-	if (this == &other)
-	    return *this;
-	name_ = other.name_;
-  face_name_ = other.face_name_;
-	size_ = other.size_;
-	fill_ = other.fill_;
-	halo_fill_ = other.halo_fill_;
-	label_p_ = other.label_p_;
-	anchor_ = other.anchor_;
-	displacement_ = other.displacement_; 
-	return *this;
+        if (this == &other)
+            return *this;
+        name_ = other.name_;
+        face_name_ = other.face_name_;
+        size_ = other.size_;
+        text_ratio_ = other.text_ratio_;
+        wrap_width_ = other.wrap_width_;
+        fill_ = other.fill_;
+        halo_fill_ = other.halo_fill_;
+        halo_radius_ = other.halo_radius_;
+        label_p_ = other.label_p_;
+        anchor_ = other.anchor_;
+        displacement_ = other.displacement_; 
+        return *this;
     } 
 
     std::string const&  text_symbolizer::get_name() const
     {
-	return name_;
+        return name_;
     }
     
     std::string const&  text_symbolizer::get_face_name() const
     {
-	return face_name_;
+        return face_name_;
     }
     
+    unsigned  text_symbolizer::get_text_ratio() const
+    {
+        return text_ratio_;
+    }
+
+    void  text_symbolizer::set_text_ratio(unsigned ratio) 
+    {
+        text_ratio_ = ratio;
+    }
+
+    unsigned  text_symbolizer::get_wrap_width() const
+    {
+        return wrap_width_;
+    }
+
+    void  text_symbolizer::set_wrap_width(unsigned width) 
+    {
+        wrap_width_ = width;
+    }
+
     unsigned  text_symbolizer::get_text_size() const
     {
-	return size_;
+        return size_;
     }
 	
     Color const&  text_symbolizer::get_fill() const
     {
-	return fill_;
+        return fill_;
     }
 	
     void  text_symbolizer::set_halo_fill(Color const& fill)
     {
-	halo_fill_ = fill;
+        halo_fill_ = fill;
     }
 
     Color const&  text_symbolizer::get_halo_fill() const
     {
-	return halo_fill_;
+        return halo_fill_;
     }
 	
     void  text_symbolizer::set_halo_radius(unsigned radius)
     {
-	halo_radius_ = radius;
+        halo_radius_ = radius;
     }
 	
     unsigned  text_symbolizer::get_halo_radius() const
     {
-	return halo_radius_;
+        return halo_radius_;
     }
 	
     void  text_symbolizer::set_label_placement(label_placement_e label_p)
     {
-	label_p_ = label_p;
+        label_p_ = label_p;
     }
 	
     label_placement_e  text_symbolizer::get_label_placement() const
     {
-	return label_p_;
+        return label_p_;
     }
 
     void  text_symbolizer::set_anchor(double x, double y)
     {
-	anchor_ = boost::make_tuple(x,y);
+        anchor_ = boost::make_tuple(x,y);
     }
     
     position const& text_symbolizer::get_anchor () const
     {
-	return anchor_;
+        return anchor_;
     }
     void  text_symbolizer::set_displacement(double x, double y)
     {
-	displacement_ = boost::make_tuple(x,y);
+        displacement_ = boost::make_tuple(x,y);
     }
     
     position const&  text_symbolizer::get_displacement() const
     {
-	return displacement_;
+        return displacement_;
     }
 }



From pavlenko at mail.berlios.de  Sat Oct 28 00:12:44 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Sat, 28 Oct 2006 00:12:44 +0200
Subject: [Mapnik-svn] r361 - trunk/boost/property_tree/detail
Message-ID: <200610272212.k9RMCiP1018506@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-28 00:12:43 +0200 (Sat, 28 Oct 2006)
New Revision: 361

Modified:
   trunk/boost/property_tree/detail/xml_parser_read_tinyxml.hpp
Log:
resolved multiple #defines

Modified: trunk/boost/property_tree/detail/xml_parser_read_tinyxml.hpp
===================================================================
--- trunk/boost/property_tree/detail/xml_parser_read_tinyxml.hpp	2006-10-27 17:29:39 UTC (rev 360)
+++ trunk/boost/property_tree/detail/xml_parser_read_tinyxml.hpp	2006-10-27 22:12:43 UTC (rev 361)
@@ -15,7 +15,10 @@
 #include <boost/property_tree/detail/xml_parser_flags.hpp>
 #include <boost/property_tree/detail/xml_parser_utils.hpp>
 
+#ifndef TIXML_USE_STL
 #define TIXML_USE_STL
+#endif
+
 #include <tinyxml.h>
 
 namespace boost { namespace property_tree { namespace xml_parser



From pavlenko at mail.berlios.de  Sat Oct 28 00:13:15 2006
From: pavlenko at mail.berlios.de (pavlenko at mail.berlios.de)
Date: Sat, 28 Oct 2006 00:13:15 +0200
Subject: [Mapnik-svn] r362 - trunk
Message-ID: <200610272213.k9RMDFkU018574@sheep.berlios.de>

Author: pavlenko
Date: 2006-10-28 00:13:13 +0200 (Sat, 28 Oct 2006)
New Revision: 362

Modified:
   trunk/SConstruct
Log:
resolved multiple #defines

Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2006-10-27 22:12:43 UTC (rev 361)
+++ trunk/SConstruct	2006-10-27 22:13:13 UTC (rev 362)
@@ -56,7 +56,7 @@
 
 # Libraries and headers dependency checks
 
-env['CPPPATH'] = ['#agg/include', '#include', '#']
+env['CPPPATH'] = ['#agg/include', '#tinyxml', '#include', '#']
 
 for path in [env['BOOST_INCLUDES'],
              env['PNG_INCLUDES'],
@@ -145,9 +145,9 @@
 # Setup the c++ args for our own codebase
 
 if env['DEBUG']:
-    env.Append(CXXFLAGS = '-ansi -Wall -ftemplate-depth-100 -O0 -fno-inline -g -pthread -DDEBUG')
+    env.Append(CXXFLAGS = '-ansi -Wall -ftemplate-depth-100 -O0 -fno-inline -g -pthread -DDEBUG -DBOOST_PROPERTY_TREE_XML_PARSER_TINYXML -DTIXML_USE_STL')
 else:
-    env.Append(CXXFLAGS = '-ansi -Wall -ftemplate-depth-100 -O3 -finline-functions -Wno-inline -pthread -DNDEBUG')
+    env.Append(CXXFLAGS = '-ansi -Wall -ftemplate-depth-100 -O3 -finline-functions -Wno-inline -pthread -DNDEBUG -DBOOST_PROPERTY_TREE_XML_PARSER_TINYXML -DTIXML_USE_STL')
 
 # Build agg first, doesn't need anything special
 



