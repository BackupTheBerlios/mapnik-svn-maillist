<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Mapnik-svn] r313 - in trunk: . bindings/python	bindings/python/mapnik demo/c++ fonts include include/mapnik	plugins/input/postgis plugins/input/raster	plugins/input/shape src utils/shapeindex
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/mapnik-svn/2006-October/index.html" >
   <LINK REL="made" HREF="mailto:mapnik-svn%40lists.berlios.de?Subject=Re%3A%20%5BMapnik-svn%5D%20r313%20-%20in%20trunk%3A%20.%20bindings/python%0A%09bindings/python/mapnik%20demo/c%2B%2B%20fonts%20include%20include/mapnik%0A%09plugins/input/postgis%20plugins/input/raster%0A%09plugins/input/shape%20src%20utils/shapeindex&In-Reply-To=%3C200610041123.k94BNUju012862%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000197.html">
   <LINK REL="Next"  HREF="000199.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mapnik-svn] r313 - in trunk: . bindings/python	bindings/python/mapnik demo/c++ fonts include include/mapnik	plugins/input/postgis plugins/input/raster	plugins/input/shape src utils/shapeindex</H1>
    <B>pavlenko at mail.berlios.de</B> 
    <A HREF="mailto:mapnik-svn%40lists.berlios.de?Subject=Re%3A%20%5BMapnik-svn%5D%20r313%20-%20in%20trunk%3A%20.%20bindings/python%0A%09bindings/python/mapnik%20demo/c%2B%2B%20fonts%20include%20include/mapnik%0A%09plugins/input/postgis%20plugins/input/raster%0A%09plugins/input/shape%20src%20utils/shapeindex&In-Reply-To=%3C200610041123.k94BNUju012862%40sheep.berlios.de%3E"
       TITLE="[Mapnik-svn] r313 - in trunk: . bindings/python	bindings/python/mapnik demo/c++ fonts include include/mapnik	plugins/input/postgis plugins/input/raster	plugins/input/shape src utils/shapeindex">pavlenko at mail.berlios.de
       </A><BR>
    <I>Wed Oct  4 13:23:30 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000197.html">[Mapnik-svn] r312 - trunk/demo/c++
</A></li>
        <LI>Next message: <A HREF="000199.html">[Mapnik-svn] r314 - trunk/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#198">[ date ]</a>
              <a href="thread.html#198">[ thread ]</a>
              <a href="subject.html#198">[ subject ]</a>
              <a href="author.html#198">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: pavlenko
Date: 2006-10-04 13:22:18 +0200 (Wed, 04 Oct 2006)
New Revision: 313

Added:
   trunk/include/mapnik/
   trunk/include/mapnik/agg_renderer.hpp
   trunk/include/mapnik/attribute.hpp
   trunk/include/mapnik/attribute_collector.hpp
   trunk/include/mapnik/attribute_descriptor.hpp
   trunk/include/mapnik/color.hpp
   trunk/include/mapnik/color_factory.hpp
   trunk/include/mapnik/comparison.hpp
   trunk/include/mapnik/config.hpp
   trunk/include/mapnik/coord.hpp
   trunk/include/mapnik/coord_array.hpp
   trunk/include/mapnik/css_color_parser.hpp
   trunk/include/mapnik/ctrans.hpp
   trunk/include/mapnik/datasource.hpp
   trunk/include/mapnik/datasource_cache.hpp
   trunk/include/mapnik/envelope.hpp
   trunk/include/mapnik/expression.hpp
   trunk/include/mapnik/factory.hpp
   trunk/include/mapnik/feature.hpp
   trunk/include/mapnik/feature_factory.hpp
   trunk/include/mapnik/feature_layer_desc.hpp
   trunk/include/mapnik/feature_style_processor.hpp
   trunk/include/mapnik/feature_type_style.hpp
   trunk/include/mapnik/fill.hpp
   trunk/include/mapnik/filter.hpp
   trunk/include/mapnik/filter_expression.hpp
   trunk/include/mapnik/filter_factory.hpp
   trunk/include/mapnik/filter_parser.hpp
   trunk/include/mapnik/filter_parser_ast.hpp
   trunk/include/mapnik/filter_visitor.hpp
   trunk/include/mapnik/font_engine_freetype.hpp
   trunk/include/mapnik/gamma.hpp
   trunk/include/mapnik/geom_util.hpp
   trunk/include/mapnik/geometry.hpp
   trunk/include/mapnik/global.hpp
   trunk/include/mapnik/graphics.hpp
   trunk/include/mapnik/image_data.hpp
   trunk/include/mapnik/image_reader.hpp
   trunk/include/mapnik/image_util.hpp
   trunk/include/mapnik/label_collision_detector.hpp
   trunk/include/mapnik/label_placement.hpp
   trunk/include/mapnik/layer.hpp
   trunk/include/mapnik/line_pattern_symbolizer.hpp
   trunk/include/mapnik/line_symbolizer.hpp
   trunk/include/mapnik/load_map.hpp
   trunk/include/mapnik/local_datasource.hpp
   trunk/include/mapnik/logical.hpp
   trunk/include/mapnik/map.hpp
   trunk/include/mapnik/math_expr.hpp
   trunk/include/mapnik/memory.hpp
   trunk/include/mapnik/params.hpp
   trunk/include/mapnik/plugin.hpp
   trunk/include/mapnik/point_symbolizer.hpp
   trunk/include/mapnik/polygon_pattern_symbolizer.hpp
   trunk/include/mapnik/polygon_symbolizer.hpp
   trunk/include/mapnik/pool.hpp
   trunk/include/mapnik/quad_tree.hpp
   trunk/include/mapnik/query.hpp
   trunk/include/mapnik/raster.hpp
   trunk/include/mapnik/raster_symbolizer.hpp
   trunk/include/mapnik/regex_filter.hpp
   trunk/include/mapnik/rule.hpp
   trunk/include/mapnik/save_map.hpp
   trunk/include/mapnik/spatial.hpp
   trunk/include/mapnik/stroke.hpp
   trunk/include/mapnik/style.hpp
   trunk/include/mapnik/style_factory.hpp
   trunk/include/mapnik/symbolizer.hpp
   trunk/include/mapnik/text_symbolizer.hpp
   trunk/include/mapnik/utils.hpp
   trunk/include/mapnik/value.hpp
   trunk/include/mapnik/vertex.hpp
   trunk/include/mapnik/vertex_transform.hpp
   trunk/include/mapnik/vertex_vector.hpp
   trunk/include/mapnik/wkb.hpp
Removed:
   trunk/include/agg_renderer.hpp
   trunk/include/attribute.hpp
   trunk/include/attribute_collector.hpp
   trunk/include/attribute_descriptor.hpp
   trunk/include/color.hpp
   trunk/include/color_factory.hpp
   trunk/include/comparison.hpp
   trunk/include/config.hpp
   trunk/include/coord.hpp
   trunk/include/coord_array.hpp
   trunk/include/css_color_parser.hpp
   trunk/include/ctrans.hpp
   trunk/include/datasource.hpp
   trunk/include/datasource_cache.hpp
   trunk/include/envelope.hpp
   trunk/include/expression.hpp
   trunk/include/factory.hpp
   trunk/include/feature.hpp
   trunk/include/feature_factory.hpp
   trunk/include/feature_layer_desc.hpp
   trunk/include/feature_style_processor.hpp
   trunk/include/feature_type_style.hpp
   trunk/include/fill.hpp
   trunk/include/filter.hpp
   trunk/include/filter_expression.hpp
   trunk/include/filter_factory.hpp
   trunk/include/filter_parser.hpp
   trunk/include/filter_parser_ast.hpp
   trunk/include/filter_visitor.hpp
   trunk/include/font_engine_freetype.hpp
   trunk/include/gamma.hpp
   trunk/include/geom_util.hpp
   trunk/include/geometry.hpp
   trunk/include/global.hpp
   trunk/include/graphics.hpp
   trunk/include/image_data.hpp
   trunk/include/image_reader.hpp
   trunk/include/image_util.hpp
   trunk/include/label_collision_detector.hpp
   trunk/include/label_placement.hpp
   trunk/include/layer.hpp
   trunk/include/line_pattern_symbolizer.hpp
   trunk/include/line_symbolizer.hpp
   trunk/include/load_map.hpp
   trunk/include/local_datasource.hpp
   trunk/include/logical.hpp
   trunk/include/map.hpp
   trunk/include/math_expr.hpp
   trunk/include/memory.hpp
   trunk/include/params.hpp
   trunk/include/plugin.hpp
   trunk/include/point_symbolizer.hpp
   trunk/include/polygon_pattern_symbolizer.hpp
   trunk/include/polygon_symbolizer.hpp
   trunk/include/pool.hpp
   trunk/include/quad_tree.hpp
   trunk/include/query.hpp
   trunk/include/raster.hpp
   trunk/include/raster_symbolizer.hpp
   trunk/include/regex_filter.hpp
   trunk/include/rule.hpp
   trunk/include/save_map.hpp
   trunk/include/spatial.hpp
   trunk/include/stroke.hpp
   trunk/include/style.hpp
   trunk/include/style_factory.hpp
   trunk/include/symbolizer.hpp
   trunk/include/text_symbolizer.hpp
   trunk/include/utils.hpp
   trunk/include/value.hpp
   trunk/include/vertex.hpp
   trunk/include/vertex_transform.hpp
   trunk/include/vertex_vector.hpp
   trunk/include/wkb.hpp
Modified:
   trunk/SConstruct
   trunk/bindings/python/SConscript
   trunk/bindings/python/mapnik/__init__.py
   trunk/bindings/python/mapnik_color.cpp
   trunk/bindings/python/mapnik_datasource_cache.cpp
   trunk/bindings/python/mapnik_envelope.cpp
   trunk/bindings/python/mapnik_filter.cpp
   trunk/bindings/python/mapnik_font_engine.cpp
   trunk/bindings/python/mapnik_image.cpp
   trunk/bindings/python/mapnik_layer.cpp
   trunk/bindings/python/mapnik_line_pattern_symbolizer.cpp
   trunk/bindings/python/mapnik_line_symbolizer.cpp
   trunk/bindings/python/mapnik_map.cpp
   trunk/bindings/python/mapnik_parameters.cpp
   trunk/bindings/python/mapnik_point_symbolizer.cpp
   trunk/bindings/python/mapnik_polygon_pattern_symbolizer.cpp
   trunk/bindings/python/mapnik_polygon_symbolizer.cpp
   trunk/bindings/python/mapnik_python.cpp
   trunk/bindings/python/mapnik_query.cpp
   trunk/bindings/python/mapnik_raster_symbolizer.cpp
   trunk/bindings/python/mapnik_rule.cpp
   trunk/bindings/python/mapnik_stroke.cpp
   trunk/bindings/python/mapnik_style.cpp
   trunk/bindings/python/mapnik_text_symbolizer.cpp
   trunk/demo/c++/rundemo.cpp
   trunk/fonts/SConscript
   trunk/plugins/input/postgis/SConscript
   trunk/plugins/input/raster/SConscript
   trunk/plugins/input/raster/raster_datasource.cpp
   trunk/plugins/input/raster/raster_datasource.hpp
   trunk/plugins/input/raster/raster_featureset.cpp
   trunk/plugins/input/raster/raster_featureset.hpp
   trunk/plugins/input/shape/SConscript
   trunk/plugins/input/shape/dbffile.cpp
   trunk/plugins/input/shape/dbffile.hpp
   trunk/plugins/input/shape/shape.cpp
   trunk/plugins/input/shape/shape.hpp
   trunk/plugins/input/shape/shape_featureset.cpp
   trunk/plugins/input/shape/shape_featureset.hpp
   trunk/plugins/input/shape/shape_index_featureset.cpp
   trunk/plugins/input/shape/shape_index_featureset.hpp
   trunk/plugins/input/shape/shapefile.cpp
   trunk/plugins/input/shape/shapefile.hpp
   trunk/plugins/input/shape/shp_index.cpp
   trunk/plugins/input/shape/shp_index.hpp
   trunk/src/SConscript
   trunk/src/agg_renderer.cpp
   trunk/src/datasource_cache.cpp
   trunk/src/envelope.cpp
   trunk/src/filter_factory.cpp
   trunk/src/font_engine_freetype.cpp
   trunk/src/graphics.cpp
   trunk/src/image_reader.cpp
   trunk/src/image_util.cpp
   trunk/src/layer.cpp
   trunk/src/line_pattern_symbolizer.cpp
   trunk/src/load_map.cpp
   trunk/src/map.cpp
   trunk/src/memory.cpp
   trunk/src/params.cpp
   trunk/src/plugin.cpp
   trunk/src/png_reader.cpp
   trunk/src/point_symbolizer.cpp
   trunk/src/polygon_pattern_symbolizer.cpp
   trunk/src/save_map.cpp
   trunk/src/text_symbolizer.cpp
   trunk/src/tiff_reader.cpp
   trunk/src/wkb.cpp
   trunk/utils/shapeindex/SConscript
   trunk/utils/shapeindex/quadtree.hpp
   trunk/utils/shapeindex/shapeindex.cpp
Log:
1. move include to mapnik/include
2. update demos,bibdibgs etc.



Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/SConstruct	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,37 +22,34 @@
 
 import os, sys, platform
 
-
-
 if platform.uname()[4] == 'x86_64':
-    LIB_PLATFORM = 'lib64'
-else :
-    LIB_PLATFORM = 'lib'
+    LIBDIR_SCHEMA='lib64' 
+else:
+    LIBDIR_SCHEMA='lib'
 
-    
 opts = Options()
-
 opts.Add('PREFIX', 'The install path &quot;prefix&quot;', '/usr/local')
 opts.Add(PathOption('BOOST_INCLUDES', 'Search path for boost include files', '/usr/include'))
-opts.Add(PathOption('BOOST_LIBS', 'Search path for boost library files', '/usr/' + LIB_PLATFORM))
+opts.Add(PathOption('BOOST_LIBS', 'Search path for boost library files', '/usr/' + LIBDIR_SCHEMA))
 opts.Add(PathOption('FREETYPE_CONFIG', 'The path to the freetype-config executable.', '/usr/bin/freetype-config'))
 opts.Add(PathOption('PNG_INCLUDES', 'Search path for libpng include files', '/usr/include'))
-opts.Add(PathOption('PNG_LIBS', 'Search path for libpng include files', '/usr/' + LIB_PLATFORM))
+opts.Add(PathOption('PNG_LIBS','Search path for libpng include files','/usr/' + LIBDIR_SCHEMA))
 opts.Add(PathOption('JPEG_INCLUDES', 'Search path for libjpeg include files', '/usr/include'))
-opts.Add(PathOption('JPEG_LIBS', 'Search path for libjpeg library files', '/usr/' + LIB_PLATFORM))
+opts.Add(PathOption('JPEG_LIBS', 'Search path for libjpeg library files', '/usr/' + LIBDIR_SCHEMA))
 opts.Add(PathOption('TIFF_INCLUDES', 'Search path for libtiff include files', '/usr/include'))
-opts.Add(PathOption('TIFF_LIBS', 'Search path for libtiff library files', '/usr/' + LIB_PLATFORM))
+opts.Add(PathOption('TIFF_LIBS', 'Search path for libtiff library files', '/usr/' + LIBDIR_SCHEMA))
 opts.Add(PathOption('PGSQL_INCLUDES', 'Search path for PostgreSQL include files', '/usr/include'))
-opts.Add(PathOption('PGSQL_LIBS', 'Search path for PostgreSQL library files', '/usr/' + LIB_PLATFORM))
+opts.Add(PathOption('PGSQL_LIBS', 'Search path for PostgreSQL library files', '/usr/' + LIBDIR_SCHEMA))
 opts.Add(PathOption('PROJ_INCLUDES', 'Search path for PROJ.4 include files', '/usr/local/include'))
-opts.Add(PathOption('PROJ_LIBS', 'Search path for PROJ.4 include files', '/usr/local/' + LIB_PLATFORM))
+opts.Add(PathOption('PROJ_LIBS', 'Search path for PROJ.4 include files', '/usr/local/' + LIBDIR_SCHEMA))
 opts.Add(PathOption('PYTHON','Python executable', sys.executable))
 opts.Add(ListOption('INPUT_PLUGINS','Input drivers to include','all',['postgis','shape','raster']))
 opts.Add(ListOption('BINDINGS','Language bindings to build','all',['python']))
+
 opts.Add('DEBUG', 'Compile a debug version of mapnik', '')
 
 env = Environment(ENV=os.environ, options=opts)
-env['LIB_PLATFORM'] = LIB_PLATFORM
+env['LIBDIR_SCHEMA'] = LIBDIR_SCHEMA
 
 Help(opts.GenerateHelpText(env))
 

Modified: trunk/bindings/python/SConscript
===================================================================
--- trunk/bindings/python/SConscript	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/SConscript	2006-10-04 11:22:18 UTC (rev 313)
@@ -23,7 +23,7 @@
 
 Import('env')
 
-prefix = env['PYTHON_PREFIX'] + '/'+env['LIB_PLATFORM']+ '/python' + env['PYTHON_VERSION'] + '/site-packages/'
+prefix = env['PYTHON_PREFIX'] + '/'+ 'lib' + '/python' + env['PYTHON_VERSION'] + '/site-packages/'
 
 libraries = ['mapnik', 'boost_python%s' % env['BOOST_APPEND']]
 headers = [env['PYTHON_PREFIX'] + '/include/python' + env['PYTHON_VERSION']] + env['CPPPATH']
@@ -36,7 +36,7 @@
 fontscollectionpath = mapniklibpath + '/fonts'
 &quot;&quot;&quot;
 
-file('mapnik/paths.py','w').write(paths % (env['PREFIX'] + '/'+env['LIB_PLATFORM']+'/mapnik',))
+file('mapnik/paths.py','w').write(paths % (env['PREFIX'] + '/'+env['LIBDIR_SCHEMA']+'/mapnik',))
 
 pymapnik = glob.glob('mapnik/*.py')
 env.Alias(target='install', source=env.Install(prefix+'/mapnik', pymapnik))

Modified: trunk/bindings/python/mapnik/__init__.py
===================================================================
--- trunk/bindings/python/mapnik/__init__.py	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik/__init__.py	2006-10-04 11:22:18 UTC (rev 313)
@@ -59,10 +59,10 @@
         return 'Envelope(%s,%s,%s,%s)' % \
                (self.minx,self.miny,self.maxx,self.maxy)
 
-def Layer (**keywords):
-    return CreateLayer(keywords)
-    
-    
+def Datasource (**keywords):
+    return CreateDatasource(keywords)
+
+
 #register datasources
 from mapnik import DatasourceCache
 DatasourceCache.instance().register_datasources('%s' % inputpluginspath)

Modified: trunk/bindings/python/mapnik_color.cpp
===================================================================
--- trunk/bindings/python/mapnik_color.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_color.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -23,8 +23,8 @@
 
 
 #include &lt;boost/python.hpp&gt;
-#include &lt;color.hpp&gt;
-#include &lt;color_factory.hpp&gt;
+#include &lt;mapnik/color.hpp&gt;
+#include &lt;mapnik/color_factory.hpp&gt;
 
 using mapnik::Color;
 using mapnik::color_factory;

Modified: trunk/bindings/python/mapnik_datasource_cache.cpp
===================================================================
--- trunk/bindings/python/mapnik_datasource_cache.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_datasource_cache.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -23,7 +23,7 @@
 //$Id$
 
 #include &lt;boost/python.hpp&gt;
-#include &quot;datasource_cache.hpp&quot;
+#include &lt;mapnik/datasource_cache.hpp&gt;
 
 void export_datasource_cache()
 {

Modified: trunk/bindings/python/mapnik_envelope.cpp
===================================================================
--- trunk/bindings/python/mapnik_envelope.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_envelope.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,7 +22,7 @@
 //$Id: mapnik_envelope.cc 27 2005-03-30 21:45:40Z pavlenko $
 
 #include &lt;boost/python.hpp&gt;
-#include &lt;envelope.hpp&gt;
+#include &lt;mapnik/envelope.hpp&gt;
 
 using mapnik::coord;
 using mapnik::Envelope;

Modified: trunk/bindings/python/mapnik_filter.cpp
===================================================================
--- trunk/bindings/python/mapnik_filter.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_filter.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,13 +22,14 @@
 //$Id$
 
 #include &lt;boost/python.hpp&gt;
-#include &lt;spatial.hpp&gt;
-#include &lt;logical.hpp&gt;
-#include &lt;comparison.hpp&gt;
-#include &lt;regex_filter.hpp&gt;
-#include &lt;filter.hpp&gt;
-#include &lt;filter_factory.hpp&gt;
 
+#include &lt;mapnik/spatial.hpp&gt;
+#include &lt;mapnik/logical.hpp&gt;
+#include &lt;mapnik/comparison.hpp&gt;
+#include &lt;mapnik/regex_filter.hpp&gt;
+#include &lt;mapnik/filter.hpp&gt;
+#include &lt;mapnik/filter_factory.hpp&gt;
+
 using mapnik::filter;
 using mapnik::filter_ptr;
 using mapnik::filter_factory;

Modified: trunk/bindings/python/mapnik_font_engine.cpp
===================================================================
--- trunk/bindings/python/mapnik_font_engine.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_font_engine.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,7 +22,7 @@
 //$Id$
 
 #include &lt;boost/python.hpp&gt;
-#include &lt;font_engine_freetype.hpp&gt;
+#include &lt;mapnik/font_engine_freetype.hpp&gt;
 
 void export_font_engine()
 {

Modified: trunk/bindings/python/mapnik_image.cpp
===================================================================
--- trunk/bindings/python/mapnik_image.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_image.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -24,14 +24,11 @@
 #include &lt;boost/python.hpp&gt;
 #include &lt;boost/python/module.hpp&gt;
 #include &lt;boost/python/def.hpp&gt;
-#include &lt;graphics.hpp&gt;
+#include &lt;mapnik/graphics.hpp&gt;
 
 using mapnik::Image32;
-
-
 using namespace boost::python;
 
-
 PyObject* rawdata( Image32 const&amp; im)
 {
     int size = im.width() * im.height() * 4;

Modified: trunk/bindings/python/mapnik_layer.cpp
===================================================================
--- trunk/bindings/python/mapnik_layer.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_layer.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -25,7 +25,7 @@
 #include &lt;boost/python.hpp&gt;
 #include &lt;boost/python/detail/api_placeholder.hpp&gt;
 #include &lt;boost/python/suite/indexing/vector_indexing_suite.hpp&gt;
-#include &lt;layer.hpp&gt;
+#include &lt;mapnik/layer.hpp&gt;
 
 using mapnik::Layer;
 using mapnik::parameters;

Modified: trunk/bindings/python/mapnik_line_pattern_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_line_pattern_symbolizer.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_line_pattern_symbolizer.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,7 +22,7 @@
 //$Id$
 
 #include &lt;boost/python.hpp&gt;
-#include &lt;line_pattern_symbolizer.hpp&gt;
+#include &lt;mapnik/line_pattern_symbolizer.hpp&gt;
 
 using mapnik::line_pattern_symbolizer;
 

Modified: trunk/bindings/python/mapnik_line_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_line_symbolizer.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_line_symbolizer.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,7 +22,7 @@
 //$Id$
 
 #include &lt;boost/python.hpp&gt;
-#include &lt;line_symbolizer.hpp&gt;
+#include &lt;mapnik/line_symbolizer.hpp&gt;
 
 using mapnik::line_symbolizer;
 using mapnik::stroke;

Modified: trunk/bindings/python/mapnik_map.cpp
===================================================================
--- trunk/bindings/python/mapnik_map.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_map.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -26,8 +26,8 @@
 #include &lt;boost/python/detail/api_placeholder.hpp&gt;
 #include &lt;boost/python/suite/indexing/vector_indexing_suite.hpp&gt;
 
-#include &lt;layer.hpp&gt;
-#include &lt;map.hpp&gt;
+#include &lt;mapnik/layer.hpp&gt;
+#include &lt;mapnik/map.hpp&gt;
 
 using mapnik::Color;
 using mapnik::coord;

Modified: trunk/bindings/python/mapnik_parameters.cpp
===================================================================
--- trunk/bindings/python/mapnik_parameters.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_parameters.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -23,7 +23,7 @@
 
 #include &lt;boost/python.hpp&gt;
 #include &lt;boost/python/detail/api_placeholder.hpp&gt;
-#include &lt;params.hpp&gt;
+#include &lt;mapnik/params.hpp&gt;
 
 using mapnik::parameter;
 using mapnik::parameters;

Modified: trunk/bindings/python/mapnik_point_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_point_symbolizer.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_point_symbolizer.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,7 +22,7 @@
 //$Id$
 
 #include &lt;boost/python.hpp&gt;
-#include &lt;point_symbolizer.hpp&gt;
+#include &lt;mapnik/point_symbolizer.hpp&gt;
 
 void export_point_symbolizer()
 {

Modified: trunk/bindings/python/mapnik_polygon_pattern_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_polygon_pattern_symbolizer.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_polygon_pattern_symbolizer.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,7 +22,7 @@
 //$Id$
 
 #include &lt;boost/python.hpp&gt;
-#include &lt;polygon_pattern_symbolizer.hpp&gt;
+#include &lt;mapnik/polygon_pattern_symbolizer.hpp&gt;
 
 void export_polygon_pattern_symbolizer()
 {

Modified: trunk/bindings/python/mapnik_polygon_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_polygon_symbolizer.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_polygon_symbolizer.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,7 +22,7 @@
 //$Id$
 
 #include &lt;boost/python.hpp&gt;
-#include &lt;polygon_symbolizer.hpp&gt;
+#include &lt;mapnik/polygon_symbolizer.hpp&gt;
 
 void export_polygon_symbolizer()
 {

Modified: trunk/bindings/python/mapnik_python.cpp
===================================================================
--- trunk/bindings/python/mapnik_python.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_python.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -47,12 +47,12 @@
 void export_text_symbolizer();
 void export_font_engine();
 
-#include &lt;map.hpp&gt;
-#include &lt;agg_renderer.hpp&gt;
-#include &lt;graphics.hpp&gt;
-#include &lt;datasource_cache.hpp&gt;
-#include &lt;load_map.hpp&gt;
-#include &lt;save_map.hpp&gt;
+#include &lt;mapnik/map.hpp&gt;
+#include &lt;mapnik/agg_renderer.hpp&gt;
+#include &lt;mapnik/graphics.hpp&gt;
+#include &lt;mapnik/datasource_cache.hpp&gt;
+#include &lt;mapnik/load_map.hpp&gt;
+#include &lt;mapnik/save_map.hpp&gt;
 
 void render_to_file(const mapnik::Map&amp; map,
                     const std::string&amp; file,

Modified: trunk/bindings/python/mapnik_query.cpp
===================================================================
--- trunk/bindings/python/mapnik_query.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_query.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,7 +22,7 @@
 //$Id$
 
 #include &lt;boost/python.hpp&gt;
-#include &lt;query.hpp&gt;
+#include &lt;mapnik/query.hpp&gt;
 
 void export_query()
 {

Modified: trunk/bindings/python/mapnik_raster_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_raster_symbolizer.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_raster_symbolizer.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,7 +22,7 @@
 //$Id$
 
 #include &lt;boost/python.hpp&gt;
-#include &lt;raster_symbolizer.hpp&gt;
+#include &lt;mapnik/raster_symbolizer.hpp&gt;
 
 void export_raster_symbolizer()
 {

Modified: trunk/bindings/python/mapnik_rule.cpp
===================================================================
--- trunk/bindings/python/mapnik_rule.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_rule.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -21,12 +21,11 @@
  *****************************************************************************/
 //$Id$
 
-
 #include &lt;boost/python.hpp&gt;
 #include &lt;boost/python/implicit.hpp&gt;
 #include &lt;boost/python/suite/indexing/vector_indexing_suite.hpp&gt;
-#include &lt;rule.hpp&gt;
 
+#include &lt;mapnik/rule.hpp&gt;
 
 void export_rule()
 {
@@ -45,8 +44,8 @@
     using mapnik::text_symbolizer;
     using mapnik::symbolizer;
     using mapnik::symbolizers;
-
     
+    
     implicitly_convertible&lt;point_symbolizer,symbolizer&gt;();
     implicitly_convertible&lt;line_symbolizer,symbolizer&gt;();
     implicitly_convertible&lt;line_pattern_symbolizer,symbolizer&gt;();

Modified: trunk/bindings/python/mapnik_stroke.cpp
===================================================================
--- trunk/bindings/python/mapnik_stroke.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_stroke.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,8 +22,9 @@
 //$Id$
 
 #include &lt;boost/python.hpp&gt;
-#include &lt;stroke.hpp&gt;
 
+#include &lt;mapnik/stroke.hpp&gt;
+
 void export_stroke ()
 {
     using namespace mapnik;

Modified: trunk/bindings/python/mapnik_style.cpp
===================================================================
--- trunk/bindings/python/mapnik_style.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_style.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -23,8 +23,9 @@
 
 #include &lt;boost/python.hpp&gt;
 #include &lt;boost/python/suite/indexing/vector_indexing_suite.hpp&gt;
-#include &lt;feature_type_style.hpp&gt;
 
+#include &lt;mapnik/feature_type_style.hpp&gt;
+
 void export_style()
 {
     using namespace boost::python;

Modified: trunk/bindings/python/mapnik_text_symbolizer.cpp
===================================================================
--- trunk/bindings/python/mapnik_text_symbolizer.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/bindings/python/mapnik_text_symbolizer.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,8 +22,9 @@
 //$Id$
 
 #include &lt;boost/python.hpp&gt;
-#include &lt;text_symbolizer.hpp&gt;
 
+#include &lt;mapnik/text_symbolizer.hpp&gt;
+
 void export_text_symbolizer()
 {
     using namespace boost::python;

Modified: trunk/demo/c++/rundemo.cpp
===================================================================
--- trunk/demo/c++/rundemo.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/demo/c++/rundemo.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -21,15 +21,14 @@
  *****************************************************************************/
 // $Id$
 
-#include &lt;map.hpp&gt;
+#include &lt;mapnik/map.hpp&gt;
+#include &lt;mapnik/datasource_cache.hpp&gt;
+#include &lt;mapnik/font_engine_freetype.hpp&gt;
+#include &lt;mapnik/agg_renderer.hpp&gt;
+#include &lt;mapnik/filter_factory.hpp&gt;
+#include &lt;mapnik/color_factory.hpp&gt;
+#include &lt;mapnik/image_util.hpp&gt;
 
-#include &lt;datasource_cache.hpp&gt;
-#include &lt;font_engine_freetype.hpp&gt;
-#include &lt;agg_renderer.hpp&gt;
-#include &lt;filter_factory.hpp&gt;
-#include &lt;color_factory.hpp&gt;
-#include &lt;image_util.hpp&gt;
-
 #include &lt;iostream&gt;
 
 using namespace mapnik;
@@ -231,7 +230,8 @@
         m.addLayer(lyr);
     }
     
-    m.zoomToBox(Envelope&lt;double&gt;(1405120.04127408,-247003.813399447,1706357.31328276,-25098.593149577));
+    m.zoomToBox(Envelope&lt;double&gt;(1405120.04127408,-247003.813399447,
+                                 1706357.31328276,-25098.593149577));
     
     Image32 buf(m.getWidth(),m.getHeight());
     agg_renderer&lt;Image32&gt; ren(m,buf);

Modified: trunk/fonts/SConscript
===================================================================
--- trunk/fonts/SConscript	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/fonts/SConscript	2006-10-04 11:22:18 UTC (rev 313)
@@ -24,4 +24,4 @@
 prefix = env['PREFIX']
 
 includes = glob.glob('*/*.ttf')
-env.Alias(target='install', source=env.Install(prefix+'/' + env['LIB_PLATFORM'] + '/mapnik/fonts', includes))
+env.Alias(target='install', source=env.Install(prefix+'/' + env['LIBDIR_SCHEMA'] + '/mapnik/fonts', includes))

Deleted: trunk/include/agg_renderer.hpp
===================================================================
--- trunk/include/agg_renderer.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/agg_renderer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,60 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef AGG_RENDERER_HPP
-#define AGG_RENDERER_HPP
-
-#include &quot;feature_style_processor.hpp&quot;
-#include &lt;boost/utility.hpp&gt;
-#include &quot;font_engine_freetype.hpp&quot;
-#include &quot;label_collision_detector.hpp&quot;
-
-namespace mapnik
-{
-    template &lt;typename T&gt;
-    class MAPNIK_DECL agg_renderer : public feature_style_processor&lt;agg_renderer&lt;T&gt; &gt;,
-                                     private boost::noncopyable
-    {
-    public:
-        agg_renderer(Map const&amp; m, T &amp; pixmap);
-        void start_map_processing(Map const&amp; map);
-        void end_map_processing(Map const&amp; map);
-        void start_layer_processing(Layer const&amp; lay);
-        void end_layer_processing(Layer const&amp; lay);
-        void process(point_symbolizer const&amp; sym,Feature const&amp; feature);
-        void process(line_symbolizer const&amp; sym,Feature const&amp; feature);
-        void process(line_pattern_symbolizer const&amp; sym,Feature const&amp; feature);
-        void process(polygon_symbolizer const&amp; sym,Feature const&amp; feature);
-        void process(polygon_pattern_symbolizer const&amp; sym,Feature const&amp; feature);
-        void process(raster_symbolizer const&amp; sym,Feature const&amp; feature);
-        void process(text_symbolizer const&amp; sym,Feature const&amp; feature);
-    private:
-        T &amp; pixmap_;
-        CoordTransform t_;
-        face_manager&lt;freetype_engine&gt; font_manager_;
-        label_collision_detector2 detector_;
-    };
-}
-
-#endif //AGG_RENDERER_HPP

Deleted: trunk/include/attribute.hpp
===================================================================
--- trunk/include/attribute.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/attribute.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,222 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: attribute.hpp 41 2005-04-13 20:21:56Z pavlenko $
-
-#ifndef ATTRIBUTE_HPP
-#define ATTRIBUTE_HPP
-
-#include &lt;typeinfo&gt;
-#include &lt;sstream&gt;
-#include &lt;map&gt;
-#include &lt;boost/any.hpp&gt;
-
-
-namespace mapnik
-{
-    template &lt;typename T&gt;
-    struct attribute_traits
-    {
-	static std::string to_string(const T&amp; value)
-	{
-	    std::stringstream ss;
-	    ss &lt;&lt; value;
-	    return ss.str();
-	}
-    };
-
-    template &lt;&gt;
-    struct attribute_traits&lt;std::string&gt;
-    {
-	static std::string to_string(const std::string&amp; value)
-	{
-	    return value;
-	}
-    };
-    
-    class MAPNIK_DECL attribute
-    {	
-    public:
-	attribute()
-	    : base_(0) {}
-
-	template &lt;typename T&gt;
-	attribute(const T&amp; value)
-	    : base_(new attribute_impl&lt;T&gt;(value)) 
-	{}
-
-	attribute(const attribute&amp; rhs)
-	    : base_(rhs.base_ ? rhs.base_-&gt;clone() : 0)
-	{}
-
-	~attribute() 
-	{
-	    delete base_;
-	}
-
-	template&lt;typename T&gt;
-	attribute&amp; operator=(const T&amp; rhs)
-	{
-	    attribute(rhs).swap(*this);
-	    return *this;
-	}
-
-	attribute&amp; operator=(const attribute&amp; rhs)
-	{
-	    attribute(rhs).swap(*this);
-	    return *this;
-	}
-
-	bool empty() const
-	{
-	    return !base_;
-	}
-
-	const std::type_info &amp; type() const
-        {
-            return base_ ? base_-&gt;type() : typeid(void);
-        }
-
-	const std::string to_string() const
-	{
-	    return base_ ? base_-&gt;to_string() : &quot;&quot;;
-	}
-    private:
-	attribute&amp; swap(attribute&amp; rhs)
-	{
-	    std::swap(base_,rhs.base_);
-	    return *this;
-	}
-	
-	class attribute_base
-	{
-	public:
-	    virtual ~attribute_base() {}
-	    virtual attribute_base* clone() const=0;
-	    virtual std::string to_string() const=0;
-	    virtual const std::type_info&amp; type()  const=0;
-	};
-
-	template &lt;typename T,typename ATraits=attribute_traits&lt;T&gt; &gt;
-	class attribute_impl : public attribute_base
-	{	    
-	public:
-	    typedef T value_type;
-	    attribute_impl(const value_type&amp; value)
-		: value_(value) {}
-	    
-	    virtual std::string to_string() const
-	    {
-		return  ATraits::to_string(value_);
-	    }
-	    
-	    virtual attribute_base* clone() const
-	    {
-		return new attribute_impl(value_);
-	    }
-	    virtual const std::type_info&amp; type() const 
-	    {
-		return typeid(value_);
-	    }
-	    value_type value_;
-	};
-    private:
-	template&lt;typename value_type&gt;
-	friend value_type* attribute_cast(attribute*);
-	attribute_base* base_;
-    };
-    
-    
-    template&lt;typename T&gt;
-    struct bad_attribute_cast : public std::bad_cast
-    {
-	virtual const char* what() const throw()
-	{
-	    return &quot;attribute::failed conversion&quot;;
-	}
-    };
-    
-    template &lt;typename T&gt; 
-    bool is_type(const attribute&amp; attr)
-    {
-	return attr.type()==typeid(T);
-    }
-    
-    template &lt;typename T&gt;
-    T* attribute_cast(attribute* attr)
-    {
-	return attr &amp;&amp; attr-&gt;type() == typeid(T)
-	    ? &amp;static_cast&lt;attribute::attribute_impl&lt;T&gt;*&gt;(attr-&gt;base_)-&gt;value_
-	    : 0;
-    }
-
-    template &lt;typename T&gt;
-    const T* attribute_cast(const attribute* attr)
-    {
-	return attribute_cast&lt;T&gt;(const_cast&lt;attribute*&gt;(attr));
-    }
-    
-    template &lt;typename T&gt;
-    T attribute_cast(const attribute&amp; attr)
-    {
-	using namespace boost;
-	typedef BOOST_DEDUCED_TYPENAME remove_reference&lt;T&gt;::type nonref;
-	const nonref * result=attribute_cast&lt;nonref&gt;(&amp;attr);
-	if (!result)
-	{
-	    throw bad_attribute_cast&lt;T&gt;();
-	}
-	return *result;
-    }
-    
-    template &lt;typename T&gt;
-    T attribute_cast(attribute&amp; attr)
-    {
-	using namespace boost;
-	typedef BOOST_DEDUCED_TYPENAME remove_reference&lt;T&gt;::type nonref;
-	nonref * result=attribute_cast&lt;nonref&gt;(&amp;attr);
-	if (!result)
-	    throw bad_attribute_cast&lt;T&gt;();
-	return *result;
-    }
-    
-       
-    template &lt;typename T&gt;
-    attribute attribute_from_string(const std::string&amp; val)
-    {
-	std::istringstream is(val);
-	T t;
-	is &gt;&gt; t;
-	return attribute(t);
-    }
-
-    template &lt;typename charT, typename traits&gt;
-    inline std::basic_ostream&lt;charT,traits&gt;&amp; 
-    operator &lt;&lt; (std::basic_ostream&lt;charT,traits&gt;&amp; out,
-		 const attribute&amp; attr)
-    {
-	out &lt;&lt; attr.to_string();
-	return out; 
-    }
-}
-
-#endif                                            //ATTRIBUTE_HPP

Deleted: trunk/include/attribute_collector.hpp
===================================================================
--- trunk/include/attribute_collector.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/attribute_collector.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,98 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef ATTRIBUTE_COLLECTOR_HPP
-#define ATTRIBUTE_COLLECTOR_HPP
-
-#include &quot;filter.hpp&quot;
-#include &quot;expression.hpp&quot;
-#include &quot;feature_layer_desc.hpp&quot;
-#include &quot;rule.hpp&quot;
-#include &lt;set&gt;
-#include &lt;iostream&gt;
-
-namespace mapnik
-{
-    
-    struct symbolizer_attributes : public boost::static_visitor&lt;&gt;
-    {
-	symbolizer_attributes(std::set&lt;std::string&gt;&amp; names)
-	    : names_(names) {}
-	
-	template &lt;typename T&gt;
-	void operator () (T const&amp;) const {}
-	void operator () (text_symbolizer const&amp; sym)
-	{
-	    names_.insert(sym.get_name());
-	}
-    private:
-	std::set&lt;std::string&gt;&amp; names_;
-    };
-
-    template &lt;typename FeatureT&gt;
-    class attribute_collector : public filter_visitor&lt;FeatureT&gt;
-    {
-    private:
-	std::set&lt;std::string&gt;&amp; names_;
-    public:
-	
-	attribute_collector(std::set&lt;std::string&gt;&amp; names)
-	    : names_(names) {}
-	
-	void visit(filter&lt;FeatureT&gt;&amp; /*filter*/) 
-	{ 
-	    //not interested
-	}
-	
-	void visit(expression&lt;FeatureT&gt;&amp; exp)
-	{
-	    property&lt;FeatureT&gt;* pf;
-	    if ((pf = dynamic_cast&lt;property&lt;FeatureT&gt;*&gt;(&amp;exp)))
-	    {
-		names_.insert(pf-&gt;name());
-	    }
-	}
-	void visit(rule_type const&amp; r)
-	{	    
-	    const symbolizers&amp; symbols = r.get_symbolizers();
-	    symbolizers::const_iterator symIter=symbols.begin();
-	    symbolizer_attributes attr(names_);
-	    while (symIter != symbols.end())
-	    {
-		boost::apply_visitor(attr,*symIter++);
-	    }
-	    filter_ptr const&amp; filter = r.get_filter();
-	    filter-&gt;accept(*this);
-	}
-
-	virtual ~attribute_collector() {}
-    private:
-	
-	// no copying 
-	attribute_collector(attribute_collector const&amp;);
-	attribute_collector&amp; operator=(attribute_collector const&amp;);
-    };   
-}
-
-#endif //ATTRIBUTE_COLLECTOR_HPP

Deleted: trunk/include/attribute_descriptor.hpp
===================================================================
--- trunk/include/attribute_descriptor.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/attribute_descriptor.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,39 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef ATTRIBUTE_DESCRIPTOR
-#define ATTRIBUTE_DESCRIPTOR
-
-#include &lt;string&gt;
-
-namespace mapnik
-{
-    struct attribute_desc
-    {
-	std::string name;
-	eType type;
-    };
-}
-
-#endif

Deleted: trunk/include/color.hpp
===================================================================
--- trunk/include/color.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/color.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,127 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: color.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef COLOR_HPP
-#define COLOR_HPP
-
-#include &lt;boost/format.hpp&gt;
-#include &quot;config.hpp&quot;
-#include &lt;sstream&gt;
-
-namespace mapnik {
-
-    class MAPNIK_DECL Color
-    {
-    private:
-        unsigned int abgr_;
-    public:
-        Color()
-            :abgr_(0xffffffff) {}
-
-        Color(int red,int green,int blue,int alpha=0xff)
-            : abgr_((alpha&amp;0xff) &lt;&lt; 24 | 
-                    (blue&amp;0xff) &lt;&lt; 16  | 
-                    (green&amp;0xff) &lt;&lt; 8  | 
-                    red&amp;0xff) {}
-        
-        explicit Color(int rgba)
-            : abgr_(rgba) {}
-
-        Color(const Color&amp; rhs)
-            : abgr_(rhs.abgr_) {}
-
-        Color&amp; operator=(const Color&amp; rhs)
-        {
-            if (this==&amp;rhs) return *this;
-            abgr_=rhs.abgr_;
-            return *this;
-        }
-        inline unsigned int red() const
-        {
-            return abgr_&amp;0xff;
-        }
-        inline unsigned int green() const
-        {
-            return (abgr_&gt;&gt;8)&amp;0xff;
-        }
-        inline unsigned int blue() const
-        {
-            return (abgr_&gt;&gt;16)&amp;0xff;
-        }
-        inline unsigned int alpha() const
-        {
-            return (abgr_&gt;&gt;24)&amp;0xff;
-        }
-	
-        inline void set_red(unsigned int r)
-        {
-            abgr_ = (abgr_ &amp; 0xffffff00) | (r&amp;0xff);
-        }
-        inline void set_green(unsigned int g)
-        {
-            abgr_ = (abgr_ &amp; 0xffff00ff) | ((g&amp;0xff) &lt;&lt; 8);
-        }
-        inline void set_blue(unsigned int b)
-        {
-            abgr_ = (abgr_ &amp; 0xff00ffff) | ((b&amp;0xff) &lt;&lt; 16);
-        }
-        inline void set_alpha(unsigned int a)
-        {
-            abgr_ = (abgr_ &amp; 0x00ffffff | (a&amp;0xff) &lt;&lt; 24);
-        }
-
-        inline unsigned int rgba() const
-        {
-            return abgr_;
-        }
-        inline void set_bgr(unsigned bgr)
-        {
-            abgr_ = (abgr_ &amp; 0xff000000) | (bgr &amp; 0xffffff);
-        }
-        inline bool operator==(Color const&amp; other) const
-        {
-            return abgr_ == other.abgr_;
-        }
-        
-        inline std::string to_string() const
-        {
-            std::stringstream ss;
-            ss &lt;&lt; &quot;rgb (&quot; 
-               &lt;&lt; red()   &lt;&lt; &quot;,&quot;  
-               &lt;&lt; green() &lt;&lt; &quot;,&quot;  
-               &lt;&lt; blue()  &lt;&lt; &quot;,&quot;
-               &lt;&lt; alpha() &lt;&lt; &quot;)&quot;;
-            return ss.str();
-        }
-        
-        inline std::string to_hex_string() const
-        {
-            std::stringstream ss;
-            ss &lt;&lt; boost::format(&quot;#%1$02x%2$02x%3$02x&quot;) % red() % green() % blue();
-            return ss.str();
-        }
-    };    
-}
-
-#endif //COLOR_HPP

Deleted: trunk/include/color_factory.hpp
===================================================================
--- trunk/include/color_factory.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/color_factory.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,53 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef COLOR_FACTORY_HPP
-#define COLOR_FACTORY_HPP
-
-#include &quot;config.hpp&quot;
-#include &quot;css_color_parser.hpp&quot;
-
-namespace mapnik
-{
-    using namespace boost::spirit;
-    class MAPNIK_DECL color_factory
-    {
-    public:
-        static Color from_string(char const* css_color)
-        {   
-            Color color;
-            actions&lt;Color&gt; a(color);
-            css_color_grammar&lt;actions&lt;Color&gt; &gt; grammar(a);
-            parse_info&lt;&gt; info = parse(css_color, grammar, space_p);
-            if (info.full) return color;
-            return Color(0,0,0);	
-        }    
-    private:
-        color_factory();
-        color_factory(color_factory const&amp;);
-        color_factory&amp; operator=(color_factory const&amp;);
-    };
-}
-
-#endif //COLOR_FACTORY_HPP

Deleted: trunk/include/comparison.hpp
===================================================================
--- trunk/include/comparison.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/comparison.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,153 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id$
-
-#ifndef COMPARISON_HPP
-#define COMPARISON_HPP
-
-
-#include &quot;filter.hpp&quot;
-#include &quot;expression.hpp&quot;
-#include &quot;attribute.hpp&quot;
-
-#include &lt;iostream&gt;
-
-namespace mapnik
-{   
-    template &lt;typename T&gt;  
-    struct greater_than
-    {
-	bool operator() (T const&amp; left, T const&amp; right) const
-	{
-	    return left &gt; right;
-	}
-	static std::string to_string()
-	{
-	    return &quot;&gt;&quot;;
-	}
-    };
-
-    template &lt;typename T&gt;  
-    struct greater_than_or_equal
-    {
-	bool operator() (T const&amp; left, T const&amp; right) const
-	{
-	    return left &gt;= right;
-	}
-	static std::string to_string()
-	{
-	    return &quot;&gt;=&quot;;
-	}
-    };
-    template &lt;typename T&gt;  
-    struct less_than
-    {
-	bool operator() (T const&amp; left, T const&amp; right) const
-	{
-	    return left &lt; right;
-	}
-	static std::string to_string()
-	{
-	    return &quot;&lt;&quot;;
-	}
-    };
-    template &lt;typename T&gt;  
-    struct less_than_or_equal
-    {
-	bool operator() (T const&amp; left, T const&amp; right) const
-	{
-	    return left &lt;= right;
-	}
-	static std::string to_string()
-	{
-	    return &quot;&lt;=&quot;;
-	}
-    };
-    template &lt;typename T&gt;  
-    struct equals
-    {
-	bool operator() (T const&amp; left, T const&amp; right) const
-	{
-	    return left == right;
-	}
-	static std::string to_string()
-	{
-	    return &quot;=&quot;;
-	}
-    };
-    
-    template &lt;typename T&gt;  
-    struct not_equals
-    {
-	bool operator() (T const&amp; left, T const&amp; right) const
-	{
-	    return left != right;
-	}
-	static std::string to_string()
-	{
-	    return &quot;&lt;&gt;&quot;;
-	}
-    };
-    
-    template &lt;typename FeatureT,typename Op&gt;
-    struct compare_filter : public filter&lt;FeatureT&gt;
-    {
-	compare_filter(expression&lt;FeatureT&gt; const&amp; left,
-		       expression&lt;FeatureT&gt; const&amp; right)
-	    : filter&lt;FeatureT&gt;(),
-	      left_(left.clone()), right_(right.clone()) {}
-
-	compare_filter(compare_filter const&amp; other)
-	    : filter&lt;FeatureT&gt;(),
-	      left_(other.left_-&gt;clone()),right_(other.right_-&gt;clone()) {}
-	
-	bool pass(const FeatureT&amp; feature) const
-	{   
-	    return Op()(left_-&gt;get_value(feature),right_-&gt;get_value(feature));     
-	}
-	void accept(filter_visitor&lt;FeatureT&gt;&amp; v)
-	{
-	    left_-&gt;accept(v);
-	    right_-&gt;accept(v);
-	    v.visit(*this);
-	}
-	std::string to_string() const
-	{
-	    return &quot;(&quot;+left_-&gt;to_string()+Op::to_string()+right_-&gt;to_string()+&quot;)&quot;;
-	}
-
-	filter&lt;FeatureT&gt;* clone() const
-	{
-	    return new compare_filter&lt;FeatureT,Op&gt;(*this);
-	}
-	virtual ~compare_filter() 
-	{
-	    delete left_;
-	    delete right_;
-	}
-    private:
-	expression&lt;FeatureT&gt;* left_;
-	expression&lt;FeatureT&gt;* right_;
-    };
-}
-
-#endif //COMPARISON_HPP

Deleted: trunk/include/config.hpp
===================================================================
--- trunk/include/config.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/config.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,39 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-#ifndef CONFIG_HPP
-#define CONFIG_HPP
-
-// Window DLL support
-
-#ifdef _WINDOWS
-# define MAPNIK_DECL __declspec (dllexport)
-# pragma warning( disable: 4251 )
-# pragma warning( disable: 4275 )
-# if (_MSC_VER &gt;= 1400) // vc8
-#   pragma warning(disable : 4996) //_CRT_SECURE_NO_DEPRECATE
-# endif
-#else
-# define MAPNIK_DECL 
-#endif
-
-#endif

Deleted: trunk/include/coord.hpp
===================================================================
--- trunk/include/coord.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/coord.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,138 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: coord.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef COORD_HPP
-#define COORD_HPP
-
-#include &lt;iostream&gt;
-#include &lt;iomanip&gt;
-#include &lt;sstream&gt;
-
-namespace mapnik 
-{   
-    template &lt;typename T,int dim&gt;
-    struct coord {
-        typedef T type;
-    };
-    
-    template &lt;typename T&gt;
-    struct coord&lt;T,2&gt; 
-    {
-        typedef T type;
-        T x;
-        T y;
-    public:
-        coord()
-            : x(),y() {}
-        coord(T x,T y)
-            : x(x),y(y) {}
-        template &lt;typename T2&gt;
-        coord (const coord&lt;T2,2&gt;&amp; rhs)
-            : x(type(rhs.x)),
-              y(type(rhs.y)) {}
-
-        template &lt;typename T2&gt;
-        coord&lt;T,2&gt;&amp; operator=(const coord&lt;T2,2&gt;&amp; rhs)
-        {
-            if ((void*)this==(void*)&amp;rhs)
-            {
-                return *this;
-            }
-            x=type(rhs.x);
-            y=type(rhs.y);
-            return *this;
-        }
-    };
-
-    template &lt;typename T&gt;
-    struct coord&lt;T,3&gt; 
-    {
-        typedef T type;
-        T x;
-        T y;
-        T z;
-    public:
-        coord()
-            : x(),y(),z() {}
-        coord(T x,T y,T z)
-            : x(x),y(y),z(z) {}
-        template &lt;typename T2&gt;
-        coord (const coord&lt;T2,3&gt;&amp; rhs)
-            : x(type(rhs.x)),
-              y(type(rhs.y)),
-              z(type(rhs.z)) {}
-
-        template &lt;typename T2&gt;
-        coord&lt;T,3&gt;&amp; operator=(const coord&lt;T2,3&gt;&amp; rhs)
-        {
-            if ((void*)this==(void*)&amp;rhs)
-            {
-                return *this;
-            }
-            x=type(rhs.x);
-            y=type(rhs.y);
-            z=type(rhs.z);
-            return *this;
-        }
-    };
-
-    typedef coord&lt;double,2&gt; coord2d;
-    typedef coord&lt;int,2&gt; coord2i;
-
-     
-    template &lt;typename charT,typename traits,typename T ,int dim&gt;
-    inline std::basic_ostream&lt;charT,traits&gt;&amp;
-    operator &lt;&lt; (std::basic_ostream&lt;charT,traits&gt;&amp; out,
-                 const coord&lt;T,dim&gt;&amp; c);
-    
-    template &lt;typename charT,typename traits,typename T&gt;
-    inline std::basic_ostream&lt;charT,traits&gt;&amp;
-    operator &lt;&lt; (std::basic_ostream&lt;charT,traits&gt;&amp; out,
-                 const coord&lt;T,2&gt;&amp; c)
-    {
-        std::basic_ostringstream&lt;charT,traits&gt; s;
-        s.copyfmt(out);
-        s.width(0);
-        s &lt;&lt; &quot;coord2(&quot; &lt;&lt; std::setprecision(16) 
-          &lt;&lt; c.x &lt;&lt; &quot;,&quot; &lt;&lt; c.y&lt;&lt; &quot;)&quot;;
-        out &lt;&lt; s.str();
-        return out;
-    }
-
-    template &lt;typename charT,typename traits,typename T&gt;
-    inline std::basic_ostream&lt;charT,traits&gt;&amp;
-    operator &lt;&lt; (std::basic_ostream&lt;charT,traits&gt;&amp; out,
-                 const coord&lt;T,3&gt;&amp; c)
-    {
-        std::basic_ostringstream&lt;charT,traits&gt; s;
-        s.copyfmt(out);
-        s.width(0);
-        s &lt;&lt; &quot;coord3(&quot; &lt;&lt; std::setprecision(16) 
-          &lt;&lt; c.x &lt;&lt; &quot;,&quot; &lt;&lt; c.y&lt;&lt; &quot;,&quot; &lt;&lt; c.z&lt;&lt;&quot;)&quot;;
-        out &lt;&lt; s.str();
-        return out;
-    } 
-}
-
-#endif // COORD_HPP

Deleted: trunk/include/coord_array.hpp
===================================================================
--- trunk/include/coord_array.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/coord_array.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,92 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: coord_array.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef COORD_ARRAY_HPP
-#define COORD_ARRAY_HPP
-
-#include &quot;coord.hpp&quot;
-#include &lt;cassert&gt;
-
-namespace mapnik
-{
-
-    template &lt;typename T&gt;
-    class coord_array 
-    {   
-	typedef T coord_type;
-	coord_type* pt_;
-	const unsigned size_;
-    public:	
-	coord_array(unsigned size=0)
-	    : pt_(static_cast&lt;coord_type*&gt;(size==0?0: ::operator new (sizeof(coord_type)*size))),
-	      size_(size) {}
-	
-	coord_array(const coord_array&amp; rhs)
-	    : pt_(static_cast&lt;coord_type*&gt;(rhs.size_==0?0: ::operator new (sizeof(coord_type)*rhs.size_))),
-	      size_(rhs.size_) {
-	    memcpy(pt_,rhs.pt_,sizeof(coord_type)*rhs.size_);
-	}
-	
-	~coord_array() 
-	{
-	    ::operator delete (pt_);
-	}
-	
-	unsigned size() const 
-	{
-	    return size_;
-	}
-	
-	void set(unsigned index,double x,double y)
-	{
-	    assert(index&lt;size_);
-	    pt_[index].x=x;
-	    pt_[index].y=y;
-	}
-	
-	const coord_type&amp; at(unsigned index) const 
-	{
-	    assert(index&lt;size_);
-	    return pt_[index];
-	}
-	
-	const coord_type&amp; operator[] (unsigned index) const
-	{
-	    assert (index&lt;size_);
-	    return pt_[index];
-	}
-	
-	coord_type&amp; operator[] (unsigned index)
-	{
-	    assert (index&lt;size_);
-	    return pt_[index];
-	}
-	
-    private:
-	coord_array&amp; operator=(const coord_array&amp;);
-    };
-}
-
-
-#endif //COORD_ARRAY_HPP

Deleted: trunk/include/css_color_parser.hpp
===================================================================
--- trunk/include/css_color_parser.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/css_color_parser.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,388 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef CSS_COLOR_PARSER_HPP
-#define CSS_COLOR_PARSER_HPP
-
-#include &lt;boost/spirit/core.hpp&gt;
-#include &lt;boost/spirit/symbols.hpp&gt;
-
-using namespace boost::spirit;
-
-namespace mapnik
-{
-    template &lt;typename ColorT&gt;
-    struct named_colors : public symbols&lt;ColorT&gt;
-    {
-	named_colors()
-	{
-	    symbols&lt;ColorT&gt;::add
-		(&quot;aliceblue&quot;, ColorT(240, 248, 255))
-		(&quot;antiquewhite&quot;, ColorT(250, 235, 215))
-		(&quot;aqua&quot;, ColorT(0, 255, 255))
-		(&quot;aquamarine&quot;, ColorT(127, 255, 212))
-		(&quot;azure&quot;, ColorT(240, 255, 255))
-		(&quot;beige&quot;, ColorT(245, 245, 220))
-		(&quot;bisque&quot;, ColorT(255, 228, 196))
-		(&quot;black&quot;, ColorT(0, 0, 0))
-		(&quot;blanchedalmond&quot;, ColorT(255,235,205))
-		(&quot;blue&quot;, ColorT(0, 0, 255))
-		(&quot;blueviolet&quot;, ColorT(138, 43, 226))
-		(&quot;brown&quot;, ColorT(165, 42, 42))
-		(&quot;burlywood&quot;, ColorT(222, 184, 135))
-		(&quot;cadetblue&quot;, ColorT(95, 158, 160))
-		(&quot;chartreuse&quot;, ColorT(127, 255, 0))
-		(&quot;chocolate&quot;, ColorT(210, 105, 30))
-		(&quot;coral&quot;, ColorT(255, 127, 80))
-		(&quot;cornflowerblue&quot;, ColorT(100, 149, 237))
-		(&quot;cornsilk&quot;, ColorT(255, 248, 220))
-		(&quot;crimson&quot;, ColorT(220, 20, 60))
-		(&quot;cyan&quot;, ColorT(0, 255, 255))
-		(&quot;darkblue&quot;, ColorT(0, 0, 139))
-		(&quot;darkcyan&quot;, ColorT(0, 139, 139))
-		(&quot;darkgoldenrod&quot;, ColorT(184, 134, 11))
-		(&quot;darkgray&quot;, ColorT(169, 169, 169))
-		(&quot;darkgreen&quot;, ColorT(0, 100, 0))
-		(&quot;darkgrey&quot;, ColorT(169, 169, 169))
-		(&quot;darkkhaki&quot;, ColorT(189, 183, 107))
-		(&quot;darkmagenta&quot;, ColorT(139, 0, 139))
-		(&quot;darkolivegreen&quot;, ColorT(85, 107, 47))
-		(&quot;darkorange&quot;, ColorT(255, 140, 0))
-		(&quot;darkorchid&quot;, ColorT(153, 50, 204))
-		(&quot;darkred&quot;, ColorT(139, 0, 0))
-		(&quot;darksalmon&quot;, ColorT(233, 150, 122))
-		(&quot;darkseagreen&quot;, ColorT(143, 188, 143))
-		(&quot;darkslateblue&quot;, ColorT(72, 61, 139))
-		(&quot;darkslategrey&quot;, ColorT(47, 79, 79))
-		(&quot;darkturquoise&quot;, ColorT(0, 206, 209))
-		(&quot;darkviolet&quot;, ColorT(148, 0, 211))
-		(&quot;deeppink&quot;, ColorT(255, 20, 147))
-		(&quot;deepskyblue&quot;, ColorT(0, 191, 255))
-		(&quot;dimgray&quot;, ColorT(105, 105, 105))
-		(&quot;dimgrey&quot;, ColorT(105, 105, 105))
-		(&quot;dodgerblue&quot;, ColorT(30, 144, 255))
-		(&quot;firebrick&quot;, ColorT(178, 34, 34))
-		(&quot;floralwhite&quot;, ColorT(255, 250, 240))
-		(&quot;forestgreen&quot;, ColorT(34, 139, 34))
-		(&quot;fuchsia&quot;, ColorT(255, 0, 255))
-		(&quot;gainsboro&quot;, ColorT(220, 220, 220))
-		(&quot;ghostwhite&quot;, ColorT(248, 248, 255))
-		(&quot;gold&quot;, ColorT(255, 215, 0))
-		(&quot;goldenrod&quot;, ColorT(218, 165, 32))
-		(&quot;gray&quot;, ColorT(128, 128, 128))
-		(&quot;grey&quot;, ColorT(128, 128, 128))
-		(&quot;green&quot;, ColorT(0, 128, 0))
-		(&quot;greenyellow&quot;, ColorT(173, 255, 47))
-		(&quot;honeydew&quot;, ColorT(240, 255, 240))
-		(&quot;hotpink&quot;, ColorT(255, 105, 180))
-		(&quot;indianred&quot;, ColorT(205, 92, 92))
-		(&quot;indigo&quot;, ColorT(75, 0, 130))
-		(&quot;ivory&quot;, ColorT(255, 255, 240))
-		(&quot;khaki&quot;, ColorT(240, 230, 140))
-		(&quot;lavender&quot;, ColorT(230, 230, 250))
-		(&quot;lavenderblush&quot;, ColorT(255, 240, 245))
-		(&quot;lawngreen&quot;, ColorT(124, 252, 0))
-		(&quot;lemonchiffon&quot;, ColorT(255, 250, 205))
-		(&quot;lightblue&quot;, ColorT(173, 216, 230))
-		(&quot;lightcoral&quot;, ColorT(240, 128, 128))
-		(&quot;lightcyan&quot;, ColorT(224, 255, 255))
-		(&quot;lightgoldenrodyellow&quot;, ColorT(250, 250, 210))
-		(&quot;lightgray&quot;, ColorT(211, 211, 211))
-		(&quot;lightgreen&quot;, ColorT(144, 238, 144))
-		(&quot;lightgrey&quot;, ColorT(211, 211, 211))
-		(&quot;lightpink&quot;, ColorT(255, 182, 193))
-		(&quot;lightsalmon&quot;, ColorT(255, 160, 122))
-		(&quot;lightseagreen&quot;, ColorT(32, 178, 170))
-		(&quot;lightskyblue&quot;, ColorT(135, 206, 250))
-		(&quot;lightslategray&quot;, ColorT(119, 136, 153))
-		(&quot;lightslategrey&quot;, ColorT(119, 136, 153))
-		(&quot;lightsteelblue&quot;, ColorT(176, 196, 222))
-		(&quot;lightyellow&quot;, ColorT(255, 255, 224))
-		(&quot;lime&quot;, ColorT(0, 255, 0))
-		(&quot;limegreen&quot;, ColorT(50, 205, 50))
-		(&quot;linen&quot;, ColorT(250, 240, 230))
-		(&quot;magenta&quot;, ColorT(255, 0, 255))
-		(&quot;maroon&quot;, ColorT(128, 0, 0))
-		(&quot;mediumaquamarine&quot;, ColorT(102, 205, 170))
-		(&quot;mediumblue&quot;, ColorT(0, 0, 205))
-		(&quot;mediumorchid&quot;, ColorT(186, 85, 211))
-		(&quot;mediumpurple&quot;, ColorT(147, 112, 219))
-		(&quot;mediumseagreen&quot;, ColorT(60, 179, 113))
-		(&quot;mediumslateblue&quot;, ColorT(123, 104, 238))
-		(&quot;mediumspringgreen&quot;, ColorT(0, 250, 154))
-		(&quot;mediumturquoise&quot;, ColorT(72, 209, 204))
-		(&quot;mediumvioletred&quot;, ColorT(199, 21, 133))
-		(&quot;midnightblue&quot;, ColorT(25, 25, 112))
-		(&quot;mintcream&quot;, ColorT(245, 255, 250))
-		(&quot;mistyrose&quot;, ColorT(255, 228, 225))
-		(&quot;moccasin&quot;, ColorT(255, 228, 181))
-		(&quot;navajowhite&quot;, ColorT(255, 222, 173))
-		(&quot;navy&quot;, ColorT(0, 0, 128))
-		(&quot;oldlace&quot;, ColorT(253, 245, 230))
-		(&quot;olive&quot;, ColorT(128, 128, 0))
-		(&quot;olivedrab&quot;, ColorT(107, 142, 35))
-		(&quot;orange&quot;, ColorT(255, 165, 0))
-		(&quot;orangered&quot;, ColorT(255, 69, 0))
-		(&quot;orchid&quot;, ColorT(218, 112, 214))
-		(&quot;palegoldenrod&quot;, ColorT(238, 232, 170))
-		(&quot;palegreen&quot;, ColorT(152, 251, 152))
-		(&quot;paleturquoise&quot;, ColorT(175, 238, 238))
-		(&quot;palevioletred&quot;, ColorT(219, 112, 147))
-		(&quot;papayawhip&quot;, ColorT(255, 239, 213))
-		(&quot;peachpuff&quot;, ColorT(255, 218, 185))
-		(&quot;peru&quot;, ColorT(205, 133, 63))
-		(&quot;pink&quot;, ColorT(255, 192, 203))
-		(&quot;plum&quot;, ColorT(221, 160, 221))
-		(&quot;powderblue&quot;, ColorT(176, 224, 230))
-		(&quot;purple&quot;, ColorT(128, 0, 128))
-		(&quot;red&quot;, ColorT(255, 0, 0))
-		(&quot;rosybrown&quot;, ColorT(188, 143, 143))
-		(&quot;royalblue&quot;, ColorT(65, 105, 225))
-		(&quot;saddlebrown&quot;, ColorT(139, 69, 19))
-		(&quot;salmon&quot;, ColorT(250, 128, 114))
-		(&quot;sandybrown&quot;, ColorT(244, 164, 96))
-		(&quot;seagreen&quot;, ColorT(46, 139, 87))
-		(&quot;seashell&quot;, ColorT(255, 245, 238))
-		(&quot;sienna&quot;, ColorT(160, 82, 45))
-		(&quot;silver&quot;, ColorT(192, 192, 192))
-		(&quot;skyblue&quot;, ColorT(135, 206, 235))
-		(&quot;slateblue&quot;, ColorT(106, 90, 205))
-		(&quot;slategray&quot;, ColorT(112, 128, 144))
-		(&quot;slategrey&quot;, ColorT(112, 128, 144))
-		(&quot;snow&quot;, ColorT(255, 250, 250))
-		(&quot;springgreen&quot;, ColorT(0, 255, 127))
-		(&quot;steelblue&quot;, ColorT(70, 130, 180))
-		(&quot;tan&quot;, ColorT(210, 180, 140))
-		(&quot;teal&quot;, ColorT(0, 128, 128))
-		(&quot;thistle&quot;, ColorT(216, 191, 216))
-		(&quot;tomato&quot;, ColorT(255, 99, 71))
-		(&quot;turquoise&quot;, ColorT(64, 224, 208))
-		(&quot;violet&quot;, ColorT(238, 130, 238))
-		(&quot;wheat&quot;, ColorT(245, 222, 179))
-		(&quot;white&quot;, ColorT(255, 255, 255))
-		(&quot;whitesmoke&quot;, ColorT(245, 245, 245))
-		(&quot;yellow&quot;, ColorT(255, 255, 0))
-		(&quot;yellowgreen&quot;, ColorT(154, 205, 50))
-		;
-	}
-    };
-    
-    template &lt;typename ActionsT&gt;
-    struct css_color_grammar : public grammar&lt;css_color_grammar&lt;ActionsT&gt; &gt;
-    {
-	css_color_grammar(ActionsT&amp; actions_)
-	    : actions(actions_) {}
-    
-	template &lt;typename ScannerT&gt;
-	struct definition
-	{
-	    definition(css_color_grammar const&amp; self)
-	    {
-		hex6 = ch_p('#') &gt;&gt; uint6x_p[self.actions.hex6_];
-		hex3 = ch_p('#') &gt;&gt; uint3x_p[self.actions.hex3_];
-		rgb = str_p(&quot;rgb&quot;) &gt;&gt; '(' &gt;&gt; uint3_p[self.actions.red_] 
-			     &gt;&gt; ',' &gt;&gt; uint3_p[self.actions.green_] 
-			     &gt;&gt; ',' &gt;&gt; uint3_p[self.actions.blue_] 
-			     &gt;&gt; ')';
-		rgb_percent = str_p(&quot;rgb&quot;) &gt;&gt; '(' &gt;&gt; ureal_p[self.actions.red_p_] &gt;&gt; '%' 
-					   &gt;&gt; ',' &gt;&gt; ureal_p[self.actions.green_p_] &gt;&gt; '%'
-					   &gt;&gt; ',' &gt;&gt; ureal_p[self.actions.blue_p_] &gt;&gt; '%'
-					   &gt;&gt; ')';
-		css_color = named_colors_p[self.actions.named_] | hex6 | hex3 | rgb_percent | rgb; 
-	    }
-	    boost::spirit::rule&lt;ScannerT&gt; rgb;
-	    boost::spirit::rule&lt;ScannerT&gt; rgb_percent;
-	    boost::spirit::rule&lt;ScannerT&gt; hex6;
-	    boost::spirit::rule&lt;ScannerT&gt; hex3;
-            boost::spirit::rule&lt;ScannerT&gt; css_color;
-	    boost::spirit::rule&lt;ScannerT&gt; const&amp; start() const
-	    {
-		return css_color;
-	    }
-	    uint_parser&lt;unsigned, 10, 1, 3&gt; uint3_p;
-	    uint_parser&lt;unsigned, 16, 6, 6&gt; uint6x_p;
-	    uint_parser&lt;unsigned, 16, 3, 3&gt; uint3x_p;
-	    named_colors&lt;typename ActionsT::color_type&gt; named_colors_p;
-	    
-	};
-	ActionsT&amp; actions;	
-    };
-    
-    template &lt;typename ColorT&gt;
-    struct named_color_action
-    {
-	named_color_action(ColorT&amp; c)
-	    : c_(c) {}
-	
-	void operator() (ColorT const&amp;c) const
-	{
-	    c_=c;
-	}
-	ColorT&amp; c_;
-    };
-
-    template &lt;typename ColorT&gt;
-    struct hex6_action
-    {
-	hex6_action(ColorT&amp; c)
-	    : c_(c) {}
-	
-	void operator () (unsigned int hex) const
-	{
-	    unsigned r = (hex &gt;&gt; 16) &amp; 0xff;
-	    unsigned g = (hex &gt;&gt; 8) &amp; 0xff;
-	    unsigned b = hex &amp; 0xff;
-	    c_.set_red(r);
-	    c_.set_green(g);
-	    c_.set_blue(b);
-	}
-	ColorT&amp; c_;
-    };
-    
-    template &lt;typename ColorT&gt;
-    struct hex3_action
-    {
-	hex3_action(ColorT&amp; c)
-	    : c_(c) {}
-	
-	void operator () (unsigned int hex) const
-	{
-	    unsigned int r = (hex &gt;&gt; 8) &amp; 0xf;
-	    unsigned int g = (hex &gt;&gt; 4) &amp; 0xf;
-	    unsigned int b = hex &amp; 0xf;
-	    c_.set_red( r | r &lt;&lt; 4);
-	    c_.set_green(g | g &lt;&lt; 4);
-	    c_.set_blue(b | b &lt;&lt; 4);
-	}
-	ColorT&amp; c_;
-    };
-
-    template &lt;typename ColorT&gt;
-    struct red_action
-    {
-	red_action(ColorT&amp; c)
-	    : c_(c) {}
-	
-	void operator () (unsigned int r) const
-	{
-	    c_.set_red(r);
-	}
-	ColorT&amp; c_;
-    };
-
-    template &lt;typename ColorT&gt;
-    struct green_action
-    {
-	green_action(ColorT&amp; c)
-	    : c_(c) {}
-	
-	void operator () (unsigned int g) const
-	{
-	    c_.set_green(g);
-	}
-	ColorT&amp; c_;
-    };
-	
-    template &lt;typename ColorT&gt;
-    struct blue_action
-    {
-	blue_action(ColorT&amp; c)
-	    : c_(c) {}
-	
-	void operator () (unsigned int b) const
-	{
-	    c_.set_blue(b);
-	}
-	ColorT&amp; c_;
-    };
-    
-
-    template &lt;typename ColorT&gt;
-    struct red_action_p
-    {
-	red_action_p(ColorT&amp; c)
-	    : c_(c) {}
-	
-	void operator () (double r) const
-	{
-	    c_.set_red(unsigned((255.0 * r)/100.0 + 0.5));
-	}
-	ColorT&amp; c_;
-    };
-
-    template &lt;typename ColorT&gt;
-    struct green_action_p
-    {
-	green_action_p(ColorT&amp; c)
-	    : c_(c) {}
-	
-	void operator () (double g) const
-	{
-	    c_.set_green(unsigned((255.0 * g)/100.0 + 0.5));
-	}
-	ColorT&amp; c_;
-    };
-
-    template &lt;typename ColorT&gt;
-    struct blue_action_p
-    {
-	blue_action_p(ColorT&amp; c)
-	    : c_(c) {}
-	
-	void operator () (double b) const
-	{
-	    c_.set_blue(unsigned((255.0 * b)/100.0 + 0.5));
-	}
-	ColorT&amp; c_;
-    };
-
-
-    template &lt;typename ColorT&gt;
-    struct actions
-    {
-	typedef ColorT color_type;
-	actions(ColorT&amp; c)
-	    : named_(c),
-	      hex6_(c),
-	      hex3_(c),
-	      red_(c),
-	      green_(c),
-	      blue_(c),
-	      red_p_(c),
-	      green_p_(c),
-	      blue_p_(c) {}
-        
-	named_color_action&lt;ColorT&gt; named_;
-	hex6_action&lt;ColorT&gt; hex6_;
-	hex3_action&lt;ColorT&gt; hex3_;
-	red_action&lt;ColorT&gt; red_;
-	green_action&lt;ColorT&gt; green_;
-	blue_action&lt;ColorT&gt; blue_;
-	red_action_p&lt;ColorT&gt; red_p_;
-	green_action_p&lt;ColorT&gt; green_p_;
-	blue_action_p&lt;ColorT&gt; blue_p_;
-    };
-}
-
-#endif //CSS_COLOR_PARSER_HPP

Deleted: trunk/include/ctrans.hpp
===================================================================
--- trunk/include/ctrans.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/ctrans.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,169 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: ctrans.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef CTRANS_HPP
-#define CTRANS_HPP
-
-#include &quot;envelope.hpp&quot;
-#include &quot;coord_array.hpp&quot;
-
-namespace mapnik
-{
-    typedef coord_array&lt;coord2d&gt; CoordinateArray;
-    
-    template &lt;typename Transform,typename Geometry&gt;
-    struct MAPNIK_DECL coord_transform
-    {
-	coord_transform(Transform const&amp; t,Geometry&amp; geom)
-	    : t_(t), geom_(geom) {}
-	
-	unsigned  vertex(double *x , double *y) const
-	{
-	    unsigned command = geom_.vertex(x,y);
-	    *x = t_.forward_x_(x);
-	    *y = t_.forward_y_(y);
-	    return command;
-	}
-	void rewind (unsigned pos)
-	{
-	    geom_.rewind(pos);
-	}
-	
-    private:
-	Transform const&amp; t_;
-	Geometry&amp; geom_;
-    };
-    
-    class CoordTransform
-    {
-    private:
-	    int width;
-	    int height;
-	    double scale_;
-	    Envelope&lt;double&gt; extent;
-    public:
-	CoordTransform(int width,int height,const Envelope&lt;double&gt;&amp; extent)
-            :width(width),height(height),extent(extent)
-	{
-	    double sx=((double)width)/extent.width();
-	    double sy=((double)height)/extent.height();
-	    scale_=std::min(sx,sy);
-	}
-	
-	inline double scale() const
-	{
-	    return scale_;
-	}
-	
-	inline void forward_x(double* x) const 
-	{
-	    *x = (*x - extent.minx() ) * scale_;   
-	}
-	
-	inline void forward_y(double* y) const 
-	{
-	    *y = (extent.maxy() - *y) * scale_;
-	}
-
-	inline double forward_x_(double* x) const 
-	{
-	    return (*x - extent.minx() ) * scale_;   
-	}
-	
-	inline double forward_y_(double* y) const 
-	{
-	    return (extent.maxy() - *y) * scale_;
-	}
-
-	inline void backward_x(double* x) const
-	{
-	    *x = extent.minx() + *x/scale_;
-	}
-	
-	inline void backward_y(double* y) const
-	{
-	    *y = extent.maxy() - *y/scale_;
-	}
-	
-	inline coord2d&amp; forward(coord2d&amp; c) const
-	{
-	    forward_x(&amp;c.x);
-	    forward_y(&amp;c.y);
-	    return c;
-	}
-
-	inline coord2d&amp; backward(coord2d&amp; c) const
-	{
-	    backward_x(&amp;c.x);
-	    backward_y(&amp;c.y);
-	    return c;
-	}
-
-	inline Envelope&lt;double&gt; forward(const Envelope&lt;double&gt;&amp; e) const
-	{
-	    double x0 = e.minx();
-	    double y0 = e.miny();
-	    double x1 = e.maxx();
-	    double y1 = e.maxy();
-	    forward_x(&amp;x0);
-	    forward_y(&amp;y0);
-	    forward_x(&amp;x1);
-	    forward_y(&amp;y1);
-	    return Envelope&lt;double&gt;(x0,y0,x1,y1);
-	}
-
-	inline Envelope&lt;double&gt; backward(const Envelope&lt;double&gt;&amp; e) const
-	{
-	    double x0 = e.minx();
-	    double y0 = e.miny();
-	    double x1 = e.maxx();
-	    double y1 = e.maxy();
-	    backward_x(&amp;x0);
-	    backward_y(&amp;y0);
-	    backward_x(&amp;x1);
-	    backward_y(&amp;y1);
-	    
-	    return Envelope&lt;double&gt;(x0,y0,x1,y1);
-	}
-
-	inline CoordinateArray&amp; forward(CoordinateArray&amp; coords) const
-	{
-	    for (unsigned i=0;i&lt;coords.size();++i)
-	    {
-		forward(coords[i]);
-	    }
-	    return coords;
-	}
-	
-	inline CoordinateArray&amp; backward(CoordinateArray&amp; coords) const
-	{
-	    for (unsigned i=0;i&lt;coords.size();++i)
-	    {
-		backward(coords[i]);
-	    }
-	    return coords;
-	}
-    };
-}
-#endif                                            //CTRANS_HPP

Deleted: trunk/include/datasource.hpp
===================================================================
--- trunk/include/datasource.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/datasource.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,119 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: datasource.hpp 43 2005-04-22 18:52:47Z pavlenko $
-
-#ifndef DATASOURCE_HPP
-#define DATASOURCE_HPP
-
-#include &lt;map&gt;
-#include &lt;string&gt;
-#include &quot;ctrans.hpp&quot;
-#include &quot;params.hpp&quot;
-#include &quot;feature.hpp&quot;
-#include &quot;query.hpp&quot;
-#include &quot;feature_layer_desc.hpp&quot;
-
-#include &lt;boost/shared_ptr.hpp&gt;
-
-namespace mapnik
-{    
-    typedef MAPNIK_DECL shared_ptr&lt;Feature&gt; feature_ptr;
-    struct MAPNIK_DECL Featureset
-    {
-        virtual feature_ptr next()=0;
-        virtual ~Featureset() {};
-    };
-    
-    typedef shared_ptr&lt;Featureset&gt; featureset_ptr;    
-    class MAPNIK_DECL datasource_exception : public std::exception
-    {
-    private:
-        const std::string message_;
-    public:
-        datasource_exception(const std::string&amp; message=std::string())
-            :message_(message) {}
-
-        ~datasource_exception() throw() {}
-        virtual const char* what() const throw()
-        {
-            return message_.c_str();
-        }
-    };
-    
-    class MAPNIK_DECL datasource : private boost::noncopyable
-    {
-        parameters params_;
-    public:        
-        enum {
-            Vector,
-            Raster
-        };
-        
-        datasource (parameters const&amp; params)
-            : params_(params) {}
-
-        parameters const&amp; params() const
-        {
-            return params_;
-        }
-        
-        virtual int type() const=0;
-        virtual featureset_ptr features(const query&amp; q) const=0;
-        virtual Envelope&lt;double&gt; const&amp; envelope() const=0;
-        virtual layer_descriptor const&amp; get_descriptor() const=0;
-        virtual ~datasource() {};
-    };
-    
-    typedef std::string datasource_name();
-    typedef datasource* create_ds(const parameters&amp; params);
-    typedef void destroy_ds(datasource *ds);
-
-    
-    class datasource_deleter
-    {
-    public:
-        void operator() (datasource* ds)
-        {
-            delete ds;
-        }
-    };
-
-    typedef boost::shared_ptr&lt;datasource&gt; datasource_p;
-    
-    ///////////////////////////////////////////
-#define DATASOURCE_PLUGIN(classname)                                    \
-    extern &quot;C&quot; MAPNIK_DECL std::string datasource_name()                \
-    {                                                                   \
-        return classname::name();                                       \
-    }                                                                   \
-        extern &quot;C&quot;  MAPNIK_DECL datasource* create(const parameters &amp;params) \
-        {                                                               \
-            return new classname(params);                               \
-        }                                                               \
-        extern &quot;C&quot; MAPNIK_DECL void destroy(datasource *ds)             \
-        {                                                               \
-            delete ds;                                                  \
-        }                                                               \
-        ///////////////////////////////////////////
-}
-#endif                                            //DATASOURCE_HPP

Deleted: trunk/include/datasource_cache.hpp
===================================================================
--- trunk/include/datasource_cache.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/datasource_cache.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,54 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: datasource_cache.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef DATASOURCE_CACHE_HPP
-#define DATASOURCE_CACHE_HPP
-
-#include &lt;map&gt;
-#include &lt;boost/shared_ptr.hpp&gt;
-
-#include &quot;utils.hpp&quot;
-#include &quot;params.hpp&quot;
-#include &quot;plugin.hpp&quot;
-#include &quot;datasource.hpp&quot;
-
-namespace mapnik
-{
-    class MAPNIK_DECL datasource_cache : public singleton &lt;datasource_cache,CreateStatic&gt;
-    {
-        friend class CreateStatic&lt;datasource_cache&gt;;
-    private:
-        datasource_cache();
-        ~datasource_cache();
-        datasource_cache(const datasource_cache&amp;);
-        datasource_cache&amp; operator=(const datasource_cache&amp;);
-        static std::map&lt;std::string,boost::shared_ptr&lt;PluginInfo&gt; &gt; plugins_;
-        static bool registered_;
-        static bool insert(const std::string&amp;  name,const lt_dlhandle module);
-    public:
-        static void register_datasources(const std::string&amp; path);
-        static boost::shared_ptr&lt;datasource&gt; create(parameters const&amp; params);
-    };
-}
-#endif   //DATASOURCE_CACHE_HPP

Deleted: trunk/include/envelope.hpp
===================================================================
--- trunk/include/envelope.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/envelope.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,88 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: envelope.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef ENVELOPE_HPP
-#define ENVELOPE_HPP
-
-#include &quot;config.hpp&quot;
-#include &lt;iomanip&gt;
-#include &quot;coord.hpp&quot;
-
-namespace mapnik
-{
-
-	template &lt;class T&gt; class MAPNIK_DECL Envelope
-    {
-    public:
-        typedef Envelope&lt;T&gt; EnvelopeType;
-    private:
-        T minx_;
-        T miny_;
-        T maxx_;
-        T maxy_;
-    public:
-        Envelope();
-        Envelope(T minx,T miny,T maxx,T maxy);
-        Envelope(const coord&lt;T,2&gt;&amp; c0,const coord&lt;T,2&gt;&amp; c1);
-        Envelope(const EnvelopeType&amp; rhs);
-        T minx() const;
-        T miny() const;
-        T maxx() const;
-        T maxy() const;
-        T width() const;
-        T height() const;
-        void width(T w);
-        void height(T h);
-        coord&lt;T,2&gt; center() const;
-        void expand_to_include(T x,T y);
-        void expand_to_include(const coord&lt;T,2&gt;&amp; c);
-        void expand_to_include(const EnvelopeType&amp; other);
-        bool contains(const coord&lt;T,2&gt; &amp;c) const;
-        bool contains(T x,T y) const;
-        bool contains(const EnvelopeType &amp;other) const;
-        bool intersects(const coord&lt;T,2&gt; &amp;c) const;
-        bool intersects(T x,T y) const;
-        bool intersects(const EnvelopeType &amp;other) const;
-        EnvelopeType intersect(const EnvelopeType&amp; other) const;
-        bool operator==(const EnvelopeType &amp;other) const;
-        void re_center(T cx,T cy);
-        void init(T x0,T y0,T x1,T y1);
-    };
-    
-    template &lt;class charT,class traits,class T&gt;
-    inline std::basic_ostream&lt;charT,traits&gt;&amp;
-    operator &lt;&lt; (std::basic_ostream&lt;charT,traits&gt;&amp; out,
-                 const Envelope&lt;T&gt;&amp; e)
-    {
-        std::basic_ostringstream&lt;charT,traits&gt; s;
-        s.copyfmt(out);
-        s.width(0);
-        s &lt;&lt;&quot;Envelope(&quot; &lt;&lt; std::setprecision(16) 
-          &lt;&lt; e.minx() &lt;&lt; &quot;,&quot; &lt;&lt; e.miny() &lt;&lt;&quot;,&quot; 
-          &lt;&lt; e.maxx() &lt;&lt; &quot;,&quot; &lt;&lt; e.maxy() &lt;&lt;&quot;)&quot;;
-        out &lt;&lt; s.str();
-        return out;
-    }
-}
-#endif // ENVELOPE_HPP

Deleted: trunk/include/expression.hpp
===================================================================
--- trunk/include/expression.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/expression.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,127 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef EXPRESSION_HPP
-#define EXPRESSION_HPP
-
-#include &quot;value.hpp&quot;
-#include &quot;filter_visitor.hpp&quot;
-
-namespace mapnik
-{
-    template &lt;typename FeatureT&gt; class filter_visitor;
-    template &lt;typename FeatureT&gt;
-    class expression
-    {
-    public:
-	virtual value get_value(FeatureT const&amp; feature) const=0;
-	virtual void accept(filter_visitor&lt;FeatureT&gt;&amp; v)=0;
-	virtual expression&lt;FeatureT&gt;* clone() const=0;
-	virtual std::string to_string() const=0;
-	virtual ~expression() {}
-    };
-
-    template &lt;typename FeatureT&gt; 
-    class literal : public expression&lt;FeatureT&gt;
-    {
-    public:
-	literal(int val)
-	    : expression&lt;FeatureT&gt;(),
-	      value_(val) {}
-	literal(double val)
-	    : expression&lt;FeatureT&gt;(),
-	      value_(val) {}
-	literal(std::string const&amp; val)
-	    : expression&lt;FeatureT&gt;(),
-	      value_(val) {}
-	literal(literal const&amp; other)
-	    : expression&lt;FeatureT&gt;(),
-	      value_(other.value_) {}
-	
-	value get_value(FeatureT const&amp; /*feature*/) const
-	{
-	    return value_;
-	}
-	void accept(filter_visitor&lt;FeatureT&gt;&amp; v)
-	{
-	    v.visit(*this);
-	}
-	expression&lt;FeatureT&gt;* clone() const
-	{
-	    return new literal(*this); 
-	}
-	std::string to_string() const
-	{
-	    return value_.to_expression_string();
-	}
-        ~literal() {}
-    private:
-	value value_;
-    };
-  
-
-    template &lt;typename FeatureT&gt; 
-    class property : public expression&lt;FeatureT&gt;
-    {
-    public:
-	property(std::string const&amp; name)
-        : expression&lt;FeatureT&gt;(),
-	    name_(name)
-	    {}
-	
-	property(property const&amp; other)
-	    : expression&lt;FeatureT&gt;(),
-	     name_(other.name_)
-	    {}
-
-	value get_value(FeatureT const&amp; feature) const
-	{
-	    return feature[name_];
-	}
-	void accept(filter_visitor&lt;FeatureT&gt;&amp; v)
-	{
-	    v.visit(*this);
-	}
-	expression&lt;FeatureT&gt;* clone() const
-	{
-	    return new property(*this); 
-	}
-	std::string const&amp; name() const
-	{
-	    return name_;
-	}
-
-	std::string to_string() const
-	{
-	    return &quot;[&quot;+name_+&quot;]&quot;;
-	}
-
-    ~property() {}
-
-    private:
-	    std::string name_;
-    };
-}
-
-#endif //EXPRESSION_HPP

Deleted: trunk/include/factory.hpp
===================================================================
--- trunk/include/factory.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/factory.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,88 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: factory.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef FACTORY_HPP
-#define FACTORY_HPP
-
-#include &lt;stdexcept&gt;
-#include &lt;map&gt;
-#include &quot;utils.hpp&quot;
-
-namespace mapnik
-{
-    template &lt;typename key_type,
-              typename product_type&gt;
-    class default_factory_error
-    {
-    public:
-        struct factory_exception : public std::exception
-        {
-            const char* what() const throw()
-            {
-                return &quot;uknown object type&quot;;
-            }
-        };
-        static product_type* on_unknown_type(const key_type&amp;)
-        {
-            return 0;
-        }
-    };
-
-    template
-    &lt;
-        typename product_type,
-        typename key_type,
-        typename product_creator=product_type* (*)(),
-        template &lt;typename,typename&gt; class factory_error_policy=default_factory_error
-        &gt;
-    class factory : public singleton&lt;factory &lt;product_type,key_type,product_creator,factory_error_policy&gt; &gt;,
-        factory_error_policy &lt;key_type,product_type&gt;
-    {
-    private:
-        typedef std::map&lt;key_type,product_creator&gt; product_map;
-        product_map map_;
-    public:
-
-        bool register_product(const key_type&amp; key,product_creator creator)
-        {
-            return map_.insert(typename product_map::value_type(key,creator)).second;
-        }
-
-        bool unregister_product(const key_type&amp; key)
-        {
-            return map_.erase(key)==1;
-        }
-
-        product_type* create_object(const key_type&amp; key,const std::string&amp; file)
-        {
-            typename product_map::const_iterator pos=map_.find(key);
-            if (pos!=map_.end())
-            {
-                return (pos-&gt;second)(file);
-            }
-            return on_unknown_type(key);
-        }
-    };
-}
-#endif                                            //FACTORY_HPP

Deleted: trunk/include/feature.hpp
===================================================================
--- trunk/include/feature.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/feature.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,118 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: feature.hpp 40 2005-04-13 20:20:46Z pavlenko $
-
-#ifndef FEATURE_HPP
-#define FEATURE_HPP
-
-#include &quot;geometry.hpp&quot;
-#include &quot;raster.hpp&quot;
-#include &quot;value.hpp&quot;
-#include &lt;map&gt;
-
-#include &lt;boost/property_map.hpp&gt;
-#include &lt;boost/utility.hpp&gt;
-
-namespace mapnik
-{
-    typedef boost::shared_ptr&lt;raster&gt; raster_ptr;    
-    //typedef std::vector&lt;value&gt; properties;
-    typedef boost::associative_property_map&lt;std::map&lt;std::string,value&gt; &gt; properties;
-    
-    template &lt;typename T1,typename T2&gt;
-    struct feature : public properties,
-		     private boost::noncopyable
-    {
-    public:
-	typedef T1 geometry_type;
-	typedef T2 raster_type;
-    private:
-	int id_;
-	geometry_type geom_;
-	raster_type   raster_;
-	std::map&lt;std::string,value&gt; props_;
-    public:
-	explicit feature(int id)
-	    : properties(props_),
-	      id_(id),
-	      geom_(),
-	      raster_() {}
-
-	feature(int id,const geometry_type&amp; geom)
-	    : properties(props_),
-	      id_(id),
-	      geom_(geom),
-	      raster_() {}
-
-	int id() const 
-	{
-	    return id_;
-	}
-	
-	void set_geometry(geometry_type&amp; geom)
-	{
-	    geom_=geom;
-	}
-	
-	geometry_type const&amp; get_geometry() const
-	{
-	    return geom_;
-	}
-        
-	const raster_type&amp; get_raster() const
-	{
-	    return raster_;
-	}
-	void set_raster(raster_type const&amp; raster)
-	{
-	    raster_=raster;
-	}
-	
-	const properties&amp; get_properties() const 
-	{
-	    return props_;
-	}
-	
-	std::string to_string() const
-	{
-	    std::stringstream ss;
-	    ss &lt;&lt; &quot;feature (&quot; &lt;&lt; std::endl;
-	    for (std::map&lt;std::string,value&gt;::const_iterator itr=props_.begin();
-		 itr != props_.end();++itr)
-	    {
-		ss &lt;&lt; &quot;  &quot; &lt;&lt; itr-&gt;first  &lt;&lt; &quot;:&quot; &lt;&lt;  itr-&gt;second &lt;&lt; std::endl;
-	    }
-	    ss &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
-	    return ss.str();
-	}
-    };
-
-    typedef feature&lt;geometry_ptr,raster_ptr&gt; Feature;
-    
-    inline std::ostream&amp; operator&lt;&lt; (std::ostream &amp; out,Feature const&amp; f)
-    {
-	out &lt;&lt; f.to_string();
-    	return out;
-    }
-}
-#endif                                            //FEATURE_HPP

Deleted: trunk/include/feature_factory.hpp
===================================================================
--- trunk/include/feature_factory.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/feature_factory.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,41 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef FEATURE_FACTORY_HPP
-#define FEATURE_FACTORY_HPP
-
-#include &quot;feature.hpp&quot;
-namespace mapnik
-{
-    struct feature_factory
-    {
-	static Feature* create (int fid)
-	{
-	    return new Feature(fid);
-	}
-    }; 
-}
-
-
-#endif //FEATURE_FACTORY_HPP

Deleted: trunk/include/feature_layer_desc.hpp
===================================================================
--- trunk/include/feature_layer_desc.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/feature_layer_desc.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,250 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef FEATURE_LAYER_DESC_HPP
-#define FEATURE_LAYER_DESC_HPP
-
-#include &lt;string&gt;
-#include &lt;vector&gt;
-#include &lt;iostream&gt;
-
-namespace mapnik
-{
-    
-    using std::string;
-    using std::vector;
-    using std::clog;
-    using std::endl;
-    
-    enum {
-	Integer=1,
-	Float  =2,
-	Double =3,
-	String =4,
-	Geometry=5,
-	Object=6 
-    };
-    
-    class attribute_descriptor
-    {
-    public:
-	attribute_descriptor(string const&amp; name,unsigned type,
-		       bool primary_key=false,
-		       int size=-1,
-		       int precision=-1)
-	    : name_(name),
-	      type_(type),
-	      primary_key_(primary_key),
-	      size_(size),
-	      precision_(precision) {}
-	      
-	attribute_descriptor(attribute_descriptor const&amp; other)
-	    : name_(other.name_),
-	      type_(other.type_),
-	      primary_key_(other.primary_key_),
-	      size_(other.size_),
-	      precision_(other.precision_) {}
-
-	attribute_descriptor&amp; operator=(attribute_descriptor const&amp; other)
-	{
-	    if (this == &amp;other)
-		return *this;	    
-	    name_=other.name_;
-	    type_=other.type_;
-	    primary_key_=other.primary_key_;
-	    size_=other.size_;
-	    precision_=other.precision_;
-	    return *this;
-	}
-	string const&amp; get_name() const
-	{
-	    return name_;
-	}
-	unsigned  get_type() const
-	{
-	    return type_;
-	}
-	bool is_primary_key() const
-	{
-	    return primary_key_;
-	}
-	int get_size() const
-	{
-	    return size_;
-	} 
-	
-	int get_precision() const
-	{
-	    return precision_;
-	}
-    private:
-	string name_;
-	int type_;
-	bool primary_key_;
-	int size_;
-	int precision_;
-    };
-     
-    template &lt;typename charT,typename traits&gt;
-    inline std::basic_ostream&lt;charT,traits&gt;&amp;
-    operator &lt;&lt; (std::basic_ostream&lt;charT,traits&gt;&amp; out,
-		 attribute_descriptor const&amp; ad)
-    {
-	out &lt;&lt; &quot;name=&quot; &lt;&lt; ad.get_name() &lt;&lt; endl;
-	out &lt;&lt; &quot;type=&quot; &lt;&lt; ad.get_type() &lt;&lt; endl;
-	out &lt;&lt; &quot;size=&quot; &lt;&lt; ad.get_size() &lt;&lt; endl;
-	return out;
-    }
-
-    class layer_descriptor 
-    {
-    public:
-	layer_descriptor(string const&amp; name,int srid=-1)
-	    : name_(name),
-	      srid_(srid) {}
-
-	layer_descriptor(layer_descriptor const&amp; other)
-	    : name_(other.name_),
-	      srid_(other.srid_),
-	      desc_ar_(other.desc_ar_) {}
-	
-	void set_name(string const&amp; name)
-	{
-	    name_=name;
-	}
-	string const&amp; get_name() const
-	{
-	    return name_;
-	}
-	
-	void set_srid(int srid) 
-	{
-	    srid_=srid;
-	}
-	
-	int get_srid() const
-	{
-	    return srid_;
-	}
-
-	void add_descriptor(attribute_descriptor const&amp; desc)
-	{
-	    desc_ar_.push_back(desc);
-	}
-	
-	vector&lt;attribute_descriptor&gt; const&amp; get_descriptors() const
-	{
-	    return desc_ar_;
-	}	
-	vector&lt;attribute_descriptor&gt;&amp; get_descriptors()
-	{
-	    return desc_ar_;
-	}
-    private:
-	string name_;
-	int srid_;
-	vector&lt;attribute_descriptor&gt; desc_ar_;
-    };
-    
-    template &lt;typename charT,typename traits&gt;
-    inline std::basic_ostream&lt;charT,traits&gt;&amp;
-    operator &lt;&lt; (std::basic_ostream&lt;charT,traits&gt;&amp; out,
-		 layer_descriptor const&amp; ld)
-    {
-	out &lt;&lt; &quot;name=&quot; &lt;&lt; ld.get_name() &lt;&lt; endl;
-	out &lt;&lt; &quot;srid=&quot; &lt;&lt; ld.get_srid() &lt;&lt; endl;
-	vector&lt;attribute_descriptor&gt; const&amp; desc_ar=ld.get_descriptors();
-	vector&lt;attribute_descriptor&gt;::const_iterator pos=desc_ar.begin();
-	while (pos != desc_ar.end())
-	{
-	    out &lt;&lt; *pos++ &lt;&lt; endl;
-	    
-	}
-	return out;
-    }
-    /*    
-    bool layer_descriptor_to_wkb(layer_descriptor const&amp; desc,array&lt;&gt;&amp; wkb)
-    {
-	//srid	
-	int srid = desc.get_srid();
-	wkb.write(&amp;srid,sizeof(int));
-
-	//attribute descriptors
-	vector&lt;attribute_descriptor&gt; const&amp; desc_ar = desc.get_descriptors();
-	vector&lt;attribute_descriptor&gt;::const_iterator itr=desc_ar.begin();
-	size_t num_desc = desc_ar.size();
-	wkb.write(&amp;num_desc,sizeof(int));
-	
-	while (itr != desc_ar.end())
-	{
-	    string name = itr-&gt;get_name();
-	    wkb.write(name.c_str(),name.size()+1);
-	       
-	    unsigned type = static_cast&lt;int&gt;(itr-&gt;get_type());
-	    wkb.write(&amp;type,sizeof(unsigned));
-
-	    bool prim_key = itr-&gt;is_primary_key();
-	    wkb.write(&amp;prim_key,sizeof(bool));
-
-	    int size = itr-&gt;get_size();
-	    wkb.write(&amp;size,sizeof(int));
-            
-	    ++itr;
-	}	
-	return true;
-    }
-    
-    bool layer_descriptor_from_wkb(const char* wkb, layer_descriptor &amp;desc)
-    {
-	unsigned pos=0;
-	int srid;
-	
-	memcpy(&amp;srid,wkb+pos,sizeof(int));
-	desc.set_srid(srid);
-	pos+=sizeof(int);
-	
-	int num_desc;
-	memcpy(&amp;num_desc,wkb+pos,sizeof(int));
-	pos+=sizeof(int);
-	
-	for (int i=0;i&lt;num_desc;++i)
-	{
-	    string name = wkb+pos;
-	    pos += name.size()+1;
-	    //std::clog&lt;&lt;&quot;name=&quot;&lt;&lt;name&lt;&lt;&quot;\n&quot;;
-	    
-	    int type;
-	    memcpy(&amp;type,wkb+pos,sizeof(int));
-	    pos += sizeof(int);
-	    attribute_descriptor ad(name,type);
-	    desc.add_descriptor(ad);
-	    //todo!!!
-	    pos += 4+1;
-	}
-	return true;
-    }
-    */    
-}
-
-#endif //FEATURE_LAYER_DESC_HPP

Deleted: trunk/include/feature_style_processor.hpp
===================================================================
--- trunk/include/feature_style_processor.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/feature_style_processor.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,184 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef FEATURE_STYLE_PROCESSOR_HPP
-#define FEATURE_STYLE_PROCESSOR_HPP
-
-#include &lt;vector&gt;
-#include &lt;iostream&gt;
-#include &lt;boost/progress.hpp&gt;
-#include &quot;envelope.hpp&quot;
-#include &quot;datasource.hpp&quot;
-#include &quot;layer.hpp&quot;
-#include &quot;map.hpp&quot;
-#include &quot;attribute_collector.hpp&quot;
-#include &quot;utils.hpp&quot;
-
-namespace mapnik
-{       
-    template &lt;typename Processor&gt;
-    class feature_style_processor 
-    {
-        struct symbol_dispatch : public boost::static_visitor&lt;&gt;
-        {
-            symbol_dispatch (Processor &amp; output,Feature const&amp; f)
-                : output_(output),f_(f) {}
-	    
-            template &lt;typename T&gt;
-            void operator () (T const&amp; sym) const
-            {
-                output_.process(sym,f_);
-            }
-
-            Processor &amp; output_;
-            Feature const&amp; f_;
-        };
-    public:
-        feature_style_processor(Map const&amp; m)
-            : m_(m) {}
-	
-        void apply()
-        {
-            boost::progress_timer t;
-            Processor &amp; p = static_cast&lt;Processor&amp;&gt;(*this);
-
-            p.start_map_processing(m_);
-	    
-            std::vector&lt;Layer&gt;::const_iterator itr = m_.layers().begin();
-            while (itr != m_.layers().end())
-            {
-                if (itr-&gt;isVisible(m_.scale()) &amp;&amp; 
-                    itr-&gt;envelope().intersects(m_.getCurrentExtent()))
-                {
-                    apply_to_layer(*itr,p);
-                }
-                ++itr;
-            }
-            p.end_map_processing(m_);
-        }	
-    private:
-        void apply_to_layer(Layer const&amp; lay,Processor &amp; p)
-        {
-            p.start_layer_processing(lay);
-            datasource *ds=lay.datasource().get();
-            if (ds)
-            {
-                Envelope&lt;double&gt; const&amp; bbox=m_.getCurrentExtent();
-                double scale = m_.scale();
-	
-                std::vector&lt;std::string&gt; const&amp; style_names = lay.styles();
-                std::vector&lt;std::string&gt;::const_iterator stylesIter = style_names.begin();
-                while (stylesIter != style_names.end())
-                {
-                    std::set&lt;std::string&gt; names;
-                    attribute_collector&lt;Feature&gt; collector(names);
-                    std::vector&lt;rule_type*&gt; if_rules;
-                    std::vector&lt;rule_type*&gt; else_rules;
-		
-                    bool active_rules=false;
-		    
-                    feature_type_style const&amp; style=m_.find_style(*stylesIter++);
-		    
-                    const std::vector&lt;rule_type&gt;&amp; rules=style.get_rules();
-                    std::vector&lt;rule_type&gt;::const_iterator ruleIter=rules.begin();
-		    
-                    query q(bbox); //BBOX query
-                    while (ruleIter!=rules.end())
-                    {
-                        if (ruleIter-&gt;active(scale))
-                        {
-                            active_rules=true;
-                            ruleIter-&gt;accept(collector);
-
-                            if (ruleIter-&gt;has_else_filter())
-                            {
-                                else_rules.push_back(const_cast&lt;rule_type*&gt;(&amp;(*ruleIter)));
-                            }
-                            else
-                            {
-                                if_rules.push_back(const_cast&lt;rule_type*&gt;(&amp;(*ruleIter))); 		    
-                            }
-                        }
-                        ++ruleIter;
-                    }
-                    std::set&lt;std::string&gt;::const_iterator namesIter=names.begin();
-                    // push all property names
-                    while (namesIter!=names.end())
-                    {
-                        q.add_property_name(*namesIter);
-                        ++namesIter;
-                    }
-                    if (active_rules)
-                    {
-                        featureset_ptr fs=ds-&gt;features(q);
-                        if (fs)
-                        {   	    
-                            feature_ptr feature;
-                            while ((feature = fs-&gt;next()))
-                            {		   
-                                bool do_else=true;		    
-                                std::vector&lt;rule_type*&gt;::const_iterator itr=if_rules.begin();
-                                while (itr!=if_rules.end())
-                                {
-                                    filter_ptr const&amp; filter=(*itr)-&gt;get_filter();    
-                                    if (filter-&gt;pass(*feature))
-                                    {   
-                                        do_else=false;
-                                        const symbolizers&amp; symbols = (*itr)-&gt;get_symbolizers();
-                                        symbolizers::const_iterator symIter=symbols.begin();
-                                        while (symIter!=symbols.end())
-                                        {   
-                                            boost::apply_visitor(symbol_dispatch(p,*feature),*symIter++);
-                                        }
-                                    }			    
-                                    ++itr;
-                                }
-                                if (do_else)
-                                {
-                                    //else filter
-                                    std::vector&lt;rule_type*&gt;::const_iterator itr=else_rules.begin();
-                                    while (itr != else_rules.end())
-                                    {
-                                        const symbolizers&amp; symbols = (*itr)-&gt;get_symbolizers();
-                                        symbolizers::const_iterator symIter=symbols.begin();
-                                        while (symIter!=symbols.end())
-                                        {
-                                            boost::apply_visitor(symbol_dispatch(p,*feature),*symIter++);
-                                        }
-                                        ++itr;
-                                    }
-                                }	  
-                            }
-                        }
-                    }
-                }
-            }
-            p.end_layer_processing(lay);
-        }
-	
-        Map const&amp; m_;
-    };
-}
-
-#endif //FEATURE_STYLE_PROCESSOR_HPP

Deleted: trunk/include/feature_type_style.hpp
===================================================================
--- trunk/include/feature_type_style.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/feature_type_style.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,67 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef FEATURE_TYPE_STYLE
-#define FEATURE_TYPE_STYLE
-
-#include &quot;rule.hpp&quot;
-#include &quot;feature.hpp&quot;
-#include &lt;vector&gt;
-
-
-namespace mapnik
-{
-    typedef std::vector&lt;rule_type&gt; rules;
-    class feature_type_style
-    {
-    private:
-        rules  rules_;
-    public:
-        feature_type_style() {}
-
-        feature_type_style(feature_type_style const&amp; rhs)
-            : rules_(rhs.rules_) {}
-	
-        feature_type_style&amp; operator=(feature_type_style const&amp; rhs)
-        {
-            if (this == &amp;rhs) return *this;
-            rules_=rhs.rules_;
-            return *this;
-        }
-	
-        void add_rule(rule_type const&amp; rule)
-        {
-            rules_.push_back(rule);
-        } 
-	
-        rules const&amp; get_rules() const
-        {
-            return rules_;
-        }
-	
-        ~feature_type_style() {}
-    };
-}
-
-#endif //FEATURE_TYPE_STYLE

Deleted: trunk/include/fill.hpp
===================================================================
--- trunk/include/fill.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/fill.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,36 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef FILL_HPP
-#define FILL_HPP
-
-namespace mapnik
-{
-    class fill 
-    {
-        
-    };
-}
-
-#endif //FILL_HPP

Deleted: trunk/include/filter.hpp
===================================================================
--- trunk/include/filter.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/filter.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,89 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef FILTER_HPP
-#define FILTER_HPP
-
-#include &quot;feature.hpp&quot;
-
-namespace mapnik
-{
-    template &lt;typename FeatureT&gt; class filter_visitor;
-    template &lt;typename FeatureT&gt;
-    class MAPNIK_DECL filter
-    {
-	public:
-		virtual bool pass(const FeatureT&amp; feature) const=0; 
-		virtual filter&lt;FeatureT&gt;* clone() const=0;
-		virtual void accept(filter_visitor&lt;FeatureT&gt;&amp; v) = 0;
-        virtual std::string to_string() const=0;
-		virtual ~filter() {}
-    };
-    
-    typedef boost::shared_ptr&lt;filter&lt;Feature&gt; &gt; filter_ptr;
-    
-    template &lt;typename FeatureT&gt;
-    class all_filter : public filter&lt;FeatureT&gt;
-    {
-	public:
-		bool pass (const FeatureT&amp;) const
-		{
-			return true;
-		}
-	
-		filter&lt;FeatureT&gt;* clone() const
-		{
-			return new all_filter&lt;FeatureT&gt;;
-		}
-		std::string to_string() const
-		{
-			return &quot;true&quot;;
-		}  
-        void accept(filter_visitor&lt;FeatureT&gt;&amp;) {}
-		virtual ~all_filter() {}
-    };
-      
-    template &lt;typename FeatureT&gt;
-    class none_filter : public filter&lt;FeatureT&gt;
-    {
-	public:
-		bool pass (const FeatureT&amp;) const
-		{
-			return false;
-		}
-	
-		filter&lt;FeatureT&gt;* clone() const
-		{
-			return new none_filter&lt;FeatureT&gt;;
-		}
-		std::string to_string() const
-		{
-			return &quot;false&quot;;
-		}  
-	    void accept(filter_visitor&lt;FeatureT&gt;&amp;) {}
-		virtual ~none_filter() {}
-	};
-}
-
-#endif //FILTER_HPP

Deleted: trunk/include/filter_expression.hpp
===================================================================
--- trunk/include/filter_expression.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/filter_expression.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,65 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef FILTER_TO_STRING_HPP
-#define FILTER_TO_STRING_HPP
-
-#include &quot;filter.hpp&quot;
-#include &quot;expression.hpp&quot;
-#include &lt;set&gt;
-
-namespace mapnik
-{
-    template &lt;typename FeatureT&gt;
-    class filter_to_string : public filter_visitor&lt;FeatureT&gt;
-    {
-    private:
-        std::string text_;
-    public:
-        filter_to_string() {}
-        void visit(filter&lt;FeatureT&gt;&amp; /*filter*/) 
-        { 
-            //not interested
-        }
-        void visit(expression&lt;FeatureT&gt;&amp; exp)
-        {
-            property&lt;FeatureT&gt;* pf;
-            if ((pf = dynamic_cast&lt;property&lt;FeatureT&gt;*&gt;(&amp;exp)))
-            {
-                names_.insert(pf-&gt;name());
-            }
-        }
-        std::string const&amp; text() const
-        {
-            return text_;
-        }
-	
-        virtual ~filter_to_string() {}
-    private:
-        filter_to_string(filter_to_string const&amp;);
-        filter_to_string&amp; operator=(filter_to_string const&amp;);
-    };
-}
-
-#endif //FILTER_TO_STRING

Deleted: trunk/include/filter_factory.hpp
===================================================================
--- trunk/include/filter_factory.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/filter_factory.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,60 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef FILTER_FACTORY_HPP
-#define FILTER_FACTORY_HPP
-
-#include &quot;filter_parser.hpp&quot;
-
-using std::string;
-
-namespace mapnik
-{
-    template&lt;typename FeatureT&gt;
-    class MAPNIK_DECL filter_factory
-    {
-    public:
-        static filter_ptr compile(string const&amp; str)
-        {
-            stack&lt;shared_ptr&lt;filter&lt;FeatureT&gt; &gt; &gt; filters;
-            stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt; exps;
-            filter_grammar&lt;FeatureT&gt; grammar(filters,exps);
-            char const *text = str.c_str();
-            parse_info&lt;&gt; info = parse(text,text+strlen(text),grammar,space_p);
-            if (info.full &amp;&amp; !filters.empty())
-            {
-                return filters.top();	
-            }
-            else 
-            {
-                clog &lt;&lt; &quot;failed at :&quot; &lt;&lt; info.stop &lt;&lt; &quot;\n&quot;;
-                return filter_ptr(new none_filter&lt;FeatureT&gt;());
-            }  
-        }
-    };
-
-    MAPNIK_DECL filter_ptr create_filter (std::string const&amp; wkt);
-}
-
-#endif //FILTER_FACTORY_HPP

Deleted: trunk/include/filter_parser.hpp
===================================================================
--- trunk/include/filter_parser.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/filter_parser.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,447 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-
-//$Id$
-
-#ifndef FILTER_PARSER_HPP
-#define FILTER_PARSER_HPP
-
-#include &lt;stack&gt;
-#include &lt;iostream&gt;
-
-#include &lt;boost/shared_ptr.hpp&gt;
-#include &lt;boost/spirit/core.hpp&gt;
-#include &lt;boost/spirit/symbols.hpp&gt;
-#include &lt;boost/spirit/utility/confix.hpp&gt;
-#include &lt;boost/spirit/utility/escape_char.hpp&gt;
-#include &lt;boost/spirit/utility/chset.hpp&gt; 
-
-#include &quot;value.hpp&quot;
-#include &quot;comparison.hpp&quot;
-#include &quot;math_expr.hpp&quot;
-#include &quot;expression.hpp&quot;
-#include &quot;filter.hpp&quot;
-#include &quot;regex_filter.hpp&quot;
-#include &quot;logical.hpp&quot;
-
-using namespace boost::spirit;
-using std::string;
-using std::clog;
-using std::stack;
-
-namespace mapnik
-{    
-    template &lt;typename FeatureT&gt;
-    struct push_integer
-    {
-        push_integer(stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt;&amp; exprs)
-            : exprs_(exprs) {}
-	
-        void operator() (int val) const
-        {
-            exprs_.push(shared_ptr&lt;expression&lt;FeatureT&gt; &gt;(new literal&lt;FeatureT&gt;(val)));
-        }
-        stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt;&amp; exprs_;
-    };
-   
-    template &lt;typename FeatureT&gt;
-    struct push_real
-    {
-        push_real(stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt;&amp; exprs)
-            : exprs_(exprs) {}
-        void operator() (double val) const
-        {
-            exprs_.push(shared_ptr&lt;expression&lt;FeatureT&gt; &gt;(new literal&lt;FeatureT&gt;(val)));
-        }
-        stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt;&amp; exprs_;
-    };
-    
-    template &lt;typename FeatureT&gt;
-    struct push_string
-    {
-        push_string(stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt;&amp; exprs)
-            : exprs_(exprs) {}
-	
-        template &lt;typename Iter&gt;
-        void operator() (Iter start,Iter end) const
-        {
-            string str(start,end);
-            char quote='\\';
-            string::size_type idx;
-            idx = str.find(quote);
-            while (idx != string::npos)
-            {	    		
-                str.erase(idx,1);
-                idx = str.find(quote);
-            }
-            exprs_.push(shared_ptr&lt;expression&lt;FeatureT&gt; &gt;(new literal&lt;FeatureT&gt;(str)));
-        }
-        stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt;&amp; exprs_;
-    };
-    
-    template &lt;typename FeatureT&gt;
-    struct push_property
-    {
-        push_property(stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt;&amp; exprs)
-            : exprs_(exprs) {}
-	
-        template &lt;typename Iter&gt;
-        void operator() (Iter start,Iter end) const
-        {
-            string str(start,end);
-            exprs_.push(shared_ptr&lt;expression&lt;FeatureT&gt; &gt;(new property&lt;FeatureT&gt;(str)));
-        }
-        stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt;&amp; exprs_;
-    };
-
-    template &lt;typename FeatureT,typename Op&gt;
-    struct compose_expression
-    {
-        compose_expression(stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt;&amp; exprs)
-            : exprs_(exprs) {}
-
-        template &lt;typename Iter&gt;
-        void operator() (Iter,Iter) const
-        {
-            if (exprs_.size()&gt;=2)
-            {
-                shared_ptr&lt;expression&lt;FeatureT&gt; &gt; right = exprs_.top();
-                exprs_.pop();
-                shared_ptr&lt;expression&lt;FeatureT&gt; &gt; left = exprs_.top();
-                exprs_.pop();
-                if (left &amp;&amp; right)
-                {
-                    exprs_.push(shared_ptr&lt;expression&lt;FeatureT&gt; &gt;
-                                (new mapnik::math_expr_b&lt;FeatureT,Op&gt;(*left,*right)));
-                }
-            }
-        }
-        stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt;&amp; exprs_;
-    };
-    
-    template &lt;typename FeatureT&gt;
-    struct compose_regex
-    {
-        compose_regex(stack&lt;shared_ptr&lt;filter&lt;FeatureT&gt; &gt; &gt;&amp; filters,
-                      stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt;&amp; exprs)
-            : filters_(filters),exprs_(exprs) {}
-
-        template &lt;typename Iter&gt;
-        void operator() (Iter start,Iter end) const
-        {
-            if (exprs_.size()&gt;=1)
-            {
-                shared_ptr&lt;expression&lt;FeatureT&gt; &gt; exp = exprs_.top();
-                exprs_.pop();
-                if (exp)
-                {		    
-                    std::string pattern(start,end);
-                    try 
-                    {
-                        filters_.push(shared_ptr&lt;filter&lt;FeatureT&gt; &gt;(new regex_filter&lt;FeatureT&gt;(*exp,pattern)));
-                    }
-                    catch (...)//boost::regex_error&amp; ex)
-                    {
-                        clog&lt;&lt;&quot;error\n&quot;;//ex.what()&lt;&lt;&quot;\n&quot;;
-                    }
-		    
-                }
-            }
-        }
-        stack&lt;shared_ptr&lt;filter&lt;FeatureT&gt; &gt; &gt;&amp; filters_;
-        stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt;&amp; exprs_;
-    };
-
-  
-    template &lt;typename FeatureT,typename Op&gt;
-    struct compose_filter
-    {
-        compose_filter(stack&lt;shared_ptr&lt;filter&lt;FeatureT&gt; &gt; &gt;&amp; filters,
-                       stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt;&amp; exprs)
-            : filters_(filters),exprs_(exprs) {}
-
-        template &lt;typename Iter&gt;
-        void operator() (Iter,Iter) const
-        {
-            if (exprs_.size()&gt;=2)
-            {
-                shared_ptr&lt;expression&lt;FeatureT&gt; &gt; right = exprs_.top();
-                exprs_.pop();
-                shared_ptr&lt;expression&lt;FeatureT&gt; &gt; left = exprs_.top();
-                exprs_.pop();
-                if (left &amp;&amp; right)
-                {
-                    filters_.push(shared_ptr&lt;filter&lt;FeatureT&gt; &gt;(new compare_filter&lt;FeatureT,Op&gt;(*left,*right)));
-                }
-            }
-        }
-        stack&lt;shared_ptr&lt;filter&lt;FeatureT&gt; &gt; &gt;&amp; filters_;
-        stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt;&amp; exprs_;
-    };
-    
-    template &lt;typename FeatureT&gt;
-    struct compose_and_filter
-    {
-        compose_and_filter(stack&lt;shared_ptr&lt;filter&lt;FeatureT&gt; &gt; &gt;&amp; filters)
-            : filters_(filters) {}
-
-        template &lt;typename Iter&gt;
-        void operator() (Iter,Iter) const
-        {
-            if (filters_.size()&gt;=2)
-            {
-                shared_ptr&lt;filter&lt;FeatureT&gt; &gt; right = filters_.top();
-                filters_.pop();
-                shared_ptr&lt;filter&lt;FeatureT&gt; &gt; left = filters_.top();
-                filters_.pop();
-                if (left &amp;&amp; right)
-                {
-                    filters_.push(shared_ptr&lt;filter&lt;FeatureT&gt; &gt;(new logical_and&lt;FeatureT&gt;(*left,*right)));
-                }
-            }
-        }
-        stack&lt;shared_ptr&lt;filter&lt;FeatureT&gt; &gt; &gt;&amp; filters_;
-    };
-    
-    template &lt;typename FeatureT&gt;
-    struct compose_or_filter
-    {
-        compose_or_filter(stack&lt;shared_ptr&lt;filter&lt;FeatureT&gt; &gt; &gt;&amp; filters)
-            : filters_(filters) {}
-
-        template &lt;typename Iter&gt;
-        void operator() (Iter,Iter) const
-        {
-            if (filters_.size()&gt;=2)
-            {
-                shared_ptr&lt;filter&lt;FeatureT&gt; &gt; right = filters_.top();
-                filters_.pop();
-                shared_ptr&lt;filter&lt;FeatureT&gt; &gt; left = filters_.top();
-                filters_.pop();
-                if (left &amp;&amp; right)
-                {
-                    filters_.push(shared_ptr&lt;filter&lt;FeatureT&gt; &gt;(new logical_or&lt;FeatureT&gt;(*left,*right)));
-                }
-            }
-        }
-        stack&lt;shared_ptr&lt;filter&lt;FeatureT&gt; &gt; &gt;&amp; filters_;
-    };
-    
-    template &lt;typename FeatureT&gt;
-    struct compose_not_filter
-    {
-        compose_not_filter(stack&lt;shared_ptr&lt;filter&lt;FeatureT&gt; &gt; &gt;&amp; filters)
-            : filters_(filters) {}
-
-        template &lt;typename Iter&gt;
-        void operator() (Iter,Iter) const
-        {
-            if (filters_.size()&gt;=1)
-            {
-                shared_ptr&lt;filter&lt;FeatureT&gt; &gt; filter_ = filters_.top();
-                filters_.pop();
-                if (filter_)
-                {
-                    filters_.push(shared_ptr&lt;filter&lt;FeatureT&gt; &gt;(new logical_not&lt;FeatureT&gt;(*filter_)));
-                }
-            }
-        }
-        stack&lt;shared_ptr&lt;filter&lt;FeatureT&gt; &gt; &gt;&amp; filters_;
-    };
-    
-    template &lt;typename FeatureT&gt;
-    struct filter_grammar : public grammar&lt;filter_grammar&lt;FeatureT&gt; &gt;
-    {
-        filter_grammar(stack&lt;shared_ptr&lt;filter&lt;FeatureT&gt; &gt; &gt;&amp; filters_,
-                       stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt;&amp; exprs_)
-            : filters(filters_),exprs(exprs_) {}
-	
-        template &lt;typename ScannerT&gt;
-        struct definition
-        {
-            definition(filter_grammar const&amp; self)
-            {	
-                typedef boost::spirit::chset&lt;wchar_t&gt; chset_t;
-
-                func1_op = &quot;sqrt&quot;,&quot;sin&quot;,&quot;cos&quot;;
-                func2_op = &quot;min&quot;,&quot;max&quot;;
-                spatial_op = &quot;Equals&quot;,&quot;Disjoint&quot;,&quot;Touches&quot;,&quot;Within&quot;,&quot;Overlaps&quot;,
-                    &quot;Crosses&quot;,&quot;Intersects&quot;,&quot;Contains&quot;,&quot;DWithin&quot;,&quot;Beyond&quot;,&quot;BBOX&quot;;
-		
-                chset_t BaseChar (L&quot;\x41-\x5A\x61-\x7A\xC0-\xD6\xD8-\xF6\xF8-\xFF\x100-\x131\x134-\x13E&quot;
-                                  L&quot;\x141-\x148\x14A-\x17E\x180-\x1C3\x1CD-\x1F0\x1F4-\x1F5\x1FA-\x217&quot;
-                                  L&quot;\x250-\x2A8\x2BB-\x2C1\x386\x388-\x38A\x38C\x38E-\x3A1\x3A3-\x3CE&quot;
-                                  L&quot;\x3D0-\x3D6\x3DA\x3DC\x3DE\x3E0\x3E2-\x3F3\x401-\x40C\x40E-\x44F&quot;
-                                  L&quot;\x451-\x45C\x45E-\x481\x490-\x4C4\x4C7-\x4C8\x4CB-\x4CC\x4D0-\x4EB&quot;
-                                  L&quot;\x4EE-\x4F5\x4F8-\x4F9\x531-\x556\x559\x561-\x586\x5D0-\x5EA&quot;
-                                  L&quot;\x5F0-\x5F2\x621-\x63A\x641-\x64A\x671-\x6B7\x6BA-\x6BE\x6C0-\x6CE&quot;
-                                  L&quot;\x6D0-\x6D3\x6D5\x6E5-\x6E6\x905-\x939\x93D\x958-\x961\x985-\x98C&quot;
-                                  L&quot;\x98F-\x990\x993-\x9A8\x9AA-\x9B0\x9B2\x9B6-\x9B9\x9DC-\x9DD&quot;
-                                  L&quot;\x9DF-\x9E1\x9F0-\x9F1\xA05-\xA0A\xA0F-\xA10\xA13-\xA28\xA2A-\xA30&quot;
-                                  L&quot;\xA32-\xA33\xA35-\xA36\xA38-\xA39\xA59-\xA5C\xA5E\xA72-\xA74&quot;
-                                  L&quot;\xA85-\xA8B\xA8D\xA8F-\xA91\xA93-\xAA8\xAAA-\xAB0\xAB2-\xAB3&quot;
-                                  L&quot;\xAB5-\xAB9\xABD\xAE0\xB05-\xB0C\xB0F-\xB10\xB13-\xB28\xB2A-\xB30&quot;
-                                  L&quot;\xB32-\xB33\xB36-\xB39\xB3D\xB5C-\xB5D\xB5F-\xB61\xB85-\xB8A&quot;
-                                  L&quot;\xB8E-\xB90\xB92-\xB95\xB99-\xB9A\xB9C\xB9E-\xB9F\xBA3-\xBA4&quot;
-                                  L&quot;\xBA8-\xBAA\xBAE-\xBB5\xBB7-\xBB9\xC05-\xC0C\xC0E-\xC10\xC12-\xC28&quot;
-                                  L&quot;\xC2A-\xC33\xC35-\xC39\xC60-\xC61\xC85-\xC8C\xC8E-\xC90\xC92-\xCA8&quot;
-                                  L&quot;\xCAA-\xCB3\xCB5-\xCB9\xCDE\xCE0-\xCE1\xD05-\xD0C\xD0E-\xD10&quot;
-                                  L&quot;\xD12-\xD28\xD2A-\xD39\xD60-\xD61\xE01-\xE2E\xE30\xE32-\xE33&quot;
-                                  L&quot;\xE40-\xE45\xE81-\xE82\xE84\xE87-\xE88\xE8A\xE8D\xE94-\xE97&quot;
-                                  L&quot;\xE99-\xE9F\xEA1-\xEA3\xEA5\xEA7\xEAA-\xEAB\xEAD-\xEAE\xEB0&quot;
-                                  L&quot;\xEB2-\xEB3\xEBD\xEC0-\xEC4\xF40-\xF47\xF49-\xF69\x10A0-\x10C5&quot;
-                                  L&quot;\x10D0-\x10F6\x1100\x1102-\x1103\x1105-\x1107\x1109\x110B-\x110C&quot;
-                                  L&quot;\x110E-\x1112\x113C\x113E\x1140\x114C\x114E\x1150\x1154-\x1155&quot;
-                                  L&quot;\x1159\x115F-\x1161\x1163\x1165\x1167\x1169\x116D-\x116E&quot;
-                                  L&quot;\x1172-\x1173\x1175\x119E\x11A8\x11AB\x11AE-\x11AF\x11B7-\x11B8&quot;
-                                  L&quot;\x11BA\x11BC-\x11C2\x11EB\x11F0\x11F9\x1E00-\x1E9B\x1EA0-\x1EF9&quot;
-                                  L&quot;\x1F00-\x1F15\x1F18-\x1F1D\x1F20-\x1F45\x1F48-\x1F4D\x1F50-\x1F57&quot;
-                                  L&quot;\x1F59\x1F5B\x1F5D\x1F5F-\x1F7D\x1F80-\x1FB4\x1FB6-\x1FBC\x1FBE&quot;
-                                  L&quot;\x1FC2-\x1FC4\x1FC6-\x1FCC\x1FD0-\x1FD3\x1FD6-\x1FDB\x1FE0-\x1FEC&quot;
-                                  L&quot;\x1FF2-\x1FF4\x1FF6-\x1FFC\x2126\x212A-\x212B\x212E\x2180-\x2182&quot;
-                                  L&quot;\x3041-\x3094\x30A1-\x30FA\x3105-\x312C\xAC00-\xD7A3&quot;);
-            
-                chset_t Ideographic(L&quot;\x4E00-\x9FA5\x3007\x3021-\x3029&quot;);
-                chset_t Letter = BaseChar | Ideographic;
-	    
-                chset_t CombiningChar(L&quot;\x0300-\x0345\x0360-\x0361\x0483-\x0486\x0591-\x05A1\x05A3-\x05B9&quot;
-                                      L&quot;\x05BB-\x05BD\x05BF\x05C1-\x05C2\x05C4\x064B-\x0652\x0670&quot;
-                                      L&quot;\x06D6-\x06DC\x06DD-\x06DF\x06E0-\x06E4\x06E7-\x06E8\x06EA-\x06ED&quot;
-                                      L&quot;\x0901-\x0903\x093C\x093E-\x094C\x094D\x0951-\x0954\x0962-\x0963&quot;
-                                      L&quot;\x0981-\x0983\x09BC\x09BE\x09BF\x09C0-\x09C4\x09C7-\x09C8&quot;
-                                      L&quot;\x09CB-\x09CD\x09D7\x09E2-\x09E3\x0A02\x0A3C\x0A3E\x0A3F&quot;
-                                      L&quot;\x0A40-\x0A42\x0A47-\x0A48\x0A4B-\x0A4D\x0A70-\x0A71\x0A81-\x0A83&quot;
-                                      L&quot;\x0ABC\x0ABE-\x0AC5\x0AC7-\x0AC9\x0ACB-\x0ACD\x0B01-\x0B03\x0B3C&quot;
-                                      L&quot;\x0B3E-\x0B43\x0B47-\x0B48\x0B4B-\x0B4D\x0B56-\x0B57\x0B82-\x0B83&quot;
-                                      L&quot;\x0BBE-\x0BC2\x0BC6-\x0BC8\x0BCA-\x0BCD\x0BD7\x0C01-\x0C03&quot;
-                                      L&quot;\x0C3E-\x0C44\x0C46-\x0C48\x0C4A-\x0C4D\x0C55-\x0C56\x0C82-\x0C83&quot;
-                                      L&quot;\x0CBE-\x0CC4\x0CC6-\x0CC8\x0CCA-\x0CCD\x0CD5-\x0CD6\x0D02-\x0D03&quot;
-                                      L&quot;\x0D3E-\x0D43\x0D46-\x0D48\x0D4A-\x0D4D\x0D57\x0E31\x0E34-\x0E3A&quot;
-                                      L&quot;\x0E47-\x0E4E\x0EB1\x0EB4-\x0EB9\x0EBB-\x0EBC\x0EC8-\x0ECD&quot;
-                                      L&quot;\x0F18-\x0F19\x0F35\x0F37\x0F39\x0F3E\x0F3F\x0F71-\x0F84&quot;
-                                      L&quot;\x0F86-\x0F8B\x0F90-\x0F95\x0F97\x0F99-\x0FAD\x0FB1-\x0FB7\x0FB9&quot;
-                                      L&quot;\x20D0-\x20DC\x20E1\x302A-\x302F\x3099\x309A&quot;);
-	    
-                chset_t Digit(L&quot;\x0030-\x0039\x0660-\x0669\x06F0-\x06F9\x0966-\x096F\x09E6-\x09EF&quot;
-                              L&quot;\x0A66-\x0A6F\x0AE6-\x0AEF\x0B66-\x0B6F\x0BE7-\x0BEF\x0C66-\x0C6F&quot;
-                              L&quot;\x0CE6-\x0CEF\x0D66-\x0D6F\x0E50-\x0E59\x0ED0-\x0ED9\x0F20-\x0F29&quot;);
-		
-                chset_t Extender(L&quot;\x00B7\x02D0\x02D1\x0387\x0640\x0E46\x0EC6\x3005\x3031-\x3035&quot;
-                                 L&quot;\x309D-\x309E\x30FC-\x30FE&quot;);
-		
-                chset_t NameChar =
-                    Letter 
-                    | Digit 
-                    | L'.'
-                    | L'-'
-                    | L'_'
-                    | L':'
-                    | CombiningChar 
-                    | Extender;
-				
-                number = strict_real_p [push_real&lt;FeatureT&gt;(self.exprs)] 
-                    | int_p [push_integer&lt;FeatureT&gt;(self.exprs)];
-		
-                string_ = confix_p(L'\'',(*lex_escape_ch_p)
-                                   [push_string&lt;FeatureT&gt;(self.exprs)],
-                                   L'\'');
-		
-                property = L'[' &gt;&gt; ( (Letter | L'_' | L':') 
-                                     &gt;&gt; *NameChar )[push_property&lt;FeatureT&gt;(self.exprs)] &gt;&gt; L']';
-		
-                literal = number | string_ | property;
-		
-                function = literal | ( func1_op &gt;&gt; L'('&gt;&gt; literal &gt;&gt; L')') | 
-                    (func2_op &gt;&gt; L'(' &gt;&gt; literal &gt;&gt; L','&gt;&gt; literal &gt;&gt; L')');
-		
-                factor = function 
-                    | L'(' &gt;&gt; or_expr &gt;&gt; L')'
-                    | ( L'-' &gt;&gt; factor) 
-                    ;
-                term = factor
-                    &gt;&gt; *((L'*' &gt;&gt; factor) [compose_expression&lt;FeatureT,mapnik::mult&lt;value&gt; &gt;(self.exprs)] 
-                         | (L'/' &gt;&gt; factor) [compose_expression&lt;FeatureT,mapnik::div&lt;value&gt; &gt;(self.exprs)]);
-		
-                expression = term &gt;&gt; *((L'+' &gt;&gt; term) [compose_expression&lt;FeatureT,mapnik::add&lt;value&gt; &gt;(self.exprs)] 
-                                       | (L'-' &gt;&gt; term) [compose_expression&lt;FeatureT,mapnik::sub&lt;value&gt; &gt;(self.exprs)]);
-
-                regex = str_p(L&quot;.match&quot;)&gt;&gt;L'('&gt;&gt;confix_p(L'\'',(*lex_escape_ch_p)
-                                                         [compose_regex&lt;FeatureT&gt;(self.filters,self.exprs)],
-                                                         L'\'') &gt;&gt;L')';
-
-                relation   = expression 
-                    &gt;&gt; *((L&quot;&gt;=&quot; &gt;&gt; expression) 
-                         [compose_filter&lt;FeatureT,greater_than_or_equal&lt;value&gt; &gt;(self.filters,self.exprs)]
-                         | (L'&gt;' &gt;&gt; expression)
-                         [compose_filter&lt;FeatureT,mapnik::greater_than&lt;value&gt; &gt;(self.filters,self.exprs)]
-                         | (L'&lt;' &gt;&gt; expression)
-                         [compose_filter&lt;FeatureT,mapnik::less_than&lt;value&gt; &gt;(self.filters,self.exprs)]
-                         | (L&quot;&lt;=&quot; &gt;&gt; expression)
-                         [compose_filter&lt;FeatureT,less_than_or_equal&lt;value&gt; &gt;(self.filters,self.exprs)]
-                         | regex );
-
-                equation = relation &gt;&gt; *( ( L'=' &gt;&gt; relation)
-                                          [compose_filter&lt;FeatureT,mapnik::equals&lt;value&gt; &gt;(self.filters,self.exprs)]
-                                          | ( L&quot;&lt;&gt;&quot; &gt;&gt; relation)
-                                          [compose_filter&lt;FeatureT,not_equals&lt;value&gt; &gt;(self.filters,self.exprs)]);
-
-                not_expr = equation | *(str_p(L&quot;not&quot;) &gt;&gt; equation)[compose_not_filter&lt;FeatureT&gt;(self.filters)];
-
-                and_expr = not_expr &gt;&gt; *(L&quot;and&quot; &gt;&gt; not_expr)[compose_and_filter&lt;FeatureT&gt;(self.filters)];
-
-                or_expr  = and_expr &gt;&gt; *(L&quot;or&quot; &gt;&gt; and_expr)[compose_or_filter&lt;FeatureT&gt;(self.filters)];
-
-                filter_statement = or_expr;	
-            }
-	    
-            boost::spirit::rule&lt;ScannerT&gt; const&amp; start() const
-            {
-                return filter_statement;
-            }
-	    	    
-            boost::spirit::rule&lt;ScannerT&gt; factor; 
-            boost::spirit::rule&lt;ScannerT&gt; term;
-            boost::spirit::rule&lt;ScannerT&gt; expression;
-            boost::spirit::rule&lt;ScannerT&gt; relation;
-            boost::spirit::rule&lt;ScannerT&gt; equation;
-            boost::spirit::rule&lt;ScannerT&gt; not_expr;
-            boost::spirit::rule&lt;ScannerT&gt; and_expr;
-            boost::spirit::rule&lt;ScannerT&gt; or_expr;
-	    
-            boost::spirit::rule&lt;ScannerT&gt; filter_statement;   
-            boost::spirit::rule&lt;ScannerT&gt; literal;
-            boost::spirit::rule&lt;ScannerT&gt; number;
-            boost::spirit::rule&lt;ScannerT&gt; string_;
-            boost::spirit::rule&lt;ScannerT&gt; property;
-            boost::spirit::rule&lt;ScannerT&gt; function;
-            boost::spirit::rule&lt;ScannerT&gt; regex;
-            symbols&lt;string&gt; func1_op;
-            symbols&lt;string&gt; func2_op;
-            symbols&lt;string&gt; spatial_op;
-        };
-        stack&lt;shared_ptr&lt;filter&lt;FeatureT&gt; &gt; &gt;&amp; filters;
-        stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt;&amp; exprs;
-    };    
-}
-
-#endif //FILTER_PARSER_HPP 

Deleted: trunk/include/filter_parser_ast.hpp
===================================================================
--- trunk/include/filter_parser_ast.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/filter_parser_ast.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,265 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef FILTER_PARSER_AST_HPP
-#define FILTER_PARSER_AST_HPP
-
-#include &lt;boost/spirit/core.hpp&gt;
-#include &lt;boost/spirit/tree/ast.hpp&gt;
-
-#include &lt;iostream&gt;
-
-using namespace std;
-using namespace boost::spirit;
-
-namespace mapnik
-{
-    struct filter_grammar_ast : public grammar&lt;filter_grammar_ast&gt;
-    {
-	
-	static const int integerID = 1;
-	static const int realID = 2;
-	static const int stringID = 3;
-	static const int propertyID = 4;
-	static const int factorID = 5;
-	static const int termID = 6;
-	static const int expressionID = 7;
-	static const int relationID = 8;
-	static const int equationID = 9;
-	static const int and_exprID = 10;
-	static const int or_exprID = 11;
-	
-	template &lt;typename ScannerT&gt;
-	struct definition
-	{
-	    
-	    definition(filter_grammar_ast const&amp; /*self*/)
-	    {			
-		real = leaf_node_d[strict_real_p];
-		integer    = leaf_node_d[int_p];
-		number = real | integer;
-		
-		string_ = inner_node_d['\''&gt;&gt; leaf_node_d[( (alpha_p | '_')  &gt;&gt; 
-					     * (alnum_p | '_' ))] &gt;&gt;  '\''];
-		
-		property = inner_node_d['[' &gt;&gt; leaf_node_d[ ( (alpha_p | '_') &gt;&gt; * (alnum_p | '_' )) ] &gt;&gt; ']'];
-		
-		literal = number | string_ | property;
-		
-		factor = literal 
-		    | (root_node_d[str_p(&quot;not&quot;)] &gt;&gt; literal) 
-		    | inner_node_d[ch_p('(') &gt;&gt; or_expr &gt;&gt; ch_p(')') ]
-		    | (root_node_d[ch_p('-')] &gt;&gt; factor)
-		    ;
-		
-		term = factor
-		    &gt;&gt; *((root_node_d[ch_p('*')] &gt;&gt; factor) | (root_node_d[ch_p('/')] &gt;&gt; factor));
-		
-		expression = term &gt;&gt; *((root_node_d[ch_p('+')] &gt;&gt; term) | (root_node_d[ch_p('-')] &gt;&gt; term));
-		relation   = expression &gt;&gt; *((root_node_d[str_p(&quot;&gt;=&quot;)] &gt;&gt; expression) 
-					     | (root_node_d[ch_p('&gt;')] &gt;&gt; expression)
-					     | (root_node_d[ch_p('&lt;')] &gt;&gt; expression)
-					     | (root_node_d[str_p(&quot;&lt;=&quot;)] &gt;&gt; expression));
-		
-		equation = relation &gt;&gt; *( (root_node_d[ch_p('=')] &gt;&gt; relation)
-					  | (root_node_d[str_p(&quot;&lt;&gt;&quot;)] &gt;&gt; relation));
-		and_expr = equation &gt;&gt; *(root_node_d[str_p(&quot;and&quot;)] &gt;&gt; equation);
-		or_expr  = and_expr &gt;&gt; *(root_node_d[str_p(&quot;or&quot;)] &gt;&gt; and_expr);
-		
-		//spatial_op = str_p(&quot;Equals&quot;) | &quot;Disjoint&quot; | &quot;Touches&quot; | &quot;Within&quot; 
-		//   | &quot;Overlaps&quot; | &quot;Crosses&quot; | &quot;Intersects&quot; | &quot;Contains&quot; | &quot;DWithin&quot; | &quot;Beyond&quot; | &quot;BBOX&quot;;
-
-		filter_statement = or_expr;
-	    }
-	    
-	    rule&lt;ScannerT&gt; const&amp; start() const
-	    {
-		return filter_statement;
-	    }
-	    	    
-	    rule&lt;ScannerT,parser_context&lt;&gt;, parser_tag&lt;factorID&gt; &gt; factor; 
-	    rule&lt;ScannerT,parser_context&lt;&gt;, parser_tag&lt;termID&gt; &gt; term;
-	    rule&lt;ScannerT,parser_context&lt;&gt;, parser_tag&lt;expressionID&gt; &gt; expression;
-	    rule&lt;ScannerT,parser_context&lt;&gt;, parser_tag&lt;relationID&gt; &gt; relation;
-	    rule&lt;ScannerT,parser_context&lt;&gt;, parser_tag&lt;equationID&gt; &gt; equation;
-	    
-	    rule&lt;ScannerT,parser_context&lt;&gt;, parser_tag&lt;and_exprID&gt; &gt; and_expr;
-	    rule&lt;ScannerT,parser_context&lt;&gt;, parser_tag&lt;or_exprID&gt; &gt; or_expr;
-	    
-	    rule&lt;ScannerT&gt; filter_statement;
-	    rule&lt;ScannerT&gt; literal,number;
-	    
-	    rule&lt;ScannerT,parser_context&lt;&gt;, parser_tag&lt;integerID&gt; &gt; integer;
-	    rule&lt;ScannerT,parser_context&lt;&gt;, parser_tag&lt;realID&gt; &gt; real;
-	    rule&lt;ScannerT,parser_context&lt;&gt;, parser_tag&lt;stringID&gt; &gt; string_;
-	    rule&lt;ScannerT,parser_context&lt;&gt;, parser_tag&lt;propertyID&gt; &gt; property;
-	    
-
-	    //rule&lt;ScannerT&gt; spatial_op;
-
-	};
-	
-    }; 
-
-    class node_data
-    {
-    public:
-	enum  {
-	    Unknown=0,
-	    Integer=1,
-	    Real   =2,
-	    String =3,
-	    Property=4
-	};
-	node_data()
-	    : type_(Unknown) {}
-
-	node_data(int type)
-	    : type_(type) {}
-    
-	node_data(node_data const&amp; other)
-	    : type_(other.type_) {}
-    
-	node_data&amp; operator=(node_data const&amp; other)
-	{
-	    if (this==&amp;other) 
-		return *this;
-	    type_=other.type_;
-	    return *this;
-	}
-	~node_data() {}
-    private:
-	int type_;    
-    };
-
-    typedef char const* iterator_t;
-    typedef node_val_data_factory&lt;node_data&gt; factory_t;
-    typedef tree_match&lt;iterator_t,factory_t&gt;::tree_iterator iter_t;
-
-    void process_node(iter_t const&amp;,string&amp;);
-    
-    void walk_ast_tree(tree_parse_info&lt;iterator_t,factory_t&gt; info,string&amp; text)
-    {
-	process_node(info.trees.begin(),text);
-    }
-    
-    void process_node(iter_t const&amp; i,string&amp; text)
-    {
-	//clog &lt;&lt; &quot;In eval_expression. i-&gt;value = &quot; &lt;&lt;
-	//   string(i-&gt;value.begin(), i-&gt;value.end()) &lt;&lt;
-	//   &quot; i-&gt;children.size() = &quot; &lt;&lt; i-&gt;children.size() &lt;&lt; endl;
-	//std::clog&lt;&lt;typeid(*i).name()&lt;&lt;&quot;\n&quot;;
-
-	if (i-&gt;value.id() == filter_grammar_ast::integerID)
-	{	
-	    assert(i-&gt;children.size()==0);
-	    string integer(i-&gt;value.begin(), i-&gt;value.end());	
-	    text+= integer;
-	}
-	else if (i-&gt;value.id() == filter_grammar_ast::realID)
-	{	
-	    assert(i-&gt;children.size()==0);
-	    string real(i-&gt;value.begin(), i-&gt;value.end());
-	    text += real;
-	}
-	else if (i-&gt;value.id() == filter_grammar_ast::stringID)
-	{	
-	    assert(i-&gt;children.size()==0);
-	    string str(i-&gt;value.begin(), i-&gt;value.end());
-	    text += str;
-	}
-	else if (i-&gt;value.id() == filter_grammar_ast::propertyID)
-	{
-	    assert(i-&gt;children.size()==0);
-	    string property_name(i-&gt;value.begin(), i-&gt;value.end());
-	    text += property_name;
-	}
-	else if (i-&gt;value.id() == filter_grammar_ast::expressionID)
-	{
-	    assert(i-&gt;children.size() == 2);
-	    assert(!i-&gt;children.begin()-&gt;value.is_root());
-	    process_node(i-&gt;children.begin(),text);	     
-	    text += string(i-&gt;value.begin(), i-&gt;value.end());
-	    process_node(i-&gt;children.begin()+1,text);
-	    
-	    text +=&quot;\n&quot;;
-	}
-	else if (i-&gt;value.id() == filter_grammar_ast::termID)
-	{
-	    assert(i-&gt;children.size() == 2);
-	    assert(!i-&gt;children.begin()-&gt;value.is_root());
-	    process_node(i-&gt;children.begin(),text);
-	    text +=  string(i-&gt;value.begin(), i-&gt;value.end());
-	    process_node(i-&gt;children.begin()+1,text);
-	    
-	    text +=&quot;\n&quot;;
-	
-	}
-	else if (i-&gt;value.id() == filter_grammar_ast::relationID)
-	{
-	    assert(i-&gt;children.size() == 2);
-	    assert(!i-&gt;children.begin()-&gt;value.is_root());
-	    process_node(i-&gt;children.begin(),text);
-	    text += string(i-&gt;value.begin(), i-&gt;value.end());
-	    process_node(i-&gt;children.begin()+1,text);
-	    
-	    text +=&quot;\n&quot;;
-
-	}
-	else if (i-&gt;value.id() == filter_grammar_ast::equationID)
-	{
-	    assert(i-&gt;children.size() == 2);
-	    assert(!i-&gt;children.begin()-&gt;value.is_root());
-	    process_node(i-&gt;children.begin(),text);
-	    text += string(i-&gt;value.begin(), i-&gt;value.end());
-	    process_node(i-&gt;children.begin()+1,text);
-	    
-	    text +=&quot;\n&quot;;
-	}
-	else if (i-&gt;value.id() == filter_grammar_ast::and_exprID)
-	{
-	    assert(i-&gt;children.size() == 2);
-	    assert(!i-&gt;children.begin()-&gt;value.is_root());
-	    process_node(i-&gt;children.begin(),text);
-	    text += string(i-&gt;value.begin(), i-&gt;value.end());
-	    process_node(i-&gt;children.begin()+1,text);
-	    
-	    text +=&quot;\n&quot;;
-	}
-	else if (i-&gt;value.id() == filter_grammar_ast::or_exprID)
-	{
-	    assert(i-&gt;children.size() == 2);
-	    assert(!i-&gt;children.begin()-&gt;value.is_root());
-            
-	    process_node(i-&gt;children.begin(),text);
-	    text += string(i-&gt;value.begin(), i-&gt;value.end());
-	    process_node(i-&gt;children.begin()+1,text);
-	    
-	    text +=&quot;\n&quot;;
-
-	}
-    }   
-}
-
-#endif //FILTER_PARSER_AST_HPP 

Deleted: trunk/include/filter_visitor.hpp
===================================================================
--- trunk/include/filter_visitor.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/filter_visitor.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,48 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef FILTER_VISITOR_HPP
-#define FILTER_VISITOR_HPP
-
-#include &quot;filter.hpp&quot;
-#include &quot;expression.hpp&quot;
-
-namespace mapnik
-{
-    template &lt;typename FeatureT&gt; class filter;
-    template &lt;typename FeatureT&gt; class expression;
-    template &lt;typename FeatureT&gt; class expression;
-    template &lt;typename Feature,template &lt;typename&gt; class Filter&gt; class rule;
-    template &lt;typename FeatureT&gt;
-    class filter_visitor
-    {
-	public:
-		virtual void visit(filter&lt;FeatureT&gt;&amp; filter)=0;
-		virtual void visit(expression&lt;FeatureT&gt;&amp;)=0;
-		virtual void visit(rule&lt;FeatureT,filter&gt; const&amp; r)=0;
-		virtual ~filter_visitor() {}
-    };    
-}
-
-#endif //FILTER_VISITOR_HPP

Deleted: trunk/include/font_engine_freetype.hpp
===================================================================
--- trunk/include/font_engine_freetype.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/font_engine_freetype.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,432 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#if !defined FONT_ENGINE_FREETYPE_HPP
-#define FONT_ENGINE_FREETYPE_HPP
-
-extern &quot;C&quot;
-{
-  #include &lt;ft2build.h&gt;
-  #include FT_FREETYPE_H
-  #include FT_GLYPH_H
-}
-
-#include &lt;boost/shared_ptr.hpp&gt;
-#include &lt;boost/utility.hpp&gt;
-#include &lt;boost/ptr_container/ptr_vector.hpp&gt;
-#include &lt;boost/thread/mutex.hpp&gt;
-
-#include &lt;string&gt;
-#include &lt;vector&gt;
-#include &lt;map&gt;
-#include &lt;iostream&gt;
-
-#include &lt;color.hpp&gt;
-#include &lt;utils.hpp&gt;
-
-namespace mapnik
-{
-
-  class font_face : boost::noncopyable
-    {
-    public:
-    	font_face(FT_Face face)
-	    : face_(face) {}
-	
-    	std::string  family_name() const
-    	{
-    	    return std::string(face_-&gt;family_name);
-    	}
-
-	std::string  style_name() const
-    	{
-    	    return std::string(face_-&gt;style_name);
-    	}
-	
-	unsigned num_glyphs() const
-	{
-	    return face_-&gt;num_glyphs;
-	}
-
-	FT_GlyphSlot glyph() const
-	{
-	    return face_-&gt;glyph;
-	}
-	
-	FT_Face get_face() const
-	{
-	    return face_;
-	}
-	
-	bool set_pixel_sizes(unsigned size)
-	{
-	    if (! FT_Set_Pixel_Sizes( face_, 0, size ))
-		return true;
-	    return false;
-	}
-        
-	
-    	~font_face()
-    	{
-    	    std::clog &lt;&lt; &quot;clean up face:&quot; &lt;&lt; family_name()&lt;&lt;&quot;:&quot; &lt;&lt; style_name() &lt;&lt; std::endl;
-    	    FT_Done_Face(face_);
-    	}
-	
-    private:
-    	FT_Face face_;
-    };
-    
-    typedef boost::shared_ptr&lt;font_face&gt; face_ptr;
-    
-    class MAPNIK_DECL freetype_engine : public mapnik::singleton&lt;freetype_engine,mapnik::CreateStatic&gt;,
-        private boost::noncopyable
-    {
-        friend class mapnik::CreateStatic&lt;freetype_engine&gt;;
-    public:
-
-        static bool register_font(std::string const&amp; file_name);
-        static std::vector&lt;std::string&gt; face_names ();
-        static face_ptr create_face(std::string const&amp; family_name);
-
-    private:
-        freetype_engine();
-        virtual ~freetype_engine();
-        static FT_Library library_;
-        static std::map&lt;std::string,std::string&gt; name2file_;
-    }; 
-    
-    template &lt;typename T&gt;
-    class MAPNIK_DECL face_manager : private boost::noncopyable
-    {
-	typedef T font_engine_type;
-	typedef std::map&lt;std::string,face_ptr&gt; faces;
-	
-    public:
-        face_ptr get_face(std::string const&amp; name)
-        {
-            typename faces::iterator itr;
-            itr = faces_.find(name);
-            if (itr != faces_.end())
-            {
-                return itr-&gt;second;
-            }
-            else
-            {
-                face_ptr face = font_engine_type::instance()-&gt;create_face(name);
-                if (face)
-                {
-                    faces_.insert(make_pair(name,face));
-                }
-                return face;	
-            }
-        }
-    private:
-	faces faces_;
-    };
-        
-    inline std::wstring to_unicode(std::string const&amp; text)
-    {
-	std::wstring out;
-	unsigned long code = 0;
-	int expect = 0;
-	std::string::const_iterator itr=text.begin();
-	
-	while ( itr != text.end())
-	{
-	    unsigned p = (*itr++) &amp; 0xff;
-	    if ( p &gt;= 0xc0)
-	    {
-		if ( p &lt; 0xe0)      // U+0080 - U+07ff
-		{
-		    expect = 1;
-		    code = p &amp; 0x1f;
-		}
-		else if ( p &lt; 0xf0)  // U+0800 - U+ffff
-		{
-		    expect = 2;
-		    code = p &amp; 0x0f;
-		}
-		else if ( p  &lt; 0xf8) // U+1000 - U+10ffff
-		{
-		    expect = 3;
-		    code = p &amp; 0x07;
-		}
-		continue;
-	    }
-	    else if (p &gt;= 0x80)
-	    {
-		--expect;
-		if (expect &gt;= 0)
-		{
-		    code &lt;&lt;= 6;
-		    code += p &amp; 0x3f;
-		}
-		if (expect &gt; 0)
-		    continue;
-		expect = 0;
-	    }
-	    else 
-	    {
-		code = p;            // U+0000 - U+007f (ascii)
-	    }
-	    out.push_back(wchar_t(code));
-	}
-	return out;
-    }
-    
-    template &lt;typename T&gt;
-    struct text_renderer : private boost::noncopyable
-    {
-
-	struct glyph_t : boost::noncopyable
-	{
-	    FT_Glyph image;
-	    glyph_t(FT_Glyph image_) : image(image_) {}
-	    ~glyph_t ()	{ FT_Done_Glyph(image);}
-	};
-	
-	typedef boost::ptr_vector&lt;glyph_t&gt; glyphs_t;
-	typedef std::pair&lt;unsigned,unsigned&gt; dimension_t;
-	typedef T pixmap_type;
-	
-	text_renderer (pixmap_type &amp; pixmap, face_ptr face)
-	    : pixmap_(pixmap),
-	      face_(face),
-	      fill_(0,0,0), 
-	      halo_fill_(255,255,255),
-	      halo_radius_(0),
-	      angle_(0.0) {}
-    
-	void set_pixel_size(unsigned size)
-	{
-	    face_-&gt;set_pixel_sizes(size);
-	}
-    
-	void set_angle(float angle)
-	{
-	    angle_=angle;
-	}
-
-	void set_fill(mapnik::Color const&amp; fill)
-	{
-	    fill_=fill;
-	}
-    
-	void set_halo_fill(mapnik::Color const&amp; halo)
-	{
-	    halo_fill_=halo;
-	}
-    
-	void set_halo_radius( int radius=1)
-	{
-	    halo_radius_=radius;
-	}
-
-	dimension_t prepare_glyphs(std::string const&amp; text)
-	{
-	    //clear glyphs
-	    glyphs_.clear();
-	    
-	    FT_Matrix matrix;
-	    FT_Vector pen;
-	    FT_Error  error;
-	    
-	    FT_Face face = face_-&gt;get_face();
-	    FT_GlyphSlot slot = face-&gt;glyph;
-	    FT_Bool use_kerning;
-	    FT_UInt previous = 0;
-	    
-	    pen.x = 0;
-	    pen.y = 0;
-	    
-	    use_kerning = FT_HAS_KERNING(face)&gt;0?true:false;
-	    
-	    FT_BBox bbox;   
-	    bbox.xMin = bbox.yMin = 32000; 
-	    bbox.xMax = bbox.yMax = -32000; //hmm?? 
-	    
-	    for (std::string::const_iterator i=text.begin();i!=text.end();++i)
-	    {
-		FT_BBox glyph_bbox; 
-		FT_Glyph image;
-		
-		matrix.xx = (FT_Fixed)( cos( angle_ ) * 0x10000L ); 
-		matrix.xy = (FT_Fixed)(-sin( angle_ ) * 0x10000L ); 
-		matrix.yx = (FT_Fixed)( sin( angle_ ) * 0x10000L ); 
-		matrix.yy = (FT_Fixed)( cos( angle_ ) * 0x10000L );
-	        	
-		FT_Set_Transform (face,&amp;matrix,&amp;pen);
-		
-		FT_UInt glyph_index = FT_Get_Char_Index( face, unsigned(*i) &amp; 0xff );
-		
-		if ( use_kerning &amp;&amp; previous &amp;&amp; glyph_index)
-		{
-		    FT_Vector delta;
-		    FT_Get_Kerning(face,previous,glyph_index,
-				   FT_KERNING_DEFAULT,&amp;delta);
-		    pen.x += delta.x;
-		    pen.y += delta.y;
-		}
-		
-		error = FT_Load_Glyph (face,glyph_index,FT_LOAD_DEFAULT); 
-		if ( error )
-		    continue;
-		
-		error = FT_Get_Glyph( face-&gt;glyph, &amp;image);
-		if ( error )
-		    continue;
-		
-		FT_Glyph_Get_CBox(image,ft_glyph_bbox_pixels, &amp;glyph_bbox); 
-		if (glyph_bbox.xMin &lt; bbox.xMin) 
-		    bbox.xMin = glyph_bbox.xMin; 
-		if (glyph_bbox.yMin &lt; bbox.yMin) 
-		    bbox.yMin = glyph_bbox.yMin; 
-		if (glyph_bbox.xMax &gt; bbox.xMax) 
-		    bbox.xMax = glyph_bbox.xMax; 
-		if (glyph_bbox.yMax &gt; bbox.yMax) 
-		    bbox.yMax = glyph_bbox.yMax;
-		
-		if ( bbox.xMin &gt; bbox.xMax )
-		{
-		    bbox.xMin = 0; 
-		    bbox.yMin = 0; 
-		    bbox.xMax = 0; 
-		    bbox.yMax = 0; 
-		}
-		
-		pen.x += slot-&gt;advance.x;
-		pen.y += slot-&gt;advance.y;
-		
-		previous = glyph_index;
-		// take ownership of the glyph
-		glyphs_.push_back(new glyph_t(image));
-	    }
-	    
-	    unsigned string_width = (bbox.xMax - bbox.xMin); 
-	    unsigned string_height = (bbox.yMax - bbox.yMin);
-	    return dimension_t(string_width,string_height);
-	}
-	
-	void render(double x0, double y0)
-	{
-	    FT_Error  error;
-	    FT_Vector start;
-	    unsigned height = pixmap_.height();
-	    
-	    start.x = unsigned(x0 * (1 &lt;&lt; 6)); 
-	    start.y = unsigned((height - y0) * (1 &lt;&lt; 6));
-	    // now render transformed glyphs
-	    typename glyphs_t::iterator pos;
-
-	    if (halo_radius_ &gt; 0)
-	    {
-		//render halo 
-		for ( pos = glyphs_.begin(); pos != glyphs_.end();++pos)
-		{
-	    
-		    FT_Glyph_Transform(pos-&gt;image,0,&amp;start);
-	    
-		    error = FT_Glyph_To_Bitmap( &amp;(pos-&gt;image),FT_RENDER_MODE_NORMAL,0,1);
-		    if ( ! error )
-		    {
-			
-			FT_BitmapGlyph bit = (FT_BitmapGlyph)pos-&gt;image;
-			render_halo(&amp;bit-&gt;bitmap, halo_fill_.rgba(), 
-				    bit-&gt;left,
-				    height - bit-&gt;top,halo_radius_);
-		    }
-		}  
-	    }
-	    //render actual text
-	    for ( pos = glyphs_.begin(); pos != glyphs_.end();++pos)
-	    {
-	    
-		FT_Glyph_Transform(pos-&gt;image,0,&amp;start);
-	    
-		error = FT_Glyph_To_Bitmap( &amp;(pos-&gt;image),FT_RENDER_MODE_NORMAL,0,1);
-		if ( ! error )
-		{
-		   
-		    FT_BitmapGlyph bit = (FT_BitmapGlyph)pos-&gt;image;
-		    render_bitmap(&amp;bit-&gt;bitmap, fill_.rgba(), 
-				  bit-&gt;left,
-				  height - bit-&gt;top);
-		}
-	    }  
-	}
-   	
-    private:
-    
-	void render_halo(FT_Bitmap *bitmap,unsigned rgba,int x,int y,int radius)
-	{
-	    int x_max=x+bitmap-&gt;width;
-	    int y_max=y+bitmap-&gt;rows;
-	    int i,p,j,q;
-	
-	    for (i=x,p=0;i&lt;x_max;++i,++p)
-	    {
-		for (j=y,q=0;j&lt;y_max;++j,++q)
-		{
-		    int gray = bitmap-&gt;buffer[q*bitmap-&gt;width+p];
-		    if (gray)
-		    {
-			for (int n=-halo_radius_; n &lt;=halo_radius_; ++n)
-			    for (int m=-halo_radius_;m &lt;= halo_radius_; ++m)
-				pixmap_.blendPixel(i+m,j+n,rgba,gray);		        
-		    }
-		}
-	    }
-	}
-    
-	void render_bitmap(FT_Bitmap *bitmap,unsigned rgba,int x,int y)
-	{
-	    int x_max=x+bitmap-&gt;width;
-	    int y_max=y+bitmap-&gt;rows;
-	    int i,p,j,q;
-	
-	    for (i=x,p=0;i&lt;x_max;++i,++p)
-	    {
-		for (j=y,q=0;j&lt;y_max;++j,++q)
-		{
-		    int gray=bitmap-&gt;buffer[q*bitmap-&gt;width+p];
-		    if (gray)
-		    {
-			pixmap_.blendPixel(i,j,rgba,gray);
-		    }
-		}
-	    }
-	}
-    
-	pixmap_type &amp; pixmap_;
-	face_ptr face_;
-	mapnik::Color fill_;
-	mapnik::Color halo_fill_;
-	int halo_radius_;
-	float angle_;
-	glyphs_t glyphs_;
-    }; 
-}
-
-
-#endif // FONT_ENGINE_FREETYPE_HPP

Deleted: trunk/include/gamma.hpp
===================================================================
--- trunk/include/gamma.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/gamma.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,51 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: gamma.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef GAMMA_HPP
-#define GAMMA_HPP
-
-namespace mapnik 
-{
-    struct MAPNIK_DECL gamma
-    {
-	unsigned char g2l[256];
-	unsigned char l2g[256];
-	gamma(double gamma=2.0)
-	{
-	    int result;
-	    for (int i=0;i&lt; 256;i++)
-	    {
-		result=(int)(pow(i/255.0,gamma) * 255.0 + 0.5);
-		g2l[i]=(unsigned char)result;
-	    }
-	    for (int i = 0; i &lt; 256; i++)
-	    {
-		result = (int)(pow(i/255.0, 1/gamma) * 255.0 + 0.5);
-		l2g[i] = (unsigned char)result;
-	    }
-	}
-    };
-}
-
-#endif  //GAMMA_HPP

Deleted: trunk/include/geom_util.hpp
===================================================================
--- trunk/include/geom_util.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/geom_util.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,189 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: geom_util.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef GEOM_UTIL_HPP
-#define GEOM_UTIL_HPP
-
-#include &lt;cmath&gt;
-
-namespace mapnik
-{
-
-    template &lt;typename T&gt;
-    bool clip_test(T p,T q,double&amp; tmin,double&amp; tmax)
-    {
-        double r;
-        bool result=true;
-        if (p&lt;0.0)
-        {
-            r=q/p;
-            if (r&gt;tmax) result=false;
-            else if (r&gt;tmin) tmin=r;
-        }
-        else if (p&gt;0.0)
-        {
-            r=q/p;
-            if (r&lt;tmin) result=false;
-            else if (r&lt;tmax) tmax=r;
-        } else if (q&lt;0.0) result=false;
-        return result;
-    }
-
-    template &lt;typename T,typename Image&gt;
-    bool clip_line(T&amp; x0,T&amp; y0,T&amp; x1,T&amp; y1,Envelope&lt;T&gt; const&amp; box)
-    {
-        double tmin=0.0;
-        double tmax=1.0;
-        double dx=x1-x0;
-        if (clip_test&lt;double&gt;(-dx,x0,tmin,tmax))
-        {
-            if (clip_test&lt;double&gt;(dx,box.width()-x0,tmin,tmax))
-            {
-                double dy=y1-y0;
-                if (clip_test&lt;double&gt;(-dy,y0,tmin,tmax))
-                {
-                    if (clip_test&lt;double&gt;(dy,box.height()-y0,tmin,tmax))
-                    {
-                        if (tmax&lt;1.0)
-                        {
-                            x1=static_cast&lt;T&gt;(x0+tmax*dx);
-                            y1=static_cast&lt;T&gt;(y0+tmax*dy);
-                        }
-                        if (tmin&gt;0.0)
-                        {
-                            x0+=static_cast&lt;T&gt;(tmin*dx);
-                            y0+=static_cast&lt;T&gt;(tmin*dy);
-                        }
-                        return true;
-                    }
-                }
-            }
-        }
-        return false;
-    }
-    
-    template &lt;typename Iter&gt; 
-    inline bool point_inside_path(double x,double y,Iter start,Iter end)
-    {
-        bool inside=false;
-        double x0=boost::get&lt;0&gt;(*start);
-        double y0=boost::get&lt;1&gt;(*start);
-        
-        double x1,y1;
-        while (++start!=end) 
-        {
-            if ( boost::get&lt;2&gt;(*start) == SEG_MOVETO)
-            {
-                x0 = boost::get&lt;0&gt;(*start);
-                y0 = boost::get&lt;1&gt;(*start);
-                continue;
-            }		
-            x1=boost::get&lt;0&gt;(*start);
-            y1=boost::get&lt;1&gt;(*start);
-            
-            if ((((y1 &lt;= y) &amp;&amp; (y &lt; y0)) ||
-                 ((y0 &lt;= y) &amp;&amp; (y &lt; y1))) &amp;&amp;
-                ( x &lt; (x0 - x1) * (y - y1)/ (y0 - y1) + x1))
-                inside=!inside;
-            x0=x1;
-            y0=y1;
-        }
-    	return inside;
-    }
-
-#define TOL 0.00001
-
-    /*
-      (Ay-Cy)(Bx-Ax)-(Ax-Cx)(By-Ay)
-      s = -----------------------------
-      L^2
-    */
-
-    inline bool point_in_circle(double x,double y,double cx,double cy,double r)
-    {
-        double dx = x - cx;
-        double dy = y - cy;
-        double d2 = dx * dx + dy * dy;
-        return (d2 &lt;= r * r);
-    }
-    
-    inline bool point_on_segment(double x,double y,double x0,double y0,double x1,double y1)
-    {	
-        double dx = x1 - x0;
-        double dy = y1 - y0;
-        if ( fabs(dx) &gt; TOL  ||  fabs(dy) &gt; TOL )
-        {
-            double s = (y0 - y) * dx - (x0 - x) * dy;
-            return ( fabs (s) &lt; TOL ) ;
-        } 
-        return false;
-    }
-
-    inline bool point_on_segment2(double x,double y,double x0,double y0,double x1,double y1)
-    {	 
-        double d  = sqrt ((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0));
-        double d0 = sqrt ((x0 - x) * (x0 - x) + (y0 - y) * (y0 - y));
-        double d1 = sqrt ((x1 - x) * (x1 - x) + (y1 - y) * (y1 - y));
-        double d2 = d0 + d1;
-        return ( d2 - d &lt; 0.01);
-    }
-    
-#undef TOL
-    template &lt;typename Iter&gt; 
-    inline bool point_on_path(double x,double y,Iter start,Iter end)
-    {
-        return false;
-    }
-    
-    template &lt;typename Iter&gt; 
-    inline bool point_on_points (double x,double y,Iter start,Iter end) 
-    {
-        return false; 
-    }
-
-    struct filter_in_box
-    {
-        Envelope&lt;double&gt; box_;
-        explicit filter_in_box(const Envelope&lt;double&gt;&amp; box)
-            : box_(box) {}
-
-        bool pass(const Envelope&lt;double&gt;&amp; extent) const
-        {
-            return extent.intersects(box_);
-        }
-    };
-
-    struct filter_at_point
-    {
-        coord2d pt_;
-        explicit filter_at_point(const coord2d&amp; pt)
-            : pt_(pt) {}
-        bool pass(const Envelope&lt;double&gt;&amp; extent) const
-        {
-            return extent.contains(pt_);
-        }
-    };
-}
-
-#endif                                            //GEOM_UTIL_HPP

Deleted: trunk/include/geometry.hpp
===================================================================
--- trunk/include/geometry.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/geometry.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,386 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-
-//$Id: geometry.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef GEOMETRY_HPP
-#define GEOMETRY_HPP
-
-#include &quot;vertex_vector.hpp&quot;
-#include &quot;vertex_transform.hpp&quot;
-#include &quot;ctrans.hpp&quot;
-#include &quot;geom_util.hpp&quot;
-#include &lt;boost/shared_ptr.hpp&gt;
-#include &lt;boost/utility.hpp&gt;
-
-namespace mapnik
-{
-    enum {
-    	Point = 1,
-    	LineString = 2,
-    	Polygon = 3
-    };
-             
-    template &lt;typename T&gt;
-    class geometry : private boost::noncopyable
-    {   
-    public:
-        typedef T vertex_type;
-        typedef typename vertex_type::type value_type;
-    private:
-        int srid_;
-    public:
-        geometry (int srid=-1)
-            : srid_(srid) {}	
-
-        int srid() const
-        {
-            return srid_;
-        }
-	
-        Envelope&lt;double&gt; envelope()
-        {
-            Envelope&lt;double&gt; result;		
-            double x,y;
-            for (unsigned i=0;i&lt;num_points();++i)
-            {
-                vertex(&amp;x,&amp;y);
-                if (i==0)
-                {
-                    result.init(x,y,x,y);
-                }
-                else
-                {
-                    result.expand_to_include(x,y);
-                }
-            }
-            return result;
-        }
-
-        virtual int type() const=0;
-        virtual bool hit_test(value_type x,value_type y) const=0;	
-        virtual void label_position(double *x, double *y) const=0;
-        virtual void move_to(value_type x,value_type y)=0;
-        virtual void line_to(value_type x,value_type y)=0;
-        virtual void transform(const mapnik::CoordTransform&amp; t)=0;
-        virtual unsigned num_points() const = 0;
-        virtual unsigned vertex(double* x, double* y)=0;
-        virtual void rewind(unsigned )=0;
-        virtual void set_capacity(size_t size)=0;
-        virtual ~geometry() {}
-    };
-    
-    template &lt;typename T&gt;
-    class point : public geometry&lt;T&gt;
-    {
-        typedef geometry&lt;T&gt; geometry_base;
-        typedef typename geometry&lt;T&gt;::vertex_type vertex_type;
-        typedef typename geometry&lt;T&gt;::value_type value_type;
-    private:
-        vertex_type pt_;
-    public:
-        point(int srid)
-            : geometry&lt;T&gt;(srid)
-        {}
-	 
-        int type() const 
-        {
-            return Point;
-        }
-        void label_position(double *x, double *y) const
-        {
-            *x = pt_.x;
-            *y = pt_.y;
-        }
-	
-        void move_to(value_type x,value_type y)
-        {
-            pt_.x = x;
-            pt_.y = y;
-        }
-	
-        void line_to(value_type ,value_type ) {}
-	
-        void transform(const mapnik::CoordTransform&amp; t)
-        {
-            t.forward_x(&amp;pt_.x);
-            t.forward_y(&amp;pt_.y);
-        }
-	
-        unsigned num_points() const
-        {
-            return 1;
-        }
-	
-        unsigned vertex(double* x, double* y)
-        {
-            *x = pt_.x;
-            *y = pt_.y;
-            return SEG_LINETO;
-        }
-	
-        void rewind(unsigned ) {}
-	
-        bool hit_test(value_type x,value_type y) const
-        {
-            return false;
-        }
-        void set_capacity(size_t) {}
-        virtual ~point() {}
-    };
-
-    template &lt;typename T, template &lt;typename&gt; class Container=vertex_vector2&gt;
-    class polygon : public geometry&lt;T&gt;
-    {
-        typedef geometry&lt;T&gt; geometry_base;
-        typedef typename geometry&lt;T&gt;::vertex_type vertex_type;
-        typedef typename geometry_base::value_type value_type;
-        typedef Container&lt;vertex_type&gt; container_type;
-    private:
-        container_type cont_;
-        mutable unsigned itr_;
-    public:
-        polygon(int srid)
-            : geometry_base(srid),
-              itr_(0)
-        {}
-        
-        int type() const 
-        {
-            return Polygon;
-        }
-	
-        void label_position(double *x, double *y) const
-        {
-	    
-            unsigned size = cont_.size();
-            if (size &lt; 3) 
-            {
-                cont_.get_vertex(0,x,y);
-                return;
-            }
-	      
-            double ai;
-            double atmp = 0;
-            double xtmp = 0;
-            double ytmp = 0;
-            double x0 =0;
-            double y0 =0;
-            double x1 =0;
-            double y1 =0;
-	    
-            unsigned i,j;
-            for (i = size-1,j = 0; j &lt; size; i = j, ++j)
-            {
-		
-                cont_.get_vertex(i,&amp;x0,&amp;y0);
-                cont_.get_vertex(j,&amp;x1,&amp;y1);
-                ai = x0 * y1 - x1 * y0;
-                atmp += ai;
-                xtmp += (x1 + x0) * ai;
-                ytmp += (y1 + y0) * ai;
-            }	  
-            if (atmp != 0)
-            {
-                *x = xtmp/(3*atmp);
-                *y = ytmp /(3*atmp);
-                return;
-            }
-            *x=x0;
-            *y=y0;	    	    
-        }
-
-        void line_to(value_type x,value_type y)
-        {
-            cont_.push_back(x,y,SEG_LINETO);
-        }
-
-        void move_to(value_type x,value_type y)
-        {
-            cont_.push_back(x,y,SEG_MOVETO);
-        }
-	
-        void transform(mapnik::CoordTransform const&amp; t)
-        {
-            unsigned size = cont_.size();
-            for (unsigned pos=0; pos &lt; size; ++pos)
-            {	
-                cont_.transform_at(pos,t);
-            }
-        }
-	
-        unsigned num_points() const
-        {
-            return cont_.size();
-        }
-	
-        unsigned vertex(double* x, double* y)
-        {
-            return cont_.get_vertex(itr_++,x,y);
-        }
-	
-        void rewind(unsigned )
-        {
-            itr_=0;
-        }
-	
-        bool hit_test(value_type x,value_type y) const
-        {	    
-            return point_inside_path(x,y,cont_.begin(),cont_.end());
-        } 
-        
-        void set_capacity(size_t size) 
-        {
-            cont_.set_capacity(size);
-        }
-        virtual ~polygon() {}
-    };
-    
-    template &lt;typename T, template &lt;typename&gt; class Container=vertex_vector&gt;
-    class line_string : public geometry&lt;T&gt;
-    {
-        typedef geometry&lt;T&gt; geometry_base;
-        typedef typename geometry_base::value_type value_type;
-        typedef typename geometry&lt;T&gt;::vertex_type vertex_type;
-        typedef Container&lt;vertex_type&gt; container_type;
-    private:
-        container_type cont_;
-        mutable unsigned itr_;
-    public:
-        line_string(int srid)
-            : geometry_base(srid),
-              itr_(0)
-        {}
-        
-        int type() const 
-        {
-            return LineString;
-        }
-        void label_position(double *x, double *y) const
-        {
-            // calculate mid point on line string
-            double x0=0;
-            double y0=0;
-            double x1=0;
-            double y1=0;
-	    
-            unsigned size = cont_.size();
-            if (size == 1)
-            {
-                cont_.get_vertex(0,x,y); 
-            }
-            else if (size == 2)
-            {
-
-                cont_.get_vertex(0,&amp;x0,&amp;y0);
-                cont_.get_vertex(1,&amp;x1,&amp;y1);
-                *x = 0.5 * (x1 + x0);
-                *y = 0.5 * (y1 + y0);		
-            }
-            else
-            {
-                double len=0.0;
-                for (unsigned pos = 1; pos &lt; size; ++pos)
-                {
-                    cont_.get_vertex(pos-1,&amp;x0,&amp;y0);
-                    cont_.get_vertex(pos,&amp;x1,&amp;y1);
-                    double dx = x1 - x0;
-                    double dy = y1 - y0;
-                    len += sqrt(dx * dx + dy * dy);
-                }
-                double midlen = 0.5 * len;
-                double dist = 0.0;
-                for (unsigned pos = 1; pos &lt; size;++pos)
-                {
-                    cont_.get_vertex(pos-1,&amp;x0,&amp;y0);
-                    cont_.get_vertex(pos,&amp;x1,&amp;y1);
-                    double dx = x1 - x0;
-                    double dy = y1 - y0; 
-                    double seg_len = sqrt(dx * dx + dy * dy);
-                    if (( dist + seg_len) &gt;= midlen)
-                    {
-                        double r = (midlen - dist)/seg_len;
-                        *x = x0 + (x1 - x0) * r;
-                        *y = y0 + (y1 - y0) * r;
-                        break;
-                    }
-                    dist += seg_len;
-                }
-            }
-	    
-        }
-        void line_to(value_type x,value_type y)
-        {
-            cont_.push_back(x,y,SEG_LINETO);
-        }
-
-        void move_to(value_type x,value_type y)
-        {
-            cont_.push_back(x,y,SEG_MOVETO);
-        }
-	
-        void transform(mapnik::CoordTransform const&amp; t)
-        {
-            unsigned size = cont_.size();
-            for (unsigned pos=0; pos &lt; size; ++pos)
-            {	
-                cont_.transform_at(pos,t);
-            }
-        }
-	
-        unsigned num_points() const
-        {
-            return cont_.size();
-        }
-	
-        unsigned vertex(double* x, double* y)
-        {
-            return cont_.get_vertex(itr_++,x,y);
-        }
-	
-        void rewind(unsigned )
-        {
-            itr_=0;
-        }
-	
-        bool hit_test(value_type x,value_type y) const
-        {	    
-            return false;
-        } 
-	
-        void set_capacity(size_t size) 
-        {
-            cont_.set_capacity(size);
-        }
-        virtual ~line_string() {}
-    };
-
-    typedef point&lt;vertex2d&gt; point_impl;
-    typedef line_string&lt;vertex2d,vertex_vector2&gt; line_string_impl;
-    typedef polygon&lt;vertex2d,vertex_vector2&gt; polygon_impl;
-    
-    typedef geometry&lt;vertex2d&gt; geometry_type;
-    typedef boost::shared_ptr&lt;geometry_type&gt; geometry_ptr;
-}
-
-#endif //GEOMETRY_HPP

Deleted: trunk/include/global.hpp
===================================================================
--- trunk/include/global.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/global.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,61 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef GLOBAL_HPP
-#define GLOBAL_HPP
-
-#include &lt;boost/cstdint.hpp&gt;
-
-namespace mapnik
-{
-    using namespace boost;
-#define int2net(A)  (int32_t) (((uint32_t) ((uint8_t) (A)[1]))      |\
-			      (((uint32_t) ((uint8_t) (A)[0])) &lt;&lt; 8))
-
-#define int4net(A)  (int32_t) (((uint32_t) ((uint8_t) (A)[3]))      |\
-			    (((uint32_t) ((uint8_t) (A)[2])) &lt;&lt; 8)  |\
-			    (((uint32_t) ((uint8_t) (A)[1])) &lt;&lt; 16) |\
-			    (((uint32_t) ((uint8_t) (A)[0])) &lt;&lt; 24))
-
-
-    typedef char byte;
-#define float8net(V,M)   do { double def_temp;\
-                              ((byte*) &amp;def_temp)[0]=(M)[7];\
-                              ((byte*) &amp;def_temp)[1]=(M)[6];\
-                              ((byte*) &amp;def_temp)[2]=(M)[5];\
-                              ((byte*) &amp;def_temp)[3]=(M)[4];\
-                              ((byte*) &amp;def_temp)[4]=(M)[3];\
-                              ((byte*) &amp;def_temp)[5]=(M)[2];\
-                              ((byte*) &amp;def_temp)[6]=(M)[1];\
-                              ((byte*) &amp;def_temp)[7]=(M)[0];\
-                              (V) = def_temp; } while(0)
-#define float4net(V,M)   do { float def_temp;\
-                              ((byte*) &amp;def_temp)[0]=(M)[3];\
-                              ((byte*) &amp;def_temp)[1]=(M)[2];\
-                              ((byte*) &amp;def_temp)[2]=(M)[1];\
-                              ((byte*) &amp;def_temp)[3]=(M)[0];\
-                              (V)=def_temp; } while(0)
-}
-
-#endif //GLOBAL_HPP

Deleted: trunk/include/graphics.hpp
===================================================================
--- trunk/include/graphics.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/graphics.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,182 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: graphics.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef GRAPHICS_HPP
-#define GRAPHICS_HPP
-
-#include &lt;cmath&gt;
-#include &lt;string&gt;
-#include &lt;cassert&gt;
-#include &quot;color.hpp&quot;
-#include &quot;gamma.hpp&quot;
-#include &quot;image_data.hpp&quot;
-#include &quot;envelope.hpp&quot;
-
-namespace mapnik
-{
-    class MAPNIK_DECL Image32
-    {
-    private:
-        unsigned width_;
-        unsigned height_;
-        Color background_;
-        ImageData32 data_;
-    public:
-        Image32(int width,int height);
-        Image32(const Image32&amp; rhs);
-        ~Image32();
-        void setBackground(const Color&amp; background);
-        const Color&amp; getBackground() const;     
-        const ImageData32&amp; data() const;
-        
-        inline ImageData32&amp; data() 
-        {
-            return data_;
-        }
-        
-        inline const unsigned char* raw_data() const
-        {
-            return data_.getBytes();
-        }
-	
-        inline unsigned char* raw_data()
-        {
-            return data_.getBytes();
-        }
-	
-        void saveToFile(const std::string&amp; file,const std::string&amp; format=&quot;auto&quot;); 
-    private:
-
-        inline bool checkBounds(unsigned x, unsigned y) const
-        {
-            return (x &lt; width_ &amp;&amp; y &lt; height_);
-        }
-
-    public:
-        inline void setPixel(int x,int y,unsigned int rgba)
-        {
-            if (checkBounds(x,y))
-            {
-                data_(x,y)=rgba;
-            }
-        }
-        inline void blendPixel(int x,int y,unsigned int rgba1,int t)
-        {
-            if (checkBounds(x,y))
-            {
-                unsigned rgba0 = data_(x,y);	
-                unsigned a1 = t;//(rgba1 &gt;&gt; 24) &amp; 0xff;
-                if (a1 == 0) return;
-                unsigned r1 = rgba1 &amp; 0xff;
-                unsigned g1 = (rgba1 &gt;&gt; 8 ) &amp; 0xff;
-                unsigned b1 = (rgba1 &gt;&gt; 16) &amp; 0xff;
-		
-                unsigned a0 = (rgba0 &gt;&gt; 24) &amp; 0xff;
-                unsigned r0 = (rgba0 &amp; 0xff) * a0;
-                unsigned g0 = ((rgba0 &gt;&gt; 8 ) &amp; 0xff) * a0;
-                unsigned b0 = ((rgba0 &gt;&gt; 16) &amp; 0xff) * a0;
-		
-		
-                a0 = ((a1 + a0) &lt;&lt; 8) - a0*a1;
-		
-                r0 = ((((r1 &lt;&lt; 8) - r0) * a1 + (r0 &lt;&lt; 8)) / a0);
-                g0 = ((((g1 &lt;&lt; 8) - g0) * a1 + (g0 &lt;&lt; 8)) / a0);
-                b0 = ((((b1 &lt;&lt; 8) - b0) * a1 + (b0 &lt;&lt; 8)) / a0);
-                a0 = a0 &gt;&gt; 8;
-                data_(x,y)= (a0 &lt;&lt; 24)| (b0 &lt;&lt; 16) |  (g0 &lt;&lt; 8) | (r0) ;
-            }
-        }
-
-        inline unsigned width() const
-        {
-            return width_;
-        }
-	
-        inline unsigned height() const
-        {
-            return height_;
-        }
-
-        inline void set_rectangle(int x0,int y0,ImageData32 const&amp; data)
-        {
-            Envelope&lt;int&gt; ext0(0,0,width_,height_);   
-            Envelope&lt;int&gt; ext1(x0,y0,x0+data.width(),y0+data.height());
-	    
-            if (ext0.intersects(ext1))
-            {	
-                Envelope&lt;int&gt; box = ext0.intersect(ext1);
-                for (int y = box.miny(); y &lt; box.maxy(); ++y)
-                {
-                    for (int x = box.minx(); x &lt; box.maxx(); ++x)
-                    {
-                        if ((data(x-x0,y-y0) &amp; 0xff000000)) 
-                        {
-                            data_(x,y)=data(x-x0,y-y0);
-                        }
-                    }
-                }   
-            }
-        }
-	
-        inline void set_rectangle_alpha(int x0,int y0,const ImageData32&amp; data)
-        {
-            Envelope&lt;int&gt; ext0(0,0,width_,height_);   
-            Envelope&lt;int&gt; ext1(x0,y0,x0 + data.width(),y0 + data.height());
-	    
-            if (ext0.intersects(ext1))
-            {	                		
-                Envelope&lt;int&gt; box = ext0.intersect(ext1);		
-                for (int y = box.miny(); y &lt; box.maxy(); ++y)
-                {
-                    for (int x = box.minx(); x &lt; box.maxx(); ++x)
-                    {
-                        unsigned rgba0 = data_(x,y);
-                        unsigned rgba1 = data(x-x0,y-y0);
-		    
-                        unsigned a1 = (rgba1 &gt;&gt; 24) &amp; 0xff;
-                        if (a1 == 0) continue;
-                        unsigned r1 = rgba1 &amp; 0xff;
-                        unsigned g1 = (rgba1 &gt;&gt; 8 ) &amp; 0xff;
-                        unsigned b1 = (rgba1 &gt;&gt; 16) &amp; 0xff;
-		    
-                        unsigned a0 = (rgba0 &gt;&gt; 24) &amp; 0xff;
-                        unsigned r0 = (rgba0 &amp; 0xff) * a0;
-                        unsigned g0 = ((rgba0 &gt;&gt; 8 ) &amp; 0xff) * a0;
-                        unsigned b0 = ((rgba0 &gt;&gt; 16) &amp; 0xff) * a0;
-		    
-		    
-                        a0 = ((a1 + a0) &lt;&lt; 8) - a0*a1;
-		    
-                        r0 = ((((r1 &lt;&lt; 8) - r0) * a1 + (r0 &lt;&lt; 8)) / a0);
-                        g0 = ((((g1 &lt;&lt; 8) - g0) * a1 + (g0 &lt;&lt; 8)) / a0);
-                        b0 = ((((b1 &lt;&lt; 8) - b0) * a1 + (b0 &lt;&lt; 8)) / a0);
-                        a0 = a0 &gt;&gt; 8;
-                        data_(x,y)= (a0 &lt;&lt; 24)| (b0 &lt;&lt; 16) |  (g0 &lt;&lt; 8) | (r0) ;
-                    }
-                }
-            }
-        }
-    };
-}
-#endif //GRAPHICS_HPP

Deleted: trunk/include/image_data.hpp
===================================================================
--- trunk/include/image_data.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/image_data.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,128 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: image_data.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef IMAGE_DATA_HPP
-#define IMAGE_DATA_HPP
-
-#include &lt;cassert&gt;
-
-namespace mapnik 
-{
-    template &lt;class T&gt; class ImageData
-    {
-    private:
-        const unsigned width_;
-        const unsigned height_;
-        T *pData_;
-        ImageData&amp; operator=(const ImageData&amp;);
-    public:
-        ImageData(unsigned width,unsigned height)
-            : width_(width),
-              height_(height),
-              pData_((width!=0 &amp;&amp; height!=0)? static_cast&lt;T*&gt;(::operator new(sizeof(T)*width*height)):0)
-        {
-            if (pData_) memset(pData_,0,sizeof(T)*width_*height_);
-        }
-
-        ImageData(const ImageData&lt;T&gt;&amp; rhs)
-            :width_(rhs.width_),
-             height_(rhs.height_),
-             pData_((rhs.width_!=0 &amp;&amp; rhs.height_!=0)? new T[rhs.width_*rhs.height_]:0)
-        {
-            if (pData_) memcpy(pData_,rhs.pData_,sizeof(T)*rhs.width_* rhs.height_);
-        }
-        inline T&amp; operator() (unsigned i,unsigned j)
-        {
-            assert(i&lt;width_ &amp;&amp; j&lt;height_);
-            return pData_[j*width_+i];
-        }
-        inline const T&amp; operator() (unsigned i,unsigned j) const
-        {
-            assert(i&lt;width_ &amp;&amp; j&lt;height_);
-            return pData_[j*width_+i];
-        }
-        inline unsigned width() const
-        {
-            return width_;
-        }
-        inline unsigned height() const
-        {
-            return height_;
-        }
-        inline void set(const T&amp; t)
-        {
-            for (unsigned i=0;i&lt;width_;++i)
-            {
-                for (unsigned j=0;j&lt;height_;++j)
-                {
-                    (*this)(i,j)=t;
-                }
-            }
-        }
-        inline const T* getData() const
-        {
-            return pData_;
-        }
-
-        inline T* getData()
-        {
-            return pData_;
-        }
-
-        inline const unsigned char* getBytes() const
-        {
-            return (unsigned char*)pData_;
-        }
-	
-        inline unsigned char* getBytes()
-        {
-            return (unsigned char*)pData_;
-        }
-	
-        inline const T* getRow(unsigned row) const
-        {
-            return pData_+row*width_;
-        }
-        inline void setRow(unsigned row,const T* buf,unsigned size)
-        {
-            assert(row&lt;height_);
-            assert(size&lt;=(width_*sizeof(T)));
-            memcpy(pData_+row*width_,buf,size*sizeof(T));
-        }
-        inline void setRow(unsigned row,unsigned x0,unsigned x1,const T* buf)
-        {
-            memcpy(pData_+row*width_+x0,buf,(x1-x0)*sizeof(T));
-        }
-
-        inline ~ImageData()
-        {
-            ::operator delete(pData_),pData_=0;
-        }
-	
-    };
-
-    typedef ImageData&lt;unsigned&gt; ImageData32;
-}
-
-#endif //IMAGE_DATA_HPP

Deleted: trunk/include/image_reader.hpp
===================================================================
--- trunk/include/image_reader.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/image_reader.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,66 +0,0 @@
-/*****************************************************************************
-* 
-* This file is part of Mapnik (c++ mapping toolkit)
-*
-* Copyright (C) 2006 Artem Pavlenko
-*
-* This library is free software; you can redistribute it and/or
-* modify it under the terms of the GNU Lesser General Public
-* License as published by the Free Software Foundation; either
-* version 2.1 of the License, or (at your option) any later version.
-*
-* This library is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-* Lesser General Public License for more details.
-*
-* You should have received a copy of the GNU Lesser General Public
-* License along with this library; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*
-*****************************************************************************/
-
-//$Id: image_reader.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef IMAGE_READER_HPP
-#define IMAGE_READER_HPP
-
-#include &lt;stdexcept&gt;
-#include &lt;string&gt;
-
-#include &quot;image_data.hpp&quot;
-#include &quot;config.hpp&quot;
-
-
-namespace mapnik 
-{
-    class ImageReaderException : public std::exception
-    {
-    private:
-        std::string message_;
-    public:
-        ImageReaderException(const std::string&amp; message) 
-            : message_(message) {}
-
-        ~ImageReaderException() throw() {}
-
-        virtual const char* what() const throw()
-        {
-            return message_.c_str();
-        }
-    };
-
-    struct MAPNIK_DECL ImageReader
-    {
-        virtual unsigned width() const=0;
-        virtual unsigned height() const=0;
-        virtual void read(unsigned x,unsigned y,ImageData32&amp; image)=0;
-        virtual ~ImageReader() {}
-    };
-
-    bool register_image_reader(const std::string&amp; type,ImageReader* (*)(const std::string&amp;));
-    MAPNIK_DECL ImageReader* get_image_reader(const std::string&amp; type,const std::string&amp; file);
-
-}
-
-#endif                                            //IMAGE_READER_HPP

Deleted: trunk/include/image_util.hpp
===================================================================
--- trunk/include/image_util.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/image_util.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,212 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: image_util.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef IMAGE_UTIL_HPP
-#define IMAGE_UTIL_HPP
-
-namespace mapnik
-{
-    class MAPNIK_DECL ImageUtils
-    {
-    public:
-        static void save_to_file(const std::string&amp; filename,const std::string&amp; type,const Image32&amp; image);
-    private:
-        static void save_as_png(const std::string&amp; filename,const Image32&amp; image);
-        static void save_as_jpeg(const std::string&amp; filename,int quality, const Image32&amp; image);
-    };
-
-    template &lt;typename T&gt;
-    double distance(T x0,T y0,T x1,T y1)
-    {
-        double dx = x1-x0;
-        double dy = y1-y0;
-        return sqrt(dx * dx + dy * dy);
-    }
-
-    template &lt;typename Image&gt;
-    inline void scale_down2(Image&amp; target,const Image&amp; source)
-    {
-        int source_width=source.width();
-        int source_height=source.height();
-
-        int target_width=target.width();
-        int target_height=target.height();
-        if (target_width&lt;source_width/2 || target_height&lt;source_height/2)
-            return;
-        int y1,x1;
-        for (int y=0;y&lt;target_height;++y)
-        {
-            y1=2*y;
-            for(int x=0;x&lt;target_width;++x)
-            {
-                x1=2*x;
-                //todo calculate average???
-                target(x,y)=source(x1,y1);
-            }
-        }
-    }
-
-    template &lt;typename Image,int scale&gt;
-    struct image_op
-    {
-        static void scale_up(Image&amp; target,const Image&amp; source)
-        {
-            if (scale&lt;3) return;
-            int source_width=source.width();
-            int source_height=source.height();
-
-            int target_width=target.width();
-            int target_height=target.height();
-            if (target_width&lt;scale*source_width || target_height&lt;scale*source_height)
-                return;
-            for (int y=0;y&lt;source_height;++y)
-            {
-                for(int x=0;x&lt;source_width;++x)
-                {
-                    unsigned p=source(x,y);
-                    for (int i=0;i&lt;scale;++i)
-                        for (int j=0;j&lt;scale;++j)
-                            target(scale*x+i,scale*y+j)=p;
-                }
-            }
-        }
-    };
-
-    template &lt;typename Image&gt;
-    struct image_op&lt;Image,2&gt;
-    {
-        static void scale_up(Image&amp; target,const Image&amp; source)
-        {
-            int source_width=source.width();
-            int source_height=source.height();
-
-            int target_width=target.width();
-            int target_height=target.height();
-            if (target_width&lt;2*source_width || target_height&lt;2*source_height)
-                return;
-            for (int y=0;y&lt;source_height;++y)
-            {
-                for(int x=0;x&lt;source_width;++x)
-                {
-                    target(2*x,2*y)=source(x,y);
-                    target(2*x+1,2*y)=source(x,y);
-                    target(2*x+1,2*y+1)=source(x,y);
-                    target(2*x,2*y+1)=source(x,y);
-                }
-            }
-        }
-    };
-
-    namespace
-    {
-        template &lt;typename Image&gt;
-        inline void scale_up(Image&amp; target,const Image&amp; source,unsigned scale)
-        {
-            int source_width=source.width();
-            int source_height=source.height();
-
-            int target_width=target.width();
-            int target_height=target.height();
-            if (target_width&lt;scale*source_width || target_height&lt;scale*source_height)
-                return;
-            for (int y=0;y&lt;source_height;++y)
-            {
-                for(int x=0;x&lt;source_width;++x)
-                {
-                    unsigned p=source(x,y);
-                    for (int i=0;i&lt;scale;++i)
-                        for (int j=0;j&lt;scale;++j)
-                            target(scale*x+i,scale*y+j)=p;
-                }
-            }
-        }
-    }
-    
-    template &lt;typename Image&gt;
-    void scale_image(Image&amp; target,const Image&amp; source,unsigned scale)
-    {
-        if (scale==2)
-        {
-            image_op&lt;Image,2&gt;::scale_up(target,source);
-        }
-        else
-        {
-            scale_up&lt;Image&gt;(target,source,scale);
-        }
-    }
-
-    template &lt;typename Image&gt;
-    inline void scale_image (Image&amp; target,const Image&amp; source)
-    {
-
-        int source_width=source.width();
-        int source_height=source.height();
-
-        int target_width=target.width();
-        int target_height=target.height();
-
-        if (source_width&lt;1 || source_height&lt;1 ||
-            target_width&lt;1 || target_height&lt;1) return;
-        int int_part_y=source_height/target_height;
-        int fract_part_y=source_height%target_height;
-        int err_y=0;
-        int int_part_x=source_width/target_width;
-        int fract_part_x=source_width%target_width;
-        int err_x=0;
-        int x=0,y=0,xs=0,ys=0;
-        int prev_y=-1;
-        for (y=0;y&lt;target_height;++y)
-        {
-            if (ys==prev_y)
-            {
-                target.setRow(y,target.getRow(y-1),target_width);
-            }
-            else
-            {
-                xs=0;
-                for (x=0;x&lt;target_width;++x)
-                {
-                    target(x,y)=source(xs,ys);
-                    xs+=int_part_x;
-                    err_x+=fract_part_x;
-                    if (err_x&gt;=target_width)
-                    {
-                        err_x-=target_width;
-                        ++xs;
-                    }
-                }
-                prev_y=ys;
-            }
-            ys+=int_part_y;
-            err_y+=fract_part_y;
-            if (err_y&gt;=target_height)
-            {
-                err_y-=target_height;
-                ++ys;
-            }
-        }
-    }
-}
-
-#endif //IMAGE_UTIL_HPP

Deleted: trunk/include/label_collision_detector.hpp
===================================================================
--- trunk/include/label_collision_detector.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/label_collision_detector.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,87 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#if !defined LABEL_COLLISION_DETECTOR
-#define LABEL_COLLISION_DETECTOR
-
-#include &quot;quad_tree.hpp&quot;
-#include &lt;vector&gt;
-
-namespace mapnik
-{
-    //this needs to be tree structure 
-    //as a proof of a concept _only_ we use sequential scan 
-
-    struct label_collision_detector
-    {
-	typedef std::vector&lt;Envelope&lt;double&gt; &gt; label_placements;
-
-	bool has_plasement(Envelope&lt;double&gt; const&amp; box)
-	{
-	    label_placements::const_iterator itr=labels_.begin();
-	    for( ; itr !=labels_.end();++itr)
-	    {
-		if (itr-&gt;intersects(box))
-		{
-		    return false;
-		}
-	    }
-	    labels_.push_back(box);
-	    return true;
-	}
-    private:
-
-	label_placements labels_;
-    };
-
-    // quad_tree based label collision detector
-    class label_collision_detector2 : boost::noncopyable
-    {
-	typedef quad_tree&lt;Envelope&lt;double&gt; &gt; tree_t;
-	tree_t tree_;
-    public:
-	
-	explicit label_collision_detector2(Envelope&lt;double&gt; const&amp; extent)
-	    : tree_(extent) {}
-	
-	bool has_placement(Envelope&lt;double&gt; const&amp; box)
-	{
-	    tree_t::query_iterator itr = tree_.query_in_box(box);
-	    tree_t::query_iterator end = tree_.query_end();
-	    
-	    for ( ;itr != end; ++itr)
-	    {
-		if (itr-&gt;intersects(box))
-		{
-		    return false;
-		}
-	    }
-	    
-	    tree_.insert(box,box);
-	    return true;
-	}	
-    };
-}
-
-#endif 

Deleted: trunk/include/label_placement.hpp
===================================================================
--- trunk/include/label_placement.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/label_placement.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,54 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id$
-
-#ifndef LABEL_PLACEMENT_HPP
-#define LABEL_PLACEMENT_HPP
-
-namespace mapnik
-{
-    struct point_
-    {
-        double x;
-        double y;
-        point_()
-            : x(0),y(0) {}
-        point_(double x_,double y_)
-            : x(x_),y(y_) {}	
-    };
-    
-    class label_placement
-    {
-    private:
-        point_ anchor_;
-        point_ displacement_;
-        double rotation_;
-    public:
-        label_placement() 
-            : anchor_(),
-              displacement_(),
-              rotation_(0.0) {}
-	
-    };
-}
- 
-#endif //LABEL_PLACEMENT_HPP

Deleted: trunk/include/layer.hpp
===================================================================
--- trunk/include/layer.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/layer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,86 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id: layer.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef LAYER_HPP
-#define LAYER_HPP
-
-#include &lt;vector&gt;
-#include &quot;feature.hpp&quot;
-#include &quot;datasource.hpp&quot;
-#include &lt;boost/shared_ptr.hpp&gt;
-
-namespace mapnik
-{
-    class MAPNIK_DECL Layer
-    {
-        std::string name_;
-        std::string title_;
-        std::string abstract_;
-        double minZoom_;
-        double maxZoom_;
-        bool active_;
-        bool selectable_;
-        
-        std::vector&lt;std::string&gt;  styles_;
-        std::string selection_style_;
-        
-        mutable std::vector&lt;boost::shared_ptr&lt;Feature&gt; &gt; selection_;
-        mutable datasource_p ds_;
-        
-    public:
-        explicit Layer(std::string const&amp; name);
-        Layer(Layer const&amp; l);
-        Layer&amp; operator=(Layer const&amp; l);
-        bool operator==(Layer const&amp; other) const;
-        void set_name(std::string const&amp; name);
-        const std::string&amp; name() const;
-        void set_title(std::string const&amp; title);
-        const std::string&amp; title() const;
-        void set_abstract(std::string const&amp; abstract);
-        const std::string&amp; abstract() const;
-        void add_style(std::string const&amp; stylename);
-        std::vector&lt;std::string&gt; const&amp; styles() const;
-        void selection_style(const std::string&amp; name);
-        const std::string&amp; selection_style() const;
-        void setMinZoom(double minZoom);
-        void setMaxZoom(double maxZoom);
-        double getMinZoom() const;
-        double getMaxZoom() const;
-        void setActive(bool active);
-        bool isActive() const;
-        void setSelectable(bool selectable);
-        bool isSelectable() const;
-        bool isVisible(double scale) const;
-        void add_to_selection(boost::shared_ptr&lt;Feature&gt;&amp; feature) const;
-        std::vector&lt;boost::shared_ptr&lt;Feature&gt; &gt;&amp; selection() const;
-        void clear_selection() const;
-        void set_datasource(datasource_p const&amp; ds);
-        datasource_p datasource() const;
-        Envelope&lt;double&gt; envelope() const;
-        ~Layer();
-    private:
-        void swap(const Layer&amp; other);
-    };
-}
-
-#endif //LAYER_HPP

Deleted: trunk/include/line_pattern_symbolizer.hpp
===================================================================
--- trunk/include/line_pattern_symbolizer.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/line_pattern_symbolizer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,45 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id: polygon_symbolizer.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef LINE_PATTERN_SYMBOLIZER_HPP
-#define LINE_PATTERN_SYMBOLIZER_HPP
-
-#include &lt;boost/shared_ptr.hpp&gt;
-#include &quot;graphics.hpp&quot;
-
-namespace mapnik 
-{      
-    struct MAPNIK_DECL line_pattern_symbolizer
-    {
-	line_pattern_symbolizer(std::string const&amp; file,
-				std::string const&amp; type,
-				unsigned width,unsigned height);
-
-	line_pattern_symbolizer(line_pattern_symbolizer const&amp; rhs);
-	ImageData32 const&amp; get_pattern() const;
-    private:
-	boost::shared_ptr&lt;ImageData32&gt; pattern_;
-    };    
-}
-
-#endif // LINE_PATTERN_SYMBOLIZER_HPP

Deleted: trunk/include/line_symbolizer.hpp
===================================================================
--- trunk/include/line_symbolizer.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/line_symbolizer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,55 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id: line_symbolizer.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef LINE_SYMBOLIZER_HPP
-#define LINE_SYMBOLIZER_HPP
-
-#include &quot;stroke.hpp&quot;
-
-namespace mapnik 
-{
-    struct MAPNIK_DECL line_symbolizer
-    {
-        explicit line_symbolizer()
-            : stroke_() {}
-        
-        line_symbolizer(stroke const&amp; stroke)
-            : stroke_(stroke) {}
-	
-        line_symbolizer(const Color&amp; pen,float width=1.0)
-            : stroke_(pen,width) {}
-        stroke const&amp; get_stroke() const
-        {
-            return stroke_;
-        }
-        void set_stroke(stroke const&amp; stroke)
-        {
-            stroke_ = stroke;
-        }
-
-    private:
-		stroke stroke_;
-    };
-}
-
-#endif //LINE_SYMBOLIZER_HPP

Deleted: trunk/include/load_map.hpp
===================================================================
--- trunk/include/load_map.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/load_map.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,35 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-// $Id$
-
-#ifndef MAP_LOADER_HPP
-#define MAP_LOADER_HPP
-
-#include &lt;string&gt;
-#include &quot;map.hpp&quot;
-
-namespace mapnik
-{
-    void load_map(Map &amp; map, std::string const&amp; filename);
-}
-
-#endif // LOAD_MAP_HPP

Deleted: trunk/include/local_datasource.hpp
===================================================================
--- trunk/include/local_datasource.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/local_datasource.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,49 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id$
-
-#ifndef LOCAL_DATASOURCE_HPP
-#define LOCAL_DATASOURCE_HPP
-
-#include &lt;vector&gt;
-
-namespace mapnik
-{
-    /*
-    class local_datasource : public datasource 
-    {
-    public:
-	local_datasource(Parameters const&amp; params);
-	int type() const;
-	static std::string name();
-	featureset_ptr features(query const&amp; q) const;
-	const Envelope&lt;double&gt;&amp; envelope() const;
-	virtual ~local_datasource();
-    private:
-	static std::string name_;
-	Envelope&lt;double&gt; extent_;
-	std::vector&lt;Feature*&gt;  
-    };
-    */
-}
-
-#endif //LOCAL_DATASOURCE_HPP

Deleted: trunk/include/logical.hpp
===================================================================
--- trunk/include/logical.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/logical.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,172 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id$
-
-#ifndef LOGICAL_HPP
-#define LOGICAL_HPP
-
-#include &quot;filter.hpp&quot;
-
-namespace mapnik
-{
-    template &lt;typename FeatureT&gt; 
-    struct logical_and : public filter&lt;FeatureT&gt;  
-    {
-	logical_and(filter&lt;FeatureT&gt; const&amp; filter1,
-		    filter&lt;FeatureT&gt; const&amp; filter2)
-	    : filter&lt;FeatureT&gt;(),
-	      filter1_(filter1.clone()),
-	      filter2_(filter2.clone()) {}
-	
-	logical_and(logical_and const&amp; other)
-	    : filter&lt;FeatureT&gt;(),
-	      filter1_(other.filter1_-&gt;clone()),
-	      filter2_(other.filter2_-&gt;clone()) {}
-
-	bool pass(const FeatureT&amp; feature) const
-	{
-	    return (filter1_-&gt;pass(feature) &amp;&amp; 
-		filter2_-&gt;pass(feature));
-	}
-	std::string to_string() const
-	{
-	    return &quot;(&quot;+filter1_-&gt;to_string()+&quot; and &quot;+filter2_-&gt;to_string()+&quot;)&quot;;
-	}
-	
-	filter&lt;FeatureT&gt;* clone() const
-	{
-	    return new logical_and(*this);
-	}
-
-	void accept(filter_visitor&lt;FeatureT&gt;&amp; v)
-	{
-	    filter1_-&gt;accept(v);
-	    filter2_-&gt;accept(v);
-	    v.visit(*this);
-	}
-
-	virtual ~logical_and()
-	{
-	    delete filter1_;
-	    delete filter2_;
-	}
-	
-    private:
-	filter&lt;FeatureT&gt;* filter1_;
-	filter&lt;FeatureT&gt;* filter2_;
-    };
-
-    template &lt;typename FeatureT&gt; 
-    struct logical_or : public filter&lt;FeatureT&gt;  
-    {
-	
-	logical_or(const filter&lt;FeatureT&gt;&amp; filter1,const filter&lt;FeatureT&gt;&amp; filter2)
-	    : filter&lt;FeatureT&gt;(),
-	      filter1_(filter1.clone()),
-	      filter2_(filter2.clone()) {}
-	
-	logical_or(logical_or const&amp; other)
-	    : filter&lt;FeatureT&gt;(),
-	      filter1_(other.filter1_-&gt;clone()),
-	      filter2_(other.filter2_-&gt;clone()) {}
-
-	bool pass(const FeatureT&amp; feature) const
-	{
-	    if (filter1_-&gt;pass(feature))
-	    {
-		return true;
-	    }
-	    else
-	    {
-		return filter2_-&gt;pass(feature);
-	    }
-	}
-	filter&lt;FeatureT&gt;* clone() const
-	{
-	    return new logical_or(*this);
-	}
-
-	void accept(filter_visitor&lt;FeatureT&gt;&amp; v)
-	{
-	    filter1_-&gt;accept(v);
-	    filter2_-&gt;accept(v);
-	    v.visit(*this);
-	}
-	std::string to_string() const
-	{
-	    return &quot;(&quot;+filter1_-&gt;to_string()+&quot; or &quot;+filter2_-&gt;to_string()+&quot;)&quot;;
-	}	
-	virtual ~logical_or()
-	{  
-	    delete filter1_;
-	    delete filter2_;
-	}
-    private:
-	filter&lt;FeatureT&gt;* filter1_;
-	filter&lt;FeatureT&gt;* filter2_;
-    };
-
-    template &lt;typename FeatureT&gt; 
-    struct logical_not : public filter&lt;FeatureT&gt;  
-    {
-	logical_not(filter&lt;FeatureT&gt; const&amp; _filter)
-	    : filter&lt;FeatureT&gt;(),
-	      filter_(_filter.clone()) {}
-	logical_not(logical_not const&amp; other)
-	    : filter&lt;FeatureT&gt;(),
-	      filter_(other.filter_-&gt;clone()) {}
-
-	int type() const
-	{
-	    return filter&lt;FeatureT&gt;::LOGICAL_OPS;
-	}
-
-	bool pass(const FeatureT&amp; feature) const
-	{
-	    return !(filter_-&gt;pass(feature));
-	}
-
-	filter&lt;FeatureT&gt;* clone() const
-	{
-	    return new logical_not(*this);
-	}
-	
-	void accept(filter_visitor&lt;FeatureT&gt;&amp; v)
-	{
-	    filter_-&gt;accept(v);
-	    v.visit(*this);
-	}
-	std::string to_string() const
-	{
-	    return &quot;not (&quot;+filter_-&gt;to_string()+&quot;)&quot;;
-	}
-	 
-	~logical_not() 
-	{
-	    delete filter_;
-	}
-    private:
-	filter&lt;FeatureT&gt;* filter_;
-    };
-}
- 
-#endif //LOGICAL_HPP

Deleted: trunk/include/map.hpp
===================================================================
--- trunk/include/map.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/map.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,85 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id: map.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef MAP_HPP
-#define MAP_HPP
-
-#include &quot;feature_type_style.hpp&quot;
-
-namespace mapnik
-{
-    class Layer;
-
-    class MAPNIK_DECL Map
-    {	
-        static const unsigned MIN_MAPSIZE=16;
-        static const unsigned MAX_MAPSIZE=2048;
-        unsigned width_;
-        unsigned height_;
-        int srid_;
-        Color background_;
-        std::map&lt;std::string,feature_type_style&gt; styles_;
-        std::vector&lt;Layer&gt; layers_;
-        Envelope&lt;double&gt; currentExtent_;
-        
-    public:
- 
-        typedef std::map&lt;std::string,feature_type_style&gt;::const_iterator style_iterator;
-        
-        Map();
-        Map(int width,int height,int srid=-1);
-        Map(const Map&amp; rhs);
-        Map&amp; operator=(const Map&amp; rhs);
-        style_iterator begin_styles() const;
-        style_iterator end_styles() const;
-        bool insert_style(std::string const&amp; name,feature_type_style const&amp; style);
-        void remove_style(const std::string&amp; name);
-        feature_type_style const&amp; find_style(std::string const&amp; name) const;
-        size_t layerCount() const;
-        void addLayer(const Layer&amp; l);
-        const Layer&amp; getLayer(size_t index) const;
-        Layer&amp; getLayer(size_t index);
-        void removeLayer(size_t index);
-        std::vector&lt;Layer&gt; const&amp; layers() const;
-        unsigned getWidth() const;
-        unsigned getHeight() const;
-        void setWidth(unsigned width);
-        void setHeight(unsigned height);
-        void resize(unsigned width,unsigned height);
-        int srid() const;
-        void setBackground(const Color&amp; c);
-        const Color&amp; getBackground() const;
-        void zoom(double zoom);
-        void zoomToBox(const Envelope&lt;double&gt;&amp; box);
-        void zoom_all();
-        void pan(int x,int y);
-        void pan_and_zoom(int x,int y,double zoom);
-        const Envelope&lt;double&gt;&amp; getCurrentExtent() const;
-        double scale() const;
-        ~Map();
-    private:
-        void fixAspectRatio();
-    };
-}
-
-#endif //MAP_HPP

Copied: trunk/include/mapnik/agg_renderer.hpp (from rev 307, trunk/include/agg_renderer.hpp)
===================================================================
--- trunk/include/agg_renderer.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/agg_renderer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,63 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef AGG_RENDERER_HPP
+#define AGG_RENDERER_HPP
+
+// boost
+#include &lt;boost/utility.hpp&gt;
+// mapnik
+#include &lt;mapnik/feature_style_processor.hpp&gt;
+#include &lt;mapnik/font_engine_freetype.hpp&gt;
+#include &lt;mapnik/label_collision_detector.hpp&gt;
+#include &lt;mapnik/map.hpp&gt;
+#include &lt;mapnik/config.hpp&gt;
+
+namespace mapnik {
+    template &lt;typename T&gt;
+    class MAPNIK_DECL agg_renderer : public feature_style_processor&lt;agg_renderer&lt;T&gt; &gt;,
+                                     private boost::noncopyable
+    {
+    public:
+        agg_renderer(Map const&amp; m, T &amp; pixmap);
+        void start_map_processing(Map const&amp; map);
+        void end_map_processing(Map const&amp; map);
+        void start_layer_processing(Layer const&amp; lay);
+        void end_layer_processing(Layer const&amp; lay);
+        void process(point_symbolizer const&amp; sym,Feature const&amp; feature);
+        void process(line_symbolizer const&amp; sym,Feature const&amp; feature);
+        void process(line_pattern_symbolizer const&amp; sym,Feature const&amp; feature);
+        void process(polygon_symbolizer const&amp; sym,Feature const&amp; feature);
+        void process(polygon_pattern_symbolizer const&amp; sym,Feature const&amp; feature);
+        void process(raster_symbolizer const&amp; sym,Feature const&amp; feature);
+        void process(text_symbolizer const&amp; sym,Feature const&amp; feature);
+    private:
+        T &amp; pixmap_;
+        CoordTransform t_;
+        face_manager&lt;freetype_engine&gt; font_manager_;
+        label_collision_detector2 detector_;
+    };
+}
+
+#endif //AGG_RENDERER_HPP

Copied: trunk/include/mapnik/attribute.hpp (from rev 307, trunk/include/attribute.hpp)
===================================================================
--- trunk/include/attribute.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/attribute.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,222 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: attribute.hpp 41 2005-04-13 20:21:56Z pavlenko $
+
+#ifndef ATTRIBUTE_HPP
+#define ATTRIBUTE_HPP
+
+// stl
+#include &lt;typeinfo&gt;
+#include &lt;sstream&gt;
+#include &lt;map&gt;
+// boost
+#include &lt;boost/any.hpp&gt;
+
+namespace mapnik {
+    template &lt;typename T&gt;
+    struct attribute_traits
+    {
+        static std::string to_string(const T&amp; value)
+        {
+            std::stringstream ss;
+            ss &lt;&lt; value;
+            return ss.str();
+        }
+    };
+
+    template &lt;&gt;
+    struct attribute_traits&lt;std::string&gt;
+    {
+        static std::string to_string(const std::string&amp; value)
+        {
+            return value;
+        }
+    };
+    
+    class MAPNIK_DECL attribute
+    {	
+    public:
+        attribute()
+            : base_(0) {}
+
+        template &lt;typename T&gt;
+        attribute(const T&amp; value)
+            : base_(new attribute_impl&lt;T&gt;(value)) 
+        {}
+
+        attribute(const attribute&amp; rhs)
+            : base_(rhs.base_ ? rhs.base_-&gt;clone() : 0)
+        {}
+
+        ~attribute() 
+        {
+            delete base_;
+        }
+
+        template&lt;typename T&gt;
+        attribute&amp; operator=(const T&amp; rhs)
+        {
+            attribute(rhs).swap(*this);
+            return *this;
+        }
+
+        attribute&amp; operator=(const attribute&amp; rhs)
+        {
+            attribute(rhs).swap(*this);
+            return *this;
+        }
+
+        bool empty() const
+        {
+            return !base_;
+        }
+
+        const std::type_info &amp; type() const
+        {
+            return base_ ? base_-&gt;type() : typeid(void);
+        }
+
+        const std::string to_string() const
+        {
+            return base_ ? base_-&gt;to_string() : &quot;&quot;;
+        }
+    private:
+        attribute&amp; swap(attribute&amp; rhs)
+        {
+            std::swap(base_,rhs.base_);
+            return *this;
+        }
+	
+        class attribute_base
+        {
+        public:
+            virtual ~attribute_base() {}
+            virtual attribute_base* clone() const=0;
+            virtual std::string to_string() const=0;
+            virtual const std::type_info&amp; type()  const=0;
+        };
+
+        template &lt;typename T,typename ATraits=attribute_traits&lt;T&gt; &gt;
+        class attribute_impl : public attribute_base
+        {	    
+        public:
+            typedef T value_type;
+            attribute_impl(const value_type&amp; value)
+                : value_(value) {}
+	    
+            virtual std::string to_string() const
+            {
+                return  ATraits::to_string(value_);
+            }
+	    
+            virtual attribute_base* clone() const
+            {
+                return new attribute_impl(value_);
+            }
+            virtual const std::type_info&amp; type() const 
+            {
+                return typeid(value_);
+            }
+            value_type value_;
+        };
+    private:
+        template&lt;typename value_type&gt;
+        friend value_type* attribute_cast(attribute*);
+        attribute_base* base_;
+    };
+    
+    
+    template&lt;typename T&gt;
+    struct bad_attribute_cast : public std::bad_cast
+    {
+        virtual const char* what() const throw()
+        {
+            return &quot;attribute::failed conversion&quot;;
+        }
+    };
+    
+    template &lt;typename T&gt; 
+    bool is_type(const attribute&amp; attr)
+    {
+        return attr.type()==typeid(T);
+    }
+    
+    template &lt;typename T&gt;
+    T* attribute_cast(attribute* attr)
+    {
+        return attr &amp;&amp; attr-&gt;type() == typeid(T)
+            ? &amp;static_cast&lt;attribute::attribute_impl&lt;T&gt;*&gt;(attr-&gt;base_)-&gt;value_
+            : 0;
+    }
+
+    template &lt;typename T&gt;
+    const T* attribute_cast(const attribute* attr)
+    {
+        return attribute_cast&lt;T&gt;(const_cast&lt;attribute*&gt;(attr));
+    }
+    
+    template &lt;typename T&gt;
+    T attribute_cast(const attribute&amp; attr)
+    {
+        using namespace boost;
+        typedef BOOST_DEDUCED_TYPENAME remove_reference&lt;T&gt;::type nonref;
+        const nonref * result=attribute_cast&lt;nonref&gt;(&amp;attr);
+        if (!result)
+        {
+            throw bad_attribute_cast&lt;T&gt;();
+        }
+        return *result;
+    }
+    
+    template &lt;typename T&gt;
+    T attribute_cast(attribute&amp; attr)
+    {
+        using namespace boost;
+        typedef BOOST_DEDUCED_TYPENAME remove_reference&lt;T&gt;::type nonref;
+        nonref * result=attribute_cast&lt;nonref&gt;(&amp;attr);
+        if (!result)
+            throw bad_attribute_cast&lt;T&gt;();
+        return *result;
+    }
+    
+       
+    template &lt;typename T&gt;
+    attribute attribute_from_string(const std::string&amp; val)
+    {
+        std::istringstream is(val);
+        T t;
+        is &gt;&gt; t;
+        return attribute(t);
+    }
+
+    template &lt;typename charT, typename traits&gt;
+    inline std::basic_ostream&lt;charT,traits&gt;&amp; 
+    operator &lt;&lt; (std::basic_ostream&lt;charT,traits&gt;&amp; out,
+                 const attribute&amp; attr)
+    {
+        out &lt;&lt; attr.to_string();
+        return out; 
+    }
+}
+
+#endif //ATTRIBUTE_HPP

Copied: trunk/include/mapnik/attribute_collector.hpp (from rev 307, trunk/include/attribute_collector.hpp)
===================================================================
--- trunk/include/attribute_collector.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/attribute_collector.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,98 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef ATTRIBUTE_COLLECTOR_HPP
+#define ATTRIBUTE_COLLECTOR_HPP
+
+// stl
+#include &lt;set&gt;
+#include &lt;iostream&gt;
+// mapnik
+#include &lt;mapnik/filter.hpp&gt;
+#include &lt;mapnik/expression.hpp&gt;
+#include &lt;mapnik/feature_layer_desc.hpp&gt;
+#include &lt;mapnik/rule.hpp&gt;
+
+namespace mapnik {
+    
+    struct symbolizer_attributes : public boost::static_visitor&lt;&gt;
+    {
+        symbolizer_attributes(std::set&lt;std::string&gt;&amp; names)
+            : names_(names) {}
+	
+        template &lt;typename T&gt;
+        void operator () (T const&amp;) const {}
+        void operator () (text_symbolizer const&amp; sym)
+        {
+            names_.insert(sym.get_name());
+        }
+    private:
+        std::set&lt;std::string&gt;&amp; names_;
+    };
+
+    template &lt;typename FeatureT&gt;
+    class attribute_collector : public filter_visitor&lt;FeatureT&gt;
+    {
+    private:
+        std::set&lt;std::string&gt;&amp; names_;
+    public:
+	
+        attribute_collector(std::set&lt;std::string&gt;&amp; names)
+            : names_(names) {}
+	
+        void visit(filter&lt;FeatureT&gt;&amp; /*filter*/) 
+        { 
+            //not interested
+        }
+	
+        void visit(expression&lt;FeatureT&gt;&amp; exp)
+        {
+            property&lt;FeatureT&gt;* pf;
+            if ((pf = dynamic_cast&lt;property&lt;FeatureT&gt;*&gt;(&amp;exp)))
+            {
+                names_.insert(pf-&gt;name());
+            }
+        }
+        void visit(rule_type const&amp; r)
+        {	    
+            const symbolizers&amp; symbols = r.get_symbolizers();
+            symbolizers::const_iterator symIter=symbols.begin();
+            symbolizer_attributes attr(names_);
+            while (symIter != symbols.end())
+            {
+                boost::apply_visitor(attr,*symIter++);
+            }
+            filter_ptr const&amp; filter = r.get_filter();
+            filter-&gt;accept(*this);
+        }
+
+        virtual ~attribute_collector() {}
+    private:	
+        // no copying 
+        attribute_collector(attribute_collector const&amp;);
+        attribute_collector&amp; operator=(attribute_collector const&amp;);
+    };   
+}
+
+#endif //ATTRIBUTE_COLLECTOR_HPP

Copied: trunk/include/mapnik/attribute_descriptor.hpp (from rev 307, trunk/include/attribute_descriptor.hpp)
===================================================================
--- trunk/include/attribute_descriptor.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/attribute_descriptor.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,38 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef ATTRIBUTE_DESCRIPTOR
+#define ATTRIBUTE_DESCRIPTOR
+
+#include &lt;string&gt;
+
+namespace mapnik {
+    struct attribute_desc
+    {
+        std::string name;
+        eType type;
+    };
+}
+
+#endif // ATTRIBUTE_DESCRIPTOR_HPP

Copied: trunk/include/mapnik/color.hpp (from rev 307, trunk/include/color.hpp)
===================================================================
--- trunk/include/color.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/color.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,127 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: color.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef COLOR_HPP
+#define COLOR_HPP
+
+#include &lt;sstream&gt;
+#include &lt;boost/format.hpp&gt;
+#include &lt;mapnik/config.hpp&gt;
+
+namespace mapnik {
+
+    class MAPNIK_DECL Color
+    {
+    private:
+        unsigned int abgr_;
+    public:
+        Color()
+            :abgr_(0xffffffff) {}
+
+        Color(int red,int green,int blue,int alpha=0xff)
+            : abgr_((alpha&amp;0xff) &lt;&lt; 24 | 
+                    (blue&amp;0xff) &lt;&lt; 16  | 
+                    (green&amp;0xff) &lt;&lt; 8  | 
+                    red&amp;0xff) {}
+        
+        explicit Color(int rgba)
+            : abgr_(rgba) {}
+
+        Color(const Color&amp; rhs)
+            : abgr_(rhs.abgr_) {}
+
+        Color&amp; operator=(const Color&amp; rhs)
+        {
+            if (this==&amp;rhs) return *this;
+            abgr_=rhs.abgr_;
+            return *this;
+        }
+        inline unsigned int red() const
+        {
+            return abgr_&amp;0xff;
+        }
+        inline unsigned int green() const
+        {
+            return (abgr_&gt;&gt;8)&amp;0xff;
+        }
+        inline unsigned int blue() const
+        {
+            return (abgr_&gt;&gt;16)&amp;0xff;
+        }
+        inline unsigned int alpha() const
+        {
+            return (abgr_&gt;&gt;24)&amp;0xff;
+        }
+	
+        inline void set_red(unsigned int r)
+        {
+            abgr_ = (abgr_ &amp; 0xffffff00) | (r&amp;0xff);
+        }
+        inline void set_green(unsigned int g)
+        {
+            abgr_ = (abgr_ &amp; 0xffff00ff) | ((g&amp;0xff) &lt;&lt; 8);
+        }
+        inline void set_blue(unsigned int b)
+        {
+            abgr_ = (abgr_ &amp; 0xff00ffff) | ((b&amp;0xff) &lt;&lt; 16);
+        }
+        inline void set_alpha(unsigned int a)
+        {
+            abgr_ = (abgr_ &amp; 0x00ffffff | (a&amp;0xff) &lt;&lt; 24);
+        }
+
+        inline unsigned int rgba() const
+        {
+            return abgr_;
+        }
+        inline void set_bgr(unsigned bgr)
+        {
+            abgr_ = (abgr_ &amp; 0xff000000) | (bgr &amp; 0xffffff);
+        }
+        inline bool operator==(Color const&amp; other) const
+        {
+            return abgr_ == other.abgr_;
+        }
+        
+        inline std::string to_string() const
+        {
+            std::stringstream ss;
+            ss &lt;&lt; &quot;rgb (&quot; 
+               &lt;&lt; red()   &lt;&lt; &quot;,&quot;  
+               &lt;&lt; green() &lt;&lt; &quot;,&quot;  
+               &lt;&lt; blue()  &lt;&lt; &quot;,&quot;
+               &lt;&lt; alpha() &lt;&lt; &quot;)&quot;;
+            return ss.str();
+        }
+        
+        inline std::string to_hex_string() const
+        {
+            std::stringstream ss;
+            ss &lt;&lt; boost::format(&quot;#%1$02x%2$02x%3$02x&quot;) % red() % green() % blue();
+            return ss.str();
+        }
+    };    
+}
+
+#endif //COLOR_HPP

Copied: trunk/include/mapnik/color_factory.hpp (from rev 307, trunk/include/color_factory.hpp)
===================================================================
--- trunk/include/color_factory.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/color_factory.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,53 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef COLOR_FACTORY_HPP
+#define COLOR_FACTORY_HPP
+
+#include &lt;mapnik/config.hpp&gt;
+#include &lt;mapnik/css_color_parser.hpp&gt;
+
+using namespace boost::spirit;
+
+namespace mapnik {    
+    class MAPNIK_DECL color_factory
+    {
+    public:
+        static Color from_string(char const* css_color)
+        {   
+            Color color;
+            actions&lt;Color&gt; a(color);
+            css_color_grammar&lt;actions&lt;Color&gt; &gt; grammar(a);
+            parse_info&lt;&gt; info = parse(css_color, grammar, space_p);
+            if (info.full) return color;
+            return Color(0,0,0);	
+        }    
+    private:
+        color_factory();
+        color_factory(color_factory const&amp;);
+        color_factory&amp; operator=(color_factory const&amp;);
+    };
+}
+
+#endif //COLOR_FACTORY_HPP

Copied: trunk/include/mapnik/comparison.hpp (from rev 307, trunk/include/comparison.hpp)
===================================================================
--- trunk/include/comparison.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/comparison.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,149 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id$
+
+#ifndef COMPARISON_HPP
+#define COMPARISON_HPP
+
+#include &lt;mapnik/filter.hpp&gt;
+#include &lt;mapnik/expression.hpp&gt;
+#include &lt;mapnik/attribute.hpp&gt;
+
+namespace mapnik {   
+    template &lt;typename T&gt;  
+    struct greater_than
+    {
+        bool operator() (T const&amp; left, T const&amp; right) const
+        {
+            return left &gt; right;
+        }
+        static std::string to_string()
+        {
+            return &quot;&gt;&quot;;
+        }
+    };
+
+    template &lt;typename T&gt;  
+    struct greater_than_or_equal
+    {
+        bool operator() (T const&amp; left, T const&amp; right) const
+        {
+            return left &gt;= right;
+        }
+        static std::string to_string()
+        {
+            return &quot;&gt;=&quot;;
+        }
+    };
+    template &lt;typename T&gt;  
+    struct less_than
+    {
+        bool operator() (T const&amp; left, T const&amp; right) const
+        {
+            return left &lt; right;
+        }
+        static std::string to_string()
+        {
+            return &quot;&lt;&quot;;
+        }
+    };
+    template &lt;typename T&gt;  
+    struct less_than_or_equal
+    {
+        bool operator() (T const&amp; left, T const&amp; right) const
+        {
+            return left &lt;= right;
+        }
+        static std::string to_string()
+        {
+            return &quot;&lt;=&quot;;
+        }
+    };
+    template &lt;typename T&gt;  
+    struct equals
+    {
+        bool operator() (T const&amp; left, T const&amp; right) const
+        {
+            return left == right;
+        }
+        static std::string to_string()
+        {
+            return &quot;=&quot;;
+        }
+    };
+    
+    template &lt;typename T&gt;  
+    struct not_equals
+    {
+        bool operator() (T const&amp; left, T const&amp; right) const
+        {
+            return left != right;
+        }
+        static std::string to_string()
+        {
+            return &quot;&lt;&gt;&quot;;
+        }
+    };
+    
+    template &lt;typename FeatureT,typename Op&gt;
+    struct compare_filter : public filter&lt;FeatureT&gt;
+    {
+        compare_filter(expression&lt;FeatureT&gt; const&amp; left,
+                       expression&lt;FeatureT&gt; const&amp; right)
+            : filter&lt;FeatureT&gt;(),
+              left_(left.clone()), right_(right.clone()) {}
+
+        compare_filter(compare_filter const&amp; other)
+            : filter&lt;FeatureT&gt;(),
+              left_(other.left_-&gt;clone()),right_(other.right_-&gt;clone()) {}
+	
+        bool pass(const FeatureT&amp; feature) const
+        {   
+            return Op()(left_-&gt;get_value(feature),right_-&gt;get_value(feature));     
+        }
+        void accept(filter_visitor&lt;FeatureT&gt;&amp; v)
+        {
+            left_-&gt;accept(v);
+            right_-&gt;accept(v);
+            v.visit(*this);
+        }
+        std::string to_string() const
+        {
+            return &quot;(&quot;+left_-&gt;to_string()+Op::to_string()+right_-&gt;to_string()+&quot;)&quot;;
+        }
+
+        filter&lt;FeatureT&gt;* clone() const
+        {
+            return new compare_filter&lt;FeatureT,Op&gt;(*this);
+        }
+        virtual ~compare_filter() 
+        {
+            delete left_;
+            delete right_;
+        }
+    private:
+        expression&lt;FeatureT&gt;* left_;
+        expression&lt;FeatureT&gt;* right_;
+    };
+}
+
+#endif //COMPARISON_HPP

Copied: trunk/include/mapnik/config.hpp (from rev 307, trunk/include/config.hpp)
===================================================================
--- trunk/include/config.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/config.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,39 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+#ifndef CONFIG_HPP
+#define CONFIG_HPP
+
+// Window DLL support
+
+#ifdef _WINDOWS
+# define MAPNIK_DECL __declspec (dllexport)
+# pragma warning( disable: 4251 )
+# pragma warning( disable: 4275 )
+# if (_MSC_VER &gt;= 1400) // vc8
+#   pragma warning(disable : 4996) //_CRT_SECURE_NO_DEPRECATE
+# endif
+#else
+# define MAPNIK_DECL 
+#endif
+
+#endif // CONFIG_HPP

Copied: trunk/include/mapnik/coord.hpp (from rev 307, trunk/include/coord.hpp)
===================================================================
--- trunk/include/coord.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/coord.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,136 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: coord.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef COORD_HPP
+#define COORD_HPP
+
+#include &lt;iomanip&gt;
+#include &lt;sstream&gt;
+
+namespace mapnik {   
+    template &lt;typename T,int dim&gt;
+    struct coord {
+        typedef T type;
+    };
+    
+    template &lt;typename T&gt;
+    struct coord&lt;T,2&gt; 
+    {
+        typedef T type;
+        T x;
+        T y;
+    public:
+        coord()
+            : x(),y() {}
+        coord(T x,T y)
+            : x(x),y(y) {}
+        template &lt;typename T2&gt;
+        coord (const coord&lt;T2,2&gt;&amp; rhs)
+            : x(type(rhs.x)),
+              y(type(rhs.y)) {}
+
+        template &lt;typename T2&gt;
+        coord&lt;T,2&gt;&amp; operator=(const coord&lt;T2,2&gt;&amp; rhs)
+        {
+            if ((void*)this==(void*)&amp;rhs)
+            {
+                return *this;
+            }
+            x=type(rhs.x);
+            y=type(rhs.y);
+            return *this;
+        }
+    };
+
+    template &lt;typename T&gt;
+    struct coord&lt;T,3&gt; 
+    {
+        typedef T type;
+        T x;
+        T y;
+        T z;
+    public:
+        coord()
+            : x(),y(),z() {}
+        coord(T x,T y,T z)
+            : x(x),y(y),z(z) {}
+        template &lt;typename T2&gt;
+        coord (const coord&lt;T2,3&gt;&amp; rhs)
+            : x(type(rhs.x)),
+              y(type(rhs.y)),
+              z(type(rhs.z)) {}
+
+        template &lt;typename T2&gt;
+        coord&lt;T,3&gt;&amp; operator=(const coord&lt;T2,3&gt;&amp; rhs)
+        {
+            if ((void*)this==(void*)&amp;rhs)
+            {
+                return *this;
+            }
+            x=type(rhs.x);
+            y=type(rhs.y);
+            z=type(rhs.z);
+            return *this;
+        }
+    };
+
+    typedef coord&lt;double,2&gt; coord2d;
+    typedef coord&lt;int,2&gt; coord2i;
+
+     
+    template &lt;typename charT,typename traits,typename T ,int dim&gt;
+    inline std::basic_ostream&lt;charT,traits&gt;&amp;
+    operator &lt;&lt; (std::basic_ostream&lt;charT,traits&gt;&amp; out,
+                 const coord&lt;T,dim&gt;&amp; c);
+    
+    template &lt;typename charT,typename traits,typename T&gt;
+    inline std::basic_ostream&lt;charT,traits&gt;&amp;
+    operator &lt;&lt; (std::basic_ostream&lt;charT,traits&gt;&amp; out,
+                 const coord&lt;T,2&gt;&amp; c)
+    {
+        std::basic_ostringstream&lt;charT,traits&gt; s;
+        s.copyfmt(out);
+        s.width(0);
+        s &lt;&lt; &quot;coord2(&quot; &lt;&lt; std::setprecision(16) 
+          &lt;&lt; c.x &lt;&lt; &quot;,&quot; &lt;&lt; c.y&lt;&lt; &quot;)&quot;;
+        out &lt;&lt; s.str();
+        return out;
+    }
+
+    template &lt;typename charT,typename traits,typename T&gt;
+    inline std::basic_ostream&lt;charT,traits&gt;&amp;
+    operator &lt;&lt; (std::basic_ostream&lt;charT,traits&gt;&amp; out,
+                 const coord&lt;T,3&gt;&amp; c)
+    {
+        std::basic_ostringstream&lt;charT,traits&gt; s;
+        s.copyfmt(out);
+        s.width(0);
+        s &lt;&lt; &quot;coord3(&quot; &lt;&lt; std::setprecision(16) 
+          &lt;&lt; c.x &lt;&lt; &quot;,&quot; &lt;&lt; c.y&lt;&lt; &quot;,&quot; &lt;&lt; c.z&lt;&lt;&quot;)&quot;;
+        out &lt;&lt; s.str();
+        return out;
+    } 
+}
+
+#endif // COORD_HPP

Copied: trunk/include/mapnik/coord_array.hpp (from rev 307, trunk/include/coord_array.hpp)
===================================================================
--- trunk/include/coord_array.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/coord_array.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,92 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: coord_array.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef COORD_ARRAY_HPP
+#define COORD_ARRAY_HPP
+
+// stl
+#include &lt;cassert&gt;
+//mapnik
+#include &lt;mapnik/coord.hpp&gt;
+
+namespace mapnik {
+    template &lt;typename T&gt;
+    class coord_array 
+    {   
+        typedef T coord_type;
+        coord_type* pt_;
+        const unsigned size_;
+    public:	
+        coord_array(unsigned size=0)
+            : pt_(static_cast&lt;coord_type*&gt;(size==0?0: ::operator new (sizeof(coord_type)*size))),
+              size_(size) {}
+	
+        coord_array(const coord_array&amp; rhs)
+            : pt_(static_cast&lt;coord_type*&gt;(rhs.size_==0?0: ::operator new (sizeof(coord_type)*rhs.size_))),
+              size_(rhs.size_) {
+            memcpy(pt_,rhs.pt_,sizeof(coord_type)*rhs.size_);
+        }
+	
+        ~coord_array() 
+        {
+            ::operator delete (pt_);
+        }
+	
+        unsigned size() const 
+        {
+            return size_;
+        }
+	
+        void set(unsigned index,double x,double y)
+        {
+            assert(index&lt;size_);
+            pt_[index].x=x;
+            pt_[index].y=y;
+        }
+	
+        const coord_type&amp; at(unsigned index) const 
+        {
+            assert(index&lt;size_);
+            return pt_[index];
+        }
+	
+        const coord_type&amp; operator[] (unsigned index) const
+        {
+            assert (index&lt;size_);
+            return pt_[index];
+        }
+	
+        coord_type&amp; operator[] (unsigned index)
+        {
+            assert (index&lt;size_);
+            return pt_[index];
+        }
+	
+    private:
+        coord_array&amp; operator=(const coord_array&amp;);
+    };
+}
+
+
+#endif //COORD_ARRAY_HPP

Copied: trunk/include/mapnik/css_color_parser.hpp (from rev 307, trunk/include/css_color_parser.hpp)
===================================================================
--- trunk/include/css_color_parser.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/css_color_parser.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,387 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef CSS_COLOR_PARSER_HPP
+#define CSS_COLOR_PARSER_HPP
+
+#include &lt;boost/spirit/core.hpp&gt;
+#include &lt;boost/spirit/symbols.hpp&gt;
+
+using namespace boost::spirit;
+
+namespace mapnik {
+    template &lt;typename ColorT&gt;
+    struct named_colors : public symbols&lt;ColorT&gt;
+    {
+        named_colors()
+        {
+            symbols&lt;ColorT&gt;::add
+                (&quot;aliceblue&quot;, ColorT(240, 248, 255))
+                (&quot;antiquewhite&quot;, ColorT(250, 235, 215))
+                (&quot;aqua&quot;, ColorT(0, 255, 255))
+                (&quot;aquamarine&quot;, ColorT(127, 255, 212))
+                (&quot;azure&quot;, ColorT(240, 255, 255))
+                (&quot;beige&quot;, ColorT(245, 245, 220))
+                (&quot;bisque&quot;, ColorT(255, 228, 196))
+                (&quot;black&quot;, ColorT(0, 0, 0))
+                (&quot;blanchedalmond&quot;, ColorT(255,235,205))
+                (&quot;blue&quot;, ColorT(0, 0, 255))
+                (&quot;blueviolet&quot;, ColorT(138, 43, 226))
+                (&quot;brown&quot;, ColorT(165, 42, 42))
+                (&quot;burlywood&quot;, ColorT(222, 184, 135))
+                (&quot;cadetblue&quot;, ColorT(95, 158, 160))
+                (&quot;chartreuse&quot;, ColorT(127, 255, 0))
+                (&quot;chocolate&quot;, ColorT(210, 105, 30))
+                (&quot;coral&quot;, ColorT(255, 127, 80))
+                (&quot;cornflowerblue&quot;, ColorT(100, 149, 237))
+                (&quot;cornsilk&quot;, ColorT(255, 248, 220))
+                (&quot;crimson&quot;, ColorT(220, 20, 60))
+                (&quot;cyan&quot;, ColorT(0, 255, 255))
+                (&quot;darkblue&quot;, ColorT(0, 0, 139))
+                (&quot;darkcyan&quot;, ColorT(0, 139, 139))
+                (&quot;darkgoldenrod&quot;, ColorT(184, 134, 11))
+                (&quot;darkgray&quot;, ColorT(169, 169, 169))
+                (&quot;darkgreen&quot;, ColorT(0, 100, 0))
+                (&quot;darkgrey&quot;, ColorT(169, 169, 169))
+                (&quot;darkkhaki&quot;, ColorT(189, 183, 107))
+                (&quot;darkmagenta&quot;, ColorT(139, 0, 139))
+                (&quot;darkolivegreen&quot;, ColorT(85, 107, 47))
+                (&quot;darkorange&quot;, ColorT(255, 140, 0))
+                (&quot;darkorchid&quot;, ColorT(153, 50, 204))
+                (&quot;darkred&quot;, ColorT(139, 0, 0))
+                (&quot;darksalmon&quot;, ColorT(233, 150, 122))
+                (&quot;darkseagreen&quot;, ColorT(143, 188, 143))
+                (&quot;darkslateblue&quot;, ColorT(72, 61, 139))
+                (&quot;darkslategrey&quot;, ColorT(47, 79, 79))
+                (&quot;darkturquoise&quot;, ColorT(0, 206, 209))
+                (&quot;darkviolet&quot;, ColorT(148, 0, 211))
+                (&quot;deeppink&quot;, ColorT(255, 20, 147))
+                (&quot;deepskyblue&quot;, ColorT(0, 191, 255))
+                (&quot;dimgray&quot;, ColorT(105, 105, 105))
+                (&quot;dimgrey&quot;, ColorT(105, 105, 105))
+                (&quot;dodgerblue&quot;, ColorT(30, 144, 255))
+                (&quot;firebrick&quot;, ColorT(178, 34, 34))
+                (&quot;floralwhite&quot;, ColorT(255, 250, 240))
+                (&quot;forestgreen&quot;, ColorT(34, 139, 34))
+                (&quot;fuchsia&quot;, ColorT(255, 0, 255))
+                (&quot;gainsboro&quot;, ColorT(220, 220, 220))
+                (&quot;ghostwhite&quot;, ColorT(248, 248, 255))
+                (&quot;gold&quot;, ColorT(255, 215, 0))
+                (&quot;goldenrod&quot;, ColorT(218, 165, 32))
+                (&quot;gray&quot;, ColorT(128, 128, 128))
+                (&quot;grey&quot;, ColorT(128, 128, 128))
+                (&quot;green&quot;, ColorT(0, 128, 0))
+                (&quot;greenyellow&quot;, ColorT(173, 255, 47))
+                (&quot;honeydew&quot;, ColorT(240, 255, 240))
+                (&quot;hotpink&quot;, ColorT(255, 105, 180))
+                (&quot;indianred&quot;, ColorT(205, 92, 92))
+                (&quot;indigo&quot;, ColorT(75, 0, 130))
+                (&quot;ivory&quot;, ColorT(255, 255, 240))
+                (&quot;khaki&quot;, ColorT(240, 230, 140))
+                (&quot;lavender&quot;, ColorT(230, 230, 250))
+                (&quot;lavenderblush&quot;, ColorT(255, 240, 245))
+                (&quot;lawngreen&quot;, ColorT(124, 252, 0))
+                (&quot;lemonchiffon&quot;, ColorT(255, 250, 205))
+                (&quot;lightblue&quot;, ColorT(173, 216, 230))
+                (&quot;lightcoral&quot;, ColorT(240, 128, 128))
+                (&quot;lightcyan&quot;, ColorT(224, 255, 255))
+                (&quot;lightgoldenrodyellow&quot;, ColorT(250, 250, 210))
+                (&quot;lightgray&quot;, ColorT(211, 211, 211))
+                (&quot;lightgreen&quot;, ColorT(144, 238, 144))
+                (&quot;lightgrey&quot;, ColorT(211, 211, 211))
+                (&quot;lightpink&quot;, ColorT(255, 182, 193))
+                (&quot;lightsalmon&quot;, ColorT(255, 160, 122))
+                (&quot;lightseagreen&quot;, ColorT(32, 178, 170))
+                (&quot;lightskyblue&quot;, ColorT(135, 206, 250))
+                (&quot;lightslategray&quot;, ColorT(119, 136, 153))
+                (&quot;lightslategrey&quot;, ColorT(119, 136, 153))
+                (&quot;lightsteelblue&quot;, ColorT(176, 196, 222))
+                (&quot;lightyellow&quot;, ColorT(255, 255, 224))
+                (&quot;lime&quot;, ColorT(0, 255, 0))
+                (&quot;limegreen&quot;, ColorT(50, 205, 50))
+                (&quot;linen&quot;, ColorT(250, 240, 230))
+                (&quot;magenta&quot;, ColorT(255, 0, 255))
+                (&quot;maroon&quot;, ColorT(128, 0, 0))
+                (&quot;mediumaquamarine&quot;, ColorT(102, 205, 170))
+                (&quot;mediumblue&quot;, ColorT(0, 0, 205))
+                (&quot;mediumorchid&quot;, ColorT(186, 85, 211))
+                (&quot;mediumpurple&quot;, ColorT(147, 112, 219))
+                (&quot;mediumseagreen&quot;, ColorT(60, 179, 113))
+                (&quot;mediumslateblue&quot;, ColorT(123, 104, 238))
+                (&quot;mediumspringgreen&quot;, ColorT(0, 250, 154))
+                (&quot;mediumturquoise&quot;, ColorT(72, 209, 204))
+                (&quot;mediumvioletred&quot;, ColorT(199, 21, 133))
+                (&quot;midnightblue&quot;, ColorT(25, 25, 112))
+                (&quot;mintcream&quot;, ColorT(245, 255, 250))
+                (&quot;mistyrose&quot;, ColorT(255, 228, 225))
+                (&quot;moccasin&quot;, ColorT(255, 228, 181))
+                (&quot;navajowhite&quot;, ColorT(255, 222, 173))
+                (&quot;navy&quot;, ColorT(0, 0, 128))
+                (&quot;oldlace&quot;, ColorT(253, 245, 230))
+                (&quot;olive&quot;, ColorT(128, 128, 0))
+                (&quot;olivedrab&quot;, ColorT(107, 142, 35))
+                (&quot;orange&quot;, ColorT(255, 165, 0))
+                (&quot;orangered&quot;, ColorT(255, 69, 0))
+                (&quot;orchid&quot;, ColorT(218, 112, 214))
+                (&quot;palegoldenrod&quot;, ColorT(238, 232, 170))
+                (&quot;palegreen&quot;, ColorT(152, 251, 152))
+                (&quot;paleturquoise&quot;, ColorT(175, 238, 238))
+                (&quot;palevioletred&quot;, ColorT(219, 112, 147))
+                (&quot;papayawhip&quot;, ColorT(255, 239, 213))
+                (&quot;peachpuff&quot;, ColorT(255, 218, 185))
+                (&quot;peru&quot;, ColorT(205, 133, 63))
+                (&quot;pink&quot;, ColorT(255, 192, 203))
+                (&quot;plum&quot;, ColorT(221, 160, 221))
+                (&quot;powderblue&quot;, ColorT(176, 224, 230))
+                (&quot;purple&quot;, ColorT(128, 0, 128))
+                (&quot;red&quot;, ColorT(255, 0, 0))
+                (&quot;rosybrown&quot;, ColorT(188, 143, 143))
+                (&quot;royalblue&quot;, ColorT(65, 105, 225))
+                (&quot;saddlebrown&quot;, ColorT(139, 69, 19))
+                (&quot;salmon&quot;, ColorT(250, 128, 114))
+                (&quot;sandybrown&quot;, ColorT(244, 164, 96))
+                (&quot;seagreen&quot;, ColorT(46, 139, 87))
+                (&quot;seashell&quot;, ColorT(255, 245, 238))
+                (&quot;sienna&quot;, ColorT(160, 82, 45))
+                (&quot;silver&quot;, ColorT(192, 192, 192))
+                (&quot;skyblue&quot;, ColorT(135, 206, 235))
+                (&quot;slateblue&quot;, ColorT(106, 90, 205))
+                (&quot;slategray&quot;, ColorT(112, 128, 144))
+                (&quot;slategrey&quot;, ColorT(112, 128, 144))
+                (&quot;snow&quot;, ColorT(255, 250, 250))
+                (&quot;springgreen&quot;, ColorT(0, 255, 127))
+                (&quot;steelblue&quot;, ColorT(70, 130, 180))
+                (&quot;tan&quot;, ColorT(210, 180, 140))
+                (&quot;teal&quot;, ColorT(0, 128, 128))
+                (&quot;thistle&quot;, ColorT(216, 191, 216))
+                (&quot;tomato&quot;, ColorT(255, 99, 71))
+                (&quot;turquoise&quot;, ColorT(64, 224, 208))
+                (&quot;violet&quot;, ColorT(238, 130, 238))
+                (&quot;wheat&quot;, ColorT(245, 222, 179))
+                (&quot;white&quot;, ColorT(255, 255, 255))
+                (&quot;whitesmoke&quot;, ColorT(245, 245, 245))
+                (&quot;yellow&quot;, ColorT(255, 255, 0))
+                (&quot;yellowgreen&quot;, ColorT(154, 205, 50))
+                ;
+        }
+    };
+    
+    template &lt;typename ActionsT&gt;
+    struct css_color_grammar : public grammar&lt;css_color_grammar&lt;ActionsT&gt; &gt;
+    {
+        css_color_grammar(ActionsT&amp; actions_)
+            : actions(actions_) {}
+    
+        template &lt;typename ScannerT&gt;
+        struct definition
+        {
+            definition(css_color_grammar const&amp; self)
+            {
+                hex6 = ch_p('#') &gt;&gt; uint6x_p[self.actions.hex6_];
+                hex3 = ch_p('#') &gt;&gt; uint3x_p[self.actions.hex3_];
+                rgb = str_p(&quot;rgb&quot;) &gt;&gt; '(' &gt;&gt; uint3_p[self.actions.red_] 
+                                   &gt;&gt; ',' &gt;&gt; uint3_p[self.actions.green_] 
+                                   &gt;&gt; ',' &gt;&gt; uint3_p[self.actions.blue_] 
+                                   &gt;&gt; ')';
+                rgb_percent = str_p(&quot;rgb&quot;) &gt;&gt; '(' &gt;&gt; ureal_p[self.actions.red_p_] &gt;&gt; '%' 
+                                           &gt;&gt; ',' &gt;&gt; ureal_p[self.actions.green_p_] &gt;&gt; '%'
+                                           &gt;&gt; ',' &gt;&gt; ureal_p[self.actions.blue_p_] &gt;&gt; '%'
+                                           &gt;&gt; ')';
+                css_color = named_colors_p[self.actions.named_] | hex6 | hex3 | rgb_percent | rgb; 
+            }
+            boost::spirit::rule&lt;ScannerT&gt; rgb;
+            boost::spirit::rule&lt;ScannerT&gt; rgb_percent;
+            boost::spirit::rule&lt;ScannerT&gt; hex6;
+            boost::spirit::rule&lt;ScannerT&gt; hex3;
+            boost::spirit::rule&lt;ScannerT&gt; css_color;
+            boost::spirit::rule&lt;ScannerT&gt; const&amp; start() const
+            {
+                return css_color;
+            }
+            uint_parser&lt;unsigned, 10, 1, 3&gt; uint3_p;
+            uint_parser&lt;unsigned, 16, 6, 6&gt; uint6x_p;
+            uint_parser&lt;unsigned, 16, 3, 3&gt; uint3x_p;
+            named_colors&lt;typename ActionsT::color_type&gt; named_colors_p;
+	    
+        };
+        ActionsT&amp; actions;	
+    };
+    
+    template &lt;typename ColorT&gt;
+    struct named_color_action
+    {
+        named_color_action(ColorT&amp; c)
+            : c_(c) {}
+	
+        void operator() (ColorT const&amp;c) const
+        {
+            c_=c;
+        }
+        ColorT&amp; c_;
+    };
+
+    template &lt;typename ColorT&gt;
+    struct hex6_action
+    {
+        hex6_action(ColorT&amp; c)
+            : c_(c) {}
+	
+        void operator () (unsigned int hex) const
+        {
+            unsigned r = (hex &gt;&gt; 16) &amp; 0xff;
+            unsigned g = (hex &gt;&gt; 8) &amp; 0xff;
+            unsigned b = hex &amp; 0xff;
+            c_.set_red(r);
+            c_.set_green(g);
+            c_.set_blue(b);
+        }
+        ColorT&amp; c_;
+    };
+    
+    template &lt;typename ColorT&gt;
+    struct hex3_action
+    {
+        hex3_action(ColorT&amp; c)
+            : c_(c) {}
+	
+        void operator () (unsigned int hex) const
+        {
+            unsigned int r = (hex &gt;&gt; 8) &amp; 0xf;
+            unsigned int g = (hex &gt;&gt; 4) &amp; 0xf;
+            unsigned int b = hex &amp; 0xf;
+            c_.set_red( r | r &lt;&lt; 4);
+            c_.set_green(g | g &lt;&lt; 4);
+            c_.set_blue(b | b &lt;&lt; 4);
+        }
+        ColorT&amp; c_;
+    };
+
+    template &lt;typename ColorT&gt;
+    struct red_action
+    {
+        red_action(ColorT&amp; c)
+            : c_(c) {}
+	
+        void operator () (unsigned int r) const
+        {
+            c_.set_red(r);
+        }
+        ColorT&amp; c_;
+    };
+
+    template &lt;typename ColorT&gt;
+    struct green_action
+    {
+        green_action(ColorT&amp; c)
+            : c_(c) {}
+	
+        void operator () (unsigned int g) const
+        {
+            c_.set_green(g);
+        }
+        ColorT&amp; c_;
+    };
+	
+    template &lt;typename ColorT&gt;
+    struct blue_action
+    {
+        blue_action(ColorT&amp; c)
+            : c_(c) {}
+	
+        void operator () (unsigned int b) const
+        {
+            c_.set_blue(b);
+        }
+        ColorT&amp; c_;
+    };
+    
+
+    template &lt;typename ColorT&gt;
+    struct red_action_p
+    {
+        red_action_p(ColorT&amp; c)
+            : c_(c) {}
+	
+        void operator () (double r) const
+        {
+            c_.set_red(unsigned((255.0 * r)/100.0 + 0.5));
+        }
+        ColorT&amp; c_;
+    };
+
+    template &lt;typename ColorT&gt;
+    struct green_action_p
+    {
+        green_action_p(ColorT&amp; c)
+            : c_(c) {}
+	
+        void operator () (double g) const
+        {
+            c_.set_green(unsigned((255.0 * g)/100.0 + 0.5));
+        }
+        ColorT&amp; c_;
+    };
+
+    template &lt;typename ColorT&gt;
+    struct blue_action_p
+    {
+        blue_action_p(ColorT&amp; c)
+            : c_(c) {}
+	
+        void operator () (double b) const
+        {
+            c_.set_blue(unsigned((255.0 * b)/100.0 + 0.5));
+        }
+        ColorT&amp; c_;
+    };
+
+
+    template &lt;typename ColorT&gt;
+    struct actions
+    {
+        typedef ColorT color_type;
+        actions(ColorT&amp; c)
+            : named_(c),
+              hex6_(c),
+              hex3_(c),
+              red_(c),
+              green_(c),
+              blue_(c),
+              red_p_(c),
+              green_p_(c),
+              blue_p_(c) {}
+        
+        named_color_action&lt;ColorT&gt; named_;
+        hex6_action&lt;ColorT&gt; hex6_;
+        hex3_action&lt;ColorT&gt; hex3_;
+        red_action&lt;ColorT&gt; red_;
+        green_action&lt;ColorT&gt; green_;
+        blue_action&lt;ColorT&gt; blue_;
+        red_action_p&lt;ColorT&gt; red_p_;
+        green_action_p&lt;ColorT&gt; green_p_;
+        blue_action_p&lt;ColorT&gt; blue_p_;
+    };
+}
+
+#endif //CSS_COLOR_PARSER_HPP

Copied: trunk/include/mapnik/ctrans.hpp (from rev 307, trunk/include/ctrans.hpp)
===================================================================
--- trunk/include/ctrans.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/ctrans.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,169 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: ctrans.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef CTRANS_HPP
+#define CTRANS_HPP
+
+#include &lt;mapnik/envelope.hpp&gt;
+#include &lt;mapnik/coord_array.hpp&gt;
+
+namespace mapnik {
+    typedef coord_array&lt;coord2d&gt; CoordinateArray;
+    
+    template &lt;typename Transform,typename Geometry&gt;
+    struct MAPNIK_DECL coord_transform
+    {
+        coord_transform(Transform const&amp; t,Geometry&amp; geom)
+            : t_(t), geom_(geom) {}
+	
+        unsigned  vertex(double *x , double *y) const
+        {
+            unsigned command = geom_.vertex(x,y);
+            *x = t_.forward_x_(x);
+            *y = t_.forward_y_(y);
+            return command;
+        }
+        void rewind (unsigned pos)
+        {
+            geom_.rewind(pos);
+        }
+	
+    private:
+        Transform const&amp; t_;
+        Geometry&amp; geom_;
+    };
+    
+    class CoordTransform
+    {
+    private:
+	    int width;
+	    int height;
+	    double scale_;
+	    Envelope&lt;double&gt; extent;
+    public:
+        CoordTransform(int width,int height,const Envelope&lt;double&gt;&amp; extent)
+            :width(width),height(height),extent(extent)
+        {
+            double sx=((double)width)/extent.width();
+            double sy=((double)height)/extent.height();
+            scale_=std::min(sx,sy);
+        }
+	
+        inline double scale() const
+        {
+            return scale_;
+        }
+	
+        inline void forward_x(double* x) const 
+        {
+            *x = (*x - extent.minx() ) * scale_;   
+        }
+	
+        inline void forward_y(double* y) const 
+        {
+            *y = (extent.maxy() - *y) * scale_;
+        }
+
+        inline double forward_x_(double* x) const 
+        {
+            return (*x - extent.minx() ) * scale_;   
+        }
+	
+        inline double forward_y_(double* y) const 
+        {
+            return (extent.maxy() - *y) * scale_;
+        }
+
+        inline void backward_x(double* x) const
+        {
+            *x = extent.minx() + *x/scale_;
+        }
+	
+        inline void backward_y(double* y) const
+        {
+            *y = extent.maxy() - *y/scale_;
+        }
+	
+        inline coord2d&amp; forward(coord2d&amp; c) const
+        {
+            forward_x(&amp;c.x);
+            forward_y(&amp;c.y);
+            return c;
+        }
+
+        inline coord2d&amp; backward(coord2d&amp; c) const
+        {
+            backward_x(&amp;c.x);
+            backward_y(&amp;c.y);
+            return c;
+        }
+
+        inline Envelope&lt;double&gt; forward(const Envelope&lt;double&gt;&amp; e) const
+        {
+            double x0 = e.minx();
+            double y0 = e.miny();
+            double x1 = e.maxx();
+            double y1 = e.maxy();
+            forward_x(&amp;x0);
+            forward_y(&amp;y0);
+            forward_x(&amp;x1);
+            forward_y(&amp;y1);
+            return Envelope&lt;double&gt;(x0,y0,x1,y1);
+        }
+
+        inline Envelope&lt;double&gt; backward(const Envelope&lt;double&gt;&amp; e) const
+        {
+            double x0 = e.minx();
+            double y0 = e.miny();
+            double x1 = e.maxx();
+            double y1 = e.maxy();
+            backward_x(&amp;x0);
+            backward_y(&amp;y0);
+            backward_x(&amp;x1);
+            backward_y(&amp;y1);
+	    
+            return Envelope&lt;double&gt;(x0,y0,x1,y1);
+        }
+
+        inline CoordinateArray&amp; forward(CoordinateArray&amp; coords) const
+        {
+            for (unsigned i=0;i&lt;coords.size();++i)
+            {
+                forward(coords[i]);
+            }
+            return coords;
+        }
+	
+        inline CoordinateArray&amp; backward(CoordinateArray&amp; coords) const
+        {
+            for (unsigned i=0;i&lt;coords.size();++i)
+            {
+                backward(coords[i]);
+            }
+            return coords;
+        }
+    };
+}
+
+#endif //CTRANS_HPP

Copied: trunk/include/mapnik/datasource.hpp (from rev 307, trunk/include/datasource.hpp)
===================================================================
--- trunk/include/datasource.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/datasource.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,124 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: datasource.hpp 43 2005-04-22 18:52:47Z pavlenko $
+
+#ifndef DATASOURCE_HPP
+#define DATASOURCE_HPP
+// stl
+#include &lt;map&gt;
+#include &lt;string&gt;
+// boost
+#include &lt;boost/utility.hpp&gt;
+#include &lt;boost/shared_ptr.hpp&gt;
+// mapnik
+#include &lt;mapnik/config.hpp&gt;
+#include &lt;mapnik/ctrans.hpp&gt;
+#include &lt;mapnik/params.hpp&gt;
+#include &lt;mapnik/feature.hpp&gt;
+#include &lt;mapnik/query.hpp&gt;
+#include &lt;mapnik/feature_layer_desc.hpp&gt;
+
+namespace mapnik {    
+    typedef MAPNIK_DECL boost::shared_ptr&lt;Feature&gt; feature_ptr;
+    
+    struct MAPNIK_DECL Featureset
+    {
+        virtual feature_ptr next()=0;
+        virtual ~Featureset() {};
+    };
+
+    typedef boost::shared_ptr&lt;Featureset&gt; featureset_ptr;
+    
+    class MAPNIK_DECL datasource_exception : public std::exception
+    {
+    private:
+        const std::string message_;
+    public:
+        datasource_exception(const std::string&amp; message=std::string())
+            :message_(message) {}
+
+        ~datasource_exception() throw() {}
+        virtual const char* what() const throw()
+        {
+            return message_.c_str();
+        }
+    };
+    
+    class MAPNIK_DECL datasource : private boost::noncopyable
+    {
+        parameters params_;
+    public:        
+        enum {
+            Vector,
+            Raster
+        };
+        
+        datasource (parameters const&amp; params)
+            : params_(params) {}
+
+        parameters const&amp; params() const
+        {
+            return params_;
+        }
+        
+        virtual int type() const=0;
+        virtual featureset_ptr features(const query&amp; q) const=0;
+        virtual Envelope&lt;double&gt; const&amp; envelope() const=0;
+        virtual layer_descriptor const&amp; get_descriptor() const=0;
+        virtual ~datasource() {};
+    };
+    
+    typedef std::string datasource_name();
+    typedef datasource* create_ds(const parameters&amp; params);
+    typedef void destroy_ds(datasource *ds);
+
+    
+    class datasource_deleter
+    {
+    public:
+        void operator() (datasource* ds)
+        {
+            delete ds;
+        }
+    };
+
+    typedef boost::shared_ptr&lt;datasource&gt; datasource_p;
+    
+    
+    #define DATASOURCE_PLUGIN(classname)                              \
+        extern &quot;C&quot; MAPNIK_DECL std::string datasource_name()            \
+        {                                                               \
+            return classname::name();                                   \
+        }                                                               \
+        extern &quot;C&quot;  MAPNIK_DECL datasource* create(const parameters &amp;params) \
+        {                                                               \
+            return new classname(params);                               \
+        }                                                               \
+        extern &quot;C&quot; MAPNIK_DECL void destroy(datasource *ds)             \
+        {                                                               \
+            delete ds;                                                  \
+        }                                                               \
+        //
+}
+
+#endif //DATASOURCE_HPP

Copied: trunk/include/mapnik/datasource_cache.hpp (from rev 307, trunk/include/datasource_cache.hpp)
===================================================================
--- trunk/include/datasource_cache.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/datasource_cache.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,57 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: datasource_cache.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef DATASOURCE_CACHE_HPP
+#define DATASOURCE_CACHE_HPP
+
+// stl
+#include &lt;map&gt;
+// boost
+#include &lt;boost/shared_ptr.hpp&gt;
+// mapnik
+#include &lt;mapnik/utils.hpp&gt;
+#include &lt;mapnik/params.hpp&gt;
+#include &lt;mapnik/plugin.hpp&gt;
+#include &lt;mapnik/datasource.hpp&gt;
+
+namespace mapnik {
+    class MAPNIK_DECL datasource_cache : 
+        public singleton &lt;datasource_cache,CreateStatic&gt;
+    {
+        friend class CreateStatic&lt;datasource_cache&gt;;
+    private:
+        datasource_cache();
+        ~datasource_cache();
+        datasource_cache(const datasource_cache&amp;);
+        datasource_cache&amp; operator=(const datasource_cache&amp;);
+        static std::map&lt;std::string,boost::shared_ptr&lt;PluginInfo&gt; &gt; plugins_;
+        static bool registered_;
+        static bool insert(const std::string&amp;  name,const lt_dlhandle module);
+    public:
+        static void register_datasources(const std::string&amp; path);
+        static boost::shared_ptr&lt;datasource&gt; create(parameters const&amp; params);
+    };
+}
+
+#endif   //DATASOURCE_CACHE_HPP

Copied: trunk/include/mapnik/envelope.hpp (from rev 307, trunk/include/envelope.hpp)
===================================================================
--- trunk/include/envelope.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/envelope.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,89 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: envelope.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef ENVELOPE_HPP
+#define ENVELOPE_HPP
+
+// stl
+#include &lt;iomanip&gt;
+// mapnik
+#include &lt;mapnik/config.hpp&gt;
+#include &lt;mapnik/coord.hpp&gt;
+
+namespace mapnik {
+	template &lt;class T&gt; class MAPNIK_DECL Envelope
+    {
+    public:
+        typedef Envelope&lt;T&gt; EnvelopeType;
+    private:
+        T minx_;
+        T miny_;
+        T maxx_;
+        T maxy_;
+    public:
+        Envelope();
+        Envelope(T minx,T miny,T maxx,T maxy);
+        Envelope(const coord&lt;T,2&gt;&amp; c0,const coord&lt;T,2&gt;&amp; c1);
+        Envelope(const EnvelopeType&amp; rhs);
+        T minx() const;
+        T miny() const;
+        T maxx() const;
+        T maxy() const;
+        T width() const;
+        T height() const;
+        void width(T w);
+        void height(T h);
+        coord&lt;T,2&gt; center() const;
+        void expand_to_include(T x,T y);
+        void expand_to_include(const coord&lt;T,2&gt;&amp; c);
+        void expand_to_include(const EnvelopeType&amp; other);
+        bool contains(const coord&lt;T,2&gt; &amp;c) const;
+        bool contains(T x,T y) const;
+        bool contains(const EnvelopeType &amp;other) const;
+        bool intersects(const coord&lt;T,2&gt; &amp;c) const;
+        bool intersects(T x,T y) const;
+        bool intersects(const EnvelopeType &amp;other) const;
+        EnvelopeType intersect(const EnvelopeType&amp; other) const;
+        bool operator==(const EnvelopeType &amp;other) const;
+        void re_center(T cx,T cy);
+        void init(T x0,T y0,T x1,T y1);
+    };
+    
+    template &lt;class charT,class traits,class T&gt;
+    inline std::basic_ostream&lt;charT,traits&gt;&amp;
+    operator &lt;&lt; (std::basic_ostream&lt;charT,traits&gt;&amp; out,
+                 const Envelope&lt;T&gt;&amp; e)
+    {
+        std::basic_ostringstream&lt;charT,traits&gt; s;
+        s.copyfmt(out);
+        s.width(0);
+        s &lt;&lt;&quot;Envelope(&quot; &lt;&lt; std::setprecision(16) 
+          &lt;&lt; e.minx() &lt;&lt; &quot;,&quot; &lt;&lt; e.miny() &lt;&lt;&quot;,&quot; 
+          &lt;&lt; e.maxx() &lt;&lt; &quot;,&quot; &lt;&lt; e.maxy() &lt;&lt;&quot;)&quot;;
+        out &lt;&lt; s.str();
+        return out;
+    }
+}
+
+#endif // ENVELOPE_HPP

Copied: trunk/include/mapnik/expression.hpp (from rev 307, trunk/include/expression.hpp)
===================================================================
--- trunk/include/expression.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/expression.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,126 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef EXPRESSION_HPP
+#define EXPRESSION_HPP
+
+#include &lt;mapnik/value.hpp&gt;
+#include &lt;mapnik/filter_visitor.hpp&gt;
+
+namespace mapnik {
+    template &lt;typename FeatureT&gt; class filter_visitor;
+    template &lt;typename FeatureT&gt;
+    class expression
+    {
+    public:
+        virtual value get_value(FeatureT const&amp; feature) const=0;
+        virtual void accept(filter_visitor&lt;FeatureT&gt;&amp; v)=0;
+        virtual expression&lt;FeatureT&gt;* clone() const=0;
+        virtual std::string to_string() const=0;
+        virtual ~expression() {}
+    };
+
+    template &lt;typename FeatureT&gt; 
+    class literal : public expression&lt;FeatureT&gt;
+    {
+    public:
+        literal(int val)
+            : expression&lt;FeatureT&gt;(),
+              value_(val) {}
+        literal(double val)
+            : expression&lt;FeatureT&gt;(),
+              value_(val) {}
+        literal(std::string const&amp; val)
+            : expression&lt;FeatureT&gt;(),
+              value_(val) {}
+        literal(literal const&amp; other)
+            : expression&lt;FeatureT&gt;(),
+              value_(other.value_) {}
+	
+        value get_value(FeatureT const&amp; /*feature*/) const
+        {
+            return value_;
+        }
+        void accept(filter_visitor&lt;FeatureT&gt;&amp; v)
+        {
+            v.visit(*this);
+        }
+        expression&lt;FeatureT&gt;* clone() const
+        {
+            return new literal(*this); 
+        }
+        std::string to_string() const
+        {
+            return value_.to_expression_string();
+        }
+        ~literal() {}
+    private:
+        value value_;
+    };
+  
+
+    template &lt;typename FeatureT&gt; 
+    class property : public expression&lt;FeatureT&gt;
+    {
+    public:
+        property(std::string const&amp; name)
+            : expression&lt;FeatureT&gt;(),
+              name_(name)
+	    {}
+	
+        property(property const&amp; other)
+            : expression&lt;FeatureT&gt;(),
+              name_(other.name_)
+	    {}
+
+        value get_value(FeatureT const&amp; feature) const
+        {
+            return feature[name_];
+        }
+        void accept(filter_visitor&lt;FeatureT&gt;&amp; v)
+        {
+            v.visit(*this);
+        }
+        expression&lt;FeatureT&gt;* clone() const
+        {
+            return new property(*this); 
+        }
+        std::string const&amp; name() const
+        {
+            return name_;
+        }
+
+        std::string to_string() const
+        {
+            return &quot;[&quot;+name_+&quot;]&quot;;
+        }
+
+        ~property() {}
+
+    private:
+	    std::string name_;
+    };
+}
+
+#endif //EXPRESSION_HPP

Copied: trunk/include/mapnik/factory.hpp (from rev 307, trunk/include/factory.hpp)
===================================================================
--- trunk/include/factory.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/factory.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,92 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: factory.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef FACTORY_HPP
+#define FACTORY_HPP
+
+// stl
+#include &lt;stdexcept&gt;
+#include &lt;map&gt;
+// mapnik
+#include &lt;mapnik/utils.hpp&gt;
+
+namespace mapnik {
+    template &lt;typename key_type,
+              typename product_type&gt;
+    class default_factory_error
+    {
+    public:
+        struct factory_exception : public std::exception
+        {
+            const char* what() const throw()
+            {
+                return &quot;uknown object type&quot;;
+            }
+        };
+        static product_type* on_unknown_type(const key_type&amp;)
+        {
+            return 0;
+        }
+    };
+
+    template
+    &lt;
+        typename product_type,
+        typename key_type,
+        typename product_creator=product_type* (*)(),
+        template &lt;typename,typename&gt; class factory_error_policy=default_factory_error
+        &gt;
+    class factory : public singleton&lt;factory &lt;product_type,
+                                              key_type,
+                                              product_creator,factory_error_policy&gt; &gt;,
+        factory_error_policy &lt;key_type,product_type&gt;
+    {
+    private:
+        typedef std::map&lt;key_type,product_creator&gt; product_map;
+        product_map map_;
+    public:
+
+        bool register_product(const key_type&amp; key,product_creator creator)
+        {
+            return map_.insert(typename product_map::value_type(key,creator)).second;
+        }
+
+        bool unregister_product(const key_type&amp; key)
+        {
+            return map_.erase(key)==1;
+        }
+
+        product_type* create_object(const key_type&amp; key,const std::string&amp; file)
+        {
+            typename product_map::const_iterator pos=map_.find(key);
+            if (pos!=map_.end())
+            {
+                return (pos-&gt;second)(file);
+            }
+            return on_unknown_type(key);
+        }
+    };
+}
+
+#endif //FACTORY_HPP

Copied: trunk/include/mapnik/feature.hpp (from rev 307, trunk/include/feature.hpp)
===================================================================
--- trunk/include/feature.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/feature.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,121 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: feature.hpp 40 2005-04-13 20:20:46Z pavlenko $
+
+#ifndef FEATURE_HPP
+#define FEATURE_HPP
+// stl
+#include &lt;map&gt;
+// boost
+#include &lt;boost/property_map.hpp&gt;
+#include &lt;boost/utility.hpp&gt;
+#include &lt;boost/shared_ptr.hpp&gt;
+// mapnik
+#include &lt;mapnik/value.hpp&gt;
+#include &lt;mapnik/geometry.hpp&gt;
+#include &lt;mapnik/raster.hpp&gt;
+
+namespace mapnik {
+    typedef boost::shared_ptr&lt;raster&gt; raster_ptr;    
+    typedef boost::associative_property_map&lt;
+        std::map&lt;std::string,value
+                 &gt; &gt; properties;
+    
+    template &lt;typename T1,typename T2&gt;
+    struct feature : public properties,
+                     private boost::noncopyable
+    {
+    public:
+        typedef T1 geometry_type;
+        typedef T2 raster_type;
+    private:
+        int id_;
+        geometry_type geom_;
+        raster_type   raster_;
+        std::map&lt;std::string,value&gt; props_;
+    public:
+        explicit feature(int id)
+            : properties(props_),
+              id_(id),
+              geom_(),
+              raster_() {}
+
+        feature(int id,const geometry_type&amp; geom)
+            : properties(props_),
+              id_(id),
+              geom_(geom),
+              raster_() {}
+
+        int id() const 
+        {
+            return id_;
+        }
+	
+        void set_geometry(geometry_type&amp; geom)
+        {
+            geom_=geom;
+        }
+	
+        geometry_type const&amp; get_geometry() const
+        {
+            return geom_;
+        }
+        
+        const raster_type&amp; get_raster() const
+        {
+            return raster_;
+        }
+        void set_raster(raster_type const&amp; raster)
+        {
+            raster_=raster;
+        }
+	
+        const properties&amp; get_properties() const 
+        {
+            return props_;
+        }
+	
+        std::string to_string() const
+        {
+            std::stringstream ss;
+            ss &lt;&lt; &quot;feature (&quot; &lt;&lt; std::endl;
+            for (std::map&lt;std::string,value&gt;::const_iterator itr=props_.begin();
+                 itr != props_.end();++itr)
+            {
+                ss &lt;&lt; &quot;  &quot; &lt;&lt; itr-&gt;first  &lt;&lt; &quot;:&quot; &lt;&lt;  itr-&gt;second &lt;&lt; std::endl;
+            }
+            ss &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
+            return ss.str();
+        }
+    };
+
+    typedef feature&lt;geometry_ptr,raster_ptr&gt; Feature;
+    
+    inline std::ostream&amp; operator&lt;&lt; (std::ostream &amp; out,Feature const&amp; f)
+    {
+        out &lt;&lt; f.to_string();
+    	return out;
+    }
+}
+
+#endif //FEATURE_HPP

Copied: trunk/include/mapnik/feature_factory.hpp (from rev 307, trunk/include/feature_factory.hpp)
===================================================================
--- trunk/include/feature_factory.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/feature_factory.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,41 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef FEATURE_FACTORY_HPP
+#define FEATURE_FACTORY_HPP
+
+#include &lt;mapnik/feature.hpp&gt;
+
+namespace mapnik
+{
+    struct feature_factory
+    {
+        static Feature* create (int fid)
+        {
+            return new Feature(fid);
+        }
+    }; 
+}
+
+#endif //FEATURE_FACTORY_HPP

Copied: trunk/include/mapnik/feature_layer_desc.hpp (from rev 307, trunk/include/feature_layer_desc.hpp)
===================================================================
--- trunk/include/feature_layer_desc.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/feature_layer_desc.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,250 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef FEATURE_LAYER_DESC_HPP
+#define FEATURE_LAYER_DESC_HPP
+
+#include &lt;string&gt;
+#include &lt;vector&gt;
+#include &lt;iostream&gt;
+
+namespace mapnik
+{
+    
+    using std::string;
+    using std::vector;
+    using std::clog;
+    using std::endl;
+    
+    enum {
+        Integer=1,
+        Float  =2,
+        Double =3,
+        String =4,
+        Geometry=5,
+        Object=6 
+    };
+    
+    class attribute_descriptor
+    {
+    public:
+        attribute_descriptor(string const&amp; name,unsigned type,
+                             bool primary_key=false,
+                             int size=-1,
+                             int precision=-1)
+            : name_(name),
+              type_(type),
+              primary_key_(primary_key),
+              size_(size),
+              precision_(precision) {}
+	      
+        attribute_descriptor(attribute_descriptor const&amp; other)
+            : name_(other.name_),
+              type_(other.type_),
+              primary_key_(other.primary_key_),
+              size_(other.size_),
+              precision_(other.precision_) {}
+
+        attribute_descriptor&amp; operator=(attribute_descriptor const&amp; other)
+        {
+            if (this == &amp;other)
+                return *this;	    
+            name_=other.name_;
+            type_=other.type_;
+            primary_key_=other.primary_key_;
+            size_=other.size_;
+            precision_=other.precision_;
+            return *this;
+        }
+        string const&amp; get_name() const
+        {
+            return name_;
+        }
+        unsigned  get_type() const
+        {
+            return type_;
+        }
+        bool is_primary_key() const
+        {
+            return primary_key_;
+        }
+        int get_size() const
+        {
+            return size_;
+        } 
+	
+        int get_precision() const
+        {
+            return precision_;
+        }
+    private:
+        string name_;
+        int type_;
+        bool primary_key_;
+        int size_;
+        int precision_;
+    };
+     
+    template &lt;typename charT,typename traits&gt;
+    inline std::basic_ostream&lt;charT,traits&gt;&amp;
+    operator &lt;&lt; (std::basic_ostream&lt;charT,traits&gt;&amp; out,
+                 attribute_descriptor const&amp; ad)
+    {
+        out &lt;&lt; &quot;name=&quot; &lt;&lt; ad.get_name() &lt;&lt; endl;
+        out &lt;&lt; &quot;type=&quot; &lt;&lt; ad.get_type() &lt;&lt; endl;
+        out &lt;&lt; &quot;size=&quot; &lt;&lt; ad.get_size() &lt;&lt; endl;
+        return out;
+    }
+
+    class layer_descriptor 
+    {
+    public:
+        layer_descriptor(string const&amp; name,int srid=-1)
+            : name_(name),
+              srid_(srid) {}
+
+        layer_descriptor(layer_descriptor const&amp; other)
+            : name_(other.name_),
+              srid_(other.srid_),
+              desc_ar_(other.desc_ar_) {}
+	
+        void set_name(string const&amp; name)
+        {
+            name_=name;
+        }
+        string const&amp; get_name() const
+        {
+            return name_;
+        }
+	
+        void set_srid(int srid) 
+        {
+            srid_=srid;
+        }
+	
+        int get_srid() const
+        {
+            return srid_;
+        }
+
+        void add_descriptor(attribute_descriptor const&amp; desc)
+        {
+            desc_ar_.push_back(desc);
+        }
+	
+        vector&lt;attribute_descriptor&gt; const&amp; get_descriptors() const
+        {
+            return desc_ar_;
+        }	
+        vector&lt;attribute_descriptor&gt;&amp; get_descriptors()
+        {
+            return desc_ar_;
+        }
+    private:
+        string name_;
+        int srid_;
+        vector&lt;attribute_descriptor&gt; desc_ar_;
+    };
+    
+    template &lt;typename charT,typename traits&gt;
+    inline std::basic_ostream&lt;charT,traits&gt;&amp;
+    operator &lt;&lt; (std::basic_ostream&lt;charT,traits&gt;&amp; out,
+                 layer_descriptor const&amp; ld)
+    {
+        out &lt;&lt; &quot;name=&quot; &lt;&lt; ld.get_name() &lt;&lt; endl;
+        out &lt;&lt; &quot;srid=&quot; &lt;&lt; ld.get_srid() &lt;&lt; endl;
+        vector&lt;attribute_descriptor&gt; const&amp; desc_ar=ld.get_descriptors();
+        vector&lt;attribute_descriptor&gt;::const_iterator pos=desc_ar.begin();
+        while (pos != desc_ar.end())
+        {
+            out &lt;&lt; *pos++ &lt;&lt; endl;
+	    
+        }
+        return out;
+    }
+    /*    
+          bool layer_descriptor_to_wkb(layer_descriptor const&amp; desc,array&lt;&gt;&amp; wkb)
+          {
+          //srid	
+          int srid = desc.get_srid();
+          wkb.write(&amp;srid,sizeof(int));
+
+          //attribute descriptors
+          vector&lt;attribute_descriptor&gt; const&amp; desc_ar = desc.get_descriptors();
+          vector&lt;attribute_descriptor&gt;::const_iterator itr=desc_ar.begin();
+          size_t num_desc = desc_ar.size();
+          wkb.write(&amp;num_desc,sizeof(int));
+	
+          while (itr != desc_ar.end())
+          {
+          string name = itr-&gt;get_name();
+          wkb.write(name.c_str(),name.size()+1);
+	       
+          unsigned type = static_cast&lt;int&gt;(itr-&gt;get_type());
+          wkb.write(&amp;type,sizeof(unsigned));
+
+          bool prim_key = itr-&gt;is_primary_key();
+          wkb.write(&amp;prim_key,sizeof(bool));
+
+          int size = itr-&gt;get_size();
+          wkb.write(&amp;size,sizeof(int));
+            
+          ++itr;
+          }	
+          return true;
+          }
+    
+          bool layer_descriptor_from_wkb(const char* wkb, layer_descriptor &amp;desc)
+          {
+          unsigned pos=0;
+          int srid;
+	
+          memcpy(&amp;srid,wkb+pos,sizeof(int));
+          desc.set_srid(srid);
+          pos+=sizeof(int);
+	
+          int num_desc;
+          memcpy(&amp;num_desc,wkb+pos,sizeof(int));
+          pos+=sizeof(int);
+	
+          for (int i=0;i&lt;num_desc;++i)
+          {
+          string name = wkb+pos;
+          pos += name.size()+1;
+          //std::clog&lt;&lt;&quot;name=&quot;&lt;&lt;name&lt;&lt;&quot;\n&quot;;
+	    
+          int type;
+          memcpy(&amp;type,wkb+pos,sizeof(int));
+          pos += sizeof(int);
+          attribute_descriptor ad(name,type);
+          desc.add_descriptor(ad);
+          //todo!!!
+          pos += 4+1;
+          }
+          return true;
+          }
+    */    
+}
+
+#endif //FEATURE_LAYER_DESC_HPP

Copied: trunk/include/mapnik/feature_style_processor.hpp (from rev 307, trunk/include/feature_style_processor.hpp)
===================================================================
--- trunk/include/feature_style_processor.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/feature_style_processor.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,189 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef FEATURE_STYLE_PROCESSOR_HPP
+#define FEATURE_STYLE_PROCESSOR_HPP
+
+//stl
+#include &lt;vector&gt;
+// boost
+#include &lt;boost/progress.hpp&gt;
+// mapnik
+#include &lt;mapnik/envelope.hpp&gt;
+#include &lt;mapnik/datasource.hpp&gt;
+#include &lt;mapnik/layer.hpp&gt;
+#include &lt;mapnik/map.hpp&gt;
+#include &lt;mapnik/attribute_collector.hpp&gt;
+#include &lt;mapnik/utils.hpp&gt;
+
+namespace mapnik
+{       
+    template &lt;typename Processor&gt;
+    class feature_style_processor 
+    {
+        struct symbol_dispatch : public boost::static_visitor&lt;&gt;
+        {
+            symbol_dispatch (Processor &amp; output,Feature const&amp; f)
+                : output_(output),f_(f) {}
+	    
+            template &lt;typename T&gt;
+            void operator () (T const&amp; sym) const
+            {
+                output_.process(sym,f_);
+            }
+
+            Processor &amp; output_;
+            Feature const&amp; f_;
+        };
+    public:
+        feature_style_processor(Map const&amp; m)
+            : m_(m) {}
+	
+        void apply()
+        {
+            boost::progress_timer t;
+            Processor &amp; p = static_cast&lt;Processor&amp;&gt;(*this);
+
+            p.start_map_processing(m_);
+	    
+            std::vector&lt;Layer&gt;::const_iterator itr = m_.layers().begin();
+            while (itr != m_.layers().end())
+            {
+                if (itr-&gt;isVisible(m_.scale()) &amp;&amp; 
+                    itr-&gt;envelope().intersects(m_.getCurrentExtent()))
+                {
+                    apply_to_layer(*itr,p);
+                }
+                ++itr;
+            }
+            p.end_map_processing(m_);
+        }	
+    private:
+        void apply_to_layer(Layer const&amp; lay,Processor &amp; p)
+        {
+            p.start_layer_processing(lay);
+            datasource *ds=lay.datasource().get();
+            if (ds)
+            {
+                Envelope&lt;double&gt; const&amp; bbox=m_.getCurrentExtent();
+                double scale = m_.scale();
+	
+                std::vector&lt;std::string&gt; const&amp; style_names = lay.styles();
+                std::vector&lt;std::string&gt;::const_iterator stylesIter = style_names.begin();
+                while (stylesIter != style_names.end())
+                {
+                    std::set&lt;std::string&gt; names;
+                    attribute_collector&lt;Feature&gt; collector(names);
+                    std::vector&lt;rule_type*&gt; if_rules;
+                    std::vector&lt;rule_type*&gt; else_rules;
+		
+                    bool active_rules=false;
+		    
+                    feature_type_style const&amp; style=m_.find_style(*stylesIter++);
+		    
+                    const std::vector&lt;rule_type&gt;&amp; rules=style.get_rules();
+                    std::vector&lt;rule_type&gt;::const_iterator ruleIter=rules.begin();
+		    
+                    query q(bbox); //BBOX query
+                    while (ruleIter!=rules.end())
+                    {
+                        if (ruleIter-&gt;active(scale))
+                        {
+                            active_rules=true;
+                            ruleIter-&gt;accept(collector);
+
+                            if (ruleIter-&gt;has_else_filter())
+                            {
+                                else_rules.push_back(const_cast&lt;rule_type*&gt;(&amp;(*ruleIter)));
+                            }
+                            else
+                            {
+                                if_rules.push_back(const_cast&lt;rule_type*&gt;(&amp;(*ruleIter))); 		    
+                            }
+                        }
+                        ++ruleIter;
+                    }
+                    std::set&lt;std::string&gt;::const_iterator namesIter=names.begin();
+                    // push all property names
+                    while (namesIter!=names.end())
+                    {
+                        q.add_property_name(*namesIter);
+                        ++namesIter;
+                    }
+                    if (active_rules)
+                    {
+                        featureset_ptr fs=ds-&gt;features(q);
+                        if (fs)
+                        {   	    
+                            feature_ptr feature;
+                            while ((feature = fs-&gt;next()))
+                            {		   
+                                bool do_else=true;		    
+                                std::vector&lt;rule_type*&gt;::const_iterator itr=if_rules.begin();
+                                while (itr!=if_rules.end())
+                                {
+                                    filter_ptr const&amp; filter=(*itr)-&gt;get_filter();    
+                                    if (filter-&gt;pass(*feature))
+                                    {   
+                                        do_else=false;
+                                        const symbolizers&amp; symbols = (*itr)-&gt;get_symbolizers();
+                                        symbolizers::const_iterator symIter=symbols.begin();
+                                        while (symIter!=symbols.end())
+                                        {   
+                                            boost::apply_visitor
+                                                (symbol_dispatch(p,*feature),*symIter++);
+                                        }
+                                    }			    
+                                    ++itr;
+                                }
+                                if (do_else)
+                                {
+                                    //else filter
+                                    std::vector&lt;rule_type*&gt;::const_iterator itr=
+                                        else_rules.begin();
+                                    while (itr != else_rules.end())
+                                    {
+                                        const symbolizers&amp; symbols = (*itr)-&gt;get_symbolizers();
+                                        symbolizers::const_iterator symIter=symbols.begin();
+                                        while (symIter!=symbols.end())
+                                        {
+                                            boost::apply_visitor
+                                                (symbol_dispatch(p,*feature),*symIter++);
+                                        }
+                                        ++itr;
+                                    }
+                                }	  
+                            }
+                        }
+                    }
+                }
+            }
+            p.end_layer_processing(lay);
+        }
+	
+        Map const&amp; m_;
+    };
+}
+
+#endif //FEATURE_STYLE_PROCESSOR_HPP

Copied: trunk/include/mapnik/feature_type_style.hpp (from rev 307, trunk/include/feature_type_style.hpp)
===================================================================
--- trunk/include/feature_type_style.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/feature_type_style.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,67 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef FEATURE_TYPE_STYLE_HPP
+#define FEATURE_TYPE_STYLE_HPP
+// stl
+#include &lt;vector&gt;
+// mapnik 
+#include &lt;mapnik/rule.hpp&gt;
+#include &lt;mapnik/feature.hpp&gt;
+
+namespace mapnik
+{
+    typedef std::vector&lt;rule_type&gt; rules;
+    class feature_type_style
+    {
+    private:
+        rules  rules_;
+    public:
+        feature_type_style() {}
+
+        feature_type_style(feature_type_style const&amp; rhs)
+            : rules_(rhs.rules_) {}
+	
+        feature_type_style&amp; operator=(feature_type_style const&amp; rhs)
+        {
+            if (this == &amp;rhs) return *this;
+            rules_=rhs.rules_;
+            return *this;
+        }
+	
+        void add_rule(rule_type const&amp; rule)
+        {
+            rules_.push_back(rule);
+        } 
+	
+        rules const&amp; get_rules() const
+        {
+            return rules_;
+        }
+	
+        ~feature_type_style() {}
+    };
+}
+
+#endif //FEATURE_TYPE_STYLE_HPP

Copied: trunk/include/mapnik/fill.hpp (from rev 307, trunk/include/fill.hpp)

Copied: trunk/include/mapnik/filter.hpp (from rev 307, trunk/include/filter.hpp)
===================================================================
--- trunk/include/filter.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/filter.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,90 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef FILTER_HPP
+#define FILTER_HPP
+
+#include &lt;mapnik/config.hpp&gt;
+#include &lt;mapnik/feature.hpp&gt;
+
+namespace mapnik
+{
+    template &lt;typename FeatureT&gt; class filter_visitor;
+    template &lt;typename FeatureT&gt;
+    class MAPNIK_DECL filter
+    {
+	public:
+		virtual bool pass(const FeatureT&amp; feature) const=0; 
+		virtual filter&lt;FeatureT&gt;* clone() const=0;
+		virtual void accept(filter_visitor&lt;FeatureT&gt;&amp; v) = 0;
+        virtual std::string to_string() const=0;
+		virtual ~filter() {}
+    };
+    
+    typedef boost::shared_ptr&lt;filter&lt;Feature&gt; &gt; filter_ptr;
+    
+    template &lt;typename FeatureT&gt;
+    class all_filter : public filter&lt;FeatureT&gt;
+    {
+	public:
+		bool pass (const FeatureT&amp;) const
+		{
+			return true;
+		}
+	
+		filter&lt;FeatureT&gt;* clone() const
+		{
+			return new all_filter&lt;FeatureT&gt;;
+		}
+		std::string to_string() const
+		{
+			return &quot;true&quot;;
+		}  
+        void accept(filter_visitor&lt;FeatureT&gt;&amp;) {}
+		virtual ~all_filter() {}
+    };
+      
+    template &lt;typename FeatureT&gt;
+    class none_filter : public filter&lt;FeatureT&gt;
+    {
+	public:
+		bool pass (const FeatureT&amp;) const
+		{
+			return false;
+		}
+	
+		filter&lt;FeatureT&gt;* clone() const
+		{
+			return new none_filter&lt;FeatureT&gt;;
+		}
+		std::string to_string() const
+		{
+			return &quot;false&quot;;
+		}  
+	    void accept(filter_visitor&lt;FeatureT&gt;&amp;) {}
+		virtual ~none_filter() {}
+	};
+}
+
+#endif //FILTER_HPP

Copied: trunk/include/mapnik/filter_expression.hpp (from rev 307, trunk/include/filter_expression.hpp)
===================================================================
--- trunk/include/filter_expression.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/filter_expression.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,67 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef FILTER_TO_STRING_HPP
+#define FILTER_TO_STRING_HPP
+
+// stl
+#include &lt;set&gt;
+// mapnik
+#include &lt;mapnik/filter.hpp&gt;
+#include &lt;mapnik/expression.hpp&gt;
+
+namespace mapnik
+{
+    template &lt;typename FeatureT&gt;
+    class filter_to_string : public filter_visitor&lt;FeatureT&gt;
+    {
+    private:
+        std::string text_;
+    public:
+        filter_to_string() {}
+        void visit(filter&lt;FeatureT&gt;&amp; /*filter*/) 
+        { 
+            //not interested
+        }
+        void visit(expression&lt;FeatureT&gt;&amp; exp)
+        {
+            property&lt;FeatureT&gt;* pf;
+            if ((pf = dynamic_cast&lt;property&lt;FeatureT&gt;*&gt;(&amp;exp)))
+            {
+                names_.insert(pf-&gt;name());
+            }
+        }
+        std::string const&amp; text() const
+        {
+            return text_;
+        }
+	
+        virtual ~filter_to_string() {}
+    private:
+        filter_to_string(filter_to_string const&amp;);
+        filter_to_string&amp; operator=(filter_to_string const&amp;);
+    };
+}
+
+#endif //FILTER_TO_STRING

Copied: trunk/include/mapnik/filter_factory.hpp (from rev 307, trunk/include/filter_factory.hpp)
===================================================================
--- trunk/include/filter_factory.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/filter_factory.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,60 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef FILTER_FACTORY_HPP
+#define FILTER_FACTORY_HPP
+
+#include &lt;mapnik/filter_parser.hpp&gt;
+
+namespace mapnik
+{
+    using std::string;
+    
+    template&lt;typename FeatureT&gt;
+    class MAPNIK_DECL filter_factory
+    {
+    public:
+        static filter_ptr compile(string const&amp; str)
+        {
+            stack&lt;shared_ptr&lt;filter&lt;FeatureT&gt; &gt; &gt; filters;
+            stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt; exps;
+            filter_grammar&lt;FeatureT&gt; grammar(filters,exps);
+            char const *text = str.c_str();
+            parse_info&lt;&gt; info = parse(text,text+strlen(text),grammar,space_p);
+            if (info.full &amp;&amp; !filters.empty())
+            {
+                return filters.top();	
+            }
+            else 
+            {
+                clog &lt;&lt; &quot;failed at :&quot; &lt;&lt; info.stop &lt;&lt; &quot;\n&quot;;
+                return filter_ptr(new none_filter&lt;FeatureT&gt;());
+            }  
+        }
+    };
+    
+    MAPNIK_DECL filter_ptr create_filter (std::string const&amp; wkt);
+}
+
+#endif //FILTER_FACTORY_HPP

Copied: trunk/include/mapnik/filter_parser.hpp (from rev 307, trunk/include/filter_parser.hpp)
===================================================================
--- trunk/include/filter_parser.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/filter_parser.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,453 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+
+//$Id$
+
+#ifndef FILTER_PARSER_HPP
+#define FILTER_PARSER_HPP
+// stl
+#include &lt;stack&gt;
+#include &lt;iostream&gt;
+// boost
+#include &lt;boost/shared_ptr.hpp&gt;
+#include &lt;boost/spirit/core.hpp&gt;
+#include &lt;boost/spirit/symbols.hpp&gt;
+#include &lt;boost/spirit/utility/confix.hpp&gt;
+#include &lt;boost/spirit/utility/escape_char.hpp&gt;
+#include &lt;boost/spirit/utility/chset.hpp&gt; 
+// mapnik
+#include &lt;mapnik/value.hpp&gt;
+#include &lt;mapnik/comparison.hpp&gt;
+#include &lt;mapnik/math_expr.hpp&gt;
+#include &lt;mapnik/expression.hpp&gt;
+#include &lt;mapnik/filter.hpp&gt;
+#include &lt;mapnik/regex_filter.hpp&gt;
+#include &lt;mapnik/logical.hpp&gt;
+
+using namespace boost::spirit;
+using boost::shared_ptr;
+
+namespace mapnik
+{    
+    using std::string;
+    using std::clog;
+    using std::stack;
+
+    template &lt;typename FeatureT&gt;
+    struct push_integer
+    {
+        push_integer(stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt;&amp; exprs)
+            : exprs_(exprs) {}
+	
+        void operator() (int val) const
+        {
+            exprs_.push(shared_ptr&lt;expression&lt;FeatureT&gt; &gt;
+                        ( new literal&lt;FeatureT&gt;(val)));
+        }
+        stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt;&amp; exprs_;
+    };
+   
+    template &lt;typename FeatureT&gt;
+    struct push_real
+    {
+        push_real(stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt;&amp; exprs)
+            : exprs_(exprs) {}
+        void operator() (double val) const
+        {
+            exprs_.push(shared_ptr&lt;expression&lt;FeatureT&gt; &gt;(new literal&lt;FeatureT&gt;(val)));
+        }
+        stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt;&amp; exprs_;
+    };
+    
+    template &lt;typename FeatureT&gt;
+    struct push_string
+    {
+        push_string(stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt;&amp; exprs)
+            : exprs_(exprs) {}
+	
+        template &lt;typename Iter&gt;
+        void operator() (Iter start,Iter end) const
+        {
+            string str(start,end);
+            char quote='\\';
+            string::size_type idx;
+            idx = str.find(quote);
+            while (idx != string::npos)
+            {	    		
+                str.erase(idx,1);
+                idx = str.find(quote);
+            }
+            exprs_.push(shared_ptr&lt;expression&lt;FeatureT&gt; &gt;(new literal&lt;FeatureT&gt;(str)));
+        }
+        stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt;&amp; exprs_;
+    };
+    
+    template &lt;typename FeatureT&gt;
+    struct push_property
+    {
+        push_property(stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt;&amp; exprs)
+            : exprs_(exprs) {}
+	
+        template &lt;typename Iter&gt;
+        void operator() (Iter start,Iter end) const
+        {
+            string str(start,end);
+            exprs_.push(shared_ptr&lt;expression&lt;FeatureT&gt; &gt;(new property&lt;FeatureT&gt;(str)));
+        }
+        stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt;&amp; exprs_;
+    };
+
+    template &lt;typename FeatureT,typename Op&gt;
+    struct compose_expression
+    {
+        compose_expression(stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt;&amp; exprs)
+            : exprs_(exprs) {}
+
+        template &lt;typename Iter&gt;
+        void operator() (Iter,Iter) const
+        {
+            if (exprs_.size()&gt;=2)
+            {
+                shared_ptr&lt;expression&lt;FeatureT&gt; &gt; right = exprs_.top();
+                exprs_.pop();
+                shared_ptr&lt;expression&lt;FeatureT&gt; &gt; left = exprs_.top();
+                exprs_.pop();
+                if (left &amp;&amp; right)
+                {
+                    exprs_.push(shared_ptr&lt;expression&lt;FeatureT&gt; &gt;
+                                (new mapnik::math_expr_b&lt;FeatureT,Op&gt;(*left,*right)));
+                }
+            }
+        }
+        stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt;&amp; exprs_;
+    };
+    
+    template &lt;typename FeatureT&gt;
+    struct compose_regex
+    {
+        compose_regex(stack&lt;shared_ptr&lt;filter&lt;FeatureT&gt; &gt; &gt;&amp; filters,
+                      stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt;&amp; exprs)
+            : filters_(filters),exprs_(exprs) {}
+
+        template &lt;typename Iter&gt;
+        void operator() (Iter start,Iter end) const
+        {
+            if (exprs_.size()&gt;=1)
+            {
+                shared_ptr&lt;expression&lt;FeatureT&gt; &gt; exp = exprs_.top();
+                exprs_.pop();
+                if (exp)
+                {		    
+                    std::string pattern(start,end);
+                    try 
+                    {
+                        filters_.push(shared_ptr&lt;filter&lt;FeatureT&gt; &gt;
+                                      (new regex_filter&lt;FeatureT&gt;(*exp,pattern)));
+                    }
+                    catch (...)//boost::regex_error&amp; ex)
+                    {
+                        clog&lt;&lt;&quot;error\n&quot;;//ex.what()&lt;&lt;&quot;\n&quot;;
+                    }
+		    
+                }
+            }
+        }
+        stack&lt;shared_ptr&lt;filter&lt;FeatureT&gt; &gt; &gt;&amp; filters_;
+        stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt;&amp; exprs_;
+    };
+
+  
+    template &lt;typename FeatureT,typename Op&gt;
+    struct compose_filter
+    {
+        compose_filter(stack&lt;shared_ptr&lt;filter&lt;FeatureT&gt; &gt; &gt;&amp; filters,
+                       stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt;&amp; exprs)
+            : filters_(filters),exprs_(exprs) {}
+
+        template &lt;typename Iter&gt;
+        void operator() (Iter,Iter) const
+        {
+            if (exprs_.size()&gt;=2)
+            {
+                shared_ptr&lt;expression&lt;FeatureT&gt; &gt; right = exprs_.top();
+                exprs_.pop();
+                shared_ptr&lt;expression&lt;FeatureT&gt; &gt; left = exprs_.top();
+                exprs_.pop();
+                if (left &amp;&amp; right)
+                {
+                    filters_.push(shared_ptr&lt;filter&lt;FeatureT&gt; &gt;(new compare_filter&lt;FeatureT,Op&gt;(*left,*right)));
+                }
+            }
+        }
+        stack&lt;shared_ptr&lt;filter&lt;FeatureT&gt; &gt; &gt;&amp; filters_;
+        stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt;&amp; exprs_;
+    };
+    
+    template &lt;typename FeatureT&gt;
+    struct compose_and_filter
+    {
+        compose_and_filter(stack&lt;shared_ptr&lt;filter&lt;FeatureT&gt; &gt; &gt;&amp; filters)
+            : filters_(filters) {}
+
+        template &lt;typename Iter&gt;
+        void operator() (Iter,Iter) const
+        {
+            if (filters_.size()&gt;=2)
+            {
+                shared_ptr&lt;filter&lt;FeatureT&gt; &gt; right = filters_.top();
+                filters_.pop();
+                shared_ptr&lt;filter&lt;FeatureT&gt; &gt; left = filters_.top();
+                filters_.pop();
+                if (left &amp;&amp; right)
+                {
+                    filters_.push(shared_ptr&lt;filter&lt;FeatureT&gt; &gt;
+                                  (new logical_and&lt;FeatureT&gt;(*left,*right)));
+                }
+            }
+        }
+        stack&lt;shared_ptr&lt;filter&lt;FeatureT&gt; &gt; &gt;&amp; filters_;
+    };
+    
+    template &lt;typename FeatureT&gt;
+    struct compose_or_filter
+    {
+        compose_or_filter(stack&lt;shared_ptr&lt;filter&lt;FeatureT&gt; &gt; &gt;&amp; filters)
+            : filters_(filters) {}
+
+        template &lt;typename Iter&gt;
+        void operator() (Iter,Iter) const
+        {
+            if (filters_.size()&gt;=2)
+            {
+                shared_ptr&lt;filter&lt;FeatureT&gt; &gt; right = filters_.top();
+                filters_.pop();
+                shared_ptr&lt;filter&lt;FeatureT&gt; &gt; left = filters_.top();
+                filters_.pop();
+                if (left &amp;&amp; right)
+                {
+                    filters_.push(shared_ptr&lt;filter&lt;FeatureT&gt; &gt;
+                                  (new logical_or&lt;FeatureT&gt;(*left,*right)));
+                }
+            }
+        }
+        stack&lt;shared_ptr&lt;filter&lt;FeatureT&gt; &gt; &gt;&amp; filters_;
+    };
+    
+    template &lt;typename FeatureT&gt;
+    struct compose_not_filter
+    {
+        compose_not_filter(stack&lt;shared_ptr&lt;filter&lt;FeatureT&gt; &gt; &gt;&amp; filters)
+            : filters_(filters) {}
+
+        template &lt;typename Iter&gt;
+        void operator() (Iter,Iter) const
+        {
+            if (filters_.size()&gt;=1)
+            {
+                shared_ptr&lt;filter&lt;FeatureT&gt; &gt; filter_ = filters_.top();
+                filters_.pop();
+                if (filter_)
+                {
+                    filters_.push(shared_ptr&lt;filter&lt;FeatureT&gt; &gt;(new logical_not&lt;FeatureT&gt;(*filter_)));
+                }
+            }
+        }
+        stack&lt;shared_ptr&lt;filter&lt;FeatureT&gt; &gt; &gt;&amp; filters_;
+    };
+    
+    template &lt;typename FeatureT&gt;
+    struct filter_grammar : public grammar&lt;filter_grammar&lt;FeatureT&gt; &gt;
+    {
+        filter_grammar(stack&lt;shared_ptr&lt;filter&lt;FeatureT&gt; &gt; &gt;&amp; filters_,
+                       stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt;&amp; exprs_)
+            : filters(filters_),exprs(exprs_) {}
+	
+        template &lt;typename ScannerT&gt;
+        struct definition
+        {
+            definition(filter_grammar const&amp; self)
+            {	
+                typedef boost::spirit::chset&lt;wchar_t&gt; chset_t;
+
+                func1_op = &quot;sqrt&quot;,&quot;sin&quot;,&quot;cos&quot;;
+                func2_op = &quot;min&quot;,&quot;max&quot;;
+                spatial_op = &quot;Equals&quot;,&quot;Disjoint&quot;,&quot;Touches&quot;,&quot;Within&quot;,&quot;Overlaps&quot;,
+                    &quot;Crosses&quot;,&quot;Intersects&quot;,&quot;Contains&quot;,&quot;DWithin&quot;,&quot;Beyond&quot;,&quot;BBOX&quot;;
+		
+                chset_t BaseChar (L&quot;\x41-\x5A\x61-\x7A\xC0-\xD6\xD8-\xF6\xF8-\xFF\x100-\x131\x134-\x13E&quot;
+                                  L&quot;\x141-\x148\x14A-\x17E\x180-\x1C3\x1CD-\x1F0\x1F4-\x1F5\x1FA-\x217&quot;
+                                  L&quot;\x250-\x2A8\x2BB-\x2C1\x386\x388-\x38A\x38C\x38E-\x3A1\x3A3-\x3CE&quot;
+                                  L&quot;\x3D0-\x3D6\x3DA\x3DC\x3DE\x3E0\x3E2-\x3F3\x401-\x40C\x40E-\x44F&quot;
+                                  L&quot;\x451-\x45C\x45E-\x481\x490-\x4C4\x4C7-\x4C8\x4CB-\x4CC\x4D0-\x4EB&quot;
+                                  L&quot;\x4EE-\x4F5\x4F8-\x4F9\x531-\x556\x559\x561-\x586\x5D0-\x5EA&quot;
+                                  L&quot;\x5F0-\x5F2\x621-\x63A\x641-\x64A\x671-\x6B7\x6BA-\x6BE\x6C0-\x6CE&quot;
+                                  L&quot;\x6D0-\x6D3\x6D5\x6E5-\x6E6\x905-\x939\x93D\x958-\x961\x985-\x98C&quot;
+                                  L&quot;\x98F-\x990\x993-\x9A8\x9AA-\x9B0\x9B2\x9B6-\x9B9\x9DC-\x9DD&quot;
+                                  L&quot;\x9DF-\x9E1\x9F0-\x9F1\xA05-\xA0A\xA0F-\xA10\xA13-\xA28\xA2A-\xA30&quot;
+                                  L&quot;\xA32-\xA33\xA35-\xA36\xA38-\xA39\xA59-\xA5C\xA5E\xA72-\xA74&quot;
+                                  L&quot;\xA85-\xA8B\xA8D\xA8F-\xA91\xA93-\xAA8\xAAA-\xAB0\xAB2-\xAB3&quot;
+                                  L&quot;\xAB5-\xAB9\xABD\xAE0\xB05-\xB0C\xB0F-\xB10\xB13-\xB28\xB2A-\xB30&quot;
+                                  L&quot;\xB32-\xB33\xB36-\xB39\xB3D\xB5C-\xB5D\xB5F-\xB61\xB85-\xB8A&quot;
+                                  L&quot;\xB8E-\xB90\xB92-\xB95\xB99-\xB9A\xB9C\xB9E-\xB9F\xBA3-\xBA4&quot;
+                                  L&quot;\xBA8-\xBAA\xBAE-\xBB5\xBB7-\xBB9\xC05-\xC0C\xC0E-\xC10\xC12-\xC28&quot;
+                                  L&quot;\xC2A-\xC33\xC35-\xC39\xC60-\xC61\xC85-\xC8C\xC8E-\xC90\xC92-\xCA8&quot;
+                                  L&quot;\xCAA-\xCB3\xCB5-\xCB9\xCDE\xCE0-\xCE1\xD05-\xD0C\xD0E-\xD10&quot;
+                                  L&quot;\xD12-\xD28\xD2A-\xD39\xD60-\xD61\xE01-\xE2E\xE30\xE32-\xE33&quot;
+                                  L&quot;\xE40-\xE45\xE81-\xE82\xE84\xE87-\xE88\xE8A\xE8D\xE94-\xE97&quot;
+                                  L&quot;\xE99-\xE9F\xEA1-\xEA3\xEA5\xEA7\xEAA-\xEAB\xEAD-\xEAE\xEB0&quot;
+                                  L&quot;\xEB2-\xEB3\xEBD\xEC0-\xEC4\xF40-\xF47\xF49-\xF69\x10A0-\x10C5&quot;
+                                  L&quot;\x10D0-\x10F6\x1100\x1102-\x1103\x1105-\x1107\x1109\x110B-\x110C&quot;
+                                  L&quot;\x110E-\x1112\x113C\x113E\x1140\x114C\x114E\x1150\x1154-\x1155&quot;
+                                  L&quot;\x1159\x115F-\x1161\x1163\x1165\x1167\x1169\x116D-\x116E&quot;
+                                  L&quot;\x1172-\x1173\x1175\x119E\x11A8\x11AB\x11AE-\x11AF\x11B7-\x11B8&quot;
+                                  L&quot;\x11BA\x11BC-\x11C2\x11EB\x11F0\x11F9\x1E00-\x1E9B\x1EA0-\x1EF9&quot;
+                                  L&quot;\x1F00-\x1F15\x1F18-\x1F1D\x1F20-\x1F45\x1F48-\x1F4D\x1F50-\x1F57&quot;
+                                  L&quot;\x1F59\x1F5B\x1F5D\x1F5F-\x1F7D\x1F80-\x1FB4\x1FB6-\x1FBC\x1FBE&quot;
+                                  L&quot;\x1FC2-\x1FC4\x1FC6-\x1FCC\x1FD0-\x1FD3\x1FD6-\x1FDB\x1FE0-\x1FEC&quot;
+                                  L&quot;\x1FF2-\x1FF4\x1FF6-\x1FFC\x2126\x212A-\x212B\x212E\x2180-\x2182&quot;
+                                  L&quot;\x3041-\x3094\x30A1-\x30FA\x3105-\x312C\xAC00-\xD7A3&quot;);
+            
+                chset_t Ideographic(L&quot;\x4E00-\x9FA5\x3007\x3021-\x3029&quot;);
+                chset_t Letter = BaseChar | Ideographic;
+	    
+                chset_t CombiningChar(L&quot;\x0300-\x0345\x0360-\x0361\x0483-\x0486\x0591-\x05A1\x05A3-\x05B9&quot;
+                                      L&quot;\x05BB-\x05BD\x05BF\x05C1-\x05C2\x05C4\x064B-\x0652\x0670&quot;
+                                      L&quot;\x06D6-\x06DC\x06DD-\x06DF\x06E0-\x06E4\x06E7-\x06E8\x06EA-\x06ED&quot;
+                                      L&quot;\x0901-\x0903\x093C\x093E-\x094C\x094D\x0951-\x0954\x0962-\x0963&quot;
+                                      L&quot;\x0981-\x0983\x09BC\x09BE\x09BF\x09C0-\x09C4\x09C7-\x09C8&quot;
+                                      L&quot;\x09CB-\x09CD\x09D7\x09E2-\x09E3\x0A02\x0A3C\x0A3E\x0A3F&quot;
+                                      L&quot;\x0A40-\x0A42\x0A47-\x0A48\x0A4B-\x0A4D\x0A70-\x0A71\x0A81-\x0A83&quot;
+                                      L&quot;\x0ABC\x0ABE-\x0AC5\x0AC7-\x0AC9\x0ACB-\x0ACD\x0B01-\x0B03\x0B3C&quot;
+                                      L&quot;\x0B3E-\x0B43\x0B47-\x0B48\x0B4B-\x0B4D\x0B56-\x0B57\x0B82-\x0B83&quot;
+                                      L&quot;\x0BBE-\x0BC2\x0BC6-\x0BC8\x0BCA-\x0BCD\x0BD7\x0C01-\x0C03&quot;
+                                      L&quot;\x0C3E-\x0C44\x0C46-\x0C48\x0C4A-\x0C4D\x0C55-\x0C56\x0C82-\x0C83&quot;
+                                      L&quot;\x0CBE-\x0CC4\x0CC6-\x0CC8\x0CCA-\x0CCD\x0CD5-\x0CD6\x0D02-\x0D03&quot;
+                                      L&quot;\x0D3E-\x0D43\x0D46-\x0D48\x0D4A-\x0D4D\x0D57\x0E31\x0E34-\x0E3A&quot;
+                                      L&quot;\x0E47-\x0E4E\x0EB1\x0EB4-\x0EB9\x0EBB-\x0EBC\x0EC8-\x0ECD&quot;
+                                      L&quot;\x0F18-\x0F19\x0F35\x0F37\x0F39\x0F3E\x0F3F\x0F71-\x0F84&quot;
+                                      L&quot;\x0F86-\x0F8B\x0F90-\x0F95\x0F97\x0F99-\x0FAD\x0FB1-\x0FB7\x0FB9&quot;
+                                      L&quot;\x20D0-\x20DC\x20E1\x302A-\x302F\x3099\x309A&quot;);
+	    
+                chset_t Digit(L&quot;\x0030-\x0039\x0660-\x0669\x06F0-\x06F9\x0966-\x096F\x09E6-\x09EF&quot;
+                              L&quot;\x0A66-\x0A6F\x0AE6-\x0AEF\x0B66-\x0B6F\x0BE7-\x0BEF\x0C66-\x0C6F&quot;
+                              L&quot;\x0CE6-\x0CEF\x0D66-\x0D6F\x0E50-\x0E59\x0ED0-\x0ED9\x0F20-\x0F29&quot;);
+		
+                chset_t Extender(L&quot;\x00B7\x02D0\x02D1\x0387\x0640\x0E46\x0EC6\x3005\x3031-\x3035&quot;
+                                 L&quot;\x309D-\x309E\x30FC-\x30FE&quot;);
+		
+                chset_t NameChar =
+                    Letter 
+                    | Digit 
+                    | L'.'
+                    | L'-'
+                    | L'_'
+                    | L':'
+                    | CombiningChar 
+                    | Extender;
+				
+                number = strict_real_p [push_real&lt;FeatureT&gt;(self.exprs)] 
+                    | int_p [push_integer&lt;FeatureT&gt;(self.exprs)];
+		
+                string_ = confix_p(L'\'',(*lex_escape_ch_p)
+                                   [push_string&lt;FeatureT&gt;(self.exprs)],
+                                   L'\'');
+		
+                property = L'[' &gt;&gt; ( (Letter | L'_' | L':') 
+                                     &gt;&gt; *NameChar )[push_property&lt;FeatureT&gt;(self.exprs)] &gt;&gt; L']';
+		
+                literal = number | string_ | property;
+		
+                function = literal | ( func1_op &gt;&gt; L'('&gt;&gt; literal &gt;&gt; L')') | 
+                    (func2_op &gt;&gt; L'(' &gt;&gt; literal &gt;&gt; L','&gt;&gt; literal &gt;&gt; L')');
+		
+                factor = function 
+                    | L'(' &gt;&gt; or_expr &gt;&gt; L')'
+                    | ( L'-' &gt;&gt; factor) 
+                    ;
+                term = factor
+                    &gt;&gt; *((L'*' &gt;&gt; factor) [compose_expression&lt;FeatureT,mapnik::mult&lt;value&gt; &gt;(self.exprs)] 
+                         | (L'/' &gt;&gt; factor) [compose_expression&lt;FeatureT,mapnik::div&lt;value&gt; &gt;(self.exprs)]);
+		
+                expression = term &gt;&gt; *((L'+' &gt;&gt; term) [compose_expression&lt;FeatureT,mapnik::add&lt;value&gt; &gt;(self.exprs)] 
+                                       | (L'-' &gt;&gt; term) [compose_expression&lt;FeatureT,mapnik::sub&lt;value&gt; &gt;(self.exprs)]);
+
+                regex = str_p(L&quot;.match&quot;)&gt;&gt;L'('&gt;&gt;confix_p(L'\'',(*lex_escape_ch_p)
+                                                         [compose_regex&lt;FeatureT&gt;(self.filters,self.exprs)],
+                                                         L'\'') &gt;&gt;L')';
+
+                relation   = expression 
+                    &gt;&gt; *((L&quot;&gt;=&quot; &gt;&gt; expression) 
+                         [compose_filter&lt;FeatureT,greater_than_or_equal&lt;value&gt; &gt;(self.filters,self.exprs)]
+                         | (L'&gt;' &gt;&gt; expression)
+                         [compose_filter&lt;FeatureT,mapnik::greater_than&lt;value&gt; &gt;(self.filters,self.exprs)]
+                         | (L'&lt;' &gt;&gt; expression)
+                         [compose_filter&lt;FeatureT,mapnik::less_than&lt;value&gt; &gt;(self.filters,self.exprs)]
+                         | (L&quot;&lt;=&quot; &gt;&gt; expression)
+                         [compose_filter&lt;FeatureT,less_than_or_equal&lt;value&gt; &gt;(self.filters,self.exprs)]
+                         | regex );
+
+                equation = relation &gt;&gt; *( ( L'=' &gt;&gt; relation)
+                                          [compose_filter&lt;FeatureT,mapnik::equals&lt;value&gt; &gt;(self.filters,self.exprs)]
+                                          | ( L&quot;&lt;&gt;&quot; &gt;&gt; relation)
+                                          [compose_filter&lt;FeatureT,not_equals&lt;value&gt; &gt;(self.filters,self.exprs)]);
+
+                not_expr = equation | *(str_p(L&quot;not&quot;) &gt;&gt; equation)[compose_not_filter&lt;FeatureT&gt;(self.filters)];
+
+                and_expr = not_expr &gt;&gt; *(L&quot;and&quot; &gt;&gt; not_expr)[compose_and_filter&lt;FeatureT&gt;(self.filters)];
+
+                or_expr  = and_expr &gt;&gt; *(L&quot;or&quot; &gt;&gt; and_expr)[compose_or_filter&lt;FeatureT&gt;(self.filters)];
+
+                filter_statement = or_expr;	
+            }
+	    
+            boost::spirit::rule&lt;ScannerT&gt; const&amp; start() const
+            {
+                return filter_statement;
+            }
+	    	    
+            boost::spirit::rule&lt;ScannerT&gt; factor; 
+            boost::spirit::rule&lt;ScannerT&gt; term;
+            boost::spirit::rule&lt;ScannerT&gt; expression;
+            boost::spirit::rule&lt;ScannerT&gt; relation;
+            boost::spirit::rule&lt;ScannerT&gt; equation;
+            boost::spirit::rule&lt;ScannerT&gt; not_expr;
+            boost::spirit::rule&lt;ScannerT&gt; and_expr;
+            boost::spirit::rule&lt;ScannerT&gt; or_expr;
+	    
+            boost::spirit::rule&lt;ScannerT&gt; filter_statement;   
+            boost::spirit::rule&lt;ScannerT&gt; literal;
+            boost::spirit::rule&lt;ScannerT&gt; number;
+            boost::spirit::rule&lt;ScannerT&gt; string_;
+            boost::spirit::rule&lt;ScannerT&gt; property;
+            boost::spirit::rule&lt;ScannerT&gt; function;
+            boost::spirit::rule&lt;ScannerT&gt; regex;
+            symbols&lt;string&gt; func1_op;
+            symbols&lt;string&gt; func2_op;
+            symbols&lt;string&gt; spatial_op;
+        };
+        stack&lt;shared_ptr&lt;filter&lt;FeatureT&gt; &gt; &gt;&amp; filters;
+        stack&lt;shared_ptr&lt;expression&lt;FeatureT&gt; &gt; &gt;&amp; exprs;
+    };    
+}
+
+#endif //FILTER_PARSER_HPP 

Copied: trunk/include/mapnik/filter_parser_ast.hpp (from rev 307, trunk/include/filter_parser_ast.hpp)
===================================================================
--- trunk/include/filter_parser_ast.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/filter_parser_ast.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,266 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef FILTER_PARSER_AST_HPP
+#define FILTER_PARSER_AST_HPP
+// stl
+#include &lt;iostream&gt;
+// boost
+#include &lt;boost/spirit/core.hpp&gt;
+#include &lt;boost/spirit/tree/ast.hpp&gt;
+
+using namespace std;
+using namespace boost::spirit;
+
+namespace mapnik
+{
+    
+    struct filter_grammar_ast : public grammar&lt;filter_grammar_ast&gt;
+    {
+	
+        static const int integerID = 1;
+        static const int realID = 2;
+        static const int stringID = 3;
+        static const int propertyID = 4;
+        static const int factorID = 5;
+        static const int termID = 6;
+        static const int expressionID = 7;
+        static const int relationID = 8;
+        static const int equationID = 9;
+        static const int and_exprID = 10;
+        static const int or_exprID = 11;
+	
+        template &lt;typename ScannerT&gt;
+        struct definition
+        {
+	    
+            definition(filter_grammar_ast const&amp; /*self*/)
+            {			
+                real = leaf_node_d[strict_real_p];
+                integer    = leaf_node_d[int_p];
+                number = real | integer;
+		
+                string_ = inner_node_d['\''&gt;&gt; leaf_node_d[( (alpha_p | '_')  &gt;&gt; 
+                                                            * (alnum_p | '_' ))] &gt;&gt;  '\''];
+		
+                property = inner_node_d['[' &gt;&gt; leaf_node_d[ ( (alpha_p | '_') &gt;&gt; * (alnum_p | '_' )) ] &gt;&gt; ']'];
+		
+                literal = number | string_ | property;
+		
+                factor = literal 
+                    | (root_node_d[str_p(&quot;not&quot;)] &gt;&gt; literal) 
+                    | inner_node_d[ch_p('(') &gt;&gt; or_expr &gt;&gt; ch_p(')') ]
+                    | (root_node_d[ch_p('-')] &gt;&gt; factor)
+                    ;
+		
+                term = factor
+                    &gt;&gt; *((root_node_d[ch_p('*')] &gt;&gt; factor) | (root_node_d[ch_p('/')] &gt;&gt; factor));
+		
+                expression = term &gt;&gt; *((root_node_d[ch_p('+')] &gt;&gt; term) | (root_node_d[ch_p('-')] &gt;&gt; term));
+                relation   = expression &gt;&gt; *((root_node_d[str_p(&quot;&gt;=&quot;)] &gt;&gt; expression) 
+                                             | (root_node_d[ch_p('&gt;')] &gt;&gt; expression)
+                                             | (root_node_d[ch_p('&lt;')] &gt;&gt; expression)
+                                             | (root_node_d[str_p(&quot;&lt;=&quot;)] &gt;&gt; expression));
+		
+                equation = relation &gt;&gt; *( (root_node_d[ch_p('=')] &gt;&gt; relation)
+                                          | (root_node_d[str_p(&quot;&lt;&gt;&quot;)] &gt;&gt; relation));
+                and_expr = equation &gt;&gt; *(root_node_d[str_p(&quot;and&quot;)] &gt;&gt; equation);
+                or_expr  = and_expr &gt;&gt; *(root_node_d[str_p(&quot;or&quot;)] &gt;&gt; and_expr);
+		
+                //spatial_op = str_p(&quot;Equals&quot;) | &quot;Disjoint&quot; | &quot;Touches&quot; | &quot;Within&quot; 
+                //   | &quot;Overlaps&quot; | &quot;Crosses&quot; | &quot;Intersects&quot; | &quot;Contains&quot; | &quot;DWithin&quot; | &quot;Beyond&quot; | &quot;BBOX&quot;;
+
+                filter_statement = or_expr;
+            }
+	    
+            rule&lt;ScannerT&gt; const&amp; start() const
+            {
+                return filter_statement;
+            }
+	    	    
+            rule&lt;ScannerT,parser_context&lt;&gt;, parser_tag&lt;factorID&gt; &gt; factor; 
+            rule&lt;ScannerT,parser_context&lt;&gt;, parser_tag&lt;termID&gt; &gt; term;
+            rule&lt;ScannerT,parser_context&lt;&gt;, parser_tag&lt;expressionID&gt; &gt; expression;
+            rule&lt;ScannerT,parser_context&lt;&gt;, parser_tag&lt;relationID&gt; &gt; relation;
+            rule&lt;ScannerT,parser_context&lt;&gt;, parser_tag&lt;equationID&gt; &gt; equation;
+	    
+            rule&lt;ScannerT,parser_context&lt;&gt;, parser_tag&lt;and_exprID&gt; &gt; and_expr;
+            rule&lt;ScannerT,parser_context&lt;&gt;, parser_tag&lt;or_exprID&gt; &gt; or_expr;
+	    
+            rule&lt;ScannerT&gt; filter_statement;
+            rule&lt;ScannerT&gt; literal,number;
+	    
+            rule&lt;ScannerT,parser_context&lt;&gt;, parser_tag&lt;integerID&gt; &gt; integer;
+            rule&lt;ScannerT,parser_context&lt;&gt;, parser_tag&lt;realID&gt; &gt; real;
+            rule&lt;ScannerT,parser_context&lt;&gt;, parser_tag&lt;stringID&gt; &gt; string_;
+            rule&lt;ScannerT,parser_context&lt;&gt;, parser_tag&lt;propertyID&gt; &gt; property;
+	    
+
+            //rule&lt;ScannerT&gt; spatial_op;
+
+        };
+	
+    }; 
+
+    class node_data
+    {
+    public:
+        enum  {
+            Unknown=0,
+            Integer=1,
+            Real   =2,
+            String =3,
+            Property=4
+        };
+        node_data()
+            : type_(Unknown) {}
+
+        node_data(int type)
+            : type_(type) {}
+    
+        node_data(node_data const&amp; other)
+            : type_(other.type_) {}
+    
+        node_data&amp; operator=(node_data const&amp; other)
+        {
+            if (this==&amp;other) 
+                return *this;
+            type_=other.type_;
+            return *this;
+        }
+        ~node_data() {}
+    private:
+        int type_;    
+    };
+
+    typedef char const* iterator_t;
+    typedef node_val_data_factory&lt;node_data&gt; factory_t;
+    typedef tree_match&lt;iterator_t,factory_t&gt;::tree_iterator iter_t;
+
+    void process_node(iter_t const&amp;,string&amp;);
+    
+    void walk_ast_tree(tree_parse_info&lt;iterator_t,factory_t&gt; info,string&amp; text)
+    {
+        process_node(info.trees.begin(),text);
+    }
+    
+    void process_node(iter_t const&amp; i,string&amp; text)
+    {
+        //clog &lt;&lt; &quot;In eval_expression. i-&gt;value = &quot; &lt;&lt;
+        //   string(i-&gt;value.begin(), i-&gt;value.end()) &lt;&lt;
+        //   &quot; i-&gt;children.size() = &quot; &lt;&lt; i-&gt;children.size() &lt;&lt; endl;
+        //std::clog&lt;&lt;typeid(*i).name()&lt;&lt;&quot;\n&quot;;
+
+        if (i-&gt;value.id() == filter_grammar_ast::integerID)
+        {	
+            assert(i-&gt;children.size()==0);
+            string integer(i-&gt;value.begin(), i-&gt;value.end());	
+            text+= integer;
+        }
+        else if (i-&gt;value.id() == filter_grammar_ast::realID)
+        {	
+            assert(i-&gt;children.size()==0);
+            string real(i-&gt;value.begin(), i-&gt;value.end());
+            text += real;
+        }
+        else if (i-&gt;value.id() == filter_grammar_ast::stringID)
+        {	
+            assert(i-&gt;children.size()==0);
+            string str(i-&gt;value.begin(), i-&gt;value.end());
+            text += str;
+        }
+        else if (i-&gt;value.id() == filter_grammar_ast::propertyID)
+        {
+            assert(i-&gt;children.size()==0);
+            string property_name(i-&gt;value.begin(), i-&gt;value.end());
+            text += property_name;
+        }
+        else if (i-&gt;value.id() == filter_grammar_ast::expressionID)
+        {
+            assert(i-&gt;children.size() == 2);
+            assert(!i-&gt;children.begin()-&gt;value.is_root());
+            process_node(i-&gt;children.begin(),text);	     
+            text += string(i-&gt;value.begin(), i-&gt;value.end());
+            process_node(i-&gt;children.begin()+1,text);
+	    
+            text +=&quot;\n&quot;;
+        }
+        else if (i-&gt;value.id() == filter_grammar_ast::termID)
+        {
+            assert(i-&gt;children.size() == 2);
+            assert(!i-&gt;children.begin()-&gt;value.is_root());
+            process_node(i-&gt;children.begin(),text);
+            text +=  string(i-&gt;value.begin(), i-&gt;value.end());
+            process_node(i-&gt;children.begin()+1,text);
+	    
+            text +=&quot;\n&quot;;
+	
+        }
+        else if (i-&gt;value.id() == filter_grammar_ast::relationID)
+        {
+            assert(i-&gt;children.size() == 2);
+            assert(!i-&gt;children.begin()-&gt;value.is_root());
+            process_node(i-&gt;children.begin(),text);
+            text += string(i-&gt;value.begin(), i-&gt;value.end());
+            process_node(i-&gt;children.begin()+1,text);
+	    
+            text +=&quot;\n&quot;;
+
+        }
+        else if (i-&gt;value.id() == filter_grammar_ast::equationID)
+        {
+            assert(i-&gt;children.size() == 2);
+            assert(!i-&gt;children.begin()-&gt;value.is_root());
+            process_node(i-&gt;children.begin(),text);
+            text += string(i-&gt;value.begin(), i-&gt;value.end());
+            process_node(i-&gt;children.begin()+1,text);
+	    
+            text +=&quot;\n&quot;;
+        }
+        else if (i-&gt;value.id() == filter_grammar_ast::and_exprID)
+        {
+            assert(i-&gt;children.size() == 2);
+            assert(!i-&gt;children.begin()-&gt;value.is_root());
+            process_node(i-&gt;children.begin(),text);
+            text += string(i-&gt;value.begin(), i-&gt;value.end());
+            process_node(i-&gt;children.begin()+1,text);
+	    
+            text +=&quot;\n&quot;;
+        }
+        else if (i-&gt;value.id() == filter_grammar_ast::or_exprID)
+        {
+            assert(i-&gt;children.size() == 2);
+            assert(!i-&gt;children.begin()-&gt;value.is_root());
+            
+            process_node(i-&gt;children.begin(),text);
+            text += string(i-&gt;value.begin(), i-&gt;value.end());
+            process_node(i-&gt;children.begin()+1,text);
+	    
+            text +=&quot;\n&quot;;
+
+        }
+    }   
+}
+
+#endif //FILTER_PARSER_AST_HPP 

Copied: trunk/include/mapnik/filter_visitor.hpp (from rev 307, trunk/include/filter_visitor.hpp)
===================================================================
--- trunk/include/filter_visitor.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/filter_visitor.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,48 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef FILTER_VISITOR_HPP
+#define FILTER_VISITOR_HPP
+
+#include &lt;mapnik/filter.hpp&gt;
+#include &lt;mapnik/expression.hpp&gt;
+
+namespace mapnik
+{
+    template &lt;typename FeatureT&gt; class filter;
+    template &lt;typename FeatureT&gt; class expression;
+    template &lt;typename FeatureT&gt; class expression;
+    template &lt;typename Feature,template &lt;typename&gt; class Filter&gt; class rule;
+    template &lt;typename FeatureT&gt;
+    class filter_visitor
+    {
+	public:
+		virtual void visit(filter&lt;FeatureT&gt;&amp; filter)=0;
+		virtual void visit(expression&lt;FeatureT&gt;&amp;)=0;
+		virtual void visit(rule&lt;FeatureT,filter&gt; const&amp; r)=0;
+		virtual ~filter_visitor() {}
+    };    
+}
+
+#endif //FILTER_VISITOR_HPP

Copied: trunk/include/mapnik/font_engine_freetype.hpp (from rev 307, trunk/include/font_engine_freetype.hpp)
===================================================================
--- trunk/include/font_engine_freetype.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/font_engine_freetype.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,432 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef FONT_ENGINE_FREETYPE_HPP
+#define FONT_ENGINE_FREETYPE_HPP
+
+// freetype2
+extern &quot;C&quot;
+{
+  #include &lt;ft2build.h&gt;
+  #include FT_FREETYPE_H
+  #include FT_GLYPH_H
+}
+
+// stl
+#include &lt;string&gt;
+#include &lt;vector&gt;
+#include &lt;map&gt;
+#include &lt;iostream&gt;
+// boost
+#include &lt;boost/shared_ptr.hpp&gt;
+#include &lt;boost/utility.hpp&gt;
+#include &lt;boost/ptr_container/ptr_vector.hpp&gt;
+#include &lt;boost/thread/mutex.hpp&gt;
+// mapnik
+#include &lt;mapnik/color.hpp&gt;
+#include &lt;mapnik/utils.hpp&gt;
+
+namespace mapnik
+{
+    class font_face : boost::noncopyable
+    {
+    public:
+    	font_face(FT_Face face)
+            : face_(face) {}
+	
+    	std::string  family_name() const
+    	{
+    	    return std::string(face_-&gt;family_name);
+    	}
+
+        std::string  style_name() const
+    	{
+    	    return std::string(face_-&gt;style_name);
+    	}
+	
+        unsigned num_glyphs() const
+        {
+            return face_-&gt;num_glyphs;
+        }
+
+        FT_GlyphSlot glyph() const
+        {
+            return face_-&gt;glyph;
+        }
+	
+        FT_Face get_face() const
+        {
+            return face_;
+        }
+	
+        bool set_pixel_sizes(unsigned size)
+        {
+            if (! FT_Set_Pixel_Sizes( face_, 0, size ))
+                return true;
+            return false;
+        }
+        
+	
+    	~font_face()
+    	{
+    	    std::clog &lt;&lt; &quot;clean up face:&quot; &lt;&lt; family_name()&lt;&lt;&quot;:&quot; &lt;&lt; style_name() &lt;&lt; std::endl;
+    	    FT_Done_Face(face_);
+    	}
+	
+    private:
+    	FT_Face face_;
+    };
+    
+    typedef boost::shared_ptr&lt;font_face&gt; face_ptr;
+    
+    class MAPNIK_DECL freetype_engine : public mapnik::singleton&lt;freetype_engine,mapnik::CreateStatic&gt;,
+                                        private boost::noncopyable
+    {
+        friend class mapnik::CreateStatic&lt;freetype_engine&gt;;
+    public:
+
+        static bool register_font(std::string const&amp; file_name);
+        static std::vector&lt;std::string&gt; face_names ();
+        static face_ptr create_face(std::string const&amp; family_name);
+
+    private:
+        freetype_engine();
+        virtual ~freetype_engine();
+        static FT_Library library_;
+        static std::map&lt;std::string,std::string&gt; name2file_;
+    }; 
+    
+    template &lt;typename T&gt;
+    class MAPNIK_DECL face_manager : private boost::noncopyable
+    {
+        typedef T font_engine_type;
+        typedef std::map&lt;std::string,face_ptr&gt; faces;
+	
+    public:
+        face_ptr get_face(std::string const&amp; name)
+        {
+            typename faces::iterator itr;
+            itr = faces_.find(name);
+            if (itr != faces_.end())
+            {
+                return itr-&gt;second;
+            }
+            else
+            {
+                face_ptr face = font_engine_type::instance()-&gt;create_face(name);
+                if (face)
+                {
+                    faces_.insert(make_pair(name,face));
+                }
+                return face;	
+            }
+        }
+    private:
+        faces faces_;
+    };
+        
+    inline std::wstring to_unicode(std::string const&amp; text)
+    {
+        std::wstring out;
+        unsigned long code = 0;
+        int expect = 0;
+        std::string::const_iterator itr=text.begin();
+	
+        while ( itr != text.end())
+        {
+            unsigned p = (*itr++) &amp; 0xff;
+            if ( p &gt;= 0xc0)
+            {
+                if ( p &lt; 0xe0)      // U+0080 - U+07ff
+                {
+                    expect = 1;
+                    code = p &amp; 0x1f;
+                }
+                else if ( p &lt; 0xf0)  // U+0800 - U+ffff
+                {
+                    expect = 2;
+                    code = p &amp; 0x0f;
+                }
+                else if ( p  &lt; 0xf8) // U+1000 - U+10ffff
+                {
+                    expect = 3;
+                    code = p &amp; 0x07;
+                }
+                continue;
+            }
+            else if (p &gt;= 0x80)
+            {
+                --expect;
+                if (expect &gt;= 0)
+                {
+                    code &lt;&lt;= 6;
+                    code += p &amp; 0x3f;
+                }
+                if (expect &gt; 0)
+                    continue;
+                expect = 0;
+            }
+            else 
+            {
+                code = p;            // U+0000 - U+007f (ascii)
+            }
+            out.push_back(wchar_t(code));
+        }
+        return out;
+    }
+    
+    template &lt;typename T&gt;
+    struct text_renderer : private boost::noncopyable
+    {
+
+        struct glyph_t : boost::noncopyable
+        {
+            FT_Glyph image;
+            glyph_t(FT_Glyph image_) : image(image_) {}
+            ~glyph_t ()	{ FT_Done_Glyph(image);}
+        };
+	
+        typedef boost::ptr_vector&lt;glyph_t&gt; glyphs_t;
+        typedef std::pair&lt;unsigned,unsigned&gt; dimension_t;
+        typedef T pixmap_type;
+	
+        text_renderer (pixmap_type &amp; pixmap, face_ptr face)
+            : pixmap_(pixmap),
+              face_(face),
+              fill_(0,0,0), 
+              halo_fill_(255,255,255),
+              halo_radius_(0),
+              angle_(0.0) {}
+    
+        void set_pixel_size(unsigned size)
+        {
+            face_-&gt;set_pixel_sizes(size);
+        }
+    
+        void set_angle(float angle)
+        {
+            angle_=angle;
+        }
+
+        void set_fill(mapnik::Color const&amp; fill)
+        {
+            fill_=fill;
+        }
+    
+        void set_halo_fill(mapnik::Color const&amp; halo)
+        {
+            halo_fill_=halo;
+        }
+    
+        void set_halo_radius( int radius=1)
+        {
+            halo_radius_=radius;
+        }
+
+        dimension_t prepare_glyphs(std::string const&amp; text)
+        {
+            //clear glyphs
+            glyphs_.clear();
+	    
+            FT_Matrix matrix;
+            FT_Vector pen;
+            FT_Error  error;
+	    
+            FT_Face face = face_-&gt;get_face();
+            FT_GlyphSlot slot = face-&gt;glyph;
+            FT_Bool use_kerning;
+            FT_UInt previous = 0;
+	    
+            pen.x = 0;
+            pen.y = 0;
+	    
+            use_kerning = FT_HAS_KERNING(face)&gt;0?true:false;
+	    
+            FT_BBox bbox;   
+            bbox.xMin = bbox.yMin = 32000; 
+            bbox.xMax = bbox.yMax = -32000; //hmm?? 
+	    
+            for (std::string::const_iterator i=text.begin();i!=text.end();++i)
+            {
+                FT_BBox glyph_bbox; 
+                FT_Glyph image;
+		
+                matrix.xx = (FT_Fixed)( cos( angle_ ) * 0x10000L ); 
+                matrix.xy = (FT_Fixed)(-sin( angle_ ) * 0x10000L ); 
+                matrix.yx = (FT_Fixed)( sin( angle_ ) * 0x10000L ); 
+                matrix.yy = (FT_Fixed)( cos( angle_ ) * 0x10000L );
+	        	
+                FT_Set_Transform (face,&amp;matrix,&amp;pen);
+		
+                FT_UInt glyph_index = FT_Get_Char_Index( face, unsigned(*i) &amp; 0xff );
+		
+                if ( use_kerning &amp;&amp; previous &amp;&amp; glyph_index)
+                {
+                    FT_Vector delta;
+                    FT_Get_Kerning(face,previous,glyph_index,
+                                   FT_KERNING_DEFAULT,&amp;delta);
+                    pen.x += delta.x;
+                    pen.y += delta.y;
+                }
+		
+                error = FT_Load_Glyph (face,glyph_index,FT_LOAD_DEFAULT); 
+                if ( error )
+                    continue;
+		
+                error = FT_Get_Glyph( face-&gt;glyph, &amp;image);
+                if ( error )
+                    continue;
+		
+                FT_Glyph_Get_CBox(image,ft_glyph_bbox_pixels, &amp;glyph_bbox); 
+                if (glyph_bbox.xMin &lt; bbox.xMin) 
+                    bbox.xMin = glyph_bbox.xMin; 
+                if (glyph_bbox.yMin &lt; bbox.yMin) 
+                    bbox.yMin = glyph_bbox.yMin; 
+                if (glyph_bbox.xMax &gt; bbox.xMax) 
+                    bbox.xMax = glyph_bbox.xMax; 
+                if (glyph_bbox.yMax &gt; bbox.yMax) 
+                    bbox.yMax = glyph_bbox.yMax;
+		
+                if ( bbox.xMin &gt; bbox.xMax )
+                {
+                    bbox.xMin = 0; 
+                    bbox.yMin = 0; 
+                    bbox.xMax = 0; 
+                    bbox.yMax = 0; 
+                }
+		
+                pen.x += slot-&gt;advance.x;
+                pen.y += slot-&gt;advance.y;
+		
+                previous = glyph_index;
+                // take ownership of the glyph
+                glyphs_.push_back(new glyph_t(image));
+            }
+	    
+            unsigned string_width = (bbox.xMax - bbox.xMin); 
+            unsigned string_height = (bbox.yMax - bbox.yMin);
+            return dimension_t(string_width,string_height);
+        }
+	
+        void render(double x0, double y0)
+        {
+            FT_Error  error;
+            FT_Vector start;
+            unsigned height = pixmap_.height();
+	    
+            start.x = unsigned(x0 * (1 &lt;&lt; 6)); 
+            start.y = unsigned((height - y0) * (1 &lt;&lt; 6));
+            // now render transformed glyphs
+            typename glyphs_t::iterator pos;
+
+            if (halo_radius_ &gt; 0)
+            {
+                //render halo 
+                for ( pos = glyphs_.begin(); pos != glyphs_.end();++pos)
+                {
+	    
+                    FT_Glyph_Transform(pos-&gt;image,0,&amp;start);
+	    
+                    error = FT_Glyph_To_Bitmap( &amp;(pos-&gt;image),FT_RENDER_MODE_NORMAL,0,1);
+                    if ( ! error )
+                    {
+			
+                        FT_BitmapGlyph bit = (FT_BitmapGlyph)pos-&gt;image;
+                        render_halo(&amp;bit-&gt;bitmap, halo_fill_.rgba(), 
+                                    bit-&gt;left,
+                                    height - bit-&gt;top,halo_radius_);
+                    }
+                }  
+            }
+            //render actual text
+            for ( pos = glyphs_.begin(); pos != glyphs_.end();++pos)
+            {
+	    
+                FT_Glyph_Transform(pos-&gt;image,0,&amp;start);
+	    
+                error = FT_Glyph_To_Bitmap( &amp;(pos-&gt;image),FT_RENDER_MODE_NORMAL,0,1);
+                if ( ! error )
+                {
+		   
+                    FT_BitmapGlyph bit = (FT_BitmapGlyph)pos-&gt;image;
+                    render_bitmap(&amp;bit-&gt;bitmap, fill_.rgba(), 
+                                  bit-&gt;left,
+                                  height - bit-&gt;top);
+                }
+            }  
+        }
+   	
+    private:
+    
+        void render_halo(FT_Bitmap *bitmap,unsigned rgba,int x,int y,int radius)
+        {
+            int x_max=x+bitmap-&gt;width;
+            int y_max=y+bitmap-&gt;rows;
+            int i,p,j,q;
+	
+            for (i=x,p=0;i&lt;x_max;++i,++p)
+            {
+                for (j=y,q=0;j&lt;y_max;++j,++q)
+                {
+                    int gray = bitmap-&gt;buffer[q*bitmap-&gt;width+p];
+                    if (gray)
+                    {
+                        for (int n=-halo_radius_; n &lt;=halo_radius_; ++n)
+                            for (int m=-halo_radius_;m &lt;= halo_radius_; ++m)
+                                pixmap_.blendPixel(i+m,j+n,rgba,gray);		        
+                    }
+                }
+            }
+        }
+    
+        void render_bitmap(FT_Bitmap *bitmap,unsigned rgba,int x,int y)
+        {
+            int x_max=x+bitmap-&gt;width;
+            int y_max=y+bitmap-&gt;rows;
+            int i,p,j,q;
+	
+            for (i=x,p=0;i&lt;x_max;++i,++p)
+            {
+                for (j=y,q=0;j&lt;y_max;++j,++q)
+                {
+                    int gray=bitmap-&gt;buffer[q*bitmap-&gt;width+p];
+                    if (gray)
+                    {
+                        pixmap_.blendPixel(i,j,rgba,gray);
+                    }
+                }
+            }
+        }
+    
+        pixmap_type &amp; pixmap_;
+        face_ptr face_;
+        Color fill_;
+        Color halo_fill_;
+        int halo_radius_;
+        float angle_;
+        glyphs_t glyphs_;
+    }; 
+}
+
+#endif // FONT_ENGINE_FREETYPE_HPP

Copied: trunk/include/mapnik/gamma.hpp (from rev 307, trunk/include/gamma.hpp)
===================================================================
--- trunk/include/gamma.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/gamma.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,51 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: gamma.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef GAMMA_HPP
+#define GAMMA_HPP
+
+namespace mapnik 
+{
+    struct MAPNIK_DECL gamma
+    {
+        unsigned char g2l[256];
+        unsigned char l2g[256];
+        gamma(double gamma=2.0)
+        {
+            int result;
+            for (int i=0;i&lt; 256;i++)
+            {
+                result=(int)(pow(i/255.0,gamma) * 255.0 + 0.5);
+                g2l[i]=(unsigned char)result;
+            }
+            for (int i = 0; i &lt; 256; i++)
+            {
+                result = (int)(pow(i/255.0, 1/gamma) * 255.0 + 0.5);
+                l2g[i] = (unsigned char)result;
+            }
+        }
+    };
+}
+
+#endif  //GAMMA_HPP

Copied: trunk/include/mapnik/geom_util.hpp (from rev 307, trunk/include/geom_util.hpp)
===================================================================
--- trunk/include/geom_util.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/geom_util.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,194 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: geom_util.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef GEOM_UTIL_HPP
+#define GEOM_UTIL_HPP
+// stl
+#include &lt;cmath&gt;
+// boost
+#include &lt;boost/tuple/tuple.hpp&gt;
+// mapnik
+#include &lt;mapnik/envelope.hpp&gt;
+#include &lt;mapnik/vertex.hpp&gt;
+
+namespace mapnik
+{
+
+    template &lt;typename T&gt;
+    bool clip_test(T p,T q,double&amp; tmin,double&amp; tmax)
+    {
+        double r;
+        bool result=true;
+        if (p&lt;0.0)
+        {
+            r=q/p;
+            if (r&gt;tmax) result=false;
+            else if (r&gt;tmin) tmin=r;
+        }
+        else if (p&gt;0.0)
+        {
+            r=q/p;
+            if (r&lt;tmin) result=false;
+            else if (r&lt;tmax) tmax=r;
+        } else if (q&lt;0.0) result=false;
+        return result;
+    }
+
+    template &lt;typename T,typename Image&gt;
+    bool clip_line(T&amp; x0,T&amp; y0,T&amp; x1,T&amp; y1,Envelope&lt;T&gt; const&amp; box)
+    {
+        double tmin=0.0;
+        double tmax=1.0;
+        double dx=x1-x0;
+        if (clip_test&lt;double&gt;(-dx,x0,tmin,tmax))
+        {
+            if (clip_test&lt;double&gt;(dx,box.width()-x0,tmin,tmax))
+            {
+                double dy=y1-y0;
+                if (clip_test&lt;double&gt;(-dy,y0,tmin,tmax))
+                {
+                    if (clip_test&lt;double&gt;(dy,box.height()-y0,tmin,tmax))
+                    {
+                        if (tmax&lt;1.0)
+                        {
+                            x1=static_cast&lt;T&gt;(x0+tmax*dx);
+                            y1=static_cast&lt;T&gt;(y0+tmax*dy);
+                        }
+                        if (tmin&gt;0.0)
+                        {
+                            x0+=static_cast&lt;T&gt;(tmin*dx);
+                            y0+=static_cast&lt;T&gt;(tmin*dy);
+                        }
+                        return true;
+                    }
+                }
+            }
+        }
+        return false;
+    }
+    
+    template &lt;typename Iter&gt; 
+    inline bool point_inside_path(double x,double y,Iter start,Iter end)
+    {
+        bool inside=false;
+        double x0=boost::get&lt;0&gt;(*start);
+        double y0=boost::get&lt;1&gt;(*start);
+        
+        double x1,y1;
+        while (++start!=end) 
+        {
+            if ( boost::get&lt;2&gt;(*start) == SEG_MOVETO)
+            {
+                x0 = boost::get&lt;0&gt;(*start);
+                y0 = boost::get&lt;1&gt;(*start);
+                continue;
+            }		
+            x1=boost::get&lt;0&gt;(*start);
+            y1=boost::get&lt;1&gt;(*start);
+            
+            if ((((y1 &lt;= y) &amp;&amp; (y &lt; y0)) ||
+                 ((y0 &lt;= y) &amp;&amp; (y &lt; y1))) &amp;&amp;
+                ( x &lt; (x0 - x1) * (y - y1)/ (y0 - y1) + x1))
+                inside=!inside;
+            x0=x1;
+            y0=y1;
+        }
+    	return inside;
+    }
+
+#define TOL 0.00001
+
+    /*
+      (Ay-Cy)(Bx-Ax)-(Ax-Cx)(By-Ay)
+      s = -----------------------------
+      L^2
+    */
+
+    inline bool point_in_circle(double x,double y,double cx,double cy,double r)
+    {
+        double dx = x - cx;
+        double dy = y - cy;
+        double d2 = dx * dx + dy * dy;
+        return (d2 &lt;= r * r);
+    }
+    
+    inline bool point_on_segment(double x,double y,double x0,double y0,double x1,double y1)
+    {	
+        double dx = x1 - x0;
+        double dy = y1 - y0;
+        if ( fabs(dx) &gt; TOL  ||  fabs(dy) &gt; TOL )
+        {
+            double s = (y0 - y) * dx - (x0 - x) * dy;
+            return ( fabs (s) &lt; TOL ) ;
+        } 
+        return false;
+    }
+
+    inline bool point_on_segment2(double x,double y,double x0,double y0,double x1,double y1)
+    {	 
+        double d  = sqrt ((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0));
+        double d0 = sqrt ((x0 - x) * (x0 - x) + (y0 - y) * (y0 - y));
+        double d1 = sqrt ((x1 - x) * (x1 - x) + (y1 - y) * (y1 - y));
+        double d2 = d0 + d1;
+        return ( d2 - d &lt; 0.01);
+    }
+    
+#undef TOL
+    template &lt;typename Iter&gt; 
+    inline bool point_on_path(double x,double y,Iter start,Iter end)
+    {
+        return false;
+    }
+    
+    template &lt;typename Iter&gt; 
+    inline bool point_on_points (double x,double y,Iter start,Iter end) 
+    {
+        return false; 
+    }
+
+    struct filter_in_box
+    {
+        Envelope&lt;double&gt; box_;
+        explicit filter_in_box(const Envelope&lt;double&gt;&amp; box)
+            : box_(box) {}
+
+        bool pass(const Envelope&lt;double&gt;&amp; extent) const
+        {
+            return extent.intersects(box_);
+        }
+    };
+
+    struct filter_at_point
+    {
+        coord2d pt_;
+        explicit filter_at_point(const coord2d&amp; pt)
+            : pt_(pt) {}
+        bool pass(const Envelope&lt;double&gt;&amp; extent) const
+        {
+            return extent.contains(pt_);
+        }
+    };
+}
+
+#endif                                            //GEOM_UTIL_HPP

Copied: trunk/include/mapnik/geometry.hpp (from rev 307, trunk/include/geometry.hpp)
===================================================================
--- trunk/include/geometry.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/geometry.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,387 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+
+//$Id: geometry.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef GEOMETRY_HPP
+#define GEOMETRY_HPP
+
+// boost
+#include &lt;boost/shared_ptr.hpp&gt;
+#include &lt;boost/utility.hpp&gt;
+// mapnik
+#include &lt;mapnik/vertex_vector.hpp&gt;
+#include &lt;mapnik/vertex_transform.hpp&gt;
+#include &lt;mapnik/ctrans.hpp&gt;
+#include &lt;mapnik/geom_util.hpp&gt;
+
+namespace mapnik {
+    enum {
+    	Point = 1,
+    	LineString = 2,
+    	Polygon = 3
+    };
+    
+    template &lt;typename T&gt;
+    class geometry : private boost::noncopyable
+    {   
+    public:
+        typedef T vertex_type;
+        typedef typename vertex_type::type value_type;
+    private:
+        int srid_;
+    public:
+        geometry (int srid=-1)
+            : srid_(srid) {}	
+
+        int srid() const
+        {
+            return srid_;
+        }
+	
+        Envelope&lt;double&gt; envelope()
+        {
+            Envelope&lt;double&gt; result;		
+            double x,y;
+            for (unsigned i=0;i&lt;num_points();++i)
+            {
+                vertex(&amp;x,&amp;y);
+                if (i==0)
+                {
+                    result.init(x,y,x,y);
+                }
+                else
+                {
+                    result.expand_to_include(x,y);
+                }
+            }
+            return result;
+        }
+
+        virtual int type() const=0;
+        virtual bool hit_test(value_type x,value_type y) const=0;	
+        virtual void label_position(double *x, double *y) const=0;
+        virtual void move_to(value_type x,value_type y)=0;
+        virtual void line_to(value_type x,value_type y)=0;
+        virtual void transform(const mapnik::CoordTransform&amp; t)=0;
+        virtual unsigned num_points() const = 0;
+        virtual unsigned vertex(double* x, double* y)=0;
+        virtual void rewind(unsigned )=0;
+        virtual void set_capacity(size_t size)=0;
+        virtual ~geometry() {}
+    };
+    
+    template &lt;typename T&gt;
+    class point : public geometry&lt;T&gt;
+    {
+        typedef geometry&lt;T&gt; geometry_base;
+        typedef typename geometry&lt;T&gt;::vertex_type vertex_type;
+        typedef typename geometry&lt;T&gt;::value_type value_type;
+    private:
+        vertex_type pt_;
+    public:
+        point(int srid)
+            : geometry&lt;T&gt;(srid)
+        {}
+	 
+        int type() const 
+        {
+            return Point;
+        }
+        void label_position(double *x, double *y) const
+        {
+            *x = pt_.x;
+            *y = pt_.y;
+        }
+	
+        void move_to(value_type x,value_type y)
+        {
+            pt_.x = x;
+            pt_.y = y;
+        }
+	
+        void line_to(value_type ,value_type ) {}
+	
+        void transform(const mapnik::CoordTransform&amp; t)
+        {
+            t.forward_x(&amp;pt_.x);
+            t.forward_y(&amp;pt_.y);
+        }
+	
+        unsigned num_points() const
+        {
+            return 1;
+        }
+	
+        unsigned vertex(double* x, double* y)
+        {
+            *x = pt_.x;
+            *y = pt_.y;
+            return SEG_LINETO;
+        }
+	
+        void rewind(unsigned ) {}
+	
+        bool hit_test(value_type x,value_type y) const
+        {
+            return false;
+        }
+        void set_capacity(size_t) {}
+        virtual ~point() {}
+    };
+
+    template &lt;typename T, template &lt;typename&gt; class Container=vertex_vector2&gt;
+    class polygon : public geometry&lt;T&gt;
+    {
+        typedef geometry&lt;T&gt; geometry_base;
+        typedef typename geometry&lt;T&gt;::vertex_type vertex_type;
+        typedef typename geometry_base::value_type value_type;
+        typedef Container&lt;vertex_type&gt; container_type;
+    private:
+        container_type cont_;
+        mutable unsigned itr_;
+    public:
+        polygon(int srid)
+            : geometry_base(srid),
+              itr_(0)
+        {}
+        
+        int type() const 
+        {
+            return Polygon;
+        }
+	
+        void label_position(double *x, double *y) const
+        {
+	    
+            unsigned size = cont_.size();
+            if (size &lt; 3) 
+            {
+                cont_.get_vertex(0,x,y);
+                return;
+            }
+	      
+            double ai;
+            double atmp = 0;
+            double xtmp = 0;
+            double ytmp = 0;
+            double x0 =0;
+            double y0 =0;
+            double x1 =0;
+            double y1 =0;
+	    
+            unsigned i,j;
+            for (i = size-1,j = 0; j &lt; size; i = j, ++j)
+            {
+		
+                cont_.get_vertex(i,&amp;x0,&amp;y0);
+                cont_.get_vertex(j,&amp;x1,&amp;y1);
+                ai = x0 * y1 - x1 * y0;
+                atmp += ai;
+                xtmp += (x1 + x0) * ai;
+                ytmp += (y1 + y0) * ai;
+            }	  
+            if (atmp != 0)
+            {
+                *x = xtmp/(3*atmp);
+                *y = ytmp /(3*atmp);
+                return;
+            }
+            *x=x0;
+            *y=y0;	    	    
+        }
+
+        void line_to(value_type x,value_type y)
+        {
+            cont_.push_back(x,y,SEG_LINETO);
+        }
+
+        void move_to(value_type x,value_type y)
+        {
+            cont_.push_back(x,y,SEG_MOVETO);
+        }
+	
+        void transform(mapnik::CoordTransform const&amp; t)
+        {
+            unsigned size = cont_.size();
+            for (unsigned pos=0; pos &lt; size; ++pos)
+            {	
+                cont_.transform_at(pos,t);
+            }
+        }
+	
+        unsigned num_points() const
+        {
+            return cont_.size();
+        }
+	
+        unsigned vertex(double* x, double* y)
+        {
+            return cont_.get_vertex(itr_++,x,y);
+        }
+	
+        void rewind(unsigned )
+        {
+            itr_=0;
+        }
+	
+        bool hit_test(value_type x,value_type y) const
+        {	    
+            return point_inside_path(x,y,cont_.begin(),cont_.end());
+        } 
+        
+        void set_capacity(size_t size) 
+        {
+            cont_.set_capacity(size);
+        }
+        virtual ~polygon() {}
+    };
+    
+    template &lt;typename T, template &lt;typename&gt; class Container=vertex_vector&gt;
+    class line_string : public geometry&lt;T&gt;
+    {
+        typedef geometry&lt;T&gt; geometry_base;
+        typedef typename geometry_base::value_type value_type;
+        typedef typename geometry&lt;T&gt;::vertex_type vertex_type;
+        typedef Container&lt;vertex_type&gt; container_type;
+    private:
+        container_type cont_;
+        mutable unsigned itr_;
+    public:
+        line_string(int srid)
+            : geometry_base(srid),
+              itr_(0)
+        {}
+        
+        int type() const 
+        {
+            return LineString;
+        }
+        void label_position(double *x, double *y) const
+        {
+            // calculate mid point on line string
+            double x0=0;
+            double y0=0;
+            double x1=0;
+            double y1=0;
+	    
+            unsigned size = cont_.size();
+            if (size == 1)
+            {
+                cont_.get_vertex(0,x,y); 
+            }
+            else if (size == 2)
+            {
+
+                cont_.get_vertex(0,&amp;x0,&amp;y0);
+                cont_.get_vertex(1,&amp;x1,&amp;y1);
+                *x = 0.5 * (x1 + x0);
+                *y = 0.5 * (y1 + y0);		
+            }
+            else
+            {
+                double len=0.0;
+                for (unsigned pos = 1; pos &lt; size; ++pos)
+                {
+                    cont_.get_vertex(pos-1,&amp;x0,&amp;y0);
+                    cont_.get_vertex(pos,&amp;x1,&amp;y1);
+                    double dx = x1 - x0;
+                    double dy = y1 - y0;
+                    len += sqrt(dx * dx + dy * dy);
+                }
+                double midlen = 0.5 * len;
+                double dist = 0.0;
+                for (unsigned pos = 1; pos &lt; size;++pos)
+                {
+                    cont_.get_vertex(pos-1,&amp;x0,&amp;y0);
+                    cont_.get_vertex(pos,&amp;x1,&amp;y1);
+                    double dx = x1 - x0;
+                    double dy = y1 - y0; 
+                    double seg_len = sqrt(dx * dx + dy * dy);
+                    if (( dist + seg_len) &gt;= midlen)
+                    {
+                        double r = (midlen - dist)/seg_len;
+                        *x = x0 + (x1 - x0) * r;
+                        *y = y0 + (y1 - y0) * r;
+                        break;
+                    }
+                    dist += seg_len;
+                }
+            }
+	    
+        }
+        void line_to(value_type x,value_type y)
+        {
+            cont_.push_back(x,y,SEG_LINETO);
+        }
+
+        void move_to(value_type x,value_type y)
+        {
+            cont_.push_back(x,y,SEG_MOVETO);
+        }
+	
+        void transform(mapnik::CoordTransform const&amp; t)
+        {
+            unsigned size = cont_.size();
+            for (unsigned pos=0; pos &lt; size; ++pos)
+            {	
+                cont_.transform_at(pos,t);
+            }
+        }
+	
+        unsigned num_points() const
+        {
+            return cont_.size();
+        }
+	
+        unsigned vertex(double* x, double* y)
+        {
+            return cont_.get_vertex(itr_++,x,y);
+        }
+	
+        void rewind(unsigned )
+        {
+            itr_=0;
+        }
+	
+        bool hit_test(value_type x,value_type y) const
+        {	    
+            return false;
+        } 
+	
+        void set_capacity(size_t size) 
+        {
+            cont_.set_capacity(size);
+        }
+        virtual ~line_string() {}
+    };
+
+    typedef point&lt;vertex2d&gt; point_impl;
+    typedef line_string&lt;vertex2d,vertex_vector2&gt; line_string_impl;
+    typedef polygon&lt;vertex2d,vertex_vector2&gt; polygon_impl;
+    
+    typedef geometry&lt;vertex2d&gt; geometry_type;
+    typedef boost::shared_ptr&lt;geometry_type&gt; geometry_ptr;
+}
+
+#endif //GEOMETRY_HPP

Copied: trunk/include/mapnik/global.hpp (from rev 307, trunk/include/global.hpp)
===================================================================
--- trunk/include/global.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/global.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,61 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef GLOBAL_HPP
+#define GLOBAL_HPP
+
+#include &lt;boost/cstdint.hpp&gt;
+
+namespace mapnik
+{
+    using namespace boost;
+#define int2net(A)  (int32_t) (((uint32_t) ((uint8_t) (A)[1]))      |   \
+                               (((uint32_t) ((uint8_t) (A)[0])) &lt;&lt; 8))
+
+#define int4net(A)  (int32_t) (((uint32_t) ((uint8_t) (A)[3]))      |   \
+                               (((uint32_t) ((uint8_t) (A)[2])) &lt;&lt; 8)  | \
+                               (((uint32_t) ((uint8_t) (A)[1])) &lt;&lt; 16) | \
+                               (((uint32_t) ((uint8_t) (A)[0])) &lt;&lt; 24))
+
+
+    typedef char byte;
+#define float8net(V,M)   do { double def_temp;  \
+        ((byte*) &amp;def_temp)[0]=(M)[7];          \
+        ((byte*) &amp;def_temp)[1]=(M)[6];          \
+        ((byte*) &amp;def_temp)[2]=(M)[5];          \
+        ((byte*) &amp;def_temp)[3]=(M)[4];          \
+        ((byte*) &amp;def_temp)[4]=(M)[3];          \
+        ((byte*) &amp;def_temp)[5]=(M)[2];          \
+        ((byte*) &amp;def_temp)[6]=(M)[1];          \
+        ((byte*) &amp;def_temp)[7]=(M)[0];          \
+        (V) = def_temp; } while(0)
+#define float4net(V,M)   do { float def_temp;   \
+        ((byte*) &amp;def_temp)[0]=(M)[3];          \
+        ((byte*) &amp;def_temp)[1]=(M)[2];          \
+        ((byte*) &amp;def_temp)[2]=(M)[1];          \
+        ((byte*) &amp;def_temp)[3]=(M)[0];          \
+        (V)=def_temp; } while(0)
+}
+
+#endif //GLOBAL_HPP

Copied: trunk/include/mapnik/graphics.hpp (from rev 307, trunk/include/graphics.hpp)
===================================================================
--- trunk/include/graphics.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/graphics.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,183 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: graphics.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef GRAPHICS_HPP
+#define GRAPHICS_HPP
+// stl
+#include &lt;cmath&gt;
+#include &lt;string&gt;
+#include &lt;cassert&gt;
+// mapnik
+#include &lt;mapnik/color.hpp&gt;
+#include &lt;mapnik/gamma.hpp&gt;
+#include &lt;mapnik/image_data.hpp&gt;
+#include &lt;mapnik/envelope.hpp&gt;
+
+namespace mapnik
+{
+    class MAPNIK_DECL Image32
+    {
+    private:
+        unsigned width_;
+        unsigned height_;
+        Color background_;
+        ImageData32 data_;
+    public:
+        Image32(int width,int height);
+        Image32(const Image32&amp; rhs);
+        ~Image32();
+        void setBackground(const Color&amp; background);
+        const Color&amp; getBackground() const;     
+        const ImageData32&amp; data() const;
+        
+        inline ImageData32&amp; data() 
+        {
+            return data_;
+        }
+        
+        inline const unsigned char* raw_data() const
+        {
+            return data_.getBytes();
+        }
+	
+        inline unsigned char* raw_data()
+        {
+            return data_.getBytes();
+        }
+	
+        void saveToFile(const std::string&amp; file,const std::string&amp; format=&quot;auto&quot;); 
+    private:
+
+        inline bool checkBounds(unsigned x, unsigned y) const
+        {
+            return (x &lt; width_ &amp;&amp; y &lt; height_);
+        }
+
+    public:
+        inline void setPixel(int x,int y,unsigned int rgba)
+        {
+            if (checkBounds(x,y))
+            {
+                data_(x,y)=rgba;
+            }
+        }
+        inline void blendPixel(int x,int y,unsigned int rgba1,int t)
+        {
+            if (checkBounds(x,y))
+            {
+                unsigned rgba0 = data_(x,y);	
+                unsigned a1 = t;//(rgba1 &gt;&gt; 24) &amp; 0xff;
+                if (a1 == 0) return;
+                unsigned r1 = rgba1 &amp; 0xff;
+                unsigned g1 = (rgba1 &gt;&gt; 8 ) &amp; 0xff;
+                unsigned b1 = (rgba1 &gt;&gt; 16) &amp; 0xff;
+		
+                unsigned a0 = (rgba0 &gt;&gt; 24) &amp; 0xff;
+                unsigned r0 = (rgba0 &amp; 0xff) * a0;
+                unsigned g0 = ((rgba0 &gt;&gt; 8 ) &amp; 0xff) * a0;
+                unsigned b0 = ((rgba0 &gt;&gt; 16) &amp; 0xff) * a0;
+		
+		
+                a0 = ((a1 + a0) &lt;&lt; 8) - a0*a1;
+		
+                r0 = ((((r1 &lt;&lt; 8) - r0) * a1 + (r0 &lt;&lt; 8)) / a0);
+                g0 = ((((g1 &lt;&lt; 8) - g0) * a1 + (g0 &lt;&lt; 8)) / a0);
+                b0 = ((((b1 &lt;&lt; 8) - b0) * a1 + (b0 &lt;&lt; 8)) / a0);
+                a0 = a0 &gt;&gt; 8;
+                data_(x,y)= (a0 &lt;&lt; 24)| (b0 &lt;&lt; 16) |  (g0 &lt;&lt; 8) | (r0) ;
+            }
+        }
+
+        inline unsigned width() const
+        {
+            return width_;
+        }
+	
+        inline unsigned height() const
+        {
+            return height_;
+        }
+
+        inline void set_rectangle(int x0,int y0,ImageData32 const&amp; data)
+        {
+            Envelope&lt;int&gt; ext0(0,0,width_,height_);   
+            Envelope&lt;int&gt; ext1(x0,y0,x0+data.width(),y0+data.height());
+	    
+            if (ext0.intersects(ext1))
+            {	
+                Envelope&lt;int&gt; box = ext0.intersect(ext1);
+                for (int y = box.miny(); y &lt; box.maxy(); ++y)
+                {
+                    for (int x = box.minx(); x &lt; box.maxx(); ++x)
+                    {
+                        if ((data(x-x0,y-y0) &amp; 0xff000000)) 
+                        {
+                            data_(x,y)=data(x-x0,y-y0);
+                        }
+                    }
+                }   
+            }
+        }
+	
+        inline void set_rectangle_alpha(int x0,int y0,const ImageData32&amp; data)
+        {
+            Envelope&lt;int&gt; ext0(0,0,width_,height_);   
+            Envelope&lt;int&gt; ext1(x0,y0,x0 + data.width(),y0 + data.height());
+	    
+            if (ext0.intersects(ext1))
+            {	                		
+                Envelope&lt;int&gt; box = ext0.intersect(ext1);		
+                for (int y = box.miny(); y &lt; box.maxy(); ++y)
+                {
+                    for (int x = box.minx(); x &lt; box.maxx(); ++x)
+                    {
+                        unsigned rgba0 = data_(x,y);
+                        unsigned rgba1 = data(x-x0,y-y0);
+		    
+                        unsigned a1 = (rgba1 &gt;&gt; 24) &amp; 0xff;
+                        if (a1 == 0) continue;
+                        unsigned r1 = rgba1 &amp; 0xff;
+                        unsigned g1 = (rgba1 &gt;&gt; 8 ) &amp; 0xff;
+                        unsigned b1 = (rgba1 &gt;&gt; 16) &amp; 0xff;
+		    
+                        unsigned a0 = (rgba0 &gt;&gt; 24) &amp; 0xff;
+                        unsigned r0 = (rgba0 &amp; 0xff) * a0;
+                        unsigned g0 = ((rgba0 &gt;&gt; 8 ) &amp; 0xff) * a0;
+                        unsigned b0 = ((rgba0 &gt;&gt; 16) &amp; 0xff) * a0;
+		    
+		    
+                        a0 = ((a1 + a0) &lt;&lt; 8) - a0*a1;
+		    
+                        r0 = ((((r1 &lt;&lt; 8) - r0) * a1 + (r0 &lt;&lt; 8)) / a0);
+                        g0 = ((((g1 &lt;&lt; 8) - g0) * a1 + (g0 &lt;&lt; 8)) / a0);
+                        b0 = ((((b1 &lt;&lt; 8) - b0) * a1 + (b0 &lt;&lt; 8)) / a0);
+                        a0 = a0 &gt;&gt; 8;
+                        data_(x,y)= (a0 &lt;&lt; 24)| (b0 &lt;&lt; 16) |  (g0 &lt;&lt; 8) | (r0) ;
+                    }
+                }
+            }
+        }
+    };
+}
+#endif //GRAPHICS_HPP

Copied: trunk/include/mapnik/image_data.hpp (from rev 307, trunk/include/image_data.hpp)

Copied: trunk/include/mapnik/image_reader.hpp (from rev 307, trunk/include/image_reader.hpp)
===================================================================
--- trunk/include/image_reader.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/image_reader.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,64 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: image_reader.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef IMAGE_READER_HPP
+#define IMAGE_READER_HPP
+// stl
+#include &lt;stdexcept&gt;
+#include &lt;string&gt;
+// mapnik
+#include &lt;mapnik/image_data.hpp&gt;
+#include &lt;mapnik/config.hpp&gt;
+
+namespace mapnik 
+{
+    class ImageReaderException : public std::exception
+    {
+    private:
+        std::string message_;
+    public:
+        ImageReaderException(const std::string&amp; message) 
+            : message_(message) {}
+
+        ~ImageReaderException() throw() {}
+
+        virtual const char* what() const throw()
+        {
+            return message_.c_str();
+        }
+    };
+
+    struct MAPNIK_DECL ImageReader
+    {
+        virtual unsigned width() const=0;
+        virtual unsigned height() const=0;
+        virtual void read(unsigned x,unsigned y,ImageData32&amp; image)=0;
+        virtual ~ImageReader() {}
+    };
+
+    bool register_image_reader(const std::string&amp; type,ImageReader* (*)(const std::string&amp;));
+    MAPNIK_DECL ImageReader* get_image_reader(const std::string&amp; type,const std::string&amp; file);
+}
+
+#endif //IMAGE_READER_HPP

Copied: trunk/include/mapnik/image_util.hpp (from rev 307, trunk/include/image_util.hpp)
===================================================================
--- trunk/include/image_util.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/image_util.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,223 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: image_util.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef IMAGE_UTIL_HPP
+#define IMAGE_UTIL_HPP
+
+// stl
+#include &lt;string&gt;
+// mapnik
+#include &lt;mapnik/config.hpp&gt;
+#include &lt;mapnik/graphics.hpp&gt;
+
+namespace mapnik
+{
+    class MAPNIK_DECL ImageUtils
+    {
+    public:
+        static void save_to_file(const std::string&amp; filename,
+                                 const std::string&amp; type,
+                                 const Image32&amp; image);
+    private:
+        static void save_as_png(const std::string&amp; filename,
+                                const Image32&amp; image);
+        static void save_as_jpeg(const std::string&amp; filename,
+                                 int quality, 
+                                 const Image32&amp; image);
+    };
+    
+    template &lt;typename T&gt;
+    double distance(T x0,T y0,T x1,T y1)
+    {
+        double dx = x1-x0;
+        double dy = y1-y0;
+        return sqrt(dx * dx + dy * dy);
+    }
+
+    template &lt;typename Image&gt;
+    inline void scale_down2(Image&amp; target,const Image&amp; source)
+    {
+        int source_width=source.width();
+        int source_height=source.height();
+
+        int target_width=target.width();
+        int target_height=target.height();
+        if (target_width&lt;source_width/2 || target_height&lt;source_height/2)
+            return;
+        int y1,x1;
+        for (int y=0;y&lt;target_height;++y)
+        {
+            y1=2*y;
+            for(int x=0;x&lt;target_width;++x)
+            {
+                x1=2*x;
+                //todo calculate average???
+                target(x,y)=source(x1,y1);
+            }
+        }
+    }
+
+    template &lt;typename Image,int scale&gt;
+    struct image_op
+    {
+        static void scale_up(Image&amp; target,const Image&amp; source)
+        {
+            if (scale&lt;3) return;
+            int source_width=source.width();
+            int source_height=source.height();
+
+            int target_width=target.width();
+            int target_height=target.height();
+            if (target_width&lt;scale*source_width || target_height&lt;scale*source_height)
+                return;
+            for (int y=0;y&lt;source_height;++y)
+            {
+                for(int x=0;x&lt;source_width;++x)
+                {
+                    unsigned p=source(x,y);
+                    for (int i=0;i&lt;scale;++i)
+                        for (int j=0;j&lt;scale;++j)
+                            target(scale*x+i,scale*y+j)=p;
+                }
+            }
+        }
+    };
+
+    template &lt;typename Image&gt;
+    struct image_op&lt;Image,2&gt;
+    {
+        static void scale_up(Image&amp; target,const Image&amp; source)
+        {
+            int source_width=source.width();
+            int source_height=source.height();
+
+            int target_width=target.width();
+            int target_height=target.height();
+            if (target_width&lt;2*source_width || target_height&lt;2*source_height)
+                return;
+            for (int y=0;y&lt;source_height;++y)
+            {
+                for(int x=0;x&lt;source_width;++x)
+                {
+                    target(2*x,2*y)=source(x,y);
+                    target(2*x+1,2*y)=source(x,y);
+                    target(2*x+1,2*y+1)=source(x,y);
+                    target(2*x,2*y+1)=source(x,y);
+                }
+            }
+        }
+    };
+
+    namespace
+    {
+        template &lt;typename Image&gt;
+        inline void scale_up(Image&amp; target,const Image&amp; source,unsigned scale)
+        {
+            int source_width=source.width();
+            int source_height=source.height();
+
+            int target_width=target.width();
+            int target_height=target.height();
+            if (target_width&lt;scale*source_width || target_height&lt;scale*source_height)
+                return;
+            for (int y=0;y&lt;source_height;++y)
+            {
+                for(int x=0;x&lt;source_width;++x)
+                {
+                    unsigned p=source(x,y);
+                    for (int i=0;i&lt;scale;++i)
+                        for (int j=0;j&lt;scale;++j)
+                            target(scale*x+i,scale*y+j)=p;
+                }
+            }
+        }
+    }
+    
+    template &lt;typename Image&gt;
+    void scale_image(Image&amp; target,const Image&amp; source,unsigned scale)
+    {
+        if (scale==2)
+        {
+            image_op&lt;Image,2&gt;::scale_up(target,source);
+        }
+        else
+        {
+            scale_up&lt;Image&gt;(target,source,scale);
+        }
+    }
+
+    template &lt;typename Image&gt;
+    inline void scale_image (Image&amp; target,const Image&amp; source)
+    {
+
+        int source_width=source.width();
+        int source_height=source.height();
+
+        int target_width=target.width();
+        int target_height=target.height();
+
+        if (source_width&lt;1 || source_height&lt;1 ||
+            target_width&lt;1 || target_height&lt;1) return;
+        int int_part_y=source_height/target_height;
+        int fract_part_y=source_height%target_height;
+        int err_y=0;
+        int int_part_x=source_width/target_width;
+        int fract_part_x=source_width%target_width;
+        int err_x=0;
+        int x=0,y=0,xs=0,ys=0;
+        int prev_y=-1;
+        for (y=0;y&lt;target_height;++y)
+        {
+            if (ys==prev_y)
+            {
+                target.setRow(y,target.getRow(y-1),target_width);
+            }
+            else
+            {
+                xs=0;
+                for (x=0;x&lt;target_width;++x)
+                {
+                    target(x,y)=source(xs,ys);
+                    xs+=int_part_x;
+                    err_x+=fract_part_x;
+                    if (err_x&gt;=target_width)
+                    {
+                        err_x-=target_width;
+                        ++xs;
+                    }
+                }
+                prev_y=ys;
+            }
+            ys+=int_part_y;
+            err_y+=fract_part_y;
+            if (err_y&gt;=target_height)
+            {
+                err_y-=target_height;
+                ++ys;
+            }
+        }
+    }
+}
+
+#endif //IMAGE_UTIL_HPP

Copied: trunk/include/mapnik/label_collision_detector.hpp (from rev 307, trunk/include/label_collision_detector.hpp)
===================================================================
--- trunk/include/label_collision_detector.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/label_collision_detector.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,88 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#if !defined LABEL_COLLISION_DETECTOR
+#define LABEL_COLLISION_DETECTOR
+// stl
+#include &lt;vector&gt;
+// mapnik
+#include &lt;mapnik/quad_tree.hpp&gt;
+
+namespace mapnik
+{
+    //this needs to be tree structure 
+    //as a proof of a concept _only_ we use sequential scan 
+
+    struct label_collision_detector
+    {
+        typedef std::vector&lt;Envelope&lt;double&gt; &gt; label_placements;
+
+        bool has_plasement(Envelope&lt;double&gt; const&amp; box)
+        {
+            label_placements::const_iterator itr=labels_.begin();
+            for( ; itr !=labels_.end();++itr)
+            {
+                if (itr-&gt;intersects(box))
+                {
+                    return false;
+                }
+            }
+            labels_.push_back(box);
+            return true;
+        }
+    private:
+
+        label_placements labels_;
+    };
+
+    // quad_tree based label collision detector
+    class label_collision_detector2 : boost::noncopyable
+    {
+        typedef quad_tree&lt;Envelope&lt;double&gt; &gt; tree_t;
+        tree_t tree_;
+    public:
+	
+        explicit label_collision_detector2(Envelope&lt;double&gt; const&amp; extent)
+            : tree_(extent) {}
+	
+        bool has_placement(Envelope&lt;double&gt; const&amp; box)
+        {
+            tree_t::query_iterator itr = tree_.query_in_box(box);
+            tree_t::query_iterator end = tree_.query_end();
+	    
+            for ( ;itr != end; ++itr)
+            {
+                if (itr-&gt;intersects(box))
+                {
+                    return false;
+                }
+            }
+	    
+            tree_.insert(box,box);
+            return true;
+        }	
+    };
+}
+
+#endif 

Copied: trunk/include/mapnik/label_placement.hpp (from rev 307, trunk/include/label_placement.hpp)

Copied: trunk/include/mapnik/layer.hpp (from rev 307, trunk/include/layer.hpp)
===================================================================
--- trunk/include/layer.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/layer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,87 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id: layer.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef LAYER_HPP
+#define LAYER_HPP
+// stl
+#include &lt;vector&gt;
+// boost
+#include &lt;boost/shared_ptr.hpp&gt;
+// mapnik
+#include &lt;mapnik/feature.hpp&gt;
+#include &lt;mapnik/datasource.hpp&gt;
+
+namespace mapnik
+{
+    class MAPNIK_DECL Layer
+    {
+        std::string name_;
+        std::string title_;
+        std::string abstract_;
+        double minZoom_;
+        double maxZoom_;
+        bool active_;
+        bool selectable_;
+        std::vector&lt;std::string&gt;  styles_;
+        std::string selection_style_;
+        datasource_p ds_;
+        
+        mutable std::vector&lt;boost::shared_ptr&lt;Feature&gt; &gt; selection_;
+        
+    public:
+        explicit Layer(std::string const&amp; name);
+        Layer(Layer const&amp; l);
+        Layer&amp; operator=(Layer const&amp; l);
+        bool operator==(Layer const&amp; other) const;
+        void set_name(std::string const&amp; name);
+        const std::string&amp; name() const;
+        void set_title(std::string const&amp; title);
+        const std::string&amp; title() const;
+        void set_abstract(std::string const&amp; abstract);
+        const std::string&amp; abstract() const;
+        void add_style(std::string const&amp; stylename);
+        std::vector&lt;std::string&gt; const&amp; styles() const;
+        void selection_style(const std::string&amp; name);
+        const std::string&amp; selection_style() const;
+        void setMinZoom(double minZoom);
+        void setMaxZoom(double maxZoom);
+        double getMinZoom() const;
+        double getMaxZoom() const;
+        void setActive(bool active);
+        bool isActive() const;
+        void setSelectable(bool selectable);
+        bool isSelectable() const;
+        bool isVisible(double scale) const;
+        void add_to_selection(boost::shared_ptr&lt;Feature&gt;&amp; feature) const;
+        std::vector&lt;boost::shared_ptr&lt;Feature&gt; &gt;&amp; selection() const;
+        void clear_selection() const;
+        void set_datasource(datasource_p const&amp; ds);
+        datasource_p datasource() const;
+        Envelope&lt;double&gt; envelope() const;
+        ~Layer();
+    private:
+        void swap(const Layer&amp; other);
+    };
+}
+
+#endif //LAYER_HPP

Copied: trunk/include/mapnik/line_pattern_symbolizer.hpp (from rev 307, trunk/include/line_pattern_symbolizer.hpp)
===================================================================
--- trunk/include/line_pattern_symbolizer.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/line_pattern_symbolizer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,45 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id: polygon_symbolizer.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef LINE_PATTERN_SYMBOLIZER_HPP
+#define LINE_PATTERN_SYMBOLIZER_HPP
+
+#include &lt;boost/shared_ptr.hpp&gt;
+#include &lt;mapnik/graphics.hpp&gt;
+
+namespace mapnik 
+{      
+    struct MAPNIK_DECL line_pattern_symbolizer
+    {
+        line_pattern_symbolizer(std::string const&amp; file,
+                                std::string const&amp; type,
+                                unsigned width,unsigned height);
+
+        line_pattern_symbolizer(line_pattern_symbolizer const&amp; rhs);
+        ImageData32 const&amp; get_pattern() const;
+    private:
+        boost::shared_ptr&lt;ImageData32&gt; pattern_;
+    };    
+}
+
+#endif // LINE_PATTERN_SYMBOLIZER_HPP

Copied: trunk/include/mapnik/line_symbolizer.hpp (from rev 307, trunk/include/line_symbolizer.hpp)
===================================================================
--- trunk/include/line_symbolizer.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/line_symbolizer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,55 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id: line_symbolizer.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef LINE_SYMBOLIZER_HPP
+#define LINE_SYMBOLIZER_HPP
+
+#include &lt;mapnik/stroke.hpp&gt;
+
+namespace mapnik 
+{
+    struct MAPNIK_DECL line_symbolizer
+    {
+        explicit line_symbolizer()
+            : stroke_() {}
+        
+        line_symbolizer(stroke const&amp; stroke)
+            : stroke_(stroke) {}
+	
+        line_symbolizer(const Color&amp; pen,float width=1.0)
+            : stroke_(pen,width) {}
+        stroke const&amp; get_stroke() const
+        {
+            return stroke_;
+        }
+        void set_stroke(stroke const&amp; stroke)
+        {
+            stroke_ = stroke;
+        }
+
+    private:
+		stroke stroke_;
+    };
+}
+
+#endif //LINE_SYMBOLIZER_HPP

Copied: trunk/include/mapnik/load_map.hpp (from rev 307, trunk/include/load_map.hpp)
===================================================================
--- trunk/include/load_map.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/load_map.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,35 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+// $Id$
+
+#ifndef MAP_LOADER_HPP
+#define MAP_LOADER_HPP
+
+#include &lt;string&gt;
+#include &lt;mapnik/map.hpp&gt;
+
+namespace mapnik
+{
+    void load_map(Map &amp; map, std::string const&amp; filename);
+}
+
+#endif // LOAD_MAP_HPP

Copied: trunk/include/mapnik/local_datasource.hpp (from rev 307, trunk/include/local_datasource.hpp)

Copied: trunk/include/mapnik/logical.hpp (from rev 307, trunk/include/logical.hpp)
===================================================================
--- trunk/include/logical.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/logical.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,172 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id$
+
+#ifndef LOGICAL_HPP
+#define LOGICAL_HPP
+
+#include &lt;mapnik/filter.hpp&gt;
+
+namespace mapnik
+{
+    template &lt;typename FeatureT&gt; 
+    struct logical_and : public filter&lt;FeatureT&gt;  
+    {
+	logical_and(filter&lt;FeatureT&gt; const&amp; filter1,
+		    filter&lt;FeatureT&gt; const&amp; filter2)
+	    : filter&lt;FeatureT&gt;(),
+	      filter1_(filter1.clone()),
+	      filter2_(filter2.clone()) {}
+	
+	logical_and(logical_and const&amp; other)
+	    : filter&lt;FeatureT&gt;(),
+	      filter1_(other.filter1_-&gt;clone()),
+	      filter2_(other.filter2_-&gt;clone()) {}
+
+	bool pass(const FeatureT&amp; feature) const
+	{
+	    return (filter1_-&gt;pass(feature) &amp;&amp; 
+		filter2_-&gt;pass(feature));
+	}
+	std::string to_string() const
+	{
+	    return &quot;(&quot;+filter1_-&gt;to_string()+&quot; and &quot;+filter2_-&gt;to_string()+&quot;)&quot;;
+	}
+	
+	filter&lt;FeatureT&gt;* clone() const
+	{
+	    return new logical_and(*this);
+	}
+
+	void accept(filter_visitor&lt;FeatureT&gt;&amp; v)
+	{
+	    filter1_-&gt;accept(v);
+	    filter2_-&gt;accept(v);
+	    v.visit(*this);
+	}
+
+	virtual ~logical_and()
+	{
+	    delete filter1_;
+	    delete filter2_;
+	}
+	
+    private:
+	filter&lt;FeatureT&gt;* filter1_;
+	filter&lt;FeatureT&gt;* filter2_;
+    };
+
+    template &lt;typename FeatureT&gt; 
+    struct logical_or : public filter&lt;FeatureT&gt;  
+    {
+	
+	logical_or(const filter&lt;FeatureT&gt;&amp; filter1,const filter&lt;FeatureT&gt;&amp; filter2)
+	    : filter&lt;FeatureT&gt;(),
+	      filter1_(filter1.clone()),
+	      filter2_(filter2.clone()) {}
+	
+	logical_or(logical_or const&amp; other)
+	    : filter&lt;FeatureT&gt;(),
+	      filter1_(other.filter1_-&gt;clone()),
+	      filter2_(other.filter2_-&gt;clone()) {}
+
+	bool pass(const FeatureT&amp; feature) const
+	{
+	    if (filter1_-&gt;pass(feature))
+	    {
+		return true;
+	    }
+	    else
+	    {
+		return filter2_-&gt;pass(feature);
+	    }
+	}
+	filter&lt;FeatureT&gt;* clone() const
+	{
+	    return new logical_or(*this);
+	}
+
+	void accept(filter_visitor&lt;FeatureT&gt;&amp; v)
+	{
+	    filter1_-&gt;accept(v);
+	    filter2_-&gt;accept(v);
+	    v.visit(*this);
+	}
+	std::string to_string() const
+	{
+	    return &quot;(&quot;+filter1_-&gt;to_string()+&quot; or &quot;+filter2_-&gt;to_string()+&quot;)&quot;;
+	}	
+	virtual ~logical_or()
+	{  
+	    delete filter1_;
+	    delete filter2_;
+	}
+    private:
+	filter&lt;FeatureT&gt;* filter1_;
+	filter&lt;FeatureT&gt;* filter2_;
+    };
+
+    template &lt;typename FeatureT&gt; 
+    struct logical_not : public filter&lt;FeatureT&gt;  
+    {
+	logical_not(filter&lt;FeatureT&gt; const&amp; _filter)
+	    : filter&lt;FeatureT&gt;(),
+	      filter_(_filter.clone()) {}
+	logical_not(logical_not const&amp; other)
+	    : filter&lt;FeatureT&gt;(),
+	      filter_(other.filter_-&gt;clone()) {}
+
+	int type() const
+	{
+	    return filter&lt;FeatureT&gt;::LOGICAL_OPS;
+	}
+
+	bool pass(const FeatureT&amp; feature) const
+	{
+	    return !(filter_-&gt;pass(feature));
+	}
+
+	filter&lt;FeatureT&gt;* clone() const
+	{
+	    return new logical_not(*this);
+	}
+	
+	void accept(filter_visitor&lt;FeatureT&gt;&amp; v)
+	{
+	    filter_-&gt;accept(v);
+	    v.visit(*this);
+	}
+	std::string to_string() const
+	{
+	    return &quot;not (&quot;+filter_-&gt;to_string()+&quot;)&quot;;
+	}
+	 
+	~logical_not() 
+	{
+	    delete filter_;
+	}
+    private:
+	filter&lt;FeatureT&gt;* filter_;
+    };
+}
+ 
+#endif //LOGICAL_HPP

Copied: trunk/include/mapnik/map.hpp (from rev 307, trunk/include/map.hpp)
===================================================================
--- trunk/include/map.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/map.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,85 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id: map.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef MAP_HPP
+#define MAP_HPP
+
+#include &lt;mapnik/feature_type_style.hpp&gt;
+
+namespace mapnik
+{
+    class Layer;
+
+    class MAPNIK_DECL Map
+    {	
+        static const unsigned MIN_MAPSIZE=16;
+        static const unsigned MAX_MAPSIZE=2048;
+        unsigned width_;
+        unsigned height_;
+        int srid_;
+        Color background_;
+        std::map&lt;std::string,feature_type_style&gt; styles_;
+        std::vector&lt;Layer&gt; layers_;
+        Envelope&lt;double&gt; currentExtent_;
+        
+    public:
+ 
+        typedef std::map&lt;std::string,feature_type_style&gt;::const_iterator style_iterator;
+        
+        Map();
+        Map(int width,int height,int srid=-1);
+        Map(const Map&amp; rhs);
+        Map&amp; operator=(const Map&amp; rhs);
+        style_iterator begin_styles() const;
+        style_iterator end_styles() const;
+        bool insert_style(std::string const&amp; name,feature_type_style const&amp; style);
+        void remove_style(const std::string&amp; name);
+        feature_type_style const&amp; find_style(std::string const&amp; name) const;
+        size_t layerCount() const;
+        void addLayer(const Layer&amp; l);
+        const Layer&amp; getLayer(size_t index) const;
+        Layer&amp; getLayer(size_t index);
+        void removeLayer(size_t index);
+        std::vector&lt;Layer&gt; const&amp; layers() const;
+        unsigned getWidth() const;
+        unsigned getHeight() const;
+        void setWidth(unsigned width);
+        void setHeight(unsigned height);
+        void resize(unsigned width,unsigned height);
+        int srid() const;
+        void setBackground(const Color&amp; c);
+        const Color&amp; getBackground() const;
+        void zoom(double zoom);
+        void zoomToBox(const Envelope&lt;double&gt;&amp; box);
+        void zoom_all();
+        void pan(int x,int y);
+        void pan_and_zoom(int x,int y,double zoom);
+        const Envelope&lt;double&gt;&amp; getCurrentExtent() const;
+        double scale() const;
+        ~Map();
+    private:
+        void fixAspectRatio();
+    };
+}
+
+#endif //MAP_HPP

Copied: trunk/include/mapnik/math_expr.hpp (from rev 307, trunk/include/math_expr.hpp)
===================================================================
--- trunk/include/math_expr.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/math_expr.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,128 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id$
+
+#ifndef MATH_EXPR_HPP
+#define MATH_EXPR_HPP
+
+#include &lt;mapnik/expression.hpp&gt;
+
+namespace mapnik
+{
+    template &lt;typename T&gt;
+    struct add
+    {
+        T operator () (T const&amp; left, T const&amp; right)
+        {
+            return left + right;
+        }
+        static std::string to_string()
+        {
+            return &quot;+&quot;;
+        } 
+    };
+
+    template &lt;typename T&gt;
+    struct sub
+    {
+        T operator () (T const&amp; left, T const&amp; right)
+        {
+            return left - right;
+        }
+        static std::string to_string()
+        {
+            return &quot;-&quot;;
+        } 
+    };
+    
+    template &lt;typename T&gt;
+    struct mult
+    {
+        T operator () (T const&amp; left, T const&amp; right)
+        {
+            return left * right;
+        }
+        static std::string to_string()
+        {
+            return &quot;*&quot;;
+        } 
+    };
+    
+    template &lt;typename T&gt;
+    struct div
+    {
+        T operator () (T const&amp; left, T const&amp; right)
+        {
+            return left / right;
+        }
+        static std::string to_string()
+        {
+            return &quot;/&quot;;
+        } 
+    };
+    
+    template &lt;typename FeatureT,typename Op&gt;
+    struct math_expr_b : public expression&lt;FeatureT&gt;
+    {
+        math_expr_b(expression&lt;FeatureT&gt; const&amp; left,
+                    expression&lt;FeatureT&gt; const&amp; right)
+            : expression&lt;FeatureT&gt;(),
+              left_(left.clone()), 
+              right_(right.clone()) {}
+        math_expr_b(math_expr_b const&amp; other)
+            : expression&lt;FeatureT&gt;(),
+              left_(other.left_-&gt;clone()),
+              right_(other.right_-&gt;clone()) {}
+
+        value get_value(FeatureT const&amp; feature) const
+        {
+            return Op ()(left_-&gt;get_value(feature),right_-&gt;get_value(feature));
+        }
+
+        void accept(filter_visitor&lt;FeatureT&gt;&amp; v)
+        {
+            left_-&gt;accept(v);
+            right_-&gt;accept(v);
+            v.visit(*this);
+        }
+
+        expression&lt;FeatureT&gt;* clone() const
+        {
+            return new math_expr_b&lt;FeatureT,Op&gt;(*this);
+        }
+        std::string to_string() const
+        {
+            return &quot;(&quot;+left_-&gt;to_string() + Op::to_string() + right_-&gt;to_string()+&quot;)&quot;;
+        }
+
+        ~math_expr_b() 
+        {
+            delete left_;
+            delete right_;
+        }
+    private:
+        expression&lt;FeatureT&gt;* left_;
+        expression&lt;FeatureT&gt;* right_;	
+    }; 
+}
+
+#endif //

Copied: trunk/include/mapnik/memory.hpp (from rev 307, trunk/include/memory.hpp)
===================================================================
--- trunk/include/memory.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/memory.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,88 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id: memory.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef MEMORY_HPP
+#define MEMORY_HPP
+
+#include &lt;iostream&gt;
+#include &lt;cassert&gt;
+
+namespace mapnik
+{
+    class MemoryUtils
+    {
+    public:
+        static size_t alignPointerSize(size_t ptrSize);
+    private:
+        MemoryUtils();
+        MemoryUtils(const MemoryUtils&amp;);
+        MemoryUtils&amp; operator=(const MemoryUtils&amp;);
+    };
+
+    class MemoryManager
+    {
+    public:
+        virtual void* allocate(size_t size)=0;
+        virtual void deallocate(void* p)=0;
+        virtual ~MemoryManager();
+    protected:
+        MemoryManager();                      // {}
+    private:
+        MemoryManager(const MemoryManager&amp;);
+        MemoryManager&amp; operator=(const MemoryManager&amp;);
+    };
+
+    class Object
+    {
+    public:
+        void* operator new(size_t size);
+        void* operator new(size_t size, MemoryManager* manager);
+        void operator delete(void* p);
+        void operator delete(void* p, MemoryManager* manager);
+    protected:
+        virtual ~Object() {}
+        Object() {}
+        Object(const Object&amp;) {}
+    protected:
+        Object&amp; operator=(const Object&amp;)
+        {
+            return *this;
+        }
+    };
+
+    template &lt;typename Geometry&gt;
+    class geometry_pool
+    {
+    public:
+        void* allocate()
+        {
+            return ::operator new(sizeof(Geometry));
+        }
+        void deallocate(void* p)
+        {
+            ::operator delete(p);
+        }
+    };
+
+}
+#endif //MEMORY_HPP

Copied: trunk/include/mapnik/params.hpp (from rev 307, trunk/include/params.hpp)
===================================================================
--- trunk/include/params.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/params.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,53 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id: params.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef PARAMS_HPP
+#define PARAMS_HPP
+
+#include &lt;string&gt;
+#include &lt;map&gt;
+
+namespace mapnik
+{
+
+    typedef std::pair&lt;const std::string,std::string&gt; parameter;
+    typedef std::map&lt;const std::string,std::string&gt; param_map;
+
+    class parameters : public param_map
+    {
+    public:
+
+        parameters() {}
+        const std::string get(std::string const&amp; key) const
+        {
+            param_map::const_iterator itr=find(key);
+            if (itr != end())
+            {
+                return itr-&gt;second;
+            }
+            return std::string();
+        }
+    };
+}
+
+#endif //PARAMS_HPP

Copied: trunk/include/mapnik/plugin.hpp (from rev 307, trunk/include/plugin.hpp)
===================================================================
--- trunk/include/plugin.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/plugin.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,50 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: plugin.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef PLUGIN_HPP
+#define PLUGIN_HPP
+// ltdl
+#include &lt;ltdl.h&gt;
+// stl
+#include &lt;string&gt;
+// boost
+#include &lt;boost/utility.hpp&gt;
+
+namespace mapnik
+{
+    class PluginInfo : boost::noncopyable
+    {
+    private:
+        std::string name_;
+        lt_dlhandle module_;
+	
+    public:
+        PluginInfo (const std::string&amp; name,const lt_dlhandle module);
+        ~PluginInfo();
+        const std::string&amp; name() const;
+        lt_dlhandle handle() const;
+    };
+}
+
+#endif //PLUGIN_HPP

Copied: trunk/include/mapnik/point_symbolizer.hpp (from rev 307, trunk/include/point_symbolizer.hpp)
===================================================================
--- trunk/include/point_symbolizer.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/point_symbolizer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,50 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id: image_symbolizer.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef POINT_SYMBOLIZER_HPP
+#define POINT_SYMBOLIZER_HPP
+
+#include &lt;boost/shared_ptr.hpp&gt;
+#include &lt;mapnik/graphics.hpp&gt; 
+
+namespace mapnik 
+{   
+    struct MAPNIK_DECL point_symbolizer
+    {	
+        explicit point_symbolizer();
+        point_symbolizer(std::string const&amp; file,
+                         std::string const&amp; type,
+                         unsigned width,unsigned height);
+        point_symbolizer(point_symbolizer const&amp; rhs);
+        void set_data (boost::shared_ptr&lt;ImageData32&gt; symbol);
+        boost::shared_ptr&lt;ImageData32&gt; const&amp; get_data() const;        
+        void set_allow_overlap(bool overlap);
+        bool get_allow_overlap() const;
+        
+    private:
+        boost::shared_ptr&lt;ImageData32&gt; symbol_;
+        bool overlap_;
+    };
+}
+
+#endif // POINT_SYMBOLIZER_HPP

Copied: trunk/include/mapnik/polygon_pattern_symbolizer.hpp (from rev 307, trunk/include/polygon_pattern_symbolizer.hpp)
===================================================================
--- trunk/include/polygon_pattern_symbolizer.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/polygon_pattern_symbolizer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,47 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id$
+
+#ifndef POLYGON_PATTERN_SYMBOLIZER_HPP
+#define POLYGON_PATTERN_SYMBOLIZER_HPP
+
+#include &lt;boost/shared_ptr.hpp&gt;
+#include &lt;mapnik/graphics.hpp&gt; 
+
+namespace mapnik
+{
+    struct MAPNIK_DECL polygon_pattern_symbolizer
+    {
+	
+        polygon_pattern_symbolizer(std::string const&amp; file,
+                                   std::string const&amp; type,
+                                   unsigned width,unsigned height);
+        
+        polygon_pattern_symbolizer(polygon_pattern_symbolizer const&amp; rhs);
+        
+        ImageData32 const&amp; get_pattern() const;
+    private:
+        boost::shared_ptr&lt;ImageData32&gt; pattern_;
+    };
+}
+
+#endif //POLYGON_PATTERN_SYMBOLIZER_HPP

Copied: trunk/include/mapnik/polygon_symbolizer.hpp (from rev 307, trunk/include/polygon_symbolizer.hpp)
===================================================================
--- trunk/include/polygon_symbolizer.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/polygon_symbolizer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,64 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: polygon_symbolizer.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef POLYGON_SYMBOLIZER_HPP
+#define POLYGON_SYMBOLIZER_HPP
+
+#include &lt;mapnik/color.hpp&gt;
+
+namespace mapnik 
+{
+    struct MAPNIK_DECL polygon_symbolizer
+    {
+        explicit polygon_symbolizer() 
+            : fill_(Color(128,128,128)),
+              opacity_(1.0) {}
+
+        polygon_symbolizer(Color const&amp; fill)
+            : fill_(fill),
+              opacity_(1.0) {}
+        
+        Color const&amp; get_fill() const
+        {
+            return fill_;
+        }
+        void set_fill(Color const&amp; fill)
+        {
+            fill_ = fill;
+        }
+        void set_opacity(float opacity)
+        {
+            opacity_ = opacity;
+        }
+        float get_opacity() const
+        {
+            return opacity_;
+        }
+    private:
+        Color fill_;
+        float opacity_;
+    };  
+}
+
+#endif // POLYGON_SYMBOLIZER_HPP

Copied: trunk/include/mapnik/pool.hpp (from rev 307, trunk/include/pool.hpp)
===================================================================
--- trunk/include/pool.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/pool.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,122 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: pool.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef POOL_HPP
+#define POOL_HPP
+
+// stl
+#include &lt;iostream&gt;
+#include &lt;map&gt;
+#include &lt;deque&gt;
+#include &lt;ctime&gt;
+// boost
+#include &lt;boost/shared_ptr.hpp&gt;
+#include &lt;boost/thread/mutex.hpp&gt;
+#include &lt;boost/utility.hpp&gt;
+// mapnik
+#include &lt;mapnik/utils.hpp&gt;
+
+namespace mapnik
+{
+    template &lt;typename T, typename PoolT&gt;
+    class PoolGuard
+    {
+    private:
+        const T&amp; obj_;
+        PoolT&amp; pool_; 
+    public:
+        explicit PoolGuard(const T&amp; ptr,PoolT&amp; pool)
+            : obj_(ptr),
+              pool_(pool) {}
+
+        ~PoolGuard() 
+        {
+            pool_-&gt;returnObject(obj_);
+        }
+
+    private:
+        PoolGuard();
+        PoolGuard(const PoolGuard&amp;);
+        PoolGuard&amp; operator=(const PoolGuard&amp;);
+    };
+
+    template &lt;typename T,template &lt;typename&gt; class Creator&gt;
+    class Pool : private boost::noncopyable
+    {
+        typedef boost::shared_ptr&lt;T&gt; HolderType;
+        typedef std::deque&lt;HolderType&gt; ContType;	
+	
+        Creator&lt;T&gt; creator_;
+        const int initialSize_; 
+        const int maxSize_;
+        ContType usedPool_;
+        ContType unusedPool_;
+        boost::mutex mutex_;
+    public:
+
+        Pool(const Creator&lt;T&gt;&amp; creator,int initialSize=5,int maxSize=20)
+            :creator_(creator),
+             initialSize_(initialSize),
+             maxSize_(maxSize)
+        {
+            for (int i=0;i&lt;initialSize_;++i) 
+            {
+                unusedPool_.push_back(HolderType(creator_()));
+            }
+        }
+
+        const HolderType&amp; borrowObject()
+        {	    
+            mutex::scoped_lock lock(mutex_);
+            typename ContType::iterator itr=unusedPool_.begin();
+            if (itr!=unusedPool_.end())
+            {  
+                std::clog&lt;&lt;&quot;borrow &quot;&lt;&lt;(*itr).get()&lt;&lt;&quot;\n&quot;;
+                usedPool_.push_back(*itr);
+                itr=unusedPool_.erase(itr);
+                return usedPool_[usedPool_.size()-1];
+            }
+            static const HolderType defaultObj;
+            return defaultObj;
+        } 
+
+        void returnObject(const HolderType&amp; obj)
+        {
+            mutex::scoped_lock lock(mutex_);
+            typename ContType::iterator itr=usedPool_.begin();
+            while (itr != usedPool_.end())
+            {
+                if (obj.get()==(*itr).get()) 
+                {
+                    std::clog&lt;&lt;&quot;return &quot;&lt;&lt;(*itr).get()&lt;&lt;&quot;\n&quot;;
+                    unusedPool_.push_back(*itr);
+                    usedPool_.erase(itr);
+                    return;
+                }
+                ++itr;
+            }
+        }
+    };
+}
+#endif //POOL_HPP

Copied: trunk/include/mapnik/quad_tree.hpp (from rev 307, trunk/include/quad_tree.hpp)
===================================================================
--- trunk/include/quad_tree.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/quad_tree.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,210 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id$
+
+#if !defined QUAD_TREE_HPP
+#define QUAD_TREE_HPP
+// stl
+#include &lt;vector&gt;
+// boost
+#include &lt;boost/ptr_container/ptr_vector.hpp&gt;
+#include &lt;boost/noncopyable.hpp&gt;
+// mapnik
+#include &lt;mapnik/envelope.hpp&gt;
+
+namespace mapnik
+{
+    template &lt;typename T&gt;
+    class quad_tree : boost::noncopyable
+    {
+        struct node
+        {
+            typedef T value_t;
+            typedef std::vector&lt;T&gt; cont_t;
+            typedef typename cont_t::iterator iterator;
+            typedef typename cont_t::const_iterator const_iterator;
+            Envelope&lt;double&gt; extent_;
+            cont_t cont_;
+            node * children_[4];
+
+            explicit node(Envelope&lt;double&gt; const&amp; ext)
+                : extent_(ext)
+            {
+                std::memset(children_,0,4*sizeof(node*));
+            }
+   
+            Envelope&lt;double&gt; const&amp; extent() const
+            {
+                return extent_;
+            }
+	    
+            iterator begin() 
+            {
+                return cont_.begin();
+            }
+	    
+            const_iterator begin() const 
+            {
+                return cont_.begin();
+            }
+	    
+            iterator end() 
+            {
+                return cont_.end();
+            }
+	    
+            const_iterator end() const 
+            {
+                return cont_.end();
+            }
+            ~node () {}
+        };
+	
+        typedef boost::ptr_vector&lt;node&gt; nodes_t;	
+        typedef typename node::cont_t cont_t;
+        typedef typename cont_t::iterator node_data_iterator;
+	
+        nodes_t nodes_;
+        node * root_;	
+        const double ratio_; 
+	
+    public:
+        typedef typename nodes_t::iterator iterator;
+        typedef typename nodes_t::const_iterator const_iterator;
+        typedef typename boost::ptr_vector&lt;T,boost::view_clone_allocator&gt; result_t;	
+        typedef typename result_t::iterator query_iterator;
+   
+        result_t query_result_;
+	
+        explicit quad_tree(Envelope&lt;double&gt; const&amp; ext,double ratio=0.55) 
+            : ratio_(ratio)
+        {
+            nodes_.push_back(new node(ext));
+            root_ = &amp;nodes_[0];
+        }
+		
+        void insert(T data, Envelope&lt;double&gt; const&amp; box)
+        {
+            do_insert_data(data,box,root_);
+        }
+        
+        query_iterator query_in_box(Envelope&lt;double&gt; const&amp; box)
+        {
+            query_result_.clear();
+            query_node(box,query_result_,root_);
+            return query_result_.begin();
+        }
+	
+        query_iterator query_end()
+        {
+            return query_result_.end();
+        }
+
+        iterator begin()
+        {
+            return nodes_.begin();
+        }
+	
+        const_iterator begin() const
+        {
+            return nodes_.begin();
+        }
+
+        iterator end()
+        {
+            return  nodes_.end();
+        }
+	
+        const_iterator end() const
+        {
+            return  nodes_.end();
+        }
+	
+    private:
+        
+        void query_node(Envelope&lt;double&gt; const&amp; box, result_t &amp; result, node * node_) const
+        {
+            if (node_)
+            {
+                Envelope&lt;double&gt; const&amp; node_extent = node_-&gt;extent();
+                if (box.intersects(node_extent))
+                {
+                    node_data_iterator i=node_-&gt;begin();
+                    node_data_iterator end=node_-&gt;end();
+                    while ( i!=end)
+                    {
+                        result.push_back(&amp;(*i));
+                        ++i;
+                    }
+                    for (int k = 0; k &lt; 4; ++k)
+                    {
+                        query_node(box,result,node_-&gt;children_[k]);
+                    }
+                }
+            }
+        }
+	
+        void do_insert_data(T data, Envelope&lt;double&gt; const&amp; box, node * n)
+        {
+            if (n)
+            {
+                Envelope&lt;double&gt; const&amp; node_extent = n-&gt;extent();
+                Envelope&lt;double&gt; ext[4];
+                split_box(node_extent,ext);		
+                for (int i=0;i&lt;4;++i)
+                {
+                    if (ext[i].contains(box))
+                    {
+                        if (!n-&gt;children_[i])
+                        {
+                            nodes_.push_back(new node(ext[i]));
+                            n-&gt;children_[i]=&amp;nodes_.back();
+                        }
+                        do_insert_data(data,box,n-&gt;children_[i]);
+                        return;
+                    }
+                }
+                n-&gt;cont_.push_back(data);
+            }
+        }
+	
+        void split_box(Envelope&lt;double&gt; const&amp; node_extent,Envelope&lt;double&gt; * ext)
+        {
+            coord2d c=node_extent.center();
+
+            double width=node_extent.width();
+            double height=node_extent.height();
+	    
+            double lox=node_extent.minx();
+            double loy=node_extent.miny();
+            double hix=node_extent.maxx();
+            double hiy=node_extent.maxy();
+	    
+            ext[0]=Envelope&lt;double&gt;(lox,loy,lox + width * ratio_,loy + height * ratio_);
+            ext[1]=Envelope&lt;double&gt;(hix - width * ratio_,loy,hix,loy + height * ratio_);
+            ext[2]=Envelope&lt;double&gt;(lox,hiy - height*ratio_,lox + width * ratio_,hiy);
+            ext[3]=Envelope&lt;double&gt;(hix - width * ratio_,hiy - height*ratio_,hix,hiy);
+        }
+    };    
+} 
+
+#endif

Copied: trunk/include/mapnik/query.hpp (from rev 307, trunk/include/query.hpp)
===================================================================
--- trunk/include/query.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/query.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,112 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id$
+
+#ifndef QUERY_HPP
+#define QUERY_HPP
+// stl
+#include &lt;set&gt;
+#include &lt;limits&gt;
+//mapnik
+#include &lt;mapnik/filter.hpp&gt;
+#include &lt;mapnik/envelope.hpp&gt;
+#include &lt;mapnik/feature.hpp&gt;
+
+namespace mapnik
+{
+    class query 
+    {
+    private:
+        Envelope&lt;double&gt; bbox_;
+        filter&lt;Feature&gt;* filter_;
+        std::set&lt;std::string&gt; names_;
+    public:
+        query() 
+            : bbox_(std::numeric_limits&lt;double&gt;::min(),
+                    std::numeric_limits&lt;double&gt;::min(),
+                    std::numeric_limits&lt;double&gt;::max(),
+                    std::numeric_limits&lt;double&gt;::max()),
+              filter_(new all_filter&lt;Feature&gt;)
+        {}
+        
+        query(const Envelope&lt;double&gt;&amp; bbox)
+            : bbox_(bbox),
+              filter_(new all_filter&lt;Feature&gt;)
+        {}
+	
+        query(const Envelope&lt;double&gt;&amp; bbox, const filter&lt;Feature&gt;&amp; f)
+            : bbox_(bbox),
+              filter_(f.clone())
+        {}
+	
+        query(const query&amp; other)
+            : bbox_(other.bbox_),
+              filter_(other.filter_-&gt;clone())
+        {}
+        
+        query&amp; operator=(const query&amp; other)
+        {
+            filter&lt;Feature&gt;* tmp=other.filter_-&gt;clone();
+            delete filter_;
+            filter_=tmp;
+            bbox_=other.bbox_;
+            names_=other.names_;
+            return *this;
+        }
+	
+        const filter&lt;Feature&gt;* get_filter() const
+        {
+            return  filter_;
+        }
+	
+        const Envelope&lt;double&gt;&amp; get_bbox() const
+        {
+            return bbox_;
+        }
+
+        void set_filter(const filter&lt;Feature&gt;&amp; f)
+        {
+            filter&lt;Feature&gt;* tmp=f.clone();
+            delete filter_;
+            filter_=tmp;
+        }
+        
+        void add_property_name(const std::string&amp; name)
+        {
+            names_.insert(name);
+        } 
+	
+        const std::set&lt;std::string&gt;&amp; property_names() const
+        {
+            return names_;
+        }
+	
+        ~query() 
+        {
+            delete filter_;
+        }
+    };
+}
+
+
+#endif //QUERY_HPP

Copied: trunk/include/mapnik/raster.hpp (from rev 307, trunk/include/raster.hpp)
===================================================================
--- trunk/include/raster.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/raster.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,41 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id: raster.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef RASTER_HPP
+#define RASTER_HPP
+
+#include &lt;mapnik/graphics.hpp&gt;
+
+namespace mapnik {
+    struct raster
+    {
+        Envelope&lt;double&gt; ext_;
+        ImageData32 data_;
+        raster(Envelope&lt;double&gt; const ext,ImageData32&amp; data)
+            : ext_(ext),
+              data_(data) {}
+    };
+}
+
+#endif //RASTER_HPP
+

Copied: trunk/include/mapnik/raster_symbolizer.hpp (from rev 307, trunk/include/raster_symbolizer.hpp)
===================================================================
--- trunk/include/raster_symbolizer.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/raster_symbolizer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,34 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id$
+
+#ifndef RASTER_SYMBOLIZER_HPP
+#define RASTER_SYMBOLIZER_HPP
+
+#include &lt;mapnik/config.hpp&gt;
+
+namespace mapnik
+{
+    struct MAPNIK_DECL raster_symbolizer { /* TODO */};
+}
+
+#endif //RASTER_SYMBOLIZER_HPP

Copied: trunk/include/mapnik/regex_filter.hpp (from rev 307, trunk/include/regex_filter.hpp)
===================================================================
--- trunk/include/regex_filter.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/regex_filter.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,81 @@
+/* This file is part of Mapnik (c++ mapping toolkit)
+ * Copyright (C) 2005 Artem Pavlenko
+ *
+ * Mapnik is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+//$Id$
+
+#ifndef REGEX_FILTER_HPP
+#define REGEX_FILTER_HPP
+// boost
+#include &lt;boost/regex.hpp&gt;
+#include &lt;boost/algorithm/string.hpp&gt;
+// mapnik
+#include &lt;mapnik/filter.hpp&gt;
+#include &lt;mapnik/expression.hpp&gt;
+
+namespace mapnik
+{ 
+    template &lt;typename FeatureT&gt;
+    struct regex_filter : public filter&lt;FeatureT&gt;
+    {
+
+        regex_filter(expression&lt;FeatureT&gt; const&amp; exp,
+                     std::string const&amp; pattern)
+            : filter&lt;FeatureT&gt;(),
+              exp_(exp.clone()),
+              pattern_(pattern) {}
+	
+        regex_filter(regex_filter const&amp; other)
+            :  filter&lt;FeatureT&gt;(),
+               exp_(other.exp_-&gt;clone()),
+               pattern_(other.pattern_) {}
+	
+        bool pass(FeatureT const&amp; feature) const
+        {
+            std::string text=exp_-&gt;get_value(feature).to_string();
+            boost::trim_if(text, boost::is_any_of(&quot;'&quot;));
+            return boost::regex_match(text,pattern_);
+        } 
+	
+        void accept(filter_visitor&lt;FeatureT&gt;&amp; v)
+        {
+            exp_-&gt;accept(v);
+            v.visit(*this);
+        }
+	
+        filter&lt;FeatureT&gt;* clone() const
+        {
+            return new regex_filter(*this);
+        }
+        std::string to_string() const
+        {
+            return exp_-&gt;to_string()+&quot;.match(&quot;+pattern_.str()+&quot;)&quot;;
+        }
+        ~regex_filter()
+        {
+            delete exp_;
+        }
+	
+    private:
+        expression&lt;FeatureT&gt;* exp_;
+        boost::regex pattern_;
+	
+    };   
+}
+
+
+#endif //REGEX_FILTER_HPP

Copied: trunk/include/mapnik/rule.hpp (from rev 307, trunk/include/rule.hpp)
===================================================================
--- trunk/include/rule.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/rule.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,283 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+#ifndef RULE_HPP
+#define RULE_HPP
+// stl
+#include &lt;string&gt;
+#include &lt;vector&gt;
+// boost
+#include &lt;boost/shared_ptr.hpp&gt;
+#include &lt;boost/variant.hpp&gt;
+// mapnik
+#include &lt;mapnik/line_symbolizer.hpp&gt;
+#include &lt;mapnik/line_pattern_symbolizer.hpp&gt;
+#include &lt;mapnik/polygon_symbolizer.hpp&gt;
+#include &lt;mapnik/polygon_pattern_symbolizer.hpp&gt;
+#include &lt;mapnik/point_symbolizer.hpp&gt;
+#include &lt;mapnik/raster_symbolizer.hpp&gt;
+#include &lt;mapnik/text_symbolizer.hpp&gt;
+#include &lt;mapnik/filter.hpp&gt;
+#include &lt;mapnik/filter_visitor.hpp&gt;
+
+namespace mapnik
+{
+    inline bool operator==(point_symbolizer const&amp; lhs,
+                           point_symbolizer const&amp; rhs)
+    {
+        return (&amp;lhs == &amp;rhs); 
+    }
+    inline bool operator==(line_symbolizer const&amp; lhs,
+                           line_symbolizer const&amp; rhs)
+    {
+        return (&amp;lhs == &amp;rhs); 
+    }
+    inline bool operator==(line_pattern_symbolizer const&amp; lhs,
+                           line_pattern_symbolizer const&amp; rhs)
+    {
+        return (&amp;lhs == &amp;rhs); 
+    }
+
+    inline bool operator==(polygon_symbolizer const&amp; lhs,
+                           polygon_symbolizer const&amp; rhs)
+    {
+        return (&amp;lhs == &amp;rhs); 
+    }
+    
+    inline bool operator==(polygon_pattern_symbolizer const&amp; lhs,
+                           polygon_pattern_symbolizer const&amp; rhs)
+    {
+        return (&amp;lhs == &amp;rhs); 
+    }
+    
+    inline bool operator==(raster_symbolizer const&amp; lhs,
+                           raster_symbolizer const&amp; rhs)
+    {
+        return (&amp;lhs == &amp;rhs); 
+    }
+    
+    inline bool operator==(text_symbolizer const&amp; lhs,
+                           text_symbolizer const&amp; rhs)
+    {
+        return (&amp;lhs == &amp;rhs); 
+    }
+    
+    typedef boost::variant&lt;point_symbolizer,
+                           line_symbolizer,
+                           line_pattern_symbolizer,
+                           polygon_symbolizer,
+                           polygon_pattern_symbolizer,
+                           raster_symbolizer,
+                           text_symbolizer&gt; symbolizer;
+    
+        
+    typedef std::vector&lt;symbolizer&gt; symbolizers;
+    
+    template &lt;typename FeatureT&gt; class all_filter;
+
+    template &lt;typename FeatureT,template &lt;typename&gt; class Filter&gt;
+    class rule
+    {
+        typedef Filter&lt;FeatureT&gt; filter_type;
+        typedef boost::shared_ptr&lt;filter_type&gt; filter_ptr;
+    private:
+
+        std::string name_;
+        std::string title_;
+        std::string abstract_;
+        double min_scale_;
+        double max_scale_;
+        symbolizers syms_;
+        filter_ptr filter_;
+        bool else_filter_;
+    public:
+        rule()
+            : name_(),
+              title_(),
+              abstract_(),
+              min_scale_(0),
+              max_scale_(std::numeric_limits&lt;double&gt;::infinity()),
+              syms_(),
+              filter_(new all_filter&lt;FeatureT&gt;),
+              else_filter_(false) {}
+                
+        rule(const std::string&amp; name,
+             const std::string&amp; title=&quot;&quot;,
+             double min_scale_denominator=0,
+             double max_scale_denominator=std::numeric_limits&lt;double&gt;::infinity())
+            : name_(name),
+              title_(title),
+              min_scale_(min_scale_denominator),
+              max_scale_(max_scale_denominator),
+              syms_(),
+              filter_(new all_filter&lt;FeatureT&gt;),
+              else_filter_(false) {}
+	    
+        rule(const rule&amp; rhs)    
+            : name_(rhs.name_),
+              title_(rhs.title_),
+              abstract_(rhs.abstract_),
+              min_scale_(rhs.min_scale_),
+              max_scale_(rhs.max_scale_),
+              syms_(rhs.syms_),
+              filter_(rhs.filter_),
+              else_filter_(rhs.else_filter_) {}
+	
+        rule&amp; operator=(rule const&amp; rhs) 
+        {
+            rule tmp(rhs);
+            swap(tmp);
+            return *this;
+        }
+        bool operator==(rule const&amp; other)
+        {
+            return  (this == &amp;other); 
+        }
+	
+        void set_max_scale(double scale)
+        {
+            max_scale_=scale;
+        }
+        
+        double get_max_scale() const
+        {
+            return max_scale_;
+        }
+        
+        void set_min_scale(double scale)
+        {
+            min_scale_=scale;
+        }
+
+        double get_min_scale() const
+        {
+            return min_scale_;
+        }
+
+       
+        void set_name(std::string const&amp; name)
+        {
+            name_=name;
+        }
+	
+        std::string const&amp; get_name() const
+        {
+            return name_;
+        }
+	
+        std::string const&amp; get_title() const
+        {
+            return  title_;
+        }
+
+        void set_title(std::string const&amp; title)
+        {
+            title_=title;
+        }
+  
+        void set_abstract(std::string const&amp; abstract)
+        {
+            abstract_=abstract;
+        }
+	
+        std::string const&amp; get_abstract() const
+        {
+            return abstract_;
+        }
+		
+        void append(const symbolizer&amp; sym)
+        {
+            syms_.push_back(sym);
+        }
+	
+        void remove_at(size_t index)
+        {
+            if (index &lt; syms_.size())
+            {
+                syms_.erase(syms_.begin()+index);
+            }
+        }
+	
+        const symbolizers&amp; get_symbolizers() const
+        {
+            return syms_;
+        }
+	
+        symbolizers::const_iterator begin()
+        {
+            return syms_.begin();
+        }
+	
+        symbolizers::const_iterator end()
+        {
+            return syms_.end();
+        }
+	
+        void set_filter(const filter_ptr&amp; filter)
+        {
+            filter_=filter;
+        }
+
+        filter_ptr const&amp; get_filter() const
+        {
+            return filter_;
+        }
+	
+        void set_else(bool else_filter)
+        {
+            else_filter_=else_filter;
+        }
+     
+        bool has_else_filter() const
+        {
+            return else_filter_;
+        }
+        
+        bool active(double scale) const
+        {
+            return ( scale &gt; min_scale_ &amp;&amp; scale &lt; max_scale_ );
+        }
+
+        void accept(filter_visitor&lt;FeatureT&gt;&amp; v) const
+        {
+            v.visit(*this);
+        }
+	
+    private:
+	
+        void swap(rule&amp; rhs) throw()
+        {
+            name_=rhs.name_;
+            title_=rhs.title_;
+            abstract_=rhs.abstract_;
+            min_scale_=rhs.min_scale_;
+            max_scale_=rhs.max_scale_;
+            syms_=rhs.syms_;
+            filter_=rhs.filter_;
+            else_filter_=rhs.else_filter_;
+        }
+    };
+
+    typedef rule&lt;Feature,filter&gt; rule_type;
+}
+
+#endif //RULE_HPP

Copied: trunk/include/mapnik/save_map.hpp (from rev 307, trunk/include/save_map.hpp)
===================================================================
--- trunk/include/save_map.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/save_map.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,36 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+// $Id$
+
+#ifndef SAVE_MAP_HPP
+#define SAVE_MAP_HPP
+// stl
+#include &lt;string&gt;
+// mapnik
+#include &lt;mapnik/map.hpp&gt;
+
+namespace mapnik
+{
+    void save_map(Map const&amp; map, std::string const&amp; filename);
+}
+
+#endif // SAVE_MAP_HPP

Copied: trunk/include/mapnik/spatial.hpp (from rev 307, trunk/include/spatial.hpp)
===================================================================
--- trunk/include/spatial.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/spatial.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,153 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+#ifndef SPATIAL_HPP
+#define SPATIAL_HPP
+
+#include &lt;mapnik/filter.hpp&gt;
+#include &lt;mapnik/filter_visitor.hpp&gt;
+
+namespace mapnik
+{    
+
+    template &lt;typename FeatureT&gt;
+    struct equals_ : public filter&lt;FeatureT&gt;
+    {
+
+        bool pass(const FeatureT&amp; feature) const
+        {
+            return false;
+        }
+	
+        void accept(const filter_visitor&lt;FeatureT&gt;&amp; v)
+        {
+            v.visit(*this);
+        }
+    };
+    
+    template &lt;typename FeatureT&gt;
+    struct disjoint : public filter&lt;FeatureT&gt;
+    {
+	  
+	
+        bool pass(const FeatureT&amp; feature) const
+        {
+            return false;
+        }
+	
+        void accept(const filter_visitor&lt;FeatureT&gt;&amp; v)
+        {
+            v.visit(*this);
+        }
+    };
+  
+    template &lt;typename FeatureT&gt;
+    struct touches : public filter&lt;FeatureT&gt;
+    {
+
+	
+        bool pass(const FeatureT&amp; feature) const
+        {
+            return false;
+        }
+	
+        void accept(const filter_visitor&lt;FeatureT&gt;&amp; v)
+        {
+            v.visit(*this);
+        }
+    };
+
+    template &lt;typename FeatureT&gt;
+    struct within : public filter&lt;FeatureT&gt;
+    {
+
+        bool pass(const FeatureT&amp; feature) const
+        {
+            return false;
+        }
+
+        void accept(const filter_visitor&lt;FeatureT&gt;&amp; v)
+        {
+            v.visit(*this);
+        }
+    };
+
+    template &lt;typename FeatureT&gt;
+    struct overlaps : public filter&lt;FeatureT&gt;
+    {
+
+        bool pass(const FeatureT&amp; feature) const
+        {
+            return false;
+        }
+	
+        void accept(const filter_visitor&lt;FeatureT&gt;&amp; v)
+        {
+            v.visit(*this);
+        }
+    };
+
+    template &lt;typename FeatureT&gt;
+    struct crosses : public filter&lt;FeatureT&gt;
+    {
+
+	
+        bool pass(const FeatureT&amp; feature) const
+        {
+            return false;
+        }
+	
+        void accept(const filter_visitor&lt;FeatureT&gt;&amp; v)
+        {
+            v.visit(*this);
+        }
+    };
+    
+    template &lt;typename FeatureT&gt;
+    struct bbox  : public filter&lt;FeatureT&gt; 
+    {
+    private:
+        Envelope&lt;double&gt; box_;
+    public:
+        bbox(const Envelope&lt;double&gt;&amp; box)
+            : box_(box) {}
+
+	
+        bool pass(const FeatureT&amp; feature) const
+        {
+            return box_.contains(feature.get_geometry()-&gt;bbox());
+        }
+	
+
+        filter&lt;FeatureT&gt;* clone() const
+        {
+            return new bbox&lt;FeatureT&gt;(box_);
+        }
+        void accept(const filter_visitor&lt;FeatureT&gt;&amp; v)
+        {
+            v.visit(*this);
+        }
+	
+        virtual ~bbox() {}
+    };
+}
+
+#endif //SPATIAL_HPP

Copied: trunk/include/mapnik/stroke.hpp (from rev 307, trunk/include/stroke.hpp)
===================================================================
--- trunk/include/stroke.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/stroke.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,170 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id$
+
+#ifndef STROKE_HPP
+#define STROKE_HPP
+// stl
+#include &lt;vector&gt;
+// mapnik
+#include &lt;mapnik/color.hpp&gt;
+ 
+namespace mapnik
+{
+    using std::pair;
+    using std::vector;
+    typedef vector&lt;pair&lt;float,float&gt; &gt; dash_array;
+    
+    enum line_cap_e
+        {
+            BUTT_CAP,
+            SQUARE_CAP,
+            ROUND_CAP
+        }; 
+    
+    enum line_join_e
+        {
+            MITER_JOIN,
+            MITER_REVERT_JOIN,
+            ROUND_JOIN,
+            BEVEL_JOIN
+        };
+    
+    class stroke
+    {	
+        Color c_;
+        float width_;
+        float opacity_; // 0.0 - 1.0
+        line_cap_e  line_cap_;
+        line_join_e line_join_;
+        dash_array dash_;	
+    public:
+        explicit stroke() 
+            : c_(0,0,0),
+              width_(1.0),
+              opacity_(1.0),
+              line_cap_(BUTT_CAP),
+              line_join_(MITER_JOIN),
+              dash_() {}
+	
+        stroke(Color const&amp; c, float width=1.0)
+            : c_(c),
+              width_(width),
+              opacity_(1.0),
+              line_cap_(BUTT_CAP),
+              line_join_(MITER_JOIN),
+              dash_() {}
+
+        stroke(stroke const&amp; other)
+            : c_(other.c_),
+              width_(other.width_),
+              opacity_(other.opacity_),
+              line_cap_(other.line_cap_),
+              line_join_(other.line_join_),
+              dash_(other.dash_) {}
+	    
+        stroke&amp; operator=(const stroke&amp; rhs)
+        {
+            stroke tmp(rhs);
+            swap(tmp);
+            return *this;
+        }
+
+        void set_color(const Color&amp; c) 
+        {
+            c_=c;
+        }
+	
+        Color const&amp; get_color() const
+        {
+            return c_;
+        }
+	
+        float get_width() const
+        {
+            return width_;
+        }
+        void set_width(float w)
+        {
+            width_=w;
+        }
+
+        void set_opacity(float opacity)
+        {    
+            if (opacity &gt; 1.0) opacity_=1.0;
+            else if (opacity &lt; 0.0) opacity_=0.0;
+            else opacity_=opacity;
+        }
+
+        float get_opacity() const 
+        {
+            return opacity_;
+        }
+	
+        void set_line_cap(line_cap_e line_cap)
+        {
+            line_cap_=line_cap;
+        }
+
+        line_cap_e get_line_cap() const 
+        {
+            return line_cap_;
+        }
+	
+        void set_line_join(line_join_e line_join) 
+        {
+            line_join_=line_join;
+        }
+	
+        line_join_e get_line_join() const 
+        {
+            return line_join_;
+        }
+	
+        void add_dash(float dash,float gap)
+        {
+            dash_.push_back(std::make_pair(dash,gap));
+        }
+        bool has_dash() const 
+        {
+            return dash_.size()&gt;0 ? true : false ;
+        }
+	
+        dash_array const&amp; get_dash_array() const
+        {
+            return  dash_;
+        }
+	
+    private:
+        void swap(const stroke&amp; other) throw()
+        {
+            c_=other.c_;
+            width_=other.width_;
+            opacity_=other.opacity_;
+            line_cap_=other.line_cap_;
+            line_join_=other.line_join_;
+            dash_ = other.dash_;
+        }
+    };
+}
+
+#endif //STROKE_HPP

Copied: trunk/include/mapnik/style.hpp (from rev 307, trunk/include/style.hpp)
===================================================================
--- trunk/include/style.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/style.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,38 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id: style.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef STYLE_HPP
+#define STYLE_HPP
+// stl
+#include &lt;vector&gt;
+#include &lt;algorithm&gt;
+#include &lt;functional&gt;
+// boost
+#include &lt;boost/shared_ptr.hpp&gt;
+// mapnik
+#include &lt;mapnik/color.hpp&gt;
+#include &lt;mapnik/symbolizer.hpp&gt;
+
+namespace mapnik { }
+
+#endif //STYLE_HPP

Copied: trunk/include/mapnik/style_factory.hpp (from rev 307, trunk/include/style_factory.hpp)
===================================================================
--- trunk/include/style_factory.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/style_factory.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,37 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id: style_factory.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef STYLE_FACTORY_HPP
+#define STYLE_FACTORY_HPP
+
+//#include &lt;mapnik/style.hpp&gt;
+
+namespace mapnik {
+    
+    class style_factory 
+    {
+    };
+}
+
+
+#endif //STYLE_FACTORY_HPP

Copied: trunk/include/mapnik/symbolizer.hpp (from rev 307, trunk/include/symbolizer.hpp)

Copied: trunk/include/mapnik/text_symbolizer.hpp (from rev 307, trunk/include/text_symbolizer.hpp)
===================================================================
--- trunk/include/text_symbolizer.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/text_symbolizer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,69 @@
+/* This file is part of Mapnik (c++ mapping toolkit)
+ * Copyright (C) 2005 Artem Pavlenko
+ *
+ * Mapnik is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+//$Id$
+
+#ifndef TEXT_SYMBOLIZER_HPP
+#define TEXT_SYMBOLIZER_HPP
+// stl
+#include &lt;string&gt;
+// boost
+#include &lt;boost/tuple/tuple.hpp&gt;
+// mapnik
+#include &lt;mapnik/color.hpp&gt;
+
+namespace mapnik
+{
+    enum label_placement_e {
+        point_placement=1,
+        line_placement=2
+    };
+        
+    typedef boost::tuple&lt;double,double&gt; position;
+    
+    struct MAPNIK_DECL text_symbolizer
+    {		
+        text_symbolizer(std::string const&amp; name,unsigned size,Color const&amp; fill);	
+        text_symbolizer(text_symbolizer const&amp; rhs);
+        text_symbolizer&amp; operator=(text_symbolizer const&amp; rhs);
+        std::string const&amp; get_name() const;
+        unsigned get_text_size() const;
+        Color const&amp; get_fill() const;
+        void set_halo_fill(Color const&amp; fill);
+        Color const&amp; get_halo_fill() const;
+        void set_halo_radius(unsigned radius);
+        unsigned get_halo_radius() const;
+        void set_label_placement(label_placement_e label_p);
+        label_placement_e get_label_placement() const;
+        void set_anchor(double x, double y);	
+        position const&amp; get_anchor() const;	
+        void set_displacement(double x, double y);
+        position const&amp; get_displacement() const;
+    private:
+        std::string name_;
+        unsigned size_;
+        Color fill_;
+        Color halo_fill_;
+        unsigned halo_radius_;
+        label_placement_e label_p_;
+        position anchor_;
+        position displacement_;
+    };
+}
+
+#endif //TEXT_SYMBOLIZER_HPP

Copied: trunk/include/mapnik/utils.hpp (from rev 307, trunk/include/utils.hpp)
===================================================================
--- trunk/include/utils.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/utils.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,222 @@
+/* This file is part of Mapnik (c++ mapping toolkit)
+ * Copyright (C) 2005 Artem Pavlenko
+ *
+ * Mapnik is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+//$Id: utils.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef UTILS_HPP
+#define UTILS_HPP
+// stl
+#include &lt;stdexcept&gt;
+#include &lt;limits&gt;
+#include &lt;ctime&gt;
+#include &lt;sstream&gt;
+#include &lt;iostream&gt;
+#include &lt;algorithm&gt;
+#include &lt;cmath&gt;
+// boost
+#include &lt;boost/thread/mutex.hpp&gt;
+
+namespace mapnik
+{
+    using boost::mutex;
+    
+    template &lt;typename T&gt;
+    class CreateUsingNew
+    {
+    public:
+        static T* create()
+        {
+            return new T;
+        }
+        static void destroy(T* obj)
+        {
+            delete obj;
+        }
+    };
+
+    template &lt;typename T&gt;
+    class CreateStatic
+    {
+    private:
+        union MaxAlign
+        {
+            char t_[sizeof(T)];
+            short int shortInt_;
+            int int_;
+            long int longInt_;
+            float float_;
+            double double_;
+            long double longDouble_;
+            struct Test;
+            int Test::* pMember_;
+            int (Test::*pMemberFn_)(int);
+        };
+    public:
+        static T* create()
+        {
+            static MaxAlign staticMemory;
+            return new(&amp;staticMemory) T;
+        }
+        static void destroy(volatile T* obj)
+        {
+            obj-&gt;~T();
+        }
+    };
+
+    template &lt;typename T,
+              template &lt;typename T&gt; class CreatePolicy=CreateStatic&gt; class singleton
+              {
+                  friend class CreatePolicy&lt;T&gt;;
+                  static T* pInstance_;
+                  static bool destroyed_;
+                  singleton(const singleton &amp;rhs);
+                  singleton&amp; operator=(const singleton&amp;);
+                  static void onDeadReference()
+                  {
+                      throw std::runtime_error(&quot;dead reference!&quot;);
+                  }
+              protected:
+                  static mutex mutex_;
+                  singleton() {}
+                  virtual ~singleton()
+                  {
+                      CreatePolicy&lt;T&gt;::destroy(pInstance_);
+                      destroyed_=true;
+                  }
+              public:
+                  static  T* instance()
+                  {
+                      if (!pInstance_)
+                      {
+                          mutex::scoped_lock lock(mutex_);
+                          if (!pInstance_)
+                          {
+                              if (destroyed_)
+                              {
+                                  onDeadReference();
+                              }
+                              else
+                              {
+                                  pInstance_=CreatePolicy&lt;T&gt;::create();
+                              }
+                          }
+                      }
+                      return pInstance_;
+                  }
+              };
+
+    template &lt;typename T,
+              template &lt;typename T&gt; class CreatePolicy&gt; mutex singleton&lt;T,CreatePolicy&gt;::mutex_;
+    template &lt;typename T,
+              template &lt;typename T&gt; class CreatePolicy&gt; T* singleton&lt;T,CreatePolicy&gt;::pInstance_=0;
+    template &lt;typename T,
+              template &lt;typename T&gt; class CreatePolicy&gt; bool singleton&lt;T,CreatePolicy&gt;::destroyed_=false;
+
+    template &lt;class T&gt; class Handle
+    {
+        T* ptr_;
+        int* pCount_;
+    public:
+        T* operator-&gt;() {return ptr_;}
+        const T* operator-&gt;() const {return ptr_;}
+        Handle(T* ptr)
+            :ptr_(ptr),pCount_(new int(1)) {}
+        Handle(const Handle&amp; rhs)
+            :ptr_(rhs.ptr_),pCount_(rhs.pCount_)
+        {
+            (*pCount_)++;
+        }
+        Handle&amp; operator=(const Handle&amp; rhs)
+        {
+            if (ptr_==rhs.ptr_) return *this;
+            if (--(*pCount_)==0)
+            {
+                delete ptr_;
+                delete pCount_;
+            }
+            ptr_=rhs.ptr_;
+            pCount_=rhs.pCount_;
+            (*pCount_)++;
+            return *this;
+        }
+        ~Handle()
+        {
+            if (--(*pCount_)==0)
+            {
+                delete ptr_;
+                delete pCount_;
+            }
+        }
+    };
+
+
+    struct timer
+    {
+        //struct timeval tv_;
+        timer()
+        {
+            //gettimeofday (&amp;tv_,0);
+        }
+        void start()
+        {
+            //gettimeofday (&amp;tv_,0);
+        }
+        void stop()
+        {
+            //timeval tv;
+            //gettimeofday (&amp;tv,0);
+            //std::ostringstream s;
+            //long sec=1000*(tv.tv_sec-tv_.tv_sec);
+            //long total_ms=sec+static_cast&lt;long&gt;(0.001*(tv.tv_usec-tv_.tv_usec));
+            //s &lt;&lt; &quot;elapsed time is &quot;&lt;&lt;total_ms&lt;&lt;&quot; ms&quot;;
+            //std::clog&lt;&lt;s.str()&lt;&lt;std::endl;
+        }
+    };
+    
+    //converters
+    class BadConversion : public std::runtime_error
+    {
+    public:
+        BadConversion(const std::string&amp; s)
+            :std::runtime_error(s)
+        {}
+    };
+    
+    template &lt;typename T&gt;
+    inline std::string toString(const T&amp; x)
+    {
+        std::ostringstream o;
+        if (!(o &lt;&lt; x))
+            throw BadConversion(std::string(&quot;toString(&quot;)
+                                + typeid(x).name() + &quot;)&quot;);
+        return o.str();
+    }
+    
+    template&lt;typename T&gt;
+    inline void fromString(const std::string&amp; s, T&amp; x,
+                           bool failIfLeftoverChars = true)
+    {
+        std::istringstream i(s);
+        char c;
+        if (!(i &gt;&gt; x) || (failIfLeftoverChars &amp;&amp; i.get(c)))
+            throw BadConversion(&quot;fromString(&quot;+s+&quot;)&quot;);
+    }
+}
+
+
+#endif //UTILS_HPP

Copied: trunk/include/mapnik/value.hpp (from rev 307, trunk/include/value.hpp)
===================================================================
--- trunk/include/value.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/value.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,452 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id$
+
+#ifndef VALUE_HPP
+#define VALUE_HPP
+
+// stl
+#include &lt;iostream&gt;
+#include &lt;string&gt;
+#include &lt;sstream&gt;
+
+// boost
+#include &lt;boost/variant.hpp&gt;
+
+namespace mapnik  {
+    typedef boost::variant&lt;int,double,std::string&gt; value_base;
+    
+    namespace impl {
+        struct equals
+            : public boost::static_visitor&lt;bool&gt;
+        {
+            template &lt;typename T, typename U&gt;
+            bool operator() (const T &amp;, const U &amp; ) const
+            {
+                return false;
+            }
+	
+            template &lt;typename T&gt;
+            bool operator() (T lhs, T rhs) const
+            {
+                return lhs == rhs;
+            }
+	
+            bool operator() (int lhs, double rhs) const
+            {
+                return  lhs == rhs;
+            }
+	
+            bool operator() (double lhs, int rhs) const
+            {
+                return  lhs == rhs;
+            }
+	
+            bool operator() (std::string const&amp; lhs, 
+                             std::string const&amp; rhs) const
+            {
+                return  lhs == rhs;
+            }
+        };
+    
+        struct greater_than
+            : public boost::static_visitor&lt;bool&gt;
+        {
+            template &lt;typename T, typename U&gt;
+            bool operator()( const T &amp;, const U &amp; ) const
+            {
+                return false;
+            }
+	
+            template &lt;typename T&gt;
+            bool operator()( T lhs, T rhs ) const
+            {
+                return lhs &gt; rhs;
+            }
+	
+            bool operator() (int lhs, double rhs) const
+            {
+                return  lhs &gt; rhs;
+            }
+	
+            bool operator() (double lhs, int rhs) const
+            {
+                return  lhs &gt; rhs;
+            }
+	
+            bool operator() (std::string const&amp; lhs, std::string const&amp; rhs) const
+            {
+                return  lhs &gt; rhs;
+            }
+        };
+    
+        struct greater_or_equal
+            : public boost::static_visitor&lt;bool&gt;
+        {	
+            template &lt;typename T, typename U&gt;
+            bool operator()( const T &amp;, const U &amp; ) const
+            {
+                return false;
+            }
+	
+            template &lt;typename T&gt;
+            bool operator() (T lhs, T rhs) const
+            {
+                return lhs &gt;= rhs;
+            }
+      
+            bool operator() (int lhs, double rhs) const
+            {
+                return  lhs &gt;= rhs;
+            }
+	
+            bool operator() (double lhs, int rhs) const
+            {
+                return  lhs &gt;= rhs;
+            }
+	
+            bool operator() (std::string const&amp; lhs, std::string const&amp; rhs ) const
+            {
+                return lhs &gt;= rhs;
+            }
+        };
+    
+        struct less_than
+            : public boost::static_visitor&lt;bool&gt;
+        {	
+            template &lt;typename T, typename U&gt;
+            bool operator()( const T &amp;, const U &amp; ) const
+            {
+                return false;
+            }
+	
+            template &lt;typename T&gt;
+            bool operator()( T  lhs,T  rhs) const
+            {
+                return lhs &lt; rhs;
+            }
+	
+            bool operator() (int lhs, double rhs) const
+            {
+                return  lhs &lt; rhs;
+            }
+	   
+            bool operator() (double lhs, int rhs) const
+            {
+                return  lhs &lt; rhs;
+            }
+	
+            bool operator()( std::string const&amp; lhs, 
+                             std::string const&amp; rhs ) const
+            {
+                return lhs &lt; rhs;
+            }
+        };
+
+        struct less_or_equal
+            : public boost::static_visitor&lt;bool&gt;
+        {	
+            template &lt;typename T, typename U&gt;
+            bool operator()( const T &amp;, const U &amp; ) const
+            {
+                return false;
+            }
+	
+            template &lt;typename T&gt;
+            bool operator()(T lhs, T rhs ) const
+            {
+                return lhs &lt;= rhs;
+            }
+	    
+            bool operator() (int lhs, double rhs) const
+            {
+                return  lhs &lt;= rhs;
+            }
+	
+            bool operator() (double lhs, int rhs) const
+            {
+                return  lhs &lt;= rhs;
+            }
+	
+            template &lt;typename T&gt;
+            bool operator()( std::string const&amp; lhs, 
+                             std::string const&amp; rhs ) const
+            {
+                return lhs &lt;= rhs;
+            }
+        };
+    
+        template &lt;typename V&gt;
+        struct add : public boost::static_visitor&lt;V&gt;
+        { 
+            typedef V value_type;
+            template &lt;typename T1, typename T2&gt;
+            value_type operator() (T1 const&amp; lhs, T2 const&amp;) const
+            {
+                return lhs;
+            }
+            template &lt;typename T&gt;
+            value_type operator() (T lhs, T rhs) const
+            {
+                return lhs + rhs ;
+            }
+	
+            value_type operator() (std::string const&amp; lhs , 
+                                   std::string const&amp; rhs ) const
+            {
+                return lhs + rhs;
+            }
+	
+            value_type operator() (double lhs, int rhs) const
+            {
+                return lhs + rhs;
+            }
+	
+            value_type operator() (int lhs, double rhs) const
+            {
+                return lhs + rhs;
+            }
+        };
+        template &lt;typename V&gt;
+        struct sub : public boost::static_visitor&lt;V&gt;
+        { 
+            typedef V value_type;
+            template &lt;typename T1, typename T2&gt;
+            value_type operator() (T1 const&amp; lhs, T2 const&amp;) const
+            {
+                return lhs;
+            }
+
+            template &lt;typename T&gt;
+            value_type operator() (T  lhs, T rhs) const
+            {
+                return lhs - rhs ;
+            }
+
+            value_type operator() (std::string const&amp; lhs,
+                                   std::string const&amp; ) const
+            {
+                return lhs;
+            }
+        	
+            value_type operator() (double lhs, int rhs) const
+            {
+                return lhs - rhs;
+            }
+	
+            value_type operator() (int lhs, double rhs) const
+            {
+                return lhs - rhs;
+            }
+        };
+    
+        template &lt;typename V&gt;
+        struct mult : public boost::static_visitor&lt;V&gt;
+        { 
+            typedef V value_type;
+            template &lt;typename T1, typename T2&gt;
+            value_type operator() (T1 const&amp; lhs , T2 const&amp; ) const
+            {
+                return lhs;
+            }
+            template &lt;typename T&gt;
+            value_type operator() (T lhs, T rhs) const
+            {
+                return lhs * rhs;
+            }
+	
+            value_type operator() (std::string const&amp; lhs,
+                                   std::string const&amp; ) const
+            {
+                return lhs;
+            }	
+	
+            value_type operator() (double lhs, int rhs) const
+            {
+                return lhs * rhs;
+            }
+	
+            value_type operator() (int lhs, double rhs) const
+            {
+                return lhs * rhs;
+            }
+        };
+
+        template &lt;typename V&gt;
+        struct div: public boost::static_visitor&lt;V&gt;
+        { 
+            typedef V value_type;
+            template &lt;typename T1, typename T2&gt;
+            value_type operator() (T1 const&amp; lhs, T2 const&amp;) const
+            {
+                return lhs;
+            }
+	    
+            template &lt;typename T&gt;
+            value_type operator() (T lhs, T rhs) const
+            {
+                return lhs / rhs;
+            }
+	
+            value_type operator() (std::string const&amp; lhs,
+                                   std::string const&amp;) const
+            {
+                return lhs;
+            }
+	
+            value_type operator() (double lhs, int rhs) const
+            {
+                return lhs / rhs;
+            }
+	
+            value_type operator() (int lhs, double rhs) const
+            {
+                return lhs / rhs;
+            }
+        };
+    
+        struct to_string : public boost::static_visitor&lt;std::string&gt;
+        {
+            template &lt;typename T&gt;
+            std::string operator() (T val) const
+            {
+                std::stringstream ss;
+                ss &lt;&lt; val;
+                return ss.str();
+            } 
+            std::string const&amp; operator() (std::string const&amp; val) const
+            {
+                return val;
+            }
+        };
+	
+        struct to_expression_string : public boost::static_visitor&lt;std::string&gt;
+        {
+            template &lt;typename T&gt;
+            std::string operator() (T val) const
+            {
+                std::stringstream ss;
+                ss &lt;&lt; val;
+                return ss.str();
+            } 
+            std::string operator() (std::string const&amp; val) const
+            {
+                return &quot;'&quot; + val + &quot;'&quot;;
+            }
+        };
+    }
+    
+    class value
+    {
+        value_base base_;
+        friend const value operator+(value const&amp;,value const&amp;);
+        friend const value operator-(value const&amp;,value const&amp;);
+        friend const value operator*(value const&amp;,value const&amp;);
+        friend const value operator/(value const&amp;,value const&amp;);
+        
+    public:
+        value ()
+            : base_(0) {}
+	
+        template &lt;typename T&gt; value(T _val_)
+            : base_(_val_) {}
+
+        bool operator==(value const&amp; other) const
+        {
+            return boost::apply_visitor(impl::equals(),base_,other.base_);
+        }
+
+        bool operator!=(value const&amp; other) const
+        {
+            return !(boost::apply_visitor(impl::equals(),base_,other.base_));
+        }
+	
+        bool operator&gt;(value const&amp; other) const
+        {
+            return boost::apply_visitor(impl::greater_than(),base_,other.base_);
+        }
+
+        bool operator&gt;=(value const&amp; other) const
+        {
+            return boost::apply_visitor(impl::greater_or_equal(),base_,other.base_);
+        }
+
+        bool operator&lt;(value const&amp; other) const
+        {
+            return boost::apply_visitor(impl::less_than(),base_,other.base_);
+        }
+
+        bool operator&lt;=(value const&amp; other) const
+        {
+            return boost::apply_visitor(impl::less_or_equal(),base_,other.base_);
+        }
+        value_base const&amp; base() const
+        {
+            return base_;
+        }
+
+        std::string to_expression_string() const
+        {
+            return boost::apply_visitor(impl::to_expression_string(),base_);
+        }
+
+        std::string to_string() const
+        {
+            return boost::apply_visitor(impl::to_string(),base_);
+        }
+    };
+    
+    inline const value operator+(value const&amp; p1,value const&amp; p2)
+    {
+
+        return value(boost::apply_visitor(impl::add&lt;value&gt;(),p1.base_, p2.base_));
+    }
+
+    inline const value operator-(value const&amp; p1,value const&amp; p2)
+    {
+
+        return value(boost::apply_visitor(impl::sub&lt;value&gt;(),p1.base_, p2.base_));
+    }
+
+    inline const value operator*(value const&amp; p1,value const&amp; p2)
+    {
+
+        return value(boost::apply_visitor(impl::mult&lt;value&gt;(),p1.base_, p2.base_));
+    }
+
+    inline const value operator/(value const&amp; p1,value const&amp; p2)
+    {
+
+        return value(boost::apply_visitor(impl::div&lt;value&gt;(),p1.base_, p2.base_));
+    }
+
+    template &lt;typename charT, typename traits&gt;
+    inline std::basic_ostream&lt;charT,traits&gt;&amp; 
+    operator &lt;&lt; (std::basic_ostream&lt;charT,traits&gt;&amp; out,
+                 value const&amp; v)
+    {
+    	out &lt;&lt; v.base();
+    	return out; 
+    }
+}
+
+#endif //VALUE_HPP

Copied: trunk/include/mapnik/vertex.hpp (from rev 307, trunk/include/vertex.hpp)
===================================================================
--- trunk/include/vertex.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/vertex.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,112 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id: vertex.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef VERTEX_HPP
+#define VERTEX_HPP
+
+#include &lt;iostream&gt;
+#include &lt;sstream&gt;
+
+namespace mapnik 
+{
+    enum {
+        SEG_END   =0,
+        SEG_MOVETO=1,
+        SEG_LINETO=2,
+        SEG_CLOSE =3
+    };
+    
+    template &lt;typename T,int dim&gt;
+    struct vertex {
+        typedef T type;
+    };
+    
+    template &lt;typename T&gt;
+    struct vertex&lt;T,2&gt; 
+    {
+        typedef T type;
+        T x;
+        T y;
+        unsigned cmd;
+        vertex() 
+            : x(0),y(0),cmd(SEG_END) {}
+        vertex(T x,T y,unsigned cmd)
+            : x(x),y(y),cmd(cmd) {}
+
+        template &lt;typename T2&gt;
+        vertex(const vertex&lt;T2,2&gt;&amp; rhs)
+            : x(type(rhs.x)),
+              y(type(rhs.y)),
+              cmd(rhs.cmd) {}
+	
+        template &lt;typename T2&gt; vertex&lt;T,2&gt; operator=(const vertex&lt;T2,2&gt;&amp; rhs)
+        {
+            if ((void*)this == (void*)&amp;rhs)
+            {
+                return *this;
+            }
+            x=type(rhs.x);
+            y=type(rhs.y);
+            cmd=rhs.cmd;
+            return *this;
+        }	
+    };
+    
+    typedef vertex&lt;double,2&gt; vertex2d;
+    typedef vertex&lt;int,2&gt; vertex2i;
+
+    
+    template &lt;class charT,class traits,class T,int dim&gt;
+    inline std::basic_ostream&lt;charT,traits&gt;&amp;
+    operator &lt;&lt; (std::basic_ostream&lt;charT,traits&gt;&amp; out,
+                 const vertex&lt;T,dim&gt;&amp; c);
+
+    template &lt;class charT,class traits,class T&gt;
+    inline std::basic_ostream&lt;charT,traits&gt;&amp;
+    operator &lt;&lt; (std::basic_ostream&lt;charT,traits&gt;&amp; out,
+                 const vertex&lt;T,2&gt;&amp; v)
+    {
+        std::basic_ostringstream&lt;charT,traits&gt; s;
+        s.copyfmt(out);
+        s.width(0);
+        s&lt;&lt;&quot;vertex2(&quot;&lt;&lt;v.x&lt;&lt;&quot;,&quot;&lt;&lt;v.y&lt;&lt;&quot;,cmd=&quot;&lt;&lt;v.cmd&lt;&lt;&quot; )&quot;;
+        out &lt;&lt; s.str();
+        return out;
+    }
+
+    template &lt;class charT,class traits,class T&gt;
+    inline std::basic_ostream&lt;charT,traits&gt;&amp;
+    operator &lt;&lt; (std::basic_ostream&lt;charT,traits&gt;&amp; out,
+                 const vertex&lt;T,3&gt;&amp; v)
+    {
+        std::basic_ostringstream&lt;charT,traits&gt; s;
+        s.copyfmt(out);
+        s.width(0);
+        s&lt;&lt;&quot;vertex3(&quot;&lt;&lt;v.x&lt;&lt;&quot;,&quot;&lt;&lt;v.y&lt;&lt;&quot;,&quot;&lt;&lt;v.z&lt;&lt;&quot;,cmd=&quot;&lt;&lt;v.cmd&lt;&lt;&quot;)&quot;;
+        out &lt;&lt; s.str();
+        return out;
+    } 
+
+}
+
+#endif // VERTEX_HPP

Copied: trunk/include/mapnik/vertex_transform.hpp (from rev 307, trunk/include/vertex_transform.hpp)
===================================================================
--- trunk/include/vertex_transform.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/vertex_transform.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,93 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//$Id: vertex_transform.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef VERTEX_TRANSFORM_HPP
+#define VERTEX_TRANSFORM_HPP
+
+// mapnik
+#include &lt;mapnik/envelope.hpp&gt;
+#include &lt;mapnik/vertex.hpp&gt;
+
+namespace mapnik
+{
+    template &lt;typename T0 ,typename T1,int shift=8&gt;
+    struct Shift
+    {
+	typedef T0 value_type;
+	typedef T1 return_type;
+	static return_type apply(value_type val)
+	{
+	    return static_cast&lt;return_type&gt;(val*(1&lt;&lt;shift));
+	}
+    };
+
+    template &lt;typename T0,typename T1&gt;
+    struct Shift&lt;T0,T1,0&gt; 
+    {
+	typedef T0 value_type;
+	typedef T1 return_type;
+	static return_type apply(value_type val)
+	{
+	    return static_cast&lt;return_type&gt;(val);
+	}
+    };
+
+    template &lt;typename T&gt;
+    struct Shift&lt;T,T,0&gt;
+    {
+	typedef T value_type;
+	typedef T return_type;
+	static T&amp; apply(T&amp; val)
+	{
+	    return val;
+	}
+    };
+
+    typedef Shift&lt;double,double,0&gt; NO_SHIFT;
+    typedef Shift&lt;double,int,0&gt; SHIFT0;
+    typedef Shift&lt;double,int,8&gt; SHIFT8;
+    
+    
+    template &lt;typename T0,typename T1,typename Trans&gt;
+    struct view_transform;
+    
+    template &lt;typename Trans&gt;
+    struct view_transform &lt;vertex2d,vertex2d,Trans&gt;   
+    {
+	
+    };
+    
+    template &lt;typename Trans&gt;
+    struct view_transform &lt;vertex2d,vertex2i,Trans&gt;   
+    {
+	
+    };
+
+    template &lt;typename Trans&gt;
+    struct view_transform&lt;Envelope&lt;double&gt;,Envelope&lt;double&gt;,Trans&gt;
+    {
+	
+    };
+}
+
+#endif //VERTEX_TRANSFORM_HPP

Copied: trunk/include/mapnik/vertex_vector.hpp (from rev 307, trunk/include/vertex_vector.hpp)
===================================================================
--- trunk/include/vertex_vector.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/vertex_vector.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,200 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+//  Credits:
+//  I gratefully acknowledge the inspiring work of Maxim Shemanarev (McSeem), 
+//  author of Anti-Grain Geometry (<A HREF="http://www.antigrain.com">http://www.antigrain.com</A>). I have used 
+//  the datastructure from AGG as a template for my own. 
+
+
+//$Id: vertex_vector.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef VERTEX_VECTOR_HPP
+#define VERTEX_VECTOT_HPP
+// stl
+#include &lt;vector&gt;
+// boost
+#include &lt;boost/utility.hpp&gt;
+#include &lt;boost/tuple/tuple.hpp&gt;
+// mapnik
+#include &lt;mapnik/vertex.hpp&gt;
+#include &lt;mapnik/ctrans.hpp&gt;
+
+namespace mapnik
+{
+    template &lt;typename T&gt;
+    class vertex_vector : private boost::noncopyable
+    {
+        typedef typename T::type value_type;
+        typedef vertex&lt;value_type,2&gt; vertex_type;
+        enum {
+            block_shift = 8,
+            block_size  = 1&lt;&lt;block_shift,
+            block_mask  = block_size - 1,
+            grow_by     = 256
+        };
+
+    private:
+        unsigned num_blocks_;
+        unsigned max_blocks_;
+        value_type** vertexs_;
+        unsigned char** commands_;
+        unsigned pos_;
+    public:
+	
+        vertex_vector() 
+            : num_blocks_(0),
+              max_blocks_(0),
+              vertexs_(0),
+              commands_(0),
+              pos_(0) {}
+
+        ~vertex_vector()
+        {
+            if ( num_blocks_ )
+            {
+                value_type** vertexs=vertexs_ + num_blocks_ - 1;
+                while ( num_blocks_-- )
+                {
+                    delete [] *vertexs;
+                    --vertexs;
+                }
+                delete [] vertexs_;
+            }
+        }
+        unsigned size() const 
+        {
+            return pos_;
+        }
+	
+        void push_back (value_type x,value_type y,unsigned command)
+        {
+            unsigned block = pos_ &gt;&gt; block_shift;
+            if (block &gt;= num_blocks_)
+            {
+                allocate_block(block);
+            }
+            value_type* vertex = vertexs_[block] + ((pos_ &amp; block_mask) &lt;&lt; 1);
+            unsigned char* cmd= commands_[block] + (pos_ &amp; block_mask);
+	    
+            *cmd = static_cast&lt;unsigned char&gt;(command);
+            *vertex++ = x;
+            *vertex   = y;
+            ++pos_;
+        }
+        unsigned get_vertex(unsigned pos,value_type* x,value_type* y) const
+        {
+            if (pos &gt;= pos_) return SEG_END;
+            unsigned block = pos &gt;&gt; block_shift;
+            const value_type* vertex = vertexs_[block] + (( pos &amp; block_mask) &lt;&lt; 1);
+            *x = (*vertex++);
+            *y = (*vertex);
+            return commands_[block] [pos &amp; block_mask];
+        }
+        	
+        void transform_at(unsigned pos,const CoordTransform&amp; t)
+        {
+            if (pos &gt;= pos_) return;
+            unsigned block = pos &gt;&gt; block_shift;
+            value_type* vertex = vertexs_[block] + (( pos &amp; block_mask) &lt;&lt; 1);
+            t.forward_x(vertex);
+            ++vertex;
+            t.forward_y(vertex);
+        }
+        void set_capacity(size_t)
+        {
+            //do nothing
+        }
+    private:
+        void allocate_block(unsigned block)
+        {
+            if (block &gt;= max_blocks_)
+            {
+                value_type** new_vertexs = new value_type* [(max_blocks_ + grow_by) * 2];
+                unsigned char** new_commands = (unsigned char**)(new_vertexs + max_blocks_ + grow_by);
+                if (vertexs_)
+                {
+                    std::memcpy(new_vertexs,vertexs_,max_blocks_ * sizeof(value_type*));
+                    std::memcpy(new_commands,commands_,max_blocks_ * sizeof(unsigned char*));
+                    delete [] vertexs_;
+                }
+                vertexs_ = new_vertexs;
+                commands_ = new_commands;
+                max_blocks_ += grow_by;
+            }
+            vertexs_[block] = new value_type [block_size * 2 + block_size / (sizeof(value_type))];
+            commands_[block] = (unsigned char*)(vertexs_[block] + block_size*2);
+            ++num_blocks_;
+        }
+    };
+
+    template &lt;typename T&gt;
+    struct vertex_vector2 : boost::noncopyable
+    {
+        typedef typename T::type value_type;
+        typedef boost::tuple&lt;value_type,value_type,char&gt; vertex_type;
+        typedef typename std::vector&lt;vertex_type&gt;::const_iterator const_iterator;
+        vertex_vector2() {}
+        unsigned size() const 
+        {
+            return cont_.size();
+        }
+
+        void push_back (value_type x,value_type y,unsigned command)
+        {
+            cont_.push_back(vertex_type(x,y,command));
+        }
+        unsigned get_vertex(unsigned pos,value_type* x,value_type* y) const
+        {
+            if (pos &gt;= cont_.size()) return SEG_END;
+            vertex_type const&amp; c = cont_[pos];
+            *x = boost::get&lt;0&gt;(c);
+            *y = boost::get&lt;1&gt;(c);
+            return boost::get&lt;2&gt;(c);
+        }
+        
+        const_iterator begin() const
+        {
+            return cont_.begin();
+        }
+        
+        const_iterator end() const
+        {
+            return cont_.end();
+        }
+
+        void transform_at(unsigned pos,const CoordTransform&amp; t)
+        {
+            if (pos &gt;= cont_.size()) return;
+            vertex_type &amp; c = cont_[pos];
+            t.forward_x(&amp;boost::get&lt;0&gt;(c));
+            t.forward_y(&amp;boost::get&lt;1&gt;(c));
+        }
+        void set_capacity(size_t size)
+        {
+            cont_.reserve(size);
+        }
+    private:
+        std::vector&lt;vertex_type&gt; cont_;
+    };
+}
+
+#endif //VERTEX_VECTOR_HPP

Copied: trunk/include/mapnik/wkb.hpp (from rev 307, trunk/include/wkb.hpp)
===================================================================
--- trunk/include/wkb.hpp	2006-10-03 08:52:24 UTC (rev 307)
+++ trunk/include/mapnik/wkb.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -0,0 +1,43 @@
+/*****************************************************************************
+ * 
+ * This file is part of Mapnik (c++ mapping toolkit)
+ *
+ * Copyright (C) 2006 Artem Pavlenko
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *****************************************************************************/
+
+//$Id: wkb.hpp 39 2005-04-10 20:39:53Z pavlenko $
+
+#ifndef WKB_HPP
+#define WKB_HPP
+
+#include &lt;mapnik/geometry.hpp&gt;
+#include &lt;mapnik/ctrans.hpp&gt;
+
+namespace mapnik
+{
+    class MAPNIK_DECL geometry_utils 
+    {
+    public:
+        static geometry_ptr from_wkb(const char* wkb, unsigned size,int srid);
+    private:
+        geometry_utils();
+        geometry_utils(const geometry_utils&amp;);
+        geometry_utils&amp; operator=(const geometry_utils&amp;);
+    };
+}
+#endif                                            //WKB_HPP

Deleted: trunk/include/math_expr.hpp
===================================================================
--- trunk/include/math_expr.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/math_expr.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,128 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id$
-
-#ifndef MATH_EXPR_HPP
-#define MATH_EXPR_HPP
-
-#include &quot;expression.hpp&quot;
-
-namespace mapnik
-{
-    template &lt;typename T&gt;
-    struct add
-    {
-        T operator () (T const&amp; left, T const&amp; right)
-        {
-            return left + right;
-        }
-        static std::string to_string()
-        {
-            return &quot;+&quot;;
-        } 
-    };
-
-    template &lt;typename T&gt;
-    struct sub
-    {
-        T operator () (T const&amp; left, T const&amp; right)
-        {
-            return left - right;
-        }
-        static std::string to_string()
-        {
-            return &quot;-&quot;;
-        } 
-    };
-    
-    template &lt;typename T&gt;
-    struct mult
-    {
-        T operator () (T const&amp; left, T const&amp; right)
-        {
-            return left * right;
-        }
-        static std::string to_string()
-        {
-            return &quot;*&quot;;
-        } 
-    };
-    
-    template &lt;typename T&gt;
-    struct div
-    {
-        T operator () (T const&amp; left, T const&amp; right)
-        {
-            return left / right;
-        }
-        static std::string to_string()
-        {
-            return &quot;/&quot;;
-        } 
-    };
-    
-    template &lt;typename FeatureT,typename Op&gt;
-    struct math_expr_b : public expression&lt;FeatureT&gt;
-    {
-        math_expr_b(expression&lt;FeatureT&gt; const&amp; left,
-                    expression&lt;FeatureT&gt; const&amp; right)
-            : expression&lt;FeatureT&gt;(),
-              left_(left.clone()), 
-              right_(right.clone()) {}
-        math_expr_b(math_expr_b const&amp; other)
-            : expression&lt;FeatureT&gt;(),
-              left_(other.left_-&gt;clone()),
-              right_(other.right_-&gt;clone()) {}
-
-        value get_value(FeatureT const&amp; feature) const
-        {
-            return Op ()(left_-&gt;get_value(feature),right_-&gt;get_value(feature));
-        }
-
-        void accept(filter_visitor&lt;FeatureT&gt;&amp; v)
-        {
-            left_-&gt;accept(v);
-            right_-&gt;accept(v);
-            v.visit(*this);
-        }
-
-        expression&lt;FeatureT&gt;* clone() const
-        {
-            return new math_expr_b&lt;FeatureT,Op&gt;(*this);
-        }
-        std::string to_string() const
-        {
-            return &quot;(&quot;+left_-&gt;to_string() + Op::to_string() + right_-&gt;to_string()+&quot;)&quot;;
-        }
-
-        ~math_expr_b() 
-        {
-            delete left_;
-            delete right_;
-        }
-    private:
-        expression&lt;FeatureT&gt;* left_;
-        expression&lt;FeatureT&gt;* right_;	
-    }; 
-}
-
-#endif //

Deleted: trunk/include/memory.hpp
===================================================================
--- trunk/include/memory.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/memory.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,88 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id: memory.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef MEMORY_HPP
-#define MEMORY_HPP
-
-#include &lt;iostream&gt;
-#include &lt;cassert&gt;
-
-namespace mapnik
-{
-    class MemoryUtils
-    {
-    public:
-	static size_t alignPointerSize(size_t ptrSize);
-    private:
-	MemoryUtils();
-	MemoryUtils(const MemoryUtils&amp;);
-	MemoryUtils&amp; operator=(const MemoryUtils&amp;);
-    };
-
-    class MemoryManager
-    {
-    public:
-	virtual void* allocate(size_t size)=0;
-	virtual void deallocate(void* p)=0;
-	virtual ~MemoryManager();
-    protected:
-	MemoryManager();                      // {}
-    private:
-	MemoryManager(const MemoryManager&amp;);
-	MemoryManager&amp; operator=(const MemoryManager&amp;);
-    };
-
-    class Object
-    {
-    public:
-	void* operator new(size_t size);
-	void* operator new(size_t size, MemoryManager* manager);
-	void operator delete(void* p);
-	void operator delete(void* p, MemoryManager* manager);
-    protected:
-	virtual ~Object() {}
-	Object() {}
-	Object(const Object&amp;) {}
-    protected:
-	Object&amp; operator=(const Object&amp;)
-	{
-	    return *this;
-	}
-    };
-
-    template &lt;typename Geometry&gt;
-    class geometry_pool
-    {
-    public:
-	void* allocate()
-	{
-	    return ::operator new(sizeof(Geometry));
-	}
-	void deallocate(void* p)
-	{
-	    ::operator delete(p);
-	}
-    };
-
-}
-#endif                                            //MEMORY_HPP

Deleted: trunk/include/params.hpp
===================================================================
--- trunk/include/params.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/params.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,53 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id: params.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef PARAMS_HPP
-#define PARAMS_HPP
-
-#include &lt;string&gt;
-#include &lt;map&gt;
-
-namespace mapnik
-{
-
-    typedef std::pair&lt;const std::string,std::string&gt; parameter;
-    typedef std::map&lt;const std::string,std::string&gt; param_map;
-
-    class parameters : public param_map
-    {
-     public:
-
-        parameters() {}
-        const std::string get(std::string const&amp; key) const
-        {
-            param_map::const_iterator itr=find(key);
-            if (itr != end())
-            {
-                return itr-&gt;second;
-            }
-            return std::string();
-        }
-    };
-}
-
-#endif //PARAMS_HPP

Deleted: trunk/include/plugin.hpp
===================================================================
--- trunk/include/plugin.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/plugin.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,48 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: plugin.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef PLUGIN_HPP
-#define PLUGIN_HPP
-
-#include &lt;ltdl.h&gt;
-#include &lt;string&gt;
-#include &lt;boost/utility.hpp&gt;
-
-namespace mapnik
-{
-    class PluginInfo : boost::noncopyable
-    {
-    private:
-	std::string name_;
-	lt_dlhandle module_;
-	
-    public:
-	PluginInfo (const std::string&amp; name,const lt_dlhandle module);
-	~PluginInfo();
-	const std::string&amp; name() const;
-	lt_dlhandle handle() const;
-    };
-}
-
-#endif //PLUGIN_HPP

Deleted: trunk/include/point_symbolizer.hpp
===================================================================
--- trunk/include/point_symbolizer.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/point_symbolizer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,50 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id: image_symbolizer.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef POINT_SYMBOLIZER_HPP
-#define POINT_SYMBOLIZER_HPP
-
-#include &lt;boost/shared_ptr.hpp&gt;
-#include &quot;graphics.hpp&quot; 
-
-namespace mapnik 
-{   
-    struct MAPNIK_DECL point_symbolizer
-    {	
-        explicit point_symbolizer();
-        point_symbolizer(std::string const&amp; file,
-                         std::string const&amp; type,
-                         unsigned width,unsigned height);
-        point_symbolizer(point_symbolizer const&amp; rhs);
-        void set_data (boost::shared_ptr&lt;ImageData32&gt; symbol);
-        boost::shared_ptr&lt;ImageData32&gt; const&amp; get_data() const;        
-        void set_allow_overlap(bool overlap);
-        bool get_allow_overlap() const;
-        
-    private:
-        boost::shared_ptr&lt;ImageData32&gt; symbol_;
-        bool overlap_;
-    };
-}
-
-#endif // POINT_SYMBOLIZER_HPP

Deleted: trunk/include/polygon_pattern_symbolizer.hpp
===================================================================
--- trunk/include/polygon_pattern_symbolizer.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/polygon_pattern_symbolizer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,47 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id$
-
-#ifndef POLYGON_PATTERN_SYMBOLIZER_HPP
-#define POLYGON_PATTERN_SYMBOLIZER_HPP
-
-#include &lt;boost/shared_ptr.hpp&gt;
-#include &quot;graphics.hpp&quot; 
-
-namespace mapnik
-{
-    struct MAPNIK_DECL polygon_pattern_symbolizer
-    {
-	
-	polygon_pattern_symbolizer(std::string const&amp; file,
-				   std::string const&amp; type,
-				   unsigned width,unsigned height);
-        
-	polygon_pattern_symbolizer(polygon_pattern_symbolizer const&amp; rhs);
-        
-	ImageData32 const&amp; get_pattern() const;
-    private:
-	boost::shared_ptr&lt;ImageData32&gt; pattern_;
-    };
-}
-
-#endif //POLYGON_PATTERN_SYMBOLIZER_HPP

Deleted: trunk/include/polygon_symbolizer.hpp
===================================================================
--- trunk/include/polygon_symbolizer.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/polygon_symbolizer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,64 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: polygon_symbolizer.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef POLYGON_SYMBOLIZER_HPP
-#define POLYGON_SYMBOLIZER_HPP
-
-#include &quot;color.hpp&quot;
-
-namespace mapnik 
-{
-    struct MAPNIK_DECL polygon_symbolizer
-    {
-        explicit polygon_symbolizer() 
-            : fill_(Color(128,128,128)),
-              opacity_(1.0) {}
-
-        polygon_symbolizer(Color const&amp; fill)
-            : fill_(fill),
-              opacity_(1.0) {}
-        
-        Color const&amp; get_fill() const
-        {
-            return fill_;
-        }
-        void set_fill(Color const&amp; fill)
-        {
-            fill_ = fill;
-        }
-        void set_opacity(float opacity)
-        {
-            opacity_ = opacity;
-        }
-        float get_opacity() const
-        {
-            return opacity_;
-        }
-    private:
-        Color fill_;
-        float opacity_;
-    };  
-}
-
-#endif // POLYGON_SYMBOLIZER_HPP

Deleted: trunk/include/pool.hpp
===================================================================
--- trunk/include/pool.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/pool.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,119 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: pool.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef POOL_HPP
-#define POOL_HPP
-
-#include &lt;iostream&gt;
-#include &lt;map&gt;
-#include &lt;deque&gt;
-#include &lt;ctime&gt;
-#include &quot;utils.hpp&quot;
-#include &lt;boost/shared_ptr.hpp&gt;
-#include &lt;boost/thread/mutex.hpp&gt;
-#include &lt;boost/utility.hpp&gt;
-
-namespace mapnik
-{
-    template &lt;typename T, typename PoolT&gt;
-    class PoolGuard
-    {
-    private:
-	const T&amp; obj_;
-        PoolT&amp; pool_; 
-    public:
-	explicit PoolGuard(const T&amp; ptr,PoolT&amp; pool)
-	    : obj_(ptr),
-	      pool_(pool) {}
-
-	~PoolGuard() 
-	{
-	    pool_-&gt;returnObject(obj_);
-	}
-
-    private:
-	PoolGuard();
-	PoolGuard(const PoolGuard&amp;);
-	PoolGuard&amp; operator=(const PoolGuard&amp;);
-    };
-
-    template &lt;typename T,template &lt;typename&gt; class Creator&gt;
-    class Pool : private boost::noncopyable
-    {
-	typedef boost::shared_ptr&lt;T&gt; HolderType;
-	typedef std::deque&lt;HolderType&gt; ContType;	
-	
-	Creator&lt;T&gt; creator_;
-	const int initialSize_; 
-	const int maxSize_;
-	ContType usedPool_;
-	ContType unusedPool_;
-	boost::mutex mutex_;
-    public:
-
-	Pool(const Creator&lt;T&gt;&amp; creator,int initialSize=5,int maxSize=20)
-	    :creator_(creator),
-	     initialSize_(initialSize),
-	     maxSize_(maxSize)
-	{
-	    for (int i=0;i&lt;initialSize_;++i) 
-	    {
-		unusedPool_.push_back(HolderType(creator_()));
-	    }
-	}
-
-	const HolderType&amp; borrowObject()
-	{	    
-	    mutex::scoped_lock lock(mutex_);
-	    typename ContType::iterator itr=unusedPool_.begin();
-	    if (itr!=unusedPool_.end())
-	    {  
-		std::clog&lt;&lt;&quot;borrow &quot;&lt;&lt;(*itr).get()&lt;&lt;&quot;\n&quot;;
-		usedPool_.push_back(*itr);
-		itr=unusedPool_.erase(itr);
-		return usedPool_[usedPool_.size()-1];
-	    }
-	    static const HolderType defaultObj;
-	    return defaultObj;
-	} 
-
-	void returnObject(const HolderType&amp; obj)
-	{
-	    mutex::scoped_lock lock(mutex_);
-	    typename ContType::iterator itr=usedPool_.begin();
-	    while (itr != usedPool_.end())
-	    {
-		if (obj.get()==(*itr).get()) 
-		{
-		    std::clog&lt;&lt;&quot;return &quot;&lt;&lt;(*itr).get()&lt;&lt;&quot;\n&quot;;
-		    unusedPool_.push_back(*itr);
-		    usedPool_.erase(itr);
-		    return;
-		}
-		++itr;
-	    }
-	}
-    };
-}
-#endif                                            //POOL_HPP

Deleted: trunk/include/quad_tree.hpp
===================================================================
--- trunk/include/quad_tree.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/quad_tree.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,209 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id$
-
-#if !defined QUAD_TREE_HPP
-#define QUAD_TREE_HPP
-
-#include &lt;boost/ptr_container/ptr_vector.hpp&gt;
-#include &lt;boost/noncopyable.hpp&gt;
-#include &lt;vector&gt;
-#include &quot;envelope.hpp&quot;
-
-
-namespace mapnik
-{
-    template &lt;typename T&gt;
-    class quad_tree : boost::noncopyable
-    {
-        struct node
-        {
-            typedef T value_t;
-            typedef std::vector&lt;T&gt; cont_t;
-            typedef typename cont_t::iterator iterator;
-            typedef typename cont_t::const_iterator const_iterator;
-            Envelope&lt;double&gt; extent_;
-            cont_t cont_;
-            node * children_[4];
-
-            explicit node(Envelope&lt;double&gt; const&amp; ext)
-                : extent_(ext)
-            {
-                std::memset(children_,0,4*sizeof(node*));
-            }
-   
-            Envelope&lt;double&gt; const&amp; extent() const
-            {
-                return extent_;
-            }
-	    
-            iterator begin() 
-            {
-                return cont_.begin();
-            }
-	    
-            const_iterator begin() const 
-            {
-                return cont_.begin();
-            }
-	    
-            iterator end() 
-            {
-                return cont_.end();
-            }
-	    
-            const_iterator end() const 
-            {
-                return cont_.end();
-            }
-            ~node () {}
-        };
-	
-        typedef boost::ptr_vector&lt;node&gt; nodes_t;	
-        typedef typename node::cont_t cont_t;
-        typedef typename cont_t::iterator node_data_iterator;
-	
-        nodes_t nodes_;
-        node * root_;	
-        const double ratio_; 
-	
-    public:
-        typedef typename nodes_t::iterator iterator;
-        typedef typename nodes_t::const_iterator const_iterator;
-        typedef typename boost::ptr_vector&lt;T,boost::view_clone_allocator&gt; result_t;	
-        typedef typename result_t::iterator query_iterator;
-   
-        result_t query_result_;
-	
-        explicit quad_tree(Envelope&lt;double&gt; const&amp; ext,double ratio=0.55) 
-            : ratio_(ratio)
-        {
-            nodes_.push_back(new node(ext));
-            root_ = &amp;nodes_[0];
-        }
-		
-        void insert(T data, Envelope&lt;double&gt; const&amp; box)
-        {
-            do_insert_data(data,box,root_);
-        }
-        
-        query_iterator query_in_box(Envelope&lt;double&gt; const&amp; box)
-        {
-            query_result_.clear();
-            query_node(box,query_result_,root_);
-            return query_result_.begin();
-        }
-	
-        query_iterator query_end()
-        {
-            return query_result_.end();
-        }
-
-        iterator begin()
-        {
-            return nodes_.begin();
-        }
-	
-        const_iterator begin() const
-        {
-            return nodes_.begin();
-        }
-
-        iterator end()
-        {
-            return  nodes_.end();
-        }
-	
-        const_iterator end() const
-        {
-            return  nodes_.end();
-        }
-	
-    private:
-        
-        void query_node(Envelope&lt;double&gt; const&amp; box, result_t &amp; result, node * node_) const
-        {
-            if (node_)
-            {
-                Envelope&lt;double&gt; const&amp; node_extent = node_-&gt;extent();
-                if (box.intersects(node_extent))
-                {
-                    node_data_iterator i=node_-&gt;begin();
-                    node_data_iterator end=node_-&gt;end();
-                    while ( i!=end)
-                    {
-                        result.push_back(&amp;(*i));
-                        ++i;
-                    }
-                    for (int k = 0; k &lt; 4; ++k)
-                    {
-                        query_node(box,result,node_-&gt;children_[k]);
-                    }
-                }
-            }
-        }
-	
-        void do_insert_data(T data, Envelope&lt;double&gt; const&amp; box, node * n)
-        {
-            if (n)
-            {
-                Envelope&lt;double&gt; const&amp; node_extent = n-&gt;extent();
-                Envelope&lt;double&gt; ext[4];
-                split_box(node_extent,ext);		
-                for (int i=0;i&lt;4;++i)
-                {
-                    if (ext[i].contains(box))
-                    {
-                        if (!n-&gt;children_[i])
-                        {
-                            nodes_.push_back(new node(ext[i]));
-                            n-&gt;children_[i]=&amp;nodes_.back();
-                        }
-                        do_insert_data(data,box,n-&gt;children_[i]);
-                        return;
-                    }
-                }
-                n-&gt;cont_.push_back(data);
-            }
-        }
-	
-        void split_box(Envelope&lt;double&gt; const&amp; node_extent,Envelope&lt;double&gt; * ext)
-        {
-            coord2d c=node_extent.center();
-
-            double width=node_extent.width();
-            double height=node_extent.height();
-	    
-            double lox=node_extent.minx();
-            double loy=node_extent.miny();
-            double hix=node_extent.maxx();
-            double hiy=node_extent.maxy();
-	    
-            ext[0]=Envelope&lt;double&gt;(lox,loy,lox + width * ratio_,loy + height * ratio_);
-            ext[1]=Envelope&lt;double&gt;(hix - width * ratio_,loy,hix,loy + height * ratio_);
-            ext[2]=Envelope&lt;double&gt;(lox,hiy - height*ratio_,lox + width * ratio_,hiy);
-            ext[3]=Envelope&lt;double&gt;(hix - width * ratio_,hiy - height*ratio_,hix,hiy);
-        }
-    };    
-} 
-
-#endif

Deleted: trunk/include/query.hpp
===================================================================
--- trunk/include/query.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/query.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,111 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id$
-
-#ifndef QUERY_HPP
-#define QUERY_HPP
-
-#include &lt;set&gt;
-#include &lt;limits&gt;
-#include &quot;filter.hpp&quot;
-#include &quot;envelope.hpp&quot;
-#include &quot;feature.hpp&quot;
-
-namespace mapnik
-{
-    class query 
-    {
-    private:
-        Envelope&lt;double&gt; bbox_;
-        filter&lt;Feature&gt;* filter_;
-        std::set&lt;std::string&gt; names_;
-    public:
-        query() 
-            : bbox_(std::numeric_limits&lt;double&gt;::min(),
-                    std::numeric_limits&lt;double&gt;::min(),
-                    std::numeric_limits&lt;double&gt;::max(),
-                    std::numeric_limits&lt;double&gt;::max()),
-              filter_(new all_filter&lt;Feature&gt;)
-        {}
-        
-        query(const Envelope&lt;double&gt;&amp; bbox)
-            : bbox_(bbox),
-              filter_(new all_filter&lt;Feature&gt;)
-        {}
-	
-        query(const Envelope&lt;double&gt;&amp; bbox, const filter&lt;Feature&gt;&amp; f)
-            : bbox_(bbox),
-              filter_(f.clone())
-        {}
-	
-        query(const query&amp; other)
-            : bbox_(other.bbox_),
-              filter_(other.filter_-&gt;clone())
-        {}
-        
-        query&amp; operator=(const query&amp; other)
-        {
-            filter&lt;Feature&gt;* tmp=other.filter_-&gt;clone();
-            delete filter_;
-            filter_=tmp;
-            bbox_=other.bbox_;
-            names_=other.names_;
-            return *this;
-        }
-	
-        const filter&lt;Feature&gt;* get_filter() const
-        {
-            return  filter_;
-        }
-	
-        const Envelope&lt;double&gt;&amp; get_bbox() const
-        {
-            return bbox_;
-        }
-
-        void set_filter(const filter&lt;Feature&gt;&amp; f)
-        {
-            filter&lt;Feature&gt;* tmp=f.clone();
-            delete filter_;
-            filter_=tmp;
-        }
-        
-        void add_property_name(const std::string&amp; name)
-        {
-            names_.insert(name);
-        } 
-	
-        const std::set&lt;std::string&gt;&amp; property_names() const
-        {
-            return names_;
-        }
-	
-        ~query() 
-        {
-            delete filter_;
-        }
-    };
-}
-
-
-#endif //QUERY_HPP

Deleted: trunk/include/raster.hpp
===================================================================
--- trunk/include/raster.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/raster.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,41 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id: raster.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef RASTER_HPP
-#define RASTER_HPP
-
-#include &quot;graphics.hpp&quot;
-
-namespace mapnik
-{
-    struct raster
-    {
-        Envelope&lt;double&gt; ext_;
-        ImageData32 data_;
-	raster(Envelope&lt;double&gt; const ext,ImageData32&amp; data)
-	    : ext_(ext),
-	      data_(data) {}
-    };
-}
-
-#endif //RASTER_HPP

Deleted: trunk/include/raster_symbolizer.hpp
===================================================================
--- trunk/include/raster_symbolizer.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/raster_symbolizer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,35 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id$
-
-#ifndef RASTER_SYMBOLIZER_HPP
-#define RASTER_SYMBOLIZER_HPP
-
-#include &lt;boost/shared_ptr.hpp&gt; 
-#include &lt;config.hpp&gt;
-
-namespace mapnik
-{
-    struct MAPNIK_DECL raster_symbolizer { /* TODO */};
-}
-
-#endif //RASTER_SYMBOLIZER

Deleted: trunk/include/regex_filter.hpp
===================================================================
--- trunk/include/regex_filter.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/regex_filter.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,81 +0,0 @@
-/* This file is part of Mapnik (c++ mapping toolkit)
- * Copyright (C) 2005 Artem Pavlenko
- *
- * Mapnik is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- */
-
-//$Id$
-
-#ifndef REGEX_FILTER_HPP
-#define REGEX_FILTER_HPP
-
-#include &quot;filter.hpp&quot;
-#include &quot;expression.hpp&quot;
-
-#include &lt;boost/regex.hpp&gt;
-#include &lt;boost/algorithm/string.hpp&gt;
-
-namespace mapnik
-{ 
-    template &lt;typename FeatureT&gt;
-    struct regex_filter : public filter&lt;FeatureT&gt;
-    {
-
-	regex_filter(expression&lt;FeatureT&gt; const&amp; exp,
-		     std::string const&amp; pattern)
-	    : filter&lt;FeatureT&gt;(),
-	      exp_(exp.clone()),
-	      pattern_(pattern) {}
-	
-	regex_filter(regex_filter const&amp; other)
-	    :  filter&lt;FeatureT&gt;(),
-	       exp_(other.exp_-&gt;clone()),
-	       pattern_(other.pattern_) {}
-	
-	bool pass(FeatureT const&amp; feature) const
-	{
-	    std::string text=exp_-&gt;get_value(feature).to_string();
-	    boost::trim_if(text,is_any_of(&quot;'&quot;));
-	    return boost::regex_match(text,pattern_);
-	}
-	
-	void accept(filter_visitor&lt;FeatureT&gt;&amp; v)
-	{
-	    exp_-&gt;accept(v);
-	    v.visit(*this);
-	}
-	
-	filter&lt;FeatureT&gt;* clone() const
-	{
-	    return new regex_filter(*this);
-	}
-	std::string to_string() const
-	{
-	    return exp_-&gt;to_string()+&quot;.match(&quot;+pattern_.str()+&quot;)&quot;;
-	}
-	~regex_filter()
-	{
-	    delete exp_;
-	}
-	
-    private:
-	expression&lt;FeatureT&gt;* exp_;
-	boost::regex pattern_;
-	
-    };   
-}
-
-
-#endif //REGEX_FILTER_HPP

Deleted: trunk/include/rule.hpp
===================================================================
--- trunk/include/rule.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/rule.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,280 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-#ifndef RULE_HPP
-#define RULE_HPP
-
-#include &quot;line_symbolizer.hpp&quot;
-#include &quot;line_pattern_symbolizer.hpp&quot;
-#include &quot;polygon_symbolizer.hpp&quot;
-#include &quot;polygon_pattern_symbolizer.hpp&quot;
-#include &quot;point_symbolizer.hpp&quot;
-#include &quot;raster_symbolizer.hpp&quot;
-#include &quot;text_symbolizer.hpp&quot;
-#include &quot;filter.hpp&quot;
-#include &quot;filter_visitor.hpp&quot;
-#include &lt;boost/shared_ptr.hpp&gt;
-#include &lt;boost/variant.hpp&gt;
-#include &lt;string&gt;
-#include &lt;vector&gt;
-
-namespace mapnik
-{
-    inline bool operator==(point_symbolizer const&amp; lhs,
-                           point_symbolizer const&amp; rhs)
-    {
-        return (&amp;lhs == &amp;rhs); 
-    }
-    inline bool operator==(line_symbolizer const&amp; lhs,
-                           line_symbolizer const&amp; rhs)
-    {
-        return (&amp;lhs == &amp;rhs); 
-    }
-    inline bool operator==(line_pattern_symbolizer const&amp; lhs,
-                           line_pattern_symbolizer const&amp; rhs)
-    {
-        return (&amp;lhs == &amp;rhs); 
-    }
-
-    inline bool operator==(polygon_symbolizer const&amp; lhs,
-                           polygon_symbolizer const&amp; rhs)
-    {
-        return (&amp;lhs == &amp;rhs); 
-    }
-    
-    inline bool operator==(polygon_pattern_symbolizer const&amp; lhs,
-                           polygon_pattern_symbolizer const&amp; rhs)
-    {
-        return (&amp;lhs == &amp;rhs); 
-    }
-    
-    inline bool operator==(raster_symbolizer const&amp; lhs,
-                           raster_symbolizer const&amp; rhs)
-    {
-        return (&amp;lhs == &amp;rhs); 
-    }
-    
-    inline bool operator==(text_symbolizer const&amp; lhs,
-                           text_symbolizer const&amp; rhs)
-    {
-        return (&amp;lhs == &amp;rhs); 
-    }
-    
-    typedef boost::variant&lt;point_symbolizer,
-                           line_symbolizer,
-                           line_pattern_symbolizer,
-                           polygon_symbolizer,
-                           polygon_pattern_symbolizer,
-                           raster_symbolizer,
-                           text_symbolizer&gt; symbolizer;
-    
-        
-    typedef std::vector&lt;symbolizer&gt; symbolizers;    
-    template &lt;typename FeatureT&gt; class all_filter;
-
-    template &lt;typename FeatureT,template &lt;typename&gt; class Filter&gt;
-    class rule
-    {
-        typedef Filter&lt;FeatureT&gt; filter_type;
-        typedef boost::shared_ptr&lt;filter_type&gt; filter_ptr;
-    private:
-
-        std::string name_;
-        std::string title_;
-        std::string abstract_;
-        double min_scale_;
-        double max_scale_;
-        symbolizers syms_;
-        filter_ptr filter_;
-        bool else_filter_;
-    public:
-        rule()
-            : name_(),
-              title_(),
-              abstract_(),
-              min_scale_(0),
-              max_scale_(std::numeric_limits&lt;double&gt;::infinity()),
-              syms_(),
-              filter_(new all_filter&lt;FeatureT&gt;),
-              else_filter_(false) {}
-                
-        rule(const std::string&amp; name,
-             const std::string&amp; title=&quot;&quot;,
-             double min_scale_denominator=0,
-             double max_scale_denominator=std::numeric_limits&lt;double&gt;::infinity())
-            : name_(name),
-              title_(title),
-              min_scale_(min_scale_denominator),
-              max_scale_(max_scale_denominator),
-              syms_(),
-              filter_(new all_filter&lt;FeatureT&gt;),
-              else_filter_(false) {}
-	    
-        rule(const rule&amp; rhs)    
-            : name_(rhs.name_),
-              title_(rhs.title_),
-              abstract_(rhs.abstract_),
-              min_scale_(rhs.min_scale_),
-              max_scale_(rhs.max_scale_),
-              syms_(rhs.syms_),
-              filter_(rhs.filter_),
-              else_filter_(rhs.else_filter_) {}
-	
-        rule&amp; operator=(rule const&amp; rhs) 
-        {
-            rule tmp(rhs);
-            swap(tmp);
-            return *this;
-        }
-        bool operator==(rule const&amp; other)
-        {
-            return  (this == &amp;other); 
-        }
-	
-        void set_max_scale(double scale)
-        {
-            max_scale_=scale;
-        }
-        
-        double get_max_scale() const
-        {
-            return max_scale_;
-        }
-        
-        void set_min_scale(double scale)
-        {
-            min_scale_=scale;
-        }
-
-        double get_min_scale() const
-        {
-            return min_scale_;
-        }
-
-       
-        void set_name(std::string const&amp; name)
-        {
-            name_=name;
-        }
-	
-        std::string const&amp; get_name() const
-        {
-            return name_;
-        }
-	
-        std::string const&amp; get_title() const
-        {
-            return  title_;
-        }
-
-        void set_title(std::string const&amp; title)
-        {
-            title_=title;
-        }
-  
-        void set_abstract(std::string const&amp; abstract)
-        {
-            abstract_=abstract;
-        }
-	
-        std::string const&amp; get_abstract() const
-        {
-            return abstract_;
-        }
-		
-        void append(const symbolizer&amp; sym)
-        {
-            syms_.push_back(sym);
-        }
-	
-        void remove_at(size_t index)
-        {
-            if (index &lt; syms_.size())
-            {
-                syms_.erase(syms_.begin()+index);
-            }
-        }
-	
-        const symbolizers&amp; get_symbolizers() const
-        {
-            return syms_;
-        }
-	
-        symbolizers::const_iterator begin()
-        {
-            return syms_.begin();
-        }
-	
-        symbolizers::const_iterator end()
-        {
-            return syms_.end();
-        }
-	
-        void set_filter(const filter_ptr&amp; filter)
-        {
-            filter_=filter;
-        }
-
-        filter_ptr const&amp; get_filter() const
-        {
-            return filter_;
-        }
-	
-        void set_else(bool else_filter)
-        {
-            else_filter_=else_filter;
-        }
-     
-        bool has_else_filter() const
-        {
-            return else_filter_;
-        }
-        
-        bool active(double scale) const
-        {
-            return ( scale &gt; min_scale_ &amp;&amp; scale &lt; max_scale_ );
-        }
-
-        void accept(filter_visitor&lt;FeatureT&gt;&amp; v) const
-        {
-            v.visit(*this);
-        }
-	
-    private:
-	
-        void swap(rule&amp; rhs) throw()
-        {
-            name_=rhs.name_;
-            title_=rhs.title_;
-            abstract_=rhs.abstract_;
-            min_scale_=rhs.min_scale_;
-            max_scale_=rhs.max_scale_;
-            syms_=rhs.syms_;
-            filter_=rhs.filter_;
-            else_filter_=rhs.else_filter_;
-        }
-    };
-
-    typedef rule&lt;Feature,filter&gt; rule_type;
-}
-
-#endif //RULE_HPP

Deleted: trunk/include/save_map.hpp
===================================================================
--- trunk/include/save_map.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/save_map.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,35 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-// $Id$
-
-#ifndef SAVE_MAP_HPP
-#define SAVE_MAP_HPP
-
-#include &lt;string&gt;
-#include &quot;map.hpp&quot;
-
-namespace mapnik
-{
-    void save_map(Map const&amp; map, std::string const&amp; filename);
-}
-
-#endif // SAVE_MAP_HPP

Deleted: trunk/include/spatial.hpp
===================================================================
--- trunk/include/spatial.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/spatial.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,154 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-#ifndef SPATIAL_HPP
-#define SPATIAL_HPP
-
-#include &quot;filter.hpp&quot;
-#include &quot;filter_visitor.hpp&quot;
-
-namespace mapnik
-{    
-
-    template &lt;typename FeatureT&gt;
-    struct equals_ : public filter&lt;FeatureT&gt;
-    {
-
-	bool pass(const FeatureT&amp; feature) const
-	{
-	    return false;
-	}
-	
-	void accept(const filter_visitor&lt;FeatureT&gt;&amp; v)
-	{
-	    v.visit(*this);
-	}
-    };
-    
-    template &lt;typename FeatureT&gt;
-    struct disjoint : public filter&lt;FeatureT&gt;
-    {
-	  
-	
-	bool pass(const FeatureT&amp; feature) const
-	{
-	    return false;
-	}
-	
-	void accept(const filter_visitor&lt;FeatureT&gt;&amp; v)
-	{
-	    v.visit(*this);
-	}
-    };
-  
-    template &lt;typename FeatureT&gt;
-    struct touches : public filter&lt;FeatureT&gt;
-    {
-
-	
-	bool pass(const FeatureT&amp; feature) const
-	{
-	    return false;
-	}
-	
-	void accept(const filter_visitor&lt;FeatureT&gt;&amp; v)
-	{
-	    v.visit(*this);
-	}
-    };
-
-    template &lt;typename FeatureT&gt;
-    struct within : public filter&lt;FeatureT&gt;
-    {
-
-	bool pass(const FeatureT&amp; feature) const
-	{
-	    return false;
-	}
-
-	void accept(const filter_visitor&lt;FeatureT&gt;&amp; v)
-	{
-	    v.visit(*this);
-	}
-    };
-
-    template &lt;typename FeatureT&gt;
-    struct overlaps : public filter&lt;FeatureT&gt;
-    {
-
-	bool pass(const FeatureT&amp; feature) const
-	{
-	    return false;
-	}
-	
-	void accept(const filter_visitor&lt;FeatureT&gt;&amp; v)
-	{
-	    v.visit(*this);
-	}
-    };
-
-    template &lt;typename FeatureT&gt;
-    struct crosses : public filter&lt;FeatureT&gt;
-    {
-
-	
-	bool pass(const FeatureT&amp; feature) const
-	{
-	    return false;
-	}
-	
-	void accept(const filter_visitor&lt;FeatureT&gt;&amp; v)
-	{
-	    v.visit(*this);
-	}
-    };
-    
-    template &lt;typename FeatureT&gt;
-    struct bbox  : public filter&lt;FeatureT&gt; 
-    {
-    private:
-	Envelope&lt;double&gt; box_;
-    public:
-	bbox(const Envelope&lt;double&gt;&amp; box)
-	    : box_(box) {}
-
-	
-	bool pass(const FeatureT&amp; feature) const
-	{
-	    return box_.contains(feature.get_geometry()-&gt;bbox());
-	}
-	
-
-	filter&lt;FeatureT&gt;* clone() const
-	{
-	    return new bbox&lt;FeatureT&gt;(box_);
-	}
-	void accept(const filter_visitor&lt;FeatureT&gt;&amp; v)
-	{
-	    v.visit(*this);
-	}
-	
-	
-	virtual ~bbox() {}
-    };
-}
-
-#endif //SPATIAL_HPP

Deleted: trunk/include/stroke.hpp
===================================================================
--- trunk/include/stroke.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/stroke.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,169 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id$
-
-#ifndef STROKE_HPP
-#define STROKE_HPP
-
-#include &quot;color.hpp&quot;
-#include &lt;vector&gt;
-
-namespace mapnik
-{
-    using std::pair;
-    using std::vector;
-    typedef vector&lt;pair&lt;float,float&gt; &gt; dash_array;
-    
-    enum line_cap_e
-        {
-            BUTT_CAP,
-            SQUARE_CAP,
-            ROUND_CAP
-        }; 
-    
-    enum line_join_e
-        {
-            MITER_JOIN,
-            MITER_REVERT_JOIN,
-            ROUND_JOIN,
-            BEVEL_JOIN
-        };
-    
-    class stroke
-    {	
-        Color c_;
-        float width_;
-        float opacity_; // 0.0 - 1.0
-        line_cap_e  line_cap_;
-        line_join_e line_join_;
-        dash_array dash_;	
-    public:
-        explicit stroke() 
-            : c_(0,0,0),
-              width_(1.0),
-              opacity_(1.0),
-              line_cap_(BUTT_CAP),
-              line_join_(MITER_JOIN),
-              dash_() {}
-	
-        stroke(Color const&amp; c, float width=1.0)
-            : c_(c),
-              width_(width),
-              opacity_(1.0),
-              line_cap_(BUTT_CAP),
-              line_join_(MITER_JOIN),
-              dash_() {}
-
-        stroke(stroke const&amp; other)
-            : c_(other.c_),
-              width_(other.width_),
-              opacity_(other.opacity_),
-              line_cap_(other.line_cap_),
-              line_join_(other.line_join_),
-              dash_(other.dash_) {}
-	    
-        stroke&amp; operator=(const stroke&amp; rhs)
-        {
-            stroke tmp(rhs);
-            swap(tmp);
-            return *this;
-        }
-
-        void set_color(const Color&amp; c) 
-        {
-            c_=c;
-        }
-	
-        Color const&amp; get_color() const
-        {
-            return c_;
-        }
-	
-        float get_width() const
-        {
-            return width_;
-        }
-        void set_width(float w)
-        {
-            width_=w;
-        }
-
-        void set_opacity(float opacity)
-        {    
-            if (opacity &gt; 1.0) opacity_=1.0;
-            else if (opacity &lt; 0.0) opacity_=0.0;
-            else opacity_=opacity;
-        }
-
-        float get_opacity() const 
-        {
-            return opacity_;
-        }
-	
-        void set_line_cap(line_cap_e line_cap)
-        {
-            line_cap_=line_cap;
-        }
-
-        line_cap_e get_line_cap() const 
-        {
-            return line_cap_;
-        }
-	
-        void set_line_join(line_join_e line_join) 
-        {
-            line_join_=line_join;
-        }
-	
-        line_join_e get_line_join() const 
-        {
-            return line_join_;
-        }
-	
-        void add_dash(float dash,float gap)
-        {
-            dash_.push_back(std::make_pair(dash,gap));
-        }
-        bool has_dash() const 
-        {
-            return dash_.size()&gt;0 ? true : false ;
-        }
-	
-        dash_array const&amp; get_dash_array() const
-        {
-            return  dash_;
-        }
-	
-    private:
-        void swap(const stroke&amp; other) throw()
-        {
-            c_=other.c_;
-            width_=other.width_;
-            opacity_=other.opacity_;
-            line_cap_=other.line_cap_;
-            line_join_=other.line_join_;
-            dash_ = other.dash_;
-        }
-    };
-}
-
-#endif //STROKE_HPP

Deleted: trunk/include/style.hpp
===================================================================
--- trunk/include/style.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/style.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,39 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id: style.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef STYLE_HPP
-#define STYLE_HPP
-
-#include &quot;color.hpp&quot;
-#include &quot;symbolizer.hpp&quot;
-
-#include &lt;vector&gt;
-#include &lt;algorithm&gt;
-#include &lt;functional&gt;
-#include &lt;boost/shared_ptr.hpp&gt;
-
-namespace mapnik
-{      
-}
-
-#endif //STYLE_HPP

Deleted: trunk/include/style_factory.hpp
===================================================================
--- trunk/include/style_factory.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/style_factory.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,37 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id: style_factory.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef STYLE_FACTORY_HPP
-#define STYLE_FACTORY_HPP
-
-//#include &quot;style.hpp&quot;
-
-namespace mapnik {
-    
-    class style_factory 
-    {
-    };
-}
-
-
-#endif //STYLE_FACTORY_HPP

Deleted: trunk/include/symbolizer.hpp
===================================================================
--- trunk/include/symbolizer.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/symbolizer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,31 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id: symbolizer.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef SYMBOLIZER_HPP
-#define SYMBOLIZER_HPP
-
-namespace mapnik 
-{
-}
-
-#endif //SYMBOLIZER_HPP

Deleted: trunk/include/text_symbolizer.hpp
===================================================================
--- trunk/include/text_symbolizer.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/text_symbolizer.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,68 +0,0 @@
-/* This file is part of Mapnik (c++ mapping toolkit)
- * Copyright (C) 2005 Artem Pavlenko
- *
- * Mapnik is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- */
-
-//$Id$
-
-#ifndef TEXT_SYMBOLIZER_HPP
-#define TEXT_SYMBOLIZER_HPP
-
-#include &lt;string&gt;
-#include &lt;boost/tuple/tuple.hpp&gt;
-#include &quot;color.hpp&quot;
-
-namespace mapnik
-{
-    enum label_placement_e {
-	point_placement=1,
-	line_placement=2
-    };
-        
-    typedef boost::tuple&lt;double,double&gt; position;
-    
-    struct MAPNIK_DECL text_symbolizer
-    {		
-	text_symbolizer(std::string const&amp; name,unsigned size,Color const&amp; fill);	
-	text_symbolizer(text_symbolizer const&amp; rhs);
-	text_symbolizer&amp; operator=(text_symbolizer const&amp; rhs);
-	std::string const&amp; get_name() const;
-	unsigned get_text_size() const;
-	Color const&amp; get_fill() const;
-	void set_halo_fill(Color const&amp; fill);
-	Color const&amp; get_halo_fill() const;
-	void set_halo_radius(unsigned radius);
-	unsigned get_halo_radius() const;
-	void set_label_placement(label_placement_e label_p);
-	label_placement_e get_label_placement() const;
-        void set_anchor(double x, double y);	
-	position const&amp; get_anchor() const;	
-	void set_displacement(double x, double y);
-	position const&amp; get_displacement() const;
-	
-    private:
-	std::string name_;
-	unsigned size_;
-	Color fill_;
-	Color halo_fill_;
-	unsigned halo_radius_;
-	label_placement_e label_p_;
-	position anchor_;
-	position displacement_;
-    };
-}
-
-#endif //TEXT_SYMBOLIZER_HPP

Deleted: trunk/include/utils.hpp
===================================================================
--- trunk/include/utils.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/utils.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,249 +0,0 @@
-/* This file is part of Mapnik (c++ mapping toolkit)
- * Copyright (C) 2005 Artem Pavlenko
- *
- * Mapnik is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- */
-
-//$Id: utils.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef UTILS_HPP
-#define UTILS_HPP
-
-#include &lt;stdexcept&gt;
-#include &lt;limits&gt;
-#include &lt;ctime&gt;
-//#include &lt;sys/time.h&gt;
-#include &lt;sstream&gt;
-#include &lt;iostream&gt;
-#include &lt;algorithm&gt;
-#include &lt;cmath&gt;
-
-#include &lt;boost/thread/mutex.hpp&gt;
-
-namespace mapnik
-{
-    using boost::mutex;
-    
-    template &lt;typename T&gt;
-    class CreateUsingNew
-    {
-    public:
-	static T* create()
-	{
-	    return new T;
-	}
-	static void destroy(T* obj)
-	{
-	    delete obj;
-	}
-    };
-
-    template &lt;typename T&gt;
-    class CreateStatic
-    {
-    private:
-	union MaxAlign
-	{
-	    char t_[sizeof(T)];
-	    short int shortInt_;
-	    int int_;
-	    long int longInt_;
-	    float float_;
-	    double double_;
-	    long double longDouble_;
-	    struct Test;
-	    int Test::* pMember_;
-	    int (Test::*pMemberFn_)(int);
-	};
-    public:
-	static T* create()
-	{
-	    static MaxAlign staticMemory;
-	    return new(&amp;staticMemory) T;
-	}
-	static void destroy(volatile T* obj)
-	{
-	    obj-&gt;~T();
-	}
-    };
-
-    template &lt;typename T,
-	      template &lt;typename T&gt; class CreatePolicy=CreateStatic&gt; class singleton
-	      {
-		  friend class CreatePolicy&lt;T&gt;;
-		  static T* pInstance_;
-		  static bool destroyed_;
-		  singleton(const singleton &amp;rhs);
-		  singleton&amp; operator=(const singleton&amp;);
-		  static void onDeadReference()
-		  {
-		      throw std::runtime_error(&quot;dead reference!&quot;);
-		  }
-	      protected:
-		  static mutex mutex_;
-		  singleton() {}
-		  virtual ~singleton()
-		  {
-		      CreatePolicy&lt;T&gt;::destroy(pInstance_);
-		      destroyed_=true;
-		  }
-	      public:
-		  static  T* instance()
-		  {
-		      if (!pInstance_)
-		      {
-			  mutex::scoped_lock lock(mutex_);
-			  if (!pInstance_)
-			  {
-			      if (destroyed_)
-			      {
-				  onDeadReference();
-			      }
-			      else
-			      {
-				  pInstance_=CreatePolicy&lt;T&gt;::create();
-			      }
-			  }
-		      }
-		      return pInstance_;
-		  }
-	      };
-
-    template &lt;typename T,
-	      template &lt;typename T&gt; class CreatePolicy&gt; mutex singleton&lt;T,CreatePolicy&gt;::mutex_;
-    template &lt;typename T,
-	      template &lt;typename T&gt; class CreatePolicy&gt; T* singleton&lt;T,CreatePolicy&gt;::pInstance_=0;
-    template &lt;typename T,
-	      template &lt;typename T&gt; class CreatePolicy&gt; bool singleton&lt;T,CreatePolicy&gt;::destroyed_=false;
-
-    template &lt;class T&gt; class Handle
-    {
-        T* ptr_;
-        int* pCount_;
-    public:
-	T* operator-&gt;() {return ptr_;}
-	const T* operator-&gt;() const {return ptr_;}
-	Handle(T* ptr)
-	    :ptr_(ptr),pCount_(new int(1)) {}
-	Handle(const Handle&amp; rhs)
-	    :ptr_(rhs.ptr_),pCount_(rhs.pCount_)
-	{
-	    (*pCount_)++;
-	}
-	Handle&amp; operator=(const Handle&amp; rhs)
-	{
-	    if (ptr_==rhs.ptr_) return *this;
-	    if (--(*pCount_)==0)
-	    {
-		delete ptr_;
-		delete pCount_;
-	    }
-	    ptr_=rhs.ptr_;
-	    pCount_=rhs.pCount_;
-	    (*pCount_)++;
-	    return *this;
-	}
-	~Handle()
-	{
-	    if (--(*pCount_)==0)
-	    {
-		delete ptr_;
-		delete pCount_;
-	    }
-	}
-    };
-
-
-    struct timer
-    {
-        //struct timeval tv_;
-        timer()
-        {
-            //gettimeofday (&amp;tv_,0);
-        }
-        void start()
-        {
-            //gettimeofday (&amp;tv_,0);
-        }
-        void stop()
-        {
-            //timeval tv;
-            //gettimeofday (&amp;tv,0);
-            //std::ostringstream s;
-            //long sec=1000*(tv.tv_sec-tv_.tv_sec);
-            //long total_ms=sec+static_cast&lt;long&gt;(0.001*(tv.tv_usec-tv_.tv_usec));
-            //s &lt;&lt; &quot;elapsed time is &quot;&lt;&lt;total_ms&lt;&lt;&quot; ms&quot;;
-            //std::clog&lt;&lt;s.str()&lt;&lt;std::endl;
-        }
-    };
-    
-    //converters
-    class BadConversion : public std::runtime_error
-    {
-    public:
-	BadConversion(const std::string&amp; s)
-	    :std::runtime_error(s)
-	{}
-    };
-    
-    template &lt;typename T&gt;
-    inline std::string toString(const T&amp; x)
-    {
-        std::ostringstream o;
-        if (!(o &lt;&lt; x))
-            throw BadConversion(std::string(&quot;toString(&quot;)
-                                + typeid(x).name() + &quot;)&quot;);
-        return o.str();
-    }
-    
-    template&lt;typename T&gt;
-    inline void fromString(const std::string&amp; s, T&amp; x,
-                           bool failIfLeftoverChars = true)
-    {
-        std::istringstream i(s);
-        char c;
-        if (!(i &gt;&gt; x) || (failIfLeftoverChars &amp;&amp; i.get(c)))
-            throw BadConversion(&quot;fromString(&quot;+s+&quot;)&quot;);
-    }
-    
-    //inline bool space (char c)
-    //{
-//		return isspace(c);
- //   }
-    
-   // inline bool not_space (char c)
-    //{
-//		return !isspace(c);
- //   }
-    
-    //inline std::string trim_left(const std::string&amp; str)
-    //{
-//		typedef std::string::const_iterator iter;
-//		iter i = std::find_if(str.begin(),str.end(),not_space);
-		//return std::string(i,str.end());	
-    //}
-    //inline std::string trim_right(const std::string&amp; str)
-    //{
-	//	std::string::size_type idx=str.find_last_not_of(&quot; &quot;);
-//		return str.substr(0,idx+1);
- //   }
-//	inline std::string trim(const std::string&amp; str)
-  //  {
-	//	return trim_left(trim_right(str));
-	//}
-}
-
-
-#endif                                            //UTILS_HPP

Deleted: trunk/include/value.hpp
===================================================================
--- trunk/include/value.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/value.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,443 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id$
-
-#ifndef VALUE_HPP
-#define VALUE_HPP
-
-#include &lt;string&gt;
-#include &lt;sstream&gt;
-#include &lt;boost/variant.hpp&gt;
-
-using namespace boost;
-namespace mapnik {
-
-    typedef variant&lt;int,double,std::string&gt; value_base;
-    
-    namespace impl {
-	struct equals
-	    : public boost::static_visitor&lt;bool&gt;
-	{
-	    template &lt;typename T, typename U&gt;
-	    bool operator() (const T &amp;, const U &amp; ) const
-	    {
-		return false;
-	    }
-	
-	    template &lt;typename T&gt;
-	    bool operator() (T lhs, T rhs) const
-	    {
-		return lhs == rhs;
-	    }
-	
-	    bool operator() (int lhs, double rhs) const
-	    {
-		return  lhs == rhs;
-	    }
-	
-	    bool operator() (double lhs, int rhs) const
-	    {
-		return  lhs == rhs;
-	    }
-	
-	    bool operator() (std::string const&amp; lhs, std::string const&amp; rhs) const
-	    {
-		return  lhs == rhs;
-	    }
-	};
-    
-	struct greater_than
-	    : public boost::static_visitor&lt;bool&gt;
-	{
-	    template &lt;typename T, typename U&gt;
-	    bool operator()( const T &amp;, const U &amp; ) const
-	    {
-		return false;
-	    }
-	
-	    template &lt;typename T&gt;
-	    bool operator()( T lhs, T rhs ) const
-	    {
-		return lhs &gt; rhs;
-	    }
-	
-	    bool operator() (int lhs, double rhs) const
-	    {
-		return  lhs &gt; rhs;
-	    }
-	
-	    bool operator() (double lhs, int rhs) const
-	    {
-		return  lhs &gt; rhs;
-	    }
-	
-	    bool operator() (std::string const&amp; lhs, std::string const&amp; rhs) const
-	    {
-		return  lhs &gt; rhs;
-	    }
-	};
-    
-	struct greater_or_equal
-	    : public boost::static_visitor&lt;bool&gt;
-	{	
-	    template &lt;typename T, typename U&gt;
-	    bool operator()( const T &amp;, const U &amp; ) const
-	    {
-		return false;
-	    }
-	
-	    template &lt;typename T&gt;
-	    bool operator() (T lhs, T rhs) const
-	    {
-		return lhs &gt;= rhs;
-	    }
-      
-	    bool operator() (int lhs, double rhs) const
-	    {
-		return  lhs &gt;= rhs;
-	    }
-	
-	    bool operator() (double lhs, int rhs) const
-	    {
-		return  lhs &gt;= rhs;
-	    }
-	
-	    bool operator() (std::string const&amp; lhs, std::string const&amp; rhs ) const
-	    {
-		return lhs &gt;= rhs;
-	    }
-	};
-    
-	struct less_than
-	    : public boost::static_visitor&lt;bool&gt;
-	{	
-	    template &lt;typename T, typename U&gt;
-	    bool operator()( const T &amp;, const U &amp; ) const
-	    {
-		return false;
-	    }
-	
-	    template &lt;typename T&gt;
-	    bool operator()( T  lhs,T  rhs) const
-	    {
-		return lhs &lt; rhs;
-	    }
-	
-	    bool operator() (int lhs, double rhs) const
-	    {
-		return  lhs &lt; rhs;
-	    }
-	   
-	    bool operator() (double lhs, int rhs) const
-	    {
-		return  lhs &lt; rhs;
-	    }
-	
-	    bool operator()( std::string const&amp; lhs, std::string const&amp; rhs ) const
-	    {
-		return lhs &lt; rhs;
-	    }
-	};
-
-	struct less_or_equal
-	    : public boost::static_visitor&lt;bool&gt;
-	{	
-	    template &lt;typename T, typename U&gt;
-	    bool operator()( const T &amp;, const U &amp; ) const
-	    {
-		return false;
-	    }
-	
-	    template &lt;typename T&gt;
-	    bool operator()(T lhs, T rhs ) const
-	    {
-		return lhs &lt;= rhs;
-	    }
-	    
-	    bool operator() (int lhs, double rhs) const
-	    {
-		return  lhs &lt;= rhs;
-	    }
-	
-	    bool operator() (double lhs, int rhs) const
-	    {
-		return  lhs &lt;= rhs;
-	    }
-	
-	    template &lt;typename T&gt;
-	    bool operator()( std::string const&amp; lhs, std::string const&amp; rhs ) const
-	    {
-		return lhs &lt;= rhs;
-	    }
-	};
-    
-	template &lt;typename V&gt;
-	struct add : public boost::static_visitor&lt;V&gt;
-	{ 
-	    typedef V value_type;
-	    template &lt;typename T1, typename T2&gt;
-	    value_type operator() (T1 const&amp; lhs, T2 const&amp;) const
-	    {
-		return lhs;
-	    }
-	    template &lt;typename T&gt;
-	    value_type operator() (T lhs, T rhs) const
-	    {
-		return lhs + rhs ;
-	    }
-	
-	    value_type operator() (std::string const&amp; lhs,std::string const&amp; rhs ) const
-	    {
-		return lhs + rhs;
-	    }
-	
-	    value_type operator() (double lhs, int rhs) const
-	    {
-		return lhs + rhs;
-	    }
-	
-	    value_type operator() (int lhs, double rhs) const
-	    {
-		return lhs + rhs;
-	    }
-	};
-	template &lt;typename V&gt;
-	struct sub : public boost::static_visitor&lt;V&gt;
-	{ 
-	    typedef V value_type;
-	    template &lt;typename T1, typename T2&gt;
-	    value_type operator() (T1 const&amp; lhs, T2 const&amp;) const
-	    {
-		return lhs;
-	    }
-
-	    template &lt;typename T&gt;
-	    value_type operator() (T  lhs, T rhs) const
-	    {
-		return lhs - rhs ;
-	    }
-
-	    value_type operator() (std::string const&amp; lhs,std::string const&amp; ) const
-	    {
-		return lhs;
-	    }
-        	
-	    value_type operator() (double lhs, int rhs) const
-	    {
-		return lhs - rhs;
-	    }
-	
-	    value_type operator() (int lhs, double rhs) const
-	    {
-		return lhs - rhs;
-	    }
-	};
-    
-	template &lt;typename V&gt;
-	struct mult : public boost::static_visitor&lt;V&gt;
-	{ 
-	    typedef V value_type;
-	    template &lt;typename T1, typename T2&gt;
-	    value_type operator() (T1 const&amp; lhs , T2 const&amp; ) const
-	    {
-		return lhs;
-	    }
-	    template &lt;typename T&gt;
-	    value_type operator() (T lhs, T rhs) const
-	    {
-		return lhs * rhs;
-	    }
-	
-	    value_type operator() (std::string const&amp; lhs,std::string const&amp; ) const
-	    {
-		return lhs;
-	    }	
-	
-	    value_type operator() (double lhs, int rhs) const
-	    {
-		return lhs * rhs;
-	    }
-	
-	    value_type operator() (int lhs, double rhs) const
-	    {
-		return lhs * rhs;
-	    }
-	};
-
-	template &lt;typename V&gt;
-	struct div: public boost::static_visitor&lt;V&gt;
-	{ 
-	    typedef V value_type;
-	    template &lt;typename T1, typename T2&gt;
-	    value_type operator() (T1 const&amp; lhs, T2 const&amp;) const
-	    {
-		return lhs;
-	    }
-	    
-	    template &lt;typename T&gt;
-	    value_type operator() (T lhs, T rhs) const
-	    {
-		return lhs / rhs;
-	    }
-	
-	    value_type operator() (std::string const&amp; lhs,std::string const&amp;) const
-	    {
-		return lhs;
-	    }
-	
-	    value_type operator() (double lhs, int rhs) const
-	    {
-		return lhs / rhs;
-	    }
-	
-	    value_type operator() (int lhs, double rhs) const
-	    {
-		return lhs / rhs;
-	    }
-	};
-    
-	struct to_string : public boost::static_visitor&lt;std::string&gt;
-	{
-	    template &lt;typename T&gt;
-	    std::string operator() (T val) const
-	    {
-		std::stringstream ss;
-		ss &lt;&lt; val;
-		return ss.str();
-	    } 
-	    std::string const&amp; operator() (std::string const&amp; val) const
-	    {
-		return val;
-	    }
-	};
-	
-	struct to_expression_string : public boost::static_visitor&lt;std::string&gt;
-	{
-	    template &lt;typename T&gt;
-	    std::string operator() (T val) const
-	    {
-		std::stringstream ss;
-		ss &lt;&lt; val;
-		return ss.str();
-	    } 
-	    std::string operator() (std::string const&amp; val) const
-	    {
-		return &quot;'&quot; + val + &quot;'&quot;;
-	    }
-	};
-    }
-    
-    class value
-    {
-        value_base base_;
-        friend const value operator+(value const&amp;,value const&amp;);
-        friend const value operator-(value const&amp;,value const&amp;);
-        friend const value operator*(value const&amp;,value const&amp;);
-        friend const value operator/(value const&amp;,value const&amp;);
-
-    public:
-	value ()
-	    : base_(0) {}
-	
-	template &lt;typename T&gt; value(T _val_)
-	    : base_(_val_) {}
-
-	bool operator==(value const&amp; other) const
-	{
-	    return boost::apply_visitor(impl::equals(),base_,other.base_);
-	}
-
-	bool operator!=(value const&amp; other) const
-	{
-	    return !(boost::apply_visitor(impl::equals(),base_,other.base_));
-	}
-	
-	bool operator&gt;(value const&amp; other) const
-	{
-	    return boost::apply_visitor(impl::greater_than(),base_,other.base_);
-	}
-
-	bool operator&gt;=(value const&amp; other) const
-	{
-	    return boost::apply_visitor(impl::greater_or_equal(),base_,other.base_);
-	}
-
-	bool operator&lt;(value const&amp; other) const
-	{
-	    return boost::apply_visitor(impl::less_than(),base_,other.base_);
-	}
-
-	bool operator&lt;=(value const&amp; other) const
-	{
-	    return boost::apply_visitor(impl::less_or_equal(),base_,other.base_);
-	}
-	value_base const&amp; base() const
-	{
-	    return base_;
-	}
-
-	std::string to_expression_string() const
-	{
-	    return boost::apply_visitor(impl::to_expression_string(),base_);
-	}
-
-	std::string to_string() const
-	{
-	    return boost::apply_visitor(impl::to_string(),base_);
-	}
-    };
-    
-    inline const value operator+(value const&amp; p1,value const&amp; p2)
-    {
-
-	return value(boost::apply_visitor(impl::add&lt;value&gt;(),p1.base_, p2.base_));
-    }
-
-    inline const value operator-(value const&amp; p1,value const&amp; p2)
-    {
-
-	return value(boost::apply_visitor(impl::sub&lt;value&gt;(),p1.base_, p2.base_));
-    }
-
-    inline const value operator*(value const&amp; p1,value const&amp; p2)
-    {
-
-	return value(boost::apply_visitor(impl::mult&lt;value&gt;(),p1.base_, p2.base_));
-    }
-
-    inline const value operator/(value const&amp; p1,value const&amp; p2)
-    {
-
-	return value(boost::apply_visitor(impl::div&lt;value&gt;(),p1.base_, p2.base_));
-    }
-
-    template &lt;typename charT, typename traits&gt;
-    inline std::basic_ostream&lt;charT,traits&gt;&amp; 
-    operator &lt;&lt; (std::basic_ostream&lt;charT,traits&gt;&amp; out,
-    		 value const&amp; v)
-    {
-    	out &lt;&lt; v.base();
-    	return out; 
-    }
-}
-
-#endif //VALUE_HPP

Deleted: trunk/include/vertex.hpp
===================================================================
--- trunk/include/vertex.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/vertex.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,113 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id: vertex.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef VERTEX_HPP
-#define VERTEX_HPP
-
-#include &lt;iostream&gt;
-#include &lt;sstream&gt;
-
-namespace mapnik 
-{
-    enum
-    {
-        SEG_END   =0,
-        SEG_MOVETO=1,
-        SEG_LINETO=2,
-        SEG_CLOSE =3
-    };
-    
-    template &lt;typename T,int dim&gt;
-    struct vertex {
-	typedef T type;
-    };
-    
-    template &lt;typename T&gt;
-    struct vertex&lt;T,2&gt; 
-    {
-	typedef T type;
-	T x;
-	T y;
-	unsigned cmd;
-	vertex() 
-	    : x(0),y(0),cmd(SEG_END) {}
-	vertex(T x,T y,unsigned cmd)
-	    : x(x),y(y),cmd(cmd) {}
-
-	template &lt;typename T2&gt;
-	vertex(const vertex&lt;T2,2&gt;&amp; rhs)
-	    : x(type(rhs.x)),
-	      y(type(rhs.y)),
-	      cmd(rhs.cmd) {}
-	
-	template &lt;typename T2&gt; vertex&lt;T,2&gt; operator=(const vertex&lt;T2,2&gt;&amp; rhs)
-	{
-	    if ((void*)this == (void*)&amp;rhs)
-	    {
-		return *this;
-	    }
-	    x=type(rhs.x);
-	    y=type(rhs.y);
-	    cmd=rhs.cmd;
-	    return *this;
-	}	
-    };
-    
-    typedef vertex&lt;double,2&gt; vertex2d;
-    typedef vertex&lt;int,2&gt; vertex2i;
-
-    
-    template &lt;class charT,class traits,class T,int dim&gt;
-    inline std::basic_ostream&lt;charT,traits&gt;&amp;
-    operator &lt;&lt; (std::basic_ostream&lt;charT,traits&gt;&amp; out,
-		 const vertex&lt;T,dim&gt;&amp; c);
-
-    template &lt;class charT,class traits,class T&gt;
-    inline std::basic_ostream&lt;charT,traits&gt;&amp;
-    operator &lt;&lt; (std::basic_ostream&lt;charT,traits&gt;&amp; out,
-		 const vertex&lt;T,2&gt;&amp; v)
-    {
-        std::basic_ostringstream&lt;charT,traits&gt; s;
-        s.copyfmt(out);
-        s.width(0);
-        s&lt;&lt;&quot;vertex2(&quot;&lt;&lt;v.x&lt;&lt;&quot;,&quot;&lt;&lt;v.y&lt;&lt;&quot;,cmd=&quot;&lt;&lt;v.cmd&lt;&lt;&quot; )&quot;;
-        out &lt;&lt; s.str();
-        return out;
-    }
-
-    template &lt;class charT,class traits,class T&gt;
-    inline std::basic_ostream&lt;charT,traits&gt;&amp;
-    operator &lt;&lt; (std::basic_ostream&lt;charT,traits&gt;&amp; out,
-		 const vertex&lt;T,3&gt;&amp; v)
-    {
-        std::basic_ostringstream&lt;charT,traits&gt; s;
-        s.copyfmt(out);
-        s.width(0);
-        s&lt;&lt;&quot;vertex3(&quot;&lt;&lt;v.x&lt;&lt;&quot;,&quot;&lt;&lt;v.y&lt;&lt;&quot;,&quot;&lt;&lt;v.z&lt;&lt;&quot;,cmd=&quot;&lt;&lt;v.cmd&lt;&lt;&quot;)&quot;;
-        out &lt;&lt; s.str();
-        return out;
-    } 
-
-}
-
-#endif // VERTEX_HPP

Deleted: trunk/include/vertex_transform.hpp
===================================================================
--- trunk/include/vertex_transform.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/vertex_transform.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,92 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//$Id: vertex_transform.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef VERTEX_TRANSFORM_HPP
-#define VERTEX_TRANSFORM_HPP
-
-#include &quot;vertex.hpp&quot;
-#include &quot;envelope.hpp&quot;
-
-namespace mapnik
-{
-    template &lt;typename T0 ,typename T1,int shift=8&gt;
-    struct Shift
-    {
-	typedef T0 value_type;
-	typedef T1 return_type;
-	static return_type apply(value_type val)
-	{
-	    return static_cast&lt;return_type&gt;(val*(1&lt;&lt;shift));
-	}
-    };
-
-    template &lt;typename T0,typename T1&gt;
-    struct Shift&lt;T0,T1,0&gt; 
-    {
-	typedef T0 value_type;
-	typedef T1 return_type;
-	static return_type apply(value_type val)
-	{
-	    return static_cast&lt;return_type&gt;(val);
-	}
-    };
-
-    template &lt;typename T&gt;
-    struct Shift&lt;T,T,0&gt;
-    {
-	typedef T value_type;
-	typedef T return_type;
-	static T&amp; apply(T&amp; val)
-	{
-	    return val;
-	}
-    };
-
-    typedef Shift&lt;double,double,0&gt; NO_SHIFT;
-    typedef Shift&lt;double,int,0&gt; SHIFT0;
-    typedef Shift&lt;double,int,8&gt; SHIFT8;
-    
-    
-    template &lt;typename T0,typename T1,typename Trans&gt;
-    struct view_transform;
-    
-    template &lt;typename Trans&gt;
-    struct view_transform &lt;vertex2d,vertex2d,Trans&gt;   
-    {
-	
-    };
-    
-    template &lt;typename Trans&gt;
-    struct view_transform &lt;vertex2d,vertex2i,Trans&gt;   
-    {
-	
-    };
-
-    template &lt;typename Trans&gt;
-    struct view_transform&lt;Envelope&lt;double&gt;,Envelope&lt;double&gt;,Trans&gt;
-    {
-	
-    };
-}
-
-#endif //VERTEX_TRANSFORM_HPP

Deleted: trunk/include/vertex_vector.hpp
===================================================================
--- trunk/include/vertex_vector.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/vertex_vector.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,199 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-//  Credits:
-//  I gratefully acknowledge the inspiring work of Maxim Shemanarev (McSeem), 
-//  author of Anti-Grain Geometry (<A HREF="http://www.antigrain.com">http://www.antigrain.com</A>). I have used 
-//  the datastructure from AGG as a template for my own. 
-
-
-//$Id: vertex_vector.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef VERTEX_VECTOR_HPP
-#define VERTEX_VECTOT_HPP
-
-#include &quot;vertex.hpp&quot;
-#include &quot;ctrans.hpp&quot;
-
-#include &lt;vector&gt;
-#include &lt;boost/utility.hpp&gt;
-#include &lt;boost/tuple/tuple.hpp&gt;
-
-namespace mapnik
-{
-    template &lt;typename T&gt;
-    class vertex_vector : private boost::noncopyable
-    {
-        typedef typename T::type value_type;
-        typedef vertex&lt;value_type,2&gt; vertex_type;
-        enum {
-            block_shift = 8,
-            block_size  = 1&lt;&lt;block_shift,
-            block_mask  = block_size - 1,
-            grow_by     = 256
-        };
-
-    private:
-        unsigned num_blocks_;
-        unsigned max_blocks_;
-        value_type** vertexs_;
-        unsigned char** commands_;
-        unsigned pos_;
-    public:
-	
-        vertex_vector() 
-            : num_blocks_(0),
-              max_blocks_(0),
-              vertexs_(0),
-              commands_(0),
-              pos_(0) {}
-
-        ~vertex_vector()
-        {
-            if ( num_blocks_ )
-            {
-                value_type** vertexs=vertexs_ + num_blocks_ - 1;
-                while ( num_blocks_-- )
-                {
-                    delete [] *vertexs;
-                    --vertexs;
-                }
-                delete [] vertexs_;
-            }
-        }
-        unsigned size() const 
-        {
-            return pos_;
-        }
-	
-        void push_back (value_type x,value_type y,unsigned command)
-        {
-            unsigned block = pos_ &gt;&gt; block_shift;
-            if (block &gt;= num_blocks_)
-            {
-                allocate_block(block);
-            }
-            value_type* vertex = vertexs_[block] + ((pos_ &amp; block_mask) &lt;&lt; 1);
-            unsigned char* cmd= commands_[block] + (pos_ &amp; block_mask);
-	    
-            *cmd = static_cast&lt;unsigned char&gt;(command);
-            *vertex++ = x;
-            *vertex   = y;
-            ++pos_;
-        }
-        unsigned get_vertex(unsigned pos,value_type* x,value_type* y) const
-        {
-            if (pos &gt;= pos_) return SEG_END;
-            unsigned block = pos &gt;&gt; block_shift;
-            const value_type* vertex = vertexs_[block] + (( pos &amp; block_mask) &lt;&lt; 1);
-            *x = (*vertex++);
-            *y = (*vertex);
-            return commands_[block] [pos &amp; block_mask];
-        }
-        	
-        void transform_at(unsigned pos,const CoordTransform&amp; t)
-        {
-            if (pos &gt;= pos_) return;
-            unsigned block = pos &gt;&gt; block_shift;
-            value_type* vertex = vertexs_[block] + (( pos &amp; block_mask) &lt;&lt; 1);
-            t.forward_x(vertex);
-            ++vertex;
-            t.forward_y(vertex);
-        }
-        void set_capacity(size_t)
-        {
-            //do nothing
-        }
-    private:
-        void allocate_block(unsigned block)
-        {
-            if (block &gt;= max_blocks_)
-            {
-                value_type** new_vertexs = new value_type* [(max_blocks_ + grow_by) * 2];
-                unsigned char** new_commands = (unsigned char**)(new_vertexs + max_blocks_ + grow_by);
-                if (vertexs_)
-                {
-                    std::memcpy(new_vertexs,vertexs_,max_blocks_ * sizeof(value_type*));
-                    std::memcpy(new_commands,commands_,max_blocks_ * sizeof(unsigned char*));
-                    delete [] vertexs_;
-                }
-                vertexs_ = new_vertexs;
-                commands_ = new_commands;
-                max_blocks_ += grow_by;
-            }
-            vertexs_[block] = new value_type [block_size * 2 + block_size / (sizeof(value_type))];
-            commands_[block] = (unsigned char*)(vertexs_[block] + block_size*2);
-            ++num_blocks_;
-        }
-    };
-
-    template &lt;typename T&gt;
-    struct vertex_vector2 : boost::noncopyable
-    {
-        typedef typename T::type value_type;
-        typedef boost::tuple&lt;value_type,value_type,char&gt; vertex_type;
-        typedef typename std::vector&lt;vertex_type&gt;::const_iterator const_iterator;
-        vertex_vector2() {}
-        unsigned size() const 
-        {
-            return cont_.size();
-        }
-
-        void push_back (value_type x,value_type y,unsigned command)
-        {
-            cont_.push_back(vertex_type(x,y,command));
-        }
-        unsigned get_vertex(unsigned pos,value_type* x,value_type* y) const
-        {
-            if (pos &gt;= cont_.size()) return SEG_END;
-            vertex_type const&amp; c = cont_[pos];
-            *x = boost::get&lt;0&gt;(c);
-            *y = boost::get&lt;1&gt;(c);
-            return boost::get&lt;2&gt;(c);
-        }
-        
-        const_iterator begin() const
-        {
-            return cont_.begin();
-        }
-        
-        const_iterator end() const
-        {
-            return cont_.end();
-        }
-
-        void transform_at(unsigned pos,const CoordTransform&amp; t)
-        {
-            if (pos &gt;= cont_.size()) return;
-            vertex_type &amp; c = cont_[pos];
-            t.forward_x(&amp;boost::get&lt;0&gt;(c));
-            t.forward_y(&amp;boost::get&lt;1&gt;(c));
-        }
-        void set_capacity(size_t size)
-        {
-            cont_.reserve(size);
-        }
-    private:
-        std::vector&lt;vertex_type&gt; cont_;
-    };
-}
-
-#endif //VERTEX_VECTOR_HPP

Deleted: trunk/include/wkb.hpp
===================================================================
--- trunk/include/wkb.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/include/wkb.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -1,43 +0,0 @@
-/*****************************************************************************
- * 
- * This file is part of Mapnik (c++ mapping toolkit)
- *
- * Copyright (C) 2006 Artem Pavlenko
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
-
-//$Id: wkb.hpp 39 2005-04-10 20:39:53Z pavlenko $
-
-#ifndef WKB_HPP
-#define WKB_HPP
-
-#include &quot;geometry.hpp&quot;
-#include &quot;ctrans.hpp&quot;
-
-namespace mapnik
-{
-    class MAPNIK_DECL geometry_utils 
-    {
-    public:
-	static geometry_ptr from_wkb(const char* wkb, unsigned size,int srid);
-    private:
-	geometry_utils();
-	geometry_utils(const geometry_utils&amp;);
-	geometry_utils&amp; operator=(const geometry_utils&amp;);
-    };
-}
-#endif                                            //WKB_HPP

Modified: trunk/plugins/input/postgis/SConscript
===================================================================
--- trunk/plugins/input/postgis/SConscript	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/postgis/SConscript	2006-10-04 11:22:18 UTC (rev 313)
@@ -32,5 +32,5 @@
 
 postgis_inputdriver = env.SharedLibrary('postgis', source=postgis_src, SHLIBPREFIX='', LIBS='pq')
 
-env.Install(prefix + '/' + env['LIB_PLATFORM'] + '/mapnik/input', postgis_inputdriver)
-env.Alias('install', prefix + '/' + env['LIB_PLATFORM'] + '/mapnik/input')
+env.Install(prefix + '/' + env['LIBDIR_SCHEMA'] + '/mapnik/input', postgis_inputdriver)
+env.Alias('install', prefix + '/' + env['LIBDIR_SCHEMA'] + '/mapnik/input')

Modified: trunk/plugins/input/raster/SConscript
===================================================================
--- trunk/plugins/input/raster/SConscript	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/raster/SConscript	2006-10-04 11:22:18 UTC (rev 313)
@@ -33,5 +33,5 @@
 
 raster_inputdriver = env.SharedLibrary('raster', source=raster_src, SHLIBPREFIX='', LIBS=[])
 
-env.Install(prefix + '/' + env['LIB_PLATFORM'] + '/mapnik/input', raster_inputdriver)
-env.Alias('install', prefix + '/' + env['LIB_PLATFORM'] + '/mapnik/input')
+env.Install(prefix + '/' + env['LIBDIR_SCHEMA'] + '/mapnik/input', raster_inputdriver)
+env.Alias('install', prefix + '/' + env['LIBDIR_SCHEMA'] + '/mapnik/input')

Modified: trunk/plugins/input/raster/raster_datasource.cpp
===================================================================
--- trunk/plugins/input/raster/raster_datasource.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/raster/raster_datasource.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -20,13 +20,16 @@
  *
  *****************************************************************************/
 //$Id: raster_datasource.cc 44 2005-04-22 18:53:54Z pavlenko $
+// boost
+#include &lt;boost/lexical_cast.hpp&gt;
+// mapnik
+#include &lt;mapnik/image_reader.hpp&gt;
 
-#include &quot;raster_datasource.hpp&quot;
-#include &quot;image_reader.hpp&quot;
 #include &quot;raster_featureset.hpp&quot;
 #include &quot;raster_info.hpp&quot;
-#include &lt;boost/lexical_cast.hpp&gt;
 
+#include &quot;raster_datasource.hpp&quot;
+
 DATASOURCE_PLUGIN(raster_datasource)
 
 using std::clog;

Modified: trunk/plugins/input/raster/raster_datasource.hpp
===================================================================
--- trunk/plugins/input/raster/raster_datasource.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/raster/raster_datasource.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -24,10 +24,9 @@
 #ifndef RASTER_DATASOURCE_HH
 #define RASTER_DATASOURCE_HH 
 
-#include &quot;datasource.hpp&quot;
-#include &quot;envelope.hpp&quot;
-#include &quot;feature.hpp&quot;
-#include &quot;image_reader.hpp&quot;
+#include &lt;mapnik/envelope.hpp&gt;
+#include &lt;mapnik/feature.hpp&gt;
+#include &lt;mapnik/datasource.hpp&gt;
 
 using namespace mapnik;
 

Modified: trunk/plugins/input/raster/raster_featureset.cpp
===================================================================
--- trunk/plugins/input/raster/raster_featureset.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/raster/raster_featureset.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -19,9 +19,11 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
  *****************************************************************************/
+// mapnik
+#include &lt;mapnik/image_reader.hpp&gt;
+#include &lt;mapnik/image_util.hpp&gt;
+
 #include &quot;raster_featureset.hpp&quot;
-#include &quot;image_reader.hpp&quot;
-#include &quot;image_util.hpp&quot;
 
 template &lt;typename LookupPolicy&gt;
 raster_featureset&lt;LookupPolicy&gt;::raster_featureset(LookupPolicy const&amp; policy,

Modified: trunk/plugins/input/raster/raster_featureset.hpp
===================================================================
--- trunk/plugins/input/raster/raster_featureset.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/raster/raster_featureset.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,9 +22,10 @@
 #ifndef RASTER_FEATURESET_HH
 #define RASTER_FEATURESET_HH
 
+#include &lt;vector&gt;
+
 #include &quot;raster_datasource.hpp&quot;
 #include &quot;raster_info.hpp&quot;
-#include &lt;vector&gt;
 
 using std::vector;
 

Modified: trunk/plugins/input/shape/SConscript
===================================================================
--- trunk/plugins/input/shape/SConscript	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/shape/SConscript	2006-10-04 11:22:18 UTC (rev 313)
@@ -38,5 +38,5 @@
 
 shape_inputdriver = env.SharedLibrary('shape', source=shape_src, SHLIBPREFIX='', LIBS=[])
 
-env.Install(prefix + '/' + env['LIB_PLATFORM'] + '/mapnik/input', shape_inputdriver)
-env.Alias('install', prefix + '/' + env['LIB_PLATFORM'] + '/mapnik/input')
+env.Install(prefix + '/' + env['LIBDIR_SCHEMA'] + '/mapnik/input', shape_inputdriver)
+env.Alias('install', prefix + '/' + env['LIBDIR_SCHEMA'] + '/mapnik/input')

Modified: trunk/plugins/input/shape/dbffile.cpp
===================================================================
--- trunk/plugins/input/shape/dbffile.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/shape/dbffile.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -19,13 +19,16 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
  *****************************************************************************/
-
-#include &quot;dbffile.hpp&quot;
-#include &quot;utils.hpp&quot;
+// stl
+#include &lt;string&gt;
+// boost
 #include &lt;boost/algorithm/string.hpp&gt;
 #include &lt;boost/lexical_cast.hpp&gt;
-#include &lt;string&gt;
+// mapnik
+#include &lt;mapnik/utils.hpp&gt;
 
+#include &quot;dbffile.hpp&quot;
+
 dbf_file::dbf_file()
     : num_records_(0),
       num_fields_(0),

Modified: trunk/plugins/input/shape/dbffile.hpp
===================================================================
--- trunk/plugins/input/shape/dbffile.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/shape/dbffile.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -20,15 +20,15 @@
  *
  *****************************************************************************/
 
-#ifndef DBFFILE_HH
-#define DBFFILE_HH
+#ifndef DBFFILE_HPP
+#define DBFFILE_HPP
 
 #include &lt;vector&gt;
 #include &lt;string&gt;
 #include &lt;fstream&gt;
 #include &lt;cassert&gt;
 
-#include &quot;feature.hpp&quot;
+#include &lt;mapnik/feature.hpp&gt;
 
 using namespace mapnik;
 
@@ -44,34 +44,35 @@
 
 class dbf_file
 {
-    private:
+private:
 
-        int num_records_;
-        int num_fields_;
-        int record_length_;
-        std::vector&lt;field_descriptor&gt; fields_;
-        std::ifstream file_;
-        char* record_;
-    public:
-        dbf_file();
-        dbf_file(const char* file_name);
-        dbf_file(const std::string&amp; file_name);
-        ~dbf_file();
-        bool open(const std::string&amp; file_name);
-        bool is_open();
-        void close();
-        int num_records() const;
-        int num_fields() const;
-        field_descriptor const&amp; descriptor(int col) const;
-        void move_to(int index);
-        std::string string_value(int col) const;
-        void add_attribute(int col,Feature const&amp; f) const throw();
-    private:
-        dbf_file(const dbf_file&amp;);
-        dbf_file&amp; operator=(const dbf_file&amp;);
-        void read_header();
-        int read_short();
-        int read_int();
-        void skip(int bytes);
+    int num_records_;
+    int num_fields_;
+    int record_length_;
+    std::vector&lt;field_descriptor&gt; fields_;
+    std::ifstream file_;
+    char* record_;
+public:
+    dbf_file();
+    dbf_file(const char* file_name);
+    dbf_file(const std::string&amp; file_name);
+    ~dbf_file();
+    bool open(const std::string&amp; file_name);
+    bool is_open();
+    void close();
+    int num_records() const;
+    int num_fields() const;
+    field_descriptor const&amp; descriptor(int col) const;
+    void move_to(int index);
+    std::string string_value(int col) const;
+    void add_attribute(int col,Feature const&amp; f) const throw();
+private:
+    dbf_file(const dbf_file&amp;);
+    dbf_file&amp; operator=(const dbf_file&amp;);
+    void read_header();
+    int read_short();
+    int read_int();
+    void skip(int bytes);
 };
-#endif                                            //DBFFILE_HH
+
+#endif //DBFFILE_HPP

Modified: trunk/plugins/input/shape/shape.cpp
===================================================================
--- trunk/plugins/input/shape/shape.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/shape/shape.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -20,13 +20,17 @@
  *
  *****************************************************************************/
 
-#include &quot;shape.hpp&quot;
+#include &lt;iostream&gt;
+#include &lt;fstream&gt;
+#include &lt;stdexcept&gt;
+
+#include &lt;mapnik/geom_util.hpp&gt;
+
+
 #include &quot;shape_featureset.hpp&quot;
 #include &quot;shape_index_featureset.hpp&quot;
-#include &quot;geom_util.hpp&quot;
 
-#include &lt;iostream&gt;
-#include &lt;stdexcept&gt;
+#include &quot;shape.hpp&quot;
 
 DATASOURCE_PLUGIN(shape_datasource)
 

Modified: trunk/plugins/input/shape/shape.hpp
===================================================================
--- trunk/plugins/input/shape/shape.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/shape/shape.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -20,11 +20,14 @@
  *
  *****************************************************************************/
 
-#ifndef SHAPE_HH
-#define SHAPE_HH
+// $Id$
 
-#include &quot;datasource.hpp&quot;
-#include &quot;envelope.hpp&quot;
+#ifndef SHAPE_HPP
+#define SHAPE_HPP
+
+#include &lt;mapnik/datasource.hpp&gt;
+#include &lt;mapnik/envelope.hpp&gt;
+
 #include &quot;shape_io.hpp&quot;
 
 using namespace mapnik;
@@ -54,4 +57,4 @@
     static std::string name_;
 };
 
-#endif //SHAPE_HH
+#endif //SHAPE_HPP

Modified: trunk/plugins/input/shape/shape_featureset.cpp
===================================================================
--- trunk/plugins/input/shape/shape_featureset.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/shape/shape_featureset.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -20,8 +20,8 @@
  *
  *****************************************************************************/
 
+#include &lt;iostream&gt;
 #include &quot;shape_featureset.hpp&quot;
-#include &lt;iostream&gt;
 
 template &lt;typename filterT&gt;
 shape_featureset&lt;filterT&gt;::shape_featureset(const filterT&amp; filter, 

Modified: trunk/plugins/input/shape/shape_featureset.hpp
===================================================================
--- trunk/plugins/input/shape/shape_featureset.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/shape/shape_featureset.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -23,8 +23,8 @@
 #ifndef SHAPE_FS_HH
 #define SHAPE_FS_HH
 
+#include &lt;mapnik/geom_util.hpp&gt;
 #include &quot;shape.hpp&quot;
-#include &quot;geom_util.hpp&quot;
 
 using namespace mapnik;
 
@@ -42,7 +42,7 @@
     mutable int count_;
 public:
     shape_featureset(const filterT&amp; filter, const std::string&amp; shape_file,
-		     const std::set&lt;std::string&gt;&amp; attribute_names,long file_length);
+                     const std::set&lt;std::string&gt;&amp; attribute_names,long file_length);
     virtual ~shape_featureset();
     feature_ptr next();
 private:

Modified: trunk/plugins/input/shape/shape_index_featureset.cpp
===================================================================
--- trunk/plugins/input/shape/shape_index_featureset.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/shape/shape_index_featureset.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,8 +22,8 @@
 
 //$Id: shape_index_featureset.cc 36 2005-04-05 14:32:18Z pavlenko $
 
+#include &lt;mapnik/feature_factory.hpp&gt;
 #include &quot;shape_index_featureset.hpp&quot;
-#include &quot;feature_factory.hpp&quot;
 
 template &lt;typename filterT&gt;
 shape_index_featureset&lt;filterT&gt;::shape_index_featureset(const filterT&amp; filter,

Modified: trunk/plugins/input/shape/shape_index_featureset.hpp
===================================================================
--- trunk/plugins/input/shape/shape_index_featureset.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/shape/shape_index_featureset.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -20,13 +20,14 @@
  *
  *****************************************************************************/
 
-#ifndef SHAPE_SQT_FS_HH
-#define SHAPE_SQT_FS_HH
+#ifndef SHAPE_INDEX_FEATURESET_HPP
+#define SHAPE_INDEX_FEATURESET_HPP
 
-#include &quot;shape_featureset.hpp&quot;
 #include &lt;set&gt;
 #include &lt;vector&gt;
 
+#include &quot;shape_featureset.hpp&quot;
+
 template &lt;typename filterT&gt;
 class MAPNIK_DECL shape_index_featureset : public Featureset
 {
@@ -42,7 +43,7 @@
 
 public:
     shape_index_featureset(const filterT&amp; filter,const std::string&amp; shape_file,
-			   const std::set&lt;std::string&gt;&amp; attribute_names);
+                           const std::set&lt;std::string&gt;&amp; attribute_names);
     virtual ~shape_index_featureset();
     feature_ptr next();
 private:
@@ -50,4 +51,5 @@
     shape_index_featureset(const shape_index_featureset&amp;);
     shape_index_featureset&amp; operator=(const shape_index_featureset&amp;);
 };
-#endif //SHAPE_SQT_FS_HH
+
+#endif //SHAPE_INDEX_FEATURESET_HPP

Modified: trunk/plugins/input/shape/shapefile.cpp
===================================================================
--- trunk/plugins/input/shape/shapefile.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/shape/shapefile.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -24,7 +24,6 @@
 
 shape_file::shape_file() {}
 
-
 shape_file::shape_file(const std::string&amp; file_name)
 {
     //file_.rdbuf()-&gt;pubsetbuf(buff_,buffer_size);

Modified: trunk/plugins/input/shape/shapefile.hpp
===================================================================
--- trunk/plugins/input/shape/shapefile.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/shape/shapefile.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,12 +22,12 @@
 
 //$Id: shapefile.hh 33 2005-04-04 13:01:03Z pavlenko $
 
-#ifndef SHAPEFILE_HH
-#define SHAPEFILE_HH
+#ifndef SHAPEFILE_HPP
+#define SHAPEFILE_HPP
 
 #include &lt;fstream&gt;
 
-#include &quot;envelope.hpp&quot;
+#include &lt;mapnik/envelope.hpp&gt;
 
 using namespace mapnik;
 
@@ -37,64 +37,66 @@
     size_t size;
     size_t pos;
     explicit shape_record(size_t size)
-	: data(static_cast&lt;char*&gt;(::operator new(sizeof(char)*size))),
-	  size(size),
-	  pos(0) {}
+        : data(static_cast&lt;char*&gt;(::operator new(sizeof(char)*size))),
+          size(size),
+          pos(0) {}
     
     char* rawdata()
     {
-	return &amp;data[0]; 
+        return &amp;data[0]; 
     }
+
     void skip(unsigned n)
     {
-	pos+=n;
+        pos+=n;
     }
+
     int read_ndr_integer()
     {
-	int val=(data[pos] &amp; 0xff)     | 
-	    (data[pos+1] &amp; 0xff) &lt;&lt; 8  |
-	    (data[pos+2] &amp; 0xff) &lt;&lt; 16 |
-	    (data[pos+3] &amp; 0xff) &lt;&lt; 24;
-	pos+=4;
-	return val;
+        int val=(data[pos] &amp; 0xff)     | 
+            (data[pos+1] &amp; 0xff) &lt;&lt; 8  |
+            (data[pos+2] &amp; 0xff) &lt;&lt; 16 |
+            (data[pos+3] &amp; 0xff) &lt;&lt; 24;
+        pos+=4;
+        return val;
     }
     
     int read_xdr_integer()
     {
-	int val=(data[pos] &amp; 0xff) &lt;&lt; 24 | 
-	    (data[pos+1] &amp; 0xff)   &lt;&lt; 16   |
-	    (data[pos+2] &amp; 0xff)   &lt;&lt; 8    |
-	    (data[pos+3] &amp; 0xff);
-	pos+=4;
-	return val;
+        int val=(data[pos] &amp; 0xff) &lt;&lt; 24 | 
+            (data[pos+1] &amp; 0xff)   &lt;&lt; 16   |
+            (data[pos+2] &amp; 0xff)   &lt;&lt; 8    |
+            (data[pos+3] &amp; 0xff);
+        pos+=4;
+        return val;
     }
     
     double read_double()
     {
-	double val;		
+        double val;		
 #ifndef WORDS_BIGENDIAN
-	std::memcpy(&amp;val,&amp;data[pos],8);	
+        std::memcpy(&amp;val,&amp;data[pos],8);	
 #else
        	long long bits = ((long long)data[pos] &amp; 0xff) | 
-	    ((long long)data[pos+1] &amp; 0xff) &lt;&lt; 8   |
-	    ((long long)data[pos+2] &amp; 0xff) &lt;&lt; 16  |
-	    ((long long)data[pos+3] &amp; 0xff) &lt;&lt; 24  |
-	    ((long long)data[pos+4] &amp; 0xff) &lt;&lt; 32  |
-	    ((long long)data[pos+5] &amp; 0xff) &lt;&lt; 40  |
-	    ((long long)data[pos+6] &amp; 0xff) &lt;&lt; 48  |
-	    ((long long)data[pos+7] &amp; 0xff) &lt;&lt; 56  ;
-	std::memcpy(&amp;val,&amp;bits,8);
+            ((long long)data[pos+1] &amp; 0xff) &lt;&lt; 8   |
+            ((long long)data[pos+2] &amp; 0xff) &lt;&lt; 16  |
+            ((long long)data[pos+3] &amp; 0xff) &lt;&lt; 24  |
+            ((long long)data[pos+4] &amp; 0xff) &lt;&lt; 32  |
+            ((long long)data[pos+5] &amp; 0xff) &lt;&lt; 40  |
+            ((long long)data[pos+6] &amp; 0xff) &lt;&lt; 48  |
+            ((long long)data[pos+7] &amp; 0xff) &lt;&lt; 56  ;
+        std::memcpy(&amp;val,&amp;bits,8);
 #endif 
-	pos+=8;
-	return val;
+        pos+=8;
+        return val;
     }
     long remains() 
     {
-	return (size-pos);
+        return (size-pos);
     }
     ~shape_record() 
     {
-	::operator delete(data);
+        ::operator delete(data);
     }	
 };
 
@@ -113,88 +115,87 @@
     
     inline void read_record(shape_record&amp; rec)
     {
-	file_.read(rec.rawdata(),rec.size);  
+        file_.read(rec.rawdata(),rec.size);  
     }
 
     inline int read_xdr_integer()
     {
-	char b[4];
-	file_.read(b, 4);
-	return b[3] &amp; 0xffu | (b[2] &amp; 0xffu) &lt;&lt; 8 |
-	    (b[1] &amp; 0xffu) &lt;&lt; 16 | (b[0] &amp; 0xffu) &lt;&lt; 24;
+        char b[4];
+        file_.read(b, 4);
+        return b[3] &amp; 0xffu | (b[2] &amp; 0xffu) &lt;&lt; 8 |
+            (b[1] &amp; 0xffu) &lt;&lt; 16 | (b[0] &amp; 0xffu) &lt;&lt; 24;
     }
 
     inline int read_ndr_integer()
     {
-	char b[4];
-	file_.read(b,4);
-	return b[0]&amp;0xffu | (b[1]&amp;0xffu) &lt;&lt; 8 | 
-	    (b[2]&amp;0xffu) &lt;&lt; 16 | (b[3]&amp;0xffu) &lt;&lt; 24;
+        char b[4];
+        file_.read(b,4);
+        return b[0]&amp;0xffu | (b[1]&amp;0xffu) &lt;&lt; 8 | 
+            (b[2]&amp;0xffu) &lt;&lt; 16 | (b[3]&amp;0xffu) &lt;&lt; 24;
     }
 
     inline double read_double()
     {
-	double val;
+        double val;
 #ifndef WORDS_BIGENDIAN
-	file_.read(reinterpret_cast&lt;char*&gt;(&amp;val),8);
+        file_.read(reinterpret_cast&lt;char*&gt;(&amp;val),8);
 #else
-	char b[8];
-	file_.read(b,8);
-	long long bits = ((long long)b[0] &amp; 0xff) | 
-	    ((long long)b[1] &amp; 0xff) &lt;&lt; 8   |
-	    ((long long)b[2] &amp; 0xff) &lt;&lt; 16  |
-	    ((long long)b[3] &amp; 0xff) &lt;&lt; 24  |
-	    ((long long)b[4] &amp; 0xff) &lt;&lt; 32  |
-	    ((long long)b[5] &amp; 0xff) &lt;&lt; 40  |
-	    ((long long)b[6] &amp; 0xff) &lt;&lt; 48  |
-	    ((long long)b[7] &amp; 0xff) &lt;&lt; 56  ;
-	memcpy(&amp;val,&amp;bits,8);
+        char b[8];
+        file_.read(b,8);
+        long long bits = ((long long)b[0] &amp; 0xff) | 
+            ((long long)b[1] &amp; 0xff) &lt;&lt; 8   |
+            ((long long)b[2] &amp; 0xff) &lt;&lt; 16  |
+            ((long long)b[3] &amp; 0xff) &lt;&lt; 24  |
+            ((long long)b[4] &amp; 0xff) &lt;&lt; 32  |
+            ((long long)b[5] &amp; 0xff) &lt;&lt; 40  |
+            ((long long)b[6] &amp; 0xff) &lt;&lt; 48  |
+            ((long long)b[7] &amp; 0xff) &lt;&lt; 56  ;
+        memcpy(&amp;val,&amp;bits,8);
 #endif
-	return val;
+        return val;
     }
 
     inline void read_envelope(Envelope&lt;double&gt;&amp; envelope)
     {
 #ifndef WORDS_BIGENDIAN
-	file_.read(reinterpret_cast&lt;char*&gt;(&amp;envelope),sizeof(envelope));
+        file_.read(reinterpret_cast&lt;char*&gt;(&amp;envelope),sizeof(envelope));
 #else
-	double minx=read_double();
-	double miny=read_double();
-	double maxx=read_double();
-	double maxy=read_double();
-	envelope.init(minx,miny,maxx,maxy);
+        double minx=read_double();
+        double miny=read_double();
+        double maxx=read_double();
+        double maxy=read_double();
+        envelope.init(minx,miny,maxx,maxy);
 #endif  
     }
 
     inline void skip(std::streampos bytes)
     {
-	file_.seekg(bytes,std::ios::cur);
+        file_.seekg(bytes,std::ios::cur);
     }
 
     inline void rewind()
     {
-	seek(100);
+        seek(100);
     }
 
     inline void seek(std::streampos pos)
     {
-	file_.seekg(pos,std::ios::beg);
+        file_.seekg(pos,std::ios::beg);
     }
 
-
     inline std::streampos pos()
     {
-	return file_.tellg();
+        return file_.tellg();
     }
 
-
     inline bool is_eof()
     {
-	return file_.eof();
+        return file_.eof();
     }
     
 private:
     shape_file(const shape_file&amp;);
     shape_file&amp; operator=(const shape_file&amp;);
 };
-#endif                                            //SHAPEFILE_HH
+
+#endif //SHAPEFILE_HPP

Modified: trunk/plugins/input/shape/shp_index.cpp
===================================================================
--- trunk/plugins/input/shape/shp_index.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/shape/shp_index.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -19,9 +19,8 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
  *****************************************************************************/
-
+#include &lt;mapnik/geom_util.hpp&gt;
 #include &quot;shp_index.hpp&quot;
-#include &quot;geom_util.hpp&quot;
 
 template &lt;typename filterT&gt;
 void shp_index&lt;filterT&gt;::query(const filterT&amp; filter,std::ifstream&amp; file,std::set&lt;int&gt;&amp; pos)

Modified: trunk/plugins/input/shape/shp_index.hpp
===================================================================
--- trunk/plugins/input/shape/shp_index.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/plugins/input/shape/shp_index.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -23,10 +23,12 @@
 #ifndef SHP_INDEX_HH
 #define SHP_INDEX_HH
 
-#include &quot;envelope.hpp&quot;
-#include &quot;query.hpp&quot;
+// st
 #include &lt;fstream&gt;
 #include &lt;set&gt;
+// mapnik
+#include &lt;mapnik/envelope.hpp&gt;
+#include &lt;mapnik/query.hpp&gt;
 
 using namespace mapnik;
 

Modified: trunk/src/SConscript
===================================================================
--- trunk/src/SConscript	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/SConscript	2006-10-04 11:22:18 UTC (rev 313)
@@ -32,32 +32,33 @@
 
 source = Split(
     &quot;&quot;&quot;
+    agg_renderer.cpp
     datasource_cache.cpp
     envelope.cpp
+    filter_factory.cpp
+    font_engine_freetype.cpp
     graphics.cpp
     image_reader.cpp
     image_util.cpp
     layer.cpp
+    line_pattern_symbolizer.cpp
+    load_map.cpp
     map.cpp
     memory.cpp
     params.cpp
     plugin.cpp
     png_reader.cpp
-    tiff_reader.cpp
-    wkb.cpp
-    agg_renderer.cpp
     point_symbolizer.cpp
     polygon_pattern_symbolizer.cpp
-    line_pattern_symbolizer.cpp
+    save_map.cpp
     text_symbolizer.cpp
-    font_engine_freetype.cpp
-    load_map.cpp
-    save_map.cpp
+    tiff_reader.cpp
+    wkb.cpp
     &quot;&quot;&quot;
     )
 
 mapnik = env.SharedLibrary('mapnik', source, LIBS=libraries, LINKFLAGS=linkflags)
 
-env.Alias(target='install', source=env.Install(prefix + '/' + env['LIB_PLATFORM'], mapnik))
-includes = glob.glob('../include' + '/*.hpp')
+env.Alias(target='install', source=env.Install(prefix + '/' + env['LIBDIR_SCHEMA'], mapnik))
+includes = glob.glob('../include/mapnik' + '/*.hpp')
 env.Alias(target='install', source=env.Install(prefix+'/include/mapnik', includes))

Modified: trunk/src/agg_renderer.cpp
===================================================================
--- trunk/src/agg_renderer.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/agg_renderer.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -21,8 +21,11 @@
  *****************************************************************************/
 //$Id$
 
-#include &quot;agg_renderer.hpp&quot;
-
+// stl
+#include &lt;iostream&gt;
+// boost
+#include &lt;boost/utility.hpp&gt;
+// agg
 #include &quot;agg_basics.h&quot;
 #include &quot;agg_rendering_buffer.h&quot;
 #include &quot;agg_rasterizer_scanline_aa.h&quot;
@@ -52,12 +55,11 @@
 #include &quot;agg_renderer_scanline.h&quot;
 #include &quot;agg_pattern_filters_rgba.h&quot;
 #include &quot;agg_renderer_outline_image.h&quot;
+// mapnik
+#include &lt;mapnik/image_util.hpp&gt;
+#include &lt;mapnik/agg_renderer.hpp&gt;
 
-#include &lt;boost/utility.hpp&gt;
-#include &lt;iostream&gt;
-#include &quot;image_util.hpp&quot;
-
-namespace mapnik
+namespace mapnik 
 {
     class pattern_source : private boost::noncopyable
     {
@@ -76,7 +78,10 @@
         agg::rgba8 pixel(int x, int y) const
         {
             unsigned c = pattern_(x,y);
-            return agg::rgba8(c &amp; 0xff, (c &gt;&gt; 8) &amp; 0xff, (c &gt;&gt; 16) &amp; 0xff,(c &gt;&gt; 24) &amp; 0xff);
+            return agg::rgba8(c &amp; 0xff, 
+                              (c &gt;&gt; 8) &amp; 0xff, 
+                              (c &gt;&gt; 16) &amp; 0xff,
+                              (c &gt;&gt; 24) &amp; 0xff);
         }
     private:
         ImageData32 const&amp; pattern_;
@@ -97,7 +102,8 @@
     template &lt;typename T&gt;
     void agg_renderer&lt;T&gt;::start_map_processing(Map const&amp; map)
     {
-        std::clog &lt;&lt; &quot;start map processing bbox=&quot; &lt;&lt; map.getCurrentExtent() &lt;&lt;  std::endl;
+        std::clog &lt;&lt; &quot;start map processing bbox=&quot; 
+                  &lt;&lt; map.getCurrentExtent() &lt;&lt; &quot;\n&quot;;
     }
 
     template &lt;typename T&gt;
@@ -460,7 +466,6 @@
                 }
             }  
         }
-    }
-    
+    }   
     template class agg_renderer&lt;Image32&gt;;
 }

Modified: trunk/src/datasource_cache.cpp
===================================================================
--- trunk/src/datasource_cache.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/datasource_cache.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -21,13 +21,14 @@
  *****************************************************************************/
 //$Id: datasource_cache.cpp 23 2005-03-22 22:16:34Z pavlenko $
 
-#include &quot;datasource_cache.hpp&quot;
-
+// stl
 #include &lt;algorithm&gt;
 #include &lt;stdexcept&gt;
-
+// boost
 #include &lt;boost/thread/mutex.hpp&gt;
 #include &lt;boost/filesystem/operations.hpp&gt;
+// mapnik
+#include &lt;mapnik/datasource_cache.hpp&gt;
 
 namespace mapnik
 {
@@ -58,7 +59,8 @@
             {
                 if (itr-&gt;second-&gt;handle())
                 {
-                    create_ds* create_datasource = (create_ds*) lt_dlsym(itr-&gt;second-&gt;handle(), &quot;create&quot;);
+                    create_ds* create_datasource = 
+                        (create_ds*) lt_dlsym(itr-&gt;second-&gt;handle(), &quot;create&quot;);
                     if (!create_datasource)
                     {
                         std::clog &lt;&lt; &quot;Cannot load symbols: &quot; &lt;&lt; lt_dlerror() &lt;&lt; std::endl;
@@ -88,7 +90,8 @@
 
     bool datasource_cache::insert(const std::string&amp; type,const lt_dlhandle module)
     {	      
-        return plugins_.insert(make_pair(type,boost::shared_ptr&lt;PluginInfo&gt;(new PluginInfo(type,module)))).second;     
+        return plugins_.insert(make_pair(type,boost::shared_ptr&lt;PluginInfo&gt;
+                                         (new PluginInfo(type,module)))).second;     
     }
 
     void datasource_cache::register_datasources(const std::string&amp; str)
@@ -106,7 +109,8 @@
                     lt_dlhandle module=lt_dlopenext(itr-&gt;string().c_str());
                     if (module)
                     {
-                        datasource_name* ds_name = (datasource_name*) lt_dlsym(module, &quot;datasource_name&quot;);
+                        datasource_name* ds_name = 
+                            (datasource_name*) lt_dlsym(module, &quot;datasource_name&quot;);
                         if (ds_name &amp;&amp; insert(ds_name(),module))
                         {                           
                             std::clog&lt;&lt;&quot;registered datasource : &quot;&lt;&lt;ds_name()&lt;&lt;std::endl;

Modified: trunk/src/envelope.cpp
===================================================================
--- trunk/src/envelope.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/envelope.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -21,34 +21,34 @@
  *****************************************************************************/
 //$Id: envelope.cpp 17 2005-03-08 23:58:43Z pavlenko $
 
-#include &quot;envelope.hpp&quot;
+#include &lt;mapnik/envelope.hpp&gt;
 
 namespace mapnik
 {
     template &lt;typename T&gt;
-        Envelope&lt;T&gt;::Envelope()
+    Envelope&lt;T&gt;::Envelope()
         :minx_(0),miny_(0),maxx_(-1),maxy_(-1) {}
 
     template &lt;typename T&gt;
-        Envelope&lt;T&gt;::Envelope(T minx_,T miny_,T maxx_,T maxy_)
+    Envelope&lt;T&gt;::Envelope(T minx_,T miny_,T maxx_,T maxy_)
     {
         init(minx_,miny_,maxx_,maxy_);
     }
 
     template &lt;typename T&gt;
-        Envelope&lt;T&gt;::Envelope(const coord&lt;T,2&gt; &amp;c0,const coord&lt;T,2&gt; &amp;c1)
+    Envelope&lt;T&gt;::Envelope(const coord&lt;T,2&gt; &amp;c0,const coord&lt;T,2&gt; &amp;c1)
     {
         init(c0.x,c0.y,c1.x,c1.y);
     }
 
     template &lt;typename T&gt;
-        Envelope&lt;T&gt;::Envelope(const Envelope &amp;rhs)
+    Envelope&lt;T&gt;::Envelope(const Envelope &amp;rhs)
     {
         init(rhs.minx_,rhs.miny_,rhs.maxx_,rhs.maxy_);
     }
 
     template &lt;typename T&gt;
-        inline bool Envelope&lt;T&gt;::operator==(const Envelope&lt;T&gt;&amp; other) const
+    inline bool Envelope&lt;T&gt;::operator==(const Envelope&lt;T&gt;&amp; other) const
     {
         return minx_==other.minx_ &amp;&amp;
             miny_==other.miny_ &amp;&amp;
@@ -57,43 +57,43 @@
     }
 
     template &lt;typename T&gt;
-        inline T Envelope&lt;T&gt;::minx() const
+    inline T Envelope&lt;T&gt;::minx() const
     {
         return minx_;
     }
 
     template &lt;typename T&gt;
-        inline T Envelope&lt;T&gt;::maxx() const
+    inline T Envelope&lt;T&gt;::maxx() const
     {
         return maxx_;
     }
 
     template &lt;typename T&gt;
-        inline T Envelope&lt;T&gt;::miny() const
+    inline T Envelope&lt;T&gt;::miny() const
     {
         return miny_;
     }
 
     template &lt;typename T&gt;
-        inline T Envelope&lt;T&gt;::maxy() const
+    inline T Envelope&lt;T&gt;::maxy() const
     {
         return maxy_;
     }
 
     template &lt;typename T&gt;
-        inline T Envelope&lt;T&gt;::width() const
+    inline T Envelope&lt;T&gt;::width() const
     {
         return maxx_-minx_;
     }
 
     template &lt;typename T&gt;
-        inline T Envelope&lt;T&gt;::height() const
+    inline T Envelope&lt;T&gt;::height() const
     {
         return maxy_-miny_;
     }
 
     template &lt;typename T&gt;
-        inline void Envelope&lt;T&gt;::width(T w)
+    inline void Envelope&lt;T&gt;::width(T w)
     {
         T cx=center().x;
         minx_=static_cast&lt;T&gt;(cx-w*0.5);
@@ -101,7 +101,7 @@
     }
 
     template &lt;typename T&gt;
-        inline void Envelope&lt;T&gt;::height(T h)
+    inline void Envelope&lt;T&gt;::height(T h)
     {
         T cy=center().y;
         miny_=static_cast&lt;T&gt;(cy-h*0.5);
@@ -109,20 +109,20 @@
     }
 
     template &lt;typename T&gt;
-        inline coord&lt;T,2&gt; Envelope&lt;T&gt;::center() const
+    inline coord&lt;T,2&gt; Envelope&lt;T&gt;::center() const
     {
         return coord&lt;T,2&gt;(static_cast&lt;T&gt;(0.5*(minx_+maxx_)),
-            static_cast&lt;T&gt;(0.5*(miny_+maxy_)));
+                          static_cast&lt;T&gt;(0.5*(miny_+maxy_)));
     }
 
     template &lt;typename T&gt;
-        inline void Envelope&lt;T&gt;::expand_to_include(const coord&lt;T,2&gt;&amp; c)
+    inline void Envelope&lt;T&gt;::expand_to_include(const coord&lt;T,2&gt;&amp; c)
     {
         expand_to_include(c.x,c.y);
     }
 
     template &lt;typename T&gt;
-        inline void Envelope&lt;T&gt;::expand_to_include(T x,T y)
+    inline void Envelope&lt;T&gt;::expand_to_include(T x,T y)
     {
         if (x&lt;minx_) minx_=x;
         if (x&gt;maxx_) maxx_=x;
@@ -131,7 +131,7 @@
     }
 
     template &lt;typename T&gt;
-        void Envelope&lt;T&gt;::expand_to_include(const Envelope&lt;T&gt; &amp;other)
+    void Envelope&lt;T&gt;::expand_to_include(const Envelope&lt;T&gt; &amp;other)
     {
         if (other.minx_&lt;minx_) minx_=other.minx_;
         if (other.maxx_&gt;maxx_) maxx_=other.maxx_;
@@ -140,19 +140,19 @@
     }
 
     template &lt;typename T&gt;
-        inline bool Envelope&lt;T&gt;::contains(const coord&lt;T,2&gt; &amp;c) const
+    inline bool Envelope&lt;T&gt;::contains(const coord&lt;T,2&gt; &amp;c) const
     {
         return contains(c.x,c.y);
     }
 
     template &lt;typename T&gt;
-        inline bool Envelope&lt;T&gt;::contains(T x,T y) const
+    inline bool Envelope&lt;T&gt;::contains(T x,T y) const
     {
         return x&gt;=minx_ &amp;&amp; x&lt;=maxx_ &amp;&amp; y&gt;=miny_ &amp;&amp; y&lt;=maxy_;
     }
 
     template &lt;typename T&gt;
-        inline bool Envelope&lt;T&gt;::contains(const Envelope&lt;T&gt; &amp;other) const
+    inline bool Envelope&lt;T&gt;::contains(const Envelope&lt;T&gt; &amp;other) const
     {
         return other.minx_&gt;=minx_ &amp;&amp;
             other.maxx_&lt;=maxx_ &amp;&amp;
@@ -161,26 +161,26 @@
     }
 
     template &lt;typename T&gt;
-        inline bool Envelope&lt;T&gt;::intersects(const coord&lt;T,2&gt; &amp;c) const
+    inline bool Envelope&lt;T&gt;::intersects(const coord&lt;T,2&gt; &amp;c) const
     {
         return intersects(c.x,c.y);
     }
 
     template &lt;typename T&gt;
-        bool Envelope&lt;T&gt;::intersects(T x,T y) const
+    bool Envelope&lt;T&gt;::intersects(T x,T y) const
     {
         return !(x&gt;maxx_ || x&lt;minx_ || y&gt;maxy_ || y&lt;miny_);
     }
 
     template &lt;typename T&gt;
-        inline bool Envelope&lt;T&gt;::intersects(const Envelope&lt;T&gt; &amp;other) const
+    inline bool Envelope&lt;T&gt;::intersects(const Envelope&lt;T&gt; &amp;other) const
     {
         return !(other.minx_&gt;maxx_ || other.maxx_&lt;minx_ ||
-            other.miny_&gt;maxy_ || other.maxy_&lt;miny_);
+                 other.miny_&gt;maxy_ || other.maxy_&lt;miny_);
     }
 
     template &lt;typename T&gt;
-        inline Envelope&lt;T&gt; Envelope&lt;T&gt;::intersect(const EnvelopeType&amp; other) const
+    inline Envelope&lt;T&gt; Envelope&lt;T&gt;::intersect(const EnvelopeType&amp; other) const
     {
 
         T x0=std::max(minx_,other.minx_);
@@ -193,7 +193,7 @@
     }
 
     template &lt;typename T&gt;
-        inline void Envelope&lt;T&gt;::re_center(T cx,T cy)
+    inline void Envelope&lt;T&gt;::re_center(T cx,T cy)
     {
         T dx=cx-center().x;
         T dy=cy-center().y;
@@ -204,7 +204,7 @@
     }
 
     template &lt;typename T&gt;
-        inline void Envelope&lt;T&gt;::init(T x0,T y0,T x1,T y1)
+    inline void Envelope&lt;T&gt;::init(T x0,T y0,T x1,T y1)
     {
         if (x0&lt;x1)
         {

Modified: trunk/src/filter_factory.cpp
===================================================================
--- trunk/src/filter_factory.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/filter_factory.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -21,7 +21,7 @@
  *****************************************************************************/
 //$Id$
 
-#include &quot;filter_factory.hpp&quot;
+#include &lt;mapnik/filter_factory.hpp&gt;
 
 namespace mapnik
 {

Modified: trunk/src/font_engine_freetype.cpp
===================================================================
--- trunk/src/font_engine_freetype.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/font_engine_freetype.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -21,7 +21,7 @@
  *****************************************************************************/
 //$Id$
 
-#include &quot;font_engine_freetype.hpp&quot;
+#include &lt;mapnik/font_engine_freetype.hpp&gt;
 
 namespace mapnik
 {

Modified: trunk/src/graphics.cpp
===================================================================
--- trunk/src/graphics.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/graphics.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -21,24 +21,26 @@
  *****************************************************************************/
 //$Id: graphics.cpp 17 2005-03-08 23:58:43Z pavlenko $
 
+// stl
 #include &lt;cassert&gt;
 #include &lt;string.h&gt;
 #include &lt;stack&gt;
 #include &lt;iostream&gt;
-#include &quot;graphics.hpp&quot;
-#include &quot;image_util.hpp&quot;
+// mapnik
+#include &lt;mapnik/graphics.hpp&gt;
+#include &lt;mapnik/image_util.hpp&gt;
 
 namespace mapnik
 {
     Image32::Image32(int width,int height)
         :width_(width),
-        height_(height),
-        data_(width,height) {}
+         height_(height),
+         data_(width,height) {}
 
     Image32::Image32(const Image32&amp; rhs)
         :width_(rhs.width_),
-        height_(rhs.height_),
-        data_(rhs.data_) {}
+         height_(rhs.height_),
+         data_(rhs.data_) {}
 
     Image32::~Image32() {}
 

Modified: trunk/src/image_reader.cpp
===================================================================
--- trunk/src/image_reader.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/image_reader.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -21,10 +21,9 @@
  *****************************************************************************/
 //$Id: image_reader.cpp 17 2005-03-08 23:58:43Z pavlenko $
 
+#include &lt;mapnik/factory.hpp&gt;
+#include &lt;mapnik/image_reader.hpp&gt;
 
-#include &quot;image_reader.hpp&quot;
-#include &quot;factory.hpp&quot;
-
 namespace mapnik
 {  
     typedef factory&lt;ImageReader,std::string, 

Modified: trunk/src/image_util.cpp
===================================================================
--- trunk/src/image_util.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/image_util.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,15 +22,17 @@
 
 //$Id: image_util.cpp 36 2005-04-05 14:32:18Z pavlenko $
 
+// stl
 #include &lt;string&gt;
-#include &quot;graphics.hpp&quot;
-#include &quot;memory.hpp&quot;
-#include &quot;image_util.hpp&quot;
-
+// mapnik
+#include &lt;mapnik/graphics.hpp&gt;
+#include &lt;mapnik/memory.hpp&gt;
+#include &lt;mapnik/image_util.hpp&gt;
+// jpeg png
 extern &quot;C&quot;
 {
-  #include &lt;png.h&gt;
-  #include &lt;jpeglib.h&gt;
+#include &lt;png.h&gt;
+#include &lt;jpeglib.h&gt;
 }
 
 namespace mapnik
@@ -47,7 +49,9 @@
         Object::operator delete(ptr);
     }
     //
-    void ImageUtils::save_to_file(const std::string&amp; filename,const std::string&amp; type,const Image32&amp; image)
+    void ImageUtils::save_to_file(const std::string&amp; filename,
+                                  const std::string&amp; type,
+                                  const Image32&amp; image)
     {
         //all that should go into image_writer factory
         if (type==&quot;png&quot;)
@@ -66,20 +70,20 @@
         if (!fp) return;
         png_voidp mem_ptr=0;
         png_structp png_ptr=png_create_write_struct(PNG_LIBPNG_VER_STRING,
-						    (png_voidp)mem_ptr,0, 0);
+                                                    (png_voidp)mem_ptr,0, 0);
 	
         if (!png_ptr) return;
         png_set_mem_fn(png_ptr,mem_ptr,malloc_fn,free_fn);
 
         // switch on optimization
-	#if defined(PNG_LIBPNG_VER) &amp;&amp; (PNG_LIBPNG_VER &gt;= 10200)
+#if defined(PNG_LIBPNG_VER) &amp;&amp; (PNG_LIBPNG_VER &gt;= 10200)
         png_uint_32 mask, flags;
 
         flags = png_get_asm_flags(png_ptr);
         mask = png_get_asm_flagmask(PNG_SELECT_READ | PNG_SELECT_WRITE);
         png_set_asm_flags(png_ptr, flags | mask);
-	#endif
-	png_set_filter (png_ptr, 0, PNG_FILTER_NONE);
+#endif
+        png_set_filter (png_ptr, 0, PNG_FILTER_NONE);
         png_infop info_ptr = png_create_info_struct(png_ptr);
         if (!info_ptr)
         {
@@ -95,11 +99,11 @@
         }
 
         png_init_io(png_ptr, fp);
-	//png_set_compression_level(png_ptr, Z_BEST_COMPRESSION);
-	//png_set_compression_strategy(png_ptr, Z_FILTERED);
+        //png_set_compression_level(png_ptr, Z_BEST_COMPRESSION);
+        //png_set_compression_strategy(png_ptr, Z_FILTERED);
         png_set_IHDR(png_ptr, info_ptr,image.width(),image.height(),8,
-            PNG_COLOR_TYPE_RGB_ALPHA,PNG_INTERLACE_NONE,
-            PNG_COMPRESSION_TYPE_DEFAULT,PNG_FILTER_TYPE_DEFAULT);
+                     PNG_COLOR_TYPE_RGB_ALPHA,PNG_INTERLACE_NONE,
+                     PNG_COMPRESSION_TYPE_DEFAULT,PNG_FILTER_TYPE_DEFAULT);
         png_write_info(png_ptr, info_ptr);
 
         const ImageData32&amp; imageData=image.data();
@@ -116,43 +120,43 @@
 
     void ImageUtils::save_as_jpeg(const std::string&amp; filename,int quality, const Image32&amp; image)
     {
-	FILE *fp=fopen(filename.c_str(), &quot;wb&quot;);
+        FILE *fp=fopen(filename.c_str(), &quot;wb&quot;);
         if (!fp) return;
-	struct jpeg_compress_struct cinfo;
-	struct jpeg_error_mgr jerr;
+        struct jpeg_compress_struct cinfo;
+        struct jpeg_error_mgr jerr;
 
-	int width=image.width();
-	int height=image.height();
+        int width=image.width();
+        int height=image.height();
 	
-	cinfo.err = jpeg_std_error(&amp;jerr);
-	jpeg_create_compress(&amp;cinfo);
-	jpeg_stdio_dest(&amp;cinfo, fp);
-	cinfo.image_width = width;
-	cinfo.image_height = height;
-	cinfo.input_components = 3;
-	cinfo.in_color_space = JCS_RGB; 
-	jpeg_set_defaults(&amp;cinfo);
-	jpeg_set_quality(&amp;cinfo, quality,1);
-	jpeg_start_compress(&amp;cinfo, 1);
-	JSAMPROW row_pointer[1];
-	JSAMPLE* row=new JSAMPLE[width*3];
-	const ImageData32&amp; imageData=image.data();
-	while (cinfo.next_scanline &lt; cinfo.image_height) 
-	{
-	    const unsigned* imageRow=imageData.getRow(cinfo.next_scanline);
-	    int index=0;
-	    for (int i=0;i&lt;width;++i)
-	    {
-		row[index++]=(imageRow[i])&amp;0xff;
-		row[index++]=(imageRow[i]&gt;&gt;8)&amp;0xff;
-		row[index++]=(imageRow[i]&gt;&gt;16)&amp;0xff;
-	    }
-	    row_pointer[0] = &amp;row[0];
-	    (void) jpeg_write_scanlines(&amp;cinfo, row_pointer, 1);
-	}
-	delete [] row;
-	jpeg_finish_compress(&amp;cinfo);
-	fclose(fp);
-	jpeg_destroy_compress(&amp;cinfo);
+        cinfo.err = jpeg_std_error(&amp;jerr);
+        jpeg_create_compress(&amp;cinfo);
+        jpeg_stdio_dest(&amp;cinfo, fp);
+        cinfo.image_width = width;
+        cinfo.image_height = height;
+        cinfo.input_components = 3;
+        cinfo.in_color_space = JCS_RGB; 
+        jpeg_set_defaults(&amp;cinfo);
+        jpeg_set_quality(&amp;cinfo, quality,1);
+        jpeg_start_compress(&amp;cinfo, 1);
+        JSAMPROW row_pointer[1];
+        JSAMPLE* row=new JSAMPLE[width*3];
+        const ImageData32&amp; imageData=image.data();
+        while (cinfo.next_scanline &lt; cinfo.image_height) 
+        {
+            const unsigned* imageRow=imageData.getRow(cinfo.next_scanline);
+            int index=0;
+            for (int i=0;i&lt;width;++i)
+            {
+                row[index++]=(imageRow[i])&amp;0xff;
+                row[index++]=(imageRow[i]&gt;&gt;8)&amp;0xff;
+                row[index++]=(imageRow[i]&gt;&gt;16)&amp;0xff;
+            }
+            row_pointer[0] = &amp;row[0];
+            (void) jpeg_write_scanlines(&amp;cinfo, row_pointer, 1);
+        }
+        delete [] row;
+        jpeg_finish_compress(&amp;cinfo);
+        fclose(fp);
+        jpeg_destroy_compress(&amp;cinfo);
     }
 }

Modified: trunk/src/layer.cpp
===================================================================
--- trunk/src/layer.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/layer.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,18 +22,22 @@
 
 //$Id: layer.cpp 17 2005-03-08 23:58:43Z pavlenko $
 
-
-#include &quot;style.hpp&quot;
-#include &quot;datasource.hpp&quot;
-#include &quot;datasource_cache.hpp&quot;
-#include &quot;layer.hpp&quot;
-
+// stl
 #include &lt;string&gt;
 #include &lt;iostream&gt;
+// boost
+#include &lt;boost/shared_ptr.hpp&gt;
+// mapnik
+#include &lt;mapnik/style.hpp&gt;
+#include &lt;mapnik/datasource.hpp&gt;
+#include &lt;mapnik/datasource_cache.hpp&gt;
+#include &lt;mapnik/layer.hpp&gt;
 
+using namespace std;
+using boost::shared_ptr;
+
 namespace mapnik
-{
-    using namespace std;
+{   
     Layer::Layer(std::string const&amp; name)
         : name_(name),
           title_(&quot;&quot;),
@@ -42,8 +46,8 @@
           maxZoom_(std::numeric_limits&lt;double&gt;::max()),
           active_(true),
           selectable_(false),
-          selection_style_(&quot;default_selection&quot;)
-    {}
+          selection_style_(&quot;default_selection&quot;),
+          ds_() {}
     
     Layer::Layer(const Layer&amp; rhs)
         : name_(rhs.name_),
@@ -54,8 +58,8 @@
           active_(rhs.active_),
           selectable_(rhs.selectable_),
           styles_(rhs.styles_),
-          ds_(rhs.ds_),
-          selection_style_(rhs.selection_style_) {}
+          selection_style_(rhs.selection_style_),
+          ds_(rhs.ds_) {}
     
     Layer&amp; Layer::operator=(const Layer&amp; rhs)
     {
@@ -79,8 +83,8 @@
         active_=rhs.active_;
         selectable_=rhs.selectable_;
         styles_=rhs.styles_;
+        selection_style_=rhs.selection_style_;
         ds_=rhs.ds_;
-        selection_style_=rhs.selection_style_;
     }
     
     Layer::~Layer() {}

Modified: trunk/src/line_pattern_symbolizer.cpp
===================================================================
--- trunk/src/line_pattern_symbolizer.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/line_pattern_symbolizer.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -21,36 +21,37 @@
  *****************************************************************************/
 
 //$Id$
+// stl
+#include &lt;iostream&gt;
+// mapnik
+#include &lt;mapnik/image_reader.hpp&gt;
+#include &lt;mapnik/line_pattern_symbolizer.hpp&gt;
 
-#include &quot;line_pattern_symbolizer.hpp&quot;
-#include &quot;image_reader.hpp&quot;
-
-
 namespace mapnik
 {
     
     line_pattern_symbolizer::line_pattern_symbolizer(std::string const&amp; file,
-			    std::string const&amp; type,
-			    unsigned width,unsigned height) 
-	: pattern_(new ImageData32(width,height))
+                                                     std::string const&amp; type,
+                                                     unsigned width,unsigned height) 
+        : pattern_(new ImageData32(width,height))
     {
-	try 
-	{
-	    std::auto_ptr&lt;ImageReader&gt; reader(get_image_reader(type,file));
-	    if (reader.get())
-		reader-&gt;read(0,0,*pattern_);		
-	} 
-	catch (...) 
-	{
-	    std::clog &lt;&lt; &quot;exception caught...&quot; &lt;&lt; std::endl;
-	}
+        try 
+        {
+            std::auto_ptr&lt;ImageReader&gt; reader(get_image_reader(type,file));
+            if (reader.get())
+                reader-&gt;read(0,0,*pattern_);		
+        } 
+        catch (...) 
+        {
+            std::clog &lt;&lt; &quot;exception caught...&quot; &lt;&lt; std::endl;
+        }
     }
 
     line_pattern_symbolizer::line_pattern_symbolizer(line_pattern_symbolizer const&amp; rhs)
-	: pattern_(rhs.pattern_) {}
+        : pattern_(rhs.pattern_) {}
 
     ImageData32 const&amp; line_pattern_symbolizer::get_pattern() const
     {
-	return *pattern_;
+        return *pattern_;
     }
 }

Modified: trunk/src/load_map.cpp
===================================================================
--- trunk/src/load_map.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/load_map.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -19,9 +19,9 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
  *****************************************************************************/
-
+// stl
 #include &lt;iostream&gt;
-
+// boost
 #include &lt;boost/foreach.hpp&gt;
 #include &lt;boost/optional.hpp&gt;
 #include &lt;boost/algorithm/string.hpp&gt;
@@ -29,14 +29,19 @@
 #include &lt;boost/tokenizer.hpp&gt;
 #include &lt;boost/property_tree/ptree.hpp&gt;
 #include &lt;boost/property_tree/xml_parser.hpp&gt;
+// mapnik
+#include &lt;mapnik/color.hpp&gt;
+#include &lt;mapnik/color_factory.hpp&gt;
+#include &lt;mapnik/filter_factory.hpp&gt;
+#include &lt;mapnik/layer.hpp&gt;
+#include &lt;mapnik/datasource_cache.hpp&gt;
 
-#include &quot;color.hpp&quot;
-#include &quot;color_factory.hpp&quot;
-#include &quot;filter_factory.hpp&quot;
-#include &quot;layer.hpp&quot;
-#include &quot;datasource_cache.hpp&quot;
-#include &quot;load_map.hpp&quot;
+#include &lt;mapnik/load_map.hpp&gt;
 
+using boost::lexical_cast;
+using boost::bad_lexical_cast;
+using boost::tokenizer;
+
 namespace mapnik 
 {
     void load_map(Map &amp; map, std::string const&amp; filename)

Modified: trunk/src/map.cpp
===================================================================
--- trunk/src/map.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/map.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -20,12 +20,12 @@
  *
  *****************************************************************************/
 
-//$Id: map.cpp 17 2005-03-08 23:58:43Z pavlenko $
+//$Id: map.cpp 17 2005-03-08 23:58:43Z pavlenko $,
 
-#include &quot;style.hpp&quot;
-#include &quot;datasource.hpp&quot;
-#include &quot;layer.hpp&quot;
-#include &quot;map.hpp&quot;
+#include &lt;mapnik/style.hpp&gt;
+#include &lt;mapnik/datasource.hpp&gt;
+#include &lt;mapnik/layer.hpp&gt;
+#include &lt;mapnik/map.hpp&gt;
 
 namespace mapnik
 {

Modified: trunk/src/memory.cpp
===================================================================
--- trunk/src/memory.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/memory.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,11 +22,8 @@
 
 //$Id: memory.cpp 17 2005-03-08 23:58:43Z pavlenko $
 
-#include &quot;memory.hpp&quot;
+#include &lt;mapnik/memory.hpp&gt;
 
-//#define GC_THREADS
-//#include &quot;gc.h&quot;
-
 namespace mapnik
 {
     void* Object::operator new(size_t size)

Modified: trunk/src/params.cpp
===================================================================
--- trunk/src/params.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/params.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,7 +22,7 @@
 
 //$Id: params.cpp 17 2005-03-08 23:58:43Z pavlenko $
 
-#include &quot;params.hpp&quot;
+#include &lt;mapnik/params.hpp&gt;
 
 namespace mapnik
 {

Modified: trunk/src/plugin.cpp
===================================================================
--- trunk/src/plugin.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/plugin.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,7 +22,7 @@
 
 //$Id: plugin.cpp 17 2005-03-08 23:58:43Z pavlenko $
 
-#include &quot;plugin.hpp&quot;
+#include &lt;mapnik/plugin.hpp&gt;
 
 namespace mapnik
 {

Modified: trunk/src/png_reader.cpp
===================================================================
--- trunk/src/png_reader.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/png_reader.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,13 +22,12 @@
 
 //$Id: png_reader.cpp 33 2005-04-04 13:01:03Z pavlenko $
 
-
 #include &lt;iostream&gt;
-#include &quot;image_reader.hpp&quot;
+#include &lt;mapnik/image_reader.hpp&gt;
 
 extern &quot;C&quot;
 {
-   #include &lt;png.h&gt;
+#include &lt;png.h&gt;
 }
 
 namespace mapnik
@@ -64,10 +63,10 @@
 
     PngReader::PngReader(const std::string&amp; fileName) 
         : fileName_(fileName),
-	  width_(0),
-	  height_(0),
-	  bit_depth_(0),
-	  color_type_(0)
+          width_(0),
+          height_(0),
+          bit_depth_(0),
+          color_type_(0)
     {
         try 
         {
@@ -87,7 +86,7 @@
     {
         png_size_t check;
         check = (png_size_t)fread(data, (png_size_t)1, length,
-				  (FILE *)png_ptr-&gt;io_ptr);
+                                  (FILE *)png_ptr-&gt;io_ptr);
 
         if (check != length)
         {

Modified: trunk/src/point_symbolizer.cpp
===================================================================
--- trunk/src/point_symbolizer.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/point_symbolizer.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -21,11 +21,14 @@
  *****************************************************************************/
 
 //$Id$
-
+// stl
+#include &lt;iostream&gt;
+// boost
 #include &lt;boost/scoped_ptr.hpp&gt;
-#include &quot;point_symbolizer.hpp&quot;
-#include &quot;image_data.hpp&quot;
-#include &quot;image_reader.hpp&quot;
+// mapnik
+#include &lt;mapnik/point_symbolizer.hpp&gt;
+#include &lt;mapnik/image_data.hpp&gt;
+#include &lt;mapnik/image_reader.hpp&gt;
 
 namespace mapnik
 {

Modified: trunk/src/polygon_pattern_symbolizer.cpp
===================================================================
--- trunk/src/polygon_pattern_symbolizer.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/polygon_pattern_symbolizer.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -19,36 +19,36 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
  *****************************************************************************/
-
 //$Id$
+// stl
+#include &lt;iostream&gt;
+// mapnik
+#include &lt;mapnik/image_reader.hpp&gt;
+#include &lt;mapnik/polygon_pattern_symbolizer.hpp&gt;
 
-#include &quot;polygon_pattern_symbolizer.hpp&quot;
-
-#include &quot;image_reader.hpp&quot;
-
 namespace mapnik
 {
     polygon_pattern_symbolizer::polygon_pattern_symbolizer(std::string const&amp; file,
-							   std::string const&amp; type,
-							   unsigned width,unsigned height) 
-	: pattern_(new ImageData32(width,height))
+                                                           std::string const&amp; type,
+                                                           unsigned width,unsigned height) 
+        : pattern_(new ImageData32(width,height))
     {
-	try 
-	{
-	    std::auto_ptr&lt;ImageReader&gt; reader(get_image_reader(type,file));
-	    if (reader.get())
-		reader-&gt;read(0,0,*pattern_);		
-	} 
-	catch (...) 
-	{
-	    std::clog&lt;&lt;&quot;exception caught...&quot;&lt;&lt;std::endl;
-	}
+        try 
+        {
+            std::auto_ptr&lt;ImageReader&gt; reader(get_image_reader(type,file));
+            if (reader.get())
+                reader-&gt;read(0,0,*pattern_);		
+        } 
+        catch (...) 
+        {
+            std::clog&lt;&lt;&quot;exception caught...&quot;&lt;&lt;std::endl;
+        }
     }
     polygon_pattern_symbolizer::polygon_pattern_symbolizer(polygon_pattern_symbolizer const&amp; rhs)
-	: pattern_(rhs.pattern_) {}
+        : pattern_(rhs.pattern_) {}
     
     ImageData32 const&amp; polygon_pattern_symbolizer::get_pattern() const
     {
-	return *pattern_;
+        return *pattern_;
     }
 }

Modified: trunk/src/save_map.cpp
===================================================================
--- trunk/src/save_map.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/save_map.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -19,25 +19,19 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
  *****************************************************************************/
-
-
+// $Id$
+// stl
 #include &lt;iostream&gt;
-
+// boost
 #include &lt;boost/foreach.hpp&gt;
-//#include &lt;boost/optional.hpp&gt;
 #include &lt;boost/algorithm/string.hpp&gt;
 #include &lt;boost/lexical_cast.hpp&gt;
 #include &lt;boost/tokenizer.hpp&gt;
 #include &lt;boost/property_tree/ptree.hpp&gt;
 #include &lt;boost/property_tree/xml_parser.hpp&gt;
+// mapnik
+#include &lt;mapnik/save_map.hpp&gt;
 
-//#include &quot;color.hpp&quot;
-//#include &quot;color_factory.hpp&quot;
-//#include &quot;filter_factory.hpp&quot;
-//#include &quot;layer.hpp&quot;
-//#include &quot;datasource_cache.hpp&quot;
-#include &quot;save_map.hpp&quot;
-
 namespace mapnik 
 {
     void save_map(Map &amp; map, std::string const&amp; filename)

Modified: trunk/src/text_symbolizer.cpp
===================================================================
--- trunk/src/text_symbolizer.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/text_symbolizer.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,7 +22,7 @@
 
 //$Id$
 
-#include &quot;text_symbolizer.hpp&quot;
+#include &lt;mapnik/text_symbolizer.hpp&gt;
 
 namespace mapnik
 {

Modified: trunk/src/tiff_reader.cpp
===================================================================
--- trunk/src/tiff_reader.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/tiff_reader.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -21,15 +21,16 @@
  *****************************************************************************/
 
 //$Id: tiff_reader.cpp 17 2005-03-08 23:58:43Z pavlenko $
+// stl
+#include &lt;iostream&gt;
+// mapnik
+#include &lt;mapnik/image_reader.hpp&gt;
 
-#include &lt;iostream&gt;
-#include &quot;image_reader.hpp&quot;
 extern &quot;C&quot; 
 {
    #include &lt;tiffio.h&gt;    
 }
 
-
 namespace mapnik 
 {
 

Modified: trunk/src/wkb.cpp
===================================================================
--- trunk/src/wkb.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/src/wkb.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -22,62 +22,62 @@
 
 //$Id: wkb.cpp 19 2005-03-22 13:53:27Z pavlenko $
 
-#include &quot;wkb.hpp&quot;
-#include &quot;geom_util.hpp&quot;
+#include &lt;mapnik/wkb.hpp&gt;
+#include &lt;mapnik/geom_util.hpp&gt;
 
 namespace mapnik
 {
     struct wkb_reader
     {
     private:
-	enum wkbByteOrder {
-	    wkbXDR=0,
-	    wkbNDR=1
-	};
-	const char* wkb_;
-	unsigned size_;
-	int srid_;
-	unsigned pos_;
-	wkbByteOrder byteOrder_;
-	bool needSwap_;
+        enum wkbByteOrder {
+            wkbXDR=0,
+            wkbNDR=1
+        };
+        const char* wkb_;
+        unsigned size_;
+        int srid_;
+        unsigned pos_;
+        wkbByteOrder byteOrder_;
+        bool needSwap_;
     public:
 	
-	enum wkbGeometryType {
-	    wkbPoint=1,
-	    wkbLineString=2,
-	    wkbPolygon=3,
-	    wkbMultiPoint=4,
-	    wkbMultiLineString=5,
-	    wkbMultiPolygon=6,
-	    wkbGeometryCollection=7
-	};
+        enum wkbGeometryType {
+            wkbPoint=1,
+            wkbLineString=2,
+            wkbPolygon=3,
+            wkbMultiPoint=4,
+            wkbMultiLineString=5,
+            wkbMultiPolygon=6,
+            wkbGeometryCollection=7
+        };
 	
-	wkb_reader(const char* wkb,unsigned size,int srid)
-	    : wkb_(wkb),
-	      size_(size),
-	      srid_(srid),
-	      pos_(0),
-	      byteOrder_((wkbByteOrder)wkb_[0])
-	{
-	    ++pos_;
+        wkb_reader(const char* wkb,unsigned size,int srid)
+            : wkb_(wkb),
+              size_(size),
+              srid_(srid),
+              pos_(0),
+              byteOrder_((wkbByteOrder)wkb_[0])
+        {
+            ++pos_;
 	    
 #ifndef WORDS_BIGENDIAN
-	    needSwap_=byteOrder_?wkbXDR:wkbNDR;
+            needSwap_=byteOrder_?wkbXDR:wkbNDR;
 #else
-	    needSwap_=byteOrder_?wkbNDR:wkbXDR;	
+            needSwap_=byteOrder_?wkbNDR:wkbXDR;	
 #endif	    
-	}
+        }
 
-	~wkb_reader() {}
+        ~wkb_reader() {}
 
-	geometry_ptr read() 
-	{
-	    geometry_ptr geom;
-	    int type=read_integer();
-	    switch (type)
-	    {
+        geometry_ptr read() 
+        {
+            geometry_ptr geom;
+            int type=read_integer();
+            switch (type)
+            {
             case wkbPoint:
-		geom = read_point();
+                geom = read_point();
                 break;
             case wkbLineString:
                 geom = read_linestring();
@@ -86,7 +86,7 @@
                 geom = read_polygon();
                 break;
             case wkbMultiPoint:
-		geom = read_multipoint();
+                geom = read_multipoint();
                 break;
             case wkbMultiLineString:
                 geom = read_multilinestring();
@@ -98,193 +98,192 @@
                 break;
             default:
                 break;
-	    }
-	    return geom;
-	}
+            }
+            return geom;
+        }
 	
     private:
-	wkb_reader(const wkb_reader&amp;);
-	wkb_reader&amp; operator=(const wkb_reader&amp;);
+        wkb_reader(const wkb_reader&amp;);
+        wkb_reader&amp; operator=(const wkb_reader&amp;);
 	
-	int read_integer() 
-	{
-	    int n;
+        int read_integer() 
+        {
+            int n;
 
-	    if (!needSwap_)
-	    {
-		memcpy(&amp;n,wkb_+pos_,4);
-	    } 
-	    else 
-	    {
-		const char* b=wkb_+pos_;
-		n = b[3]&amp;0xff | (b[2]&amp;0xff)&lt;&lt;8 | (b[1]&amp;0xff)&lt;&lt;16 | (b[0]&amp;0xff)&lt;&lt;24;
-	    }
-	    pos_+=4;
+            if (!needSwap_)
+            {
+                memcpy(&amp;n,wkb_+pos_,4);
+            } 
+            else 
+            {
+                const char* b=wkb_+pos_;
+                n = b[3]&amp;0xff | (b[2]&amp;0xff)&lt;&lt;8 | (b[1]&amp;0xff)&lt;&lt;16 | (b[0]&amp;0xff)&lt;&lt;24;
+            }
+            pos_+=4;
 
-	    return n;
-	}
+            return n;
+        }
 	
-	double read_double()
-	{
-	    double d;
+        double read_double()
+        {
+            double d;
 
-	    if (!needSwap_)
-	    {
-		memcpy(&amp;d,wkb_+pos_,8);
-	    }
-	    else 
-	    {
-		// we rely on the fact that &quot;long long&quot; is in C standard,
-		// but not in C++ yet
-		// this is not quite portable
-		const char* b= wkb_+pos_;
-		long long n = (long long)b[7]&amp;0xff | 
-		    ((long long)b[6]&amp;0xff)&lt;&lt;8 | 
-		    ((long long)b[5]&amp;0xff)&lt;&lt;16 | 
-		    ((long long)b[4]&amp;0xff)&lt;&lt;24 |
-		    ((long long)b[3]&amp;0xff)&lt;&lt;32 |
-		    ((long long)b[2]&amp;0xff)&lt;&lt;40 |
-		    ((long long)b[1]&amp;0xff)&lt;&lt;48 |
-		    ((long long)b[0]&amp;0xff)&lt;&lt;56;
-		memcpy(&amp;d,&amp;n,8);
-	    }
-	    pos_+=8;
+            if (!needSwap_)
+            {
+                memcpy(&amp;d,wkb_+pos_,8);
+            }
+            else 
+            {
+                // we rely on the fact that &quot;long long&quot; is in C standard,
+                // but not in C++ yet
+                // this is not quite portable
+                const char* b= wkb_+pos_;
+                long long n = (long long)b[7]&amp;0xff | 
+                    ((long long)b[6]&amp;0xff)&lt;&lt;8 | 
+                    ((long long)b[5]&amp;0xff)&lt;&lt;16 | 
+                    ((long long)b[4]&amp;0xff)&lt;&lt;24 |
+                    ((long long)b[3]&amp;0xff)&lt;&lt;32 |
+                    ((long long)b[2]&amp;0xff)&lt;&lt;40 |
+                    ((long long)b[1]&amp;0xff)&lt;&lt;48 |
+                    ((long long)b[0]&amp;0xff)&lt;&lt;56;
+                memcpy(&amp;d,&amp;n,8);
+            }
+            pos_+=8;
 
-	    return d;
-	}
+            return d;
+        }
 	
-	void read_coords(CoordinateArray&amp; ar)
-	{
-	    int size=sizeof(coord&lt;double,2&gt;)*ar.size();
-	    if (!needSwap_)
-	    {
-		std::memcpy(&amp;ar[0],wkb_+pos_,size);
+        void read_coords(CoordinateArray&amp; ar)
+        {
+            int size=sizeof(coord&lt;double,2&gt;)*ar.size();
+            if (!needSwap_)
+            {
+                std::memcpy(&amp;ar[0],wkb_+pos_,size);
 		
-	    }
-	    else 
-	    {
-		for (unsigned i=0;i&lt;ar.size();++i)
-		{
-		    ar[i].x=read_double();
-		    ar[i].y=read_double();
-		}
-	    }
-	    pos_+=size;
-	}
+            }
+            else 
+            {
+                for (unsigned i=0;i&lt;ar.size();++i)
+                {
+                    ar[i].x=read_double();
+                    ar[i].y=read_double();
+                }
+            }
+            pos_+=size;
+        }
 	
-	geometry_ptr read_point()
-	{
-	    geometry_ptr pt(new point&lt;vertex2d&gt;(srid_));
-	    double x = read_double();
-	    double y = read_double();
-	    pt-&gt;move_to(x,y);
-	    return pt;
-	}
+        geometry_ptr read_point()
+        {
+            geometry_ptr pt(new point&lt;vertex2d&gt;(srid_));
+            double x = read_double();
+            double y = read_double();
+            pt-&gt;move_to(x,y);
+            return pt;
+        }
 	
-	geometry_ptr read_multipoint()
-	{
-	    geometry_ptr pt(new point&lt;vertex2d&gt;(srid_));
-	    int num_points = read_integer();
-	    for (int i=0;i&lt;num_points;++i) 
-	    {
-		pos_+=5; 
-		double x = read_double();
-		double y = read_double();
-		pt-&gt;move_to(x,y);
-	    }
-	    return pt; 
-	}
+        geometry_ptr read_multipoint()
+        {
+            geometry_ptr pt(new point&lt;vertex2d&gt;(srid_));
+            int num_points = read_integer();
+            for (int i=0;i&lt;num_points;++i) 
+            {
+                pos_+=5; 
+                double x = read_double();
+                double y = read_double();
+                pt-&gt;move_to(x,y);
+            }
+            return pt; 
+        }
 
-	geometry_ptr read_linestring()
-	{
-	    geometry_ptr line(new line_string&lt;vertex2d&gt;(srid_));
-	    int num_points=read_integer();
-	    CoordinateArray ar(num_points);
-	    read_coords(ar);
-	    line-&gt;set_capacity(num_points);
-	    line-&gt;move_to(ar[0].x,ar[0].y);
-	    for (int i=1;i&lt;num_points;++i)
-	    {
-		line-&gt;line_to(ar[i].x,ar[i].y);
-	    }
-	    return line;
-	}
+        geometry_ptr read_linestring()
+        {
+            geometry_ptr line(new line_string&lt;vertex2d&gt;(srid_));
+            int num_points=read_integer();
+            CoordinateArray ar(num_points);
+            read_coords(ar);
+            line-&gt;set_capacity(num_points);
+            line-&gt;move_to(ar[0].x,ar[0].y);
+            for (int i=1;i&lt;num_points;++i)
+            {
+                line-&gt;line_to(ar[i].x,ar[i].y);
+            }
+            return line;
+        }
 
-	geometry_ptr read_multilinestring()
-	{
-	    geometry_ptr line(new line_string&lt;vertex2d&gt;(srid_));
-	    int num_lines=read_integer();
+        geometry_ptr read_multilinestring()
+        {
+            geometry_ptr line(new line_string&lt;vertex2d&gt;(srid_));
+            int num_lines=read_integer();
 
-	    for (int i=0;i&lt;num_lines;++i)
-	    {
-		pos_+=5;
+            for (int i=0;i&lt;num_lines;++i)
+            {
+                pos_+=5;
 		
-		int num_points=read_integer();
-		CoordinateArray ar(num_points);
-		read_coords(ar);
-		line-&gt;move_to(ar[0].x,ar[0].y);
+                int num_points=read_integer();
+                CoordinateArray ar(num_points);
+                read_coords(ar);
+                line-&gt;move_to(ar[0].x,ar[0].y);
 		
-		for (int i=1;i&lt;num_points;++i)
-		{
-		    line-&gt;line_to(ar[i].x,ar[i].y);
-		}
-	    }
-	    return line;
-	}
+                for (int i=1;i&lt;num_points;++i)
+                {
+                    line-&gt;line_to(ar[i].x,ar[i].y);
+                }
+            }
+            return line;
+        }
 
-	geometry_ptr read_polygon() 
-	{
-	    geometry_ptr poly(new polygon&lt;vertex2d&gt;(srid_));
+        geometry_ptr read_polygon() 
+        {
+            geometry_ptr poly(new polygon&lt;vertex2d&gt;(srid_));
 	    
-	    int num_rings=read_integer();
+            int num_rings=read_integer();
 
-	    for (int i=0;i&lt;num_rings;++i)
-	    {
-		int num_points=read_integer();
-		CoordinateArray ar(num_points);
-		read_coords(ar);
-		poly-&gt;move_to(ar[0].x,ar[0].y);
+            for (int i=0;i&lt;num_rings;++i)
+            {
+                int num_points=read_integer();
+                CoordinateArray ar(num_points);
+                read_coords(ar);
+                poly-&gt;move_to(ar[0].x,ar[0].y);
 
-		for (int j=1;j&lt;num_points;++j)
-		{
-		    poly-&gt;line_to(ar[j].x,ar[j].y);
-		}
-		poly-&gt;line_to(ar[0].x,ar[0].y);
+                for (int j=1;j&lt;num_points;++j)
+                {
+                    poly-&gt;line_to(ar[j].x,ar[j].y);
+                }
+                poly-&gt;line_to(ar[0].x,ar[0].y);
 		
-	    }
-	    return poly;
-	}
+            }
+            return poly;
+        }
 	
-	geometry_ptr read_multipolygon()
-	{
-	    geometry_ptr poly(new polygon&lt;vertex2d&gt;(srid_));
+        geometry_ptr read_multipolygon()
+        {
+            geometry_ptr poly(new polygon&lt;vertex2d&gt;(srid_));
 
-	    int num_polys=read_integer();
-	    for (int i=0;i&lt;num_polys;++i)
-	    {
-		pos_+=5;
-		int num_rings=read_integer();
-		for (int i=0;i&lt;num_rings;++i)
-		{
-		    int num_points=read_integer();
-		    CoordinateArray ar(num_points);
-		    read_coords(ar);
-		    poly-&gt;move_to(ar[0].x,ar[0].y);
-		    for (int j=1;j&lt;num_points;++j)
-		    {
-			poly-&gt;line_to(ar[j].x,ar[j].y);
-		    }
-		    poly-&gt;line_to(ar[0].x,ar[0].y);
-		}
-	    }
-	    return poly;
+            int num_polys=read_integer();
+            for (int i=0;i&lt;num_polys;++i)
+            {
+                pos_+=5;
+                int num_rings=read_integer();
+                for (int i=0;i&lt;num_rings;++i)
+                {
+                    int num_points=read_integer();
+                    CoordinateArray ar(num_points);
+                    read_coords(ar);
+                    poly-&gt;move_to(ar[0].x,ar[0].y);
+                    for (int j=1;j&lt;num_points;++j)
+                    {
+                        poly-&gt;line_to(ar[j].x,ar[j].y);
+                    }
+                    poly-&gt;line_to(ar[0].x,ar[0].y);
+                }
+            }
+            return poly;
         }
     };
-
-
+    
     geometry_ptr geometry_utils::from_wkb(const char* wkb, unsigned size,int srid) 
     {
-	wkb_reader reader(wkb,size,srid);
-	return reader.read();
+        wkb_reader reader(wkb,size,srid);
+        return reader.read();
     }    
 }

Modified: trunk/utils/shapeindex/SConscript
===================================================================
--- trunk/utils/shapeindex/SConscript	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/utils/shapeindex/SConscript	2006-10-04 11:22:18 UTC (rev 313)
@@ -33,7 +33,7 @@
     &quot;&quot;&quot;
     )
 
-headers = ['#plugins/input/shape'] + env['CPPPATH']
+headers = ['#plugins/input/shape'] + env['CPPPATH'] 
 
 shapeindex = env.Program('shapeindex', source, CPPPATH=headers, LIBS='boost_program_options%s' % env['BOOST_APPEND'])
 

Modified: trunk/utils/shapeindex/quadtree.hpp
===================================================================
--- trunk/utils/shapeindex/quadtree.hpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/utils/shapeindex/quadtree.hpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -23,10 +23,11 @@
 
 #ifndef QUADTREE_HH
 #define QUADTREE_HH
-
-#include &quot;envelope.hpp&quot;
+// stl
 #include &lt;vector&gt;
 #include &lt;fstream&gt;
+// mapnik
+#include &lt;mapnik/envelope.hpp&gt;
 
 using namespace mapnik;
 

Modified: trunk/utils/shapeindex/shapeindex.cpp
===================================================================
--- trunk/utils/shapeindex/shapeindex.cpp	2006-10-03 10:06:38 UTC (rev 312)
+++ trunk/utils/shapeindex/shapeindex.cpp	2006-10-04 11:22:18 UTC (rev 313)
@@ -21,17 +21,18 @@
  *****************************************************************************/
 //$Id: shapeindex.cc 27 2005-03-30 21:45:40Z pavlenko $
 
-#include &quot;shape.hpp&quot;
-#include &quot;quadtree.hpp&quot;
 
+#include &lt;iostream&gt;
+#include &lt;vector&gt;
+#include &lt;string&gt;
+
+
 #include &lt;boost/tokenizer.hpp&gt;
 #include &lt;boost/algorithm/string.hpp&gt;
 #include &lt;boost/program_options.hpp&gt;
+#include &quot;quadtree.hpp&quot;
+#include &quot;shape.hpp&quot;
 
-#include &lt;iostream&gt;
-#include &lt;vector&gt;
-#include &lt;string&gt;
-
 const int MAXDEPTH = 64;
 const int DEFAULT_DEPTH = 8;
 const double MINRATIO=0.5;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000197.html">[Mapnik-svn] r312 - trunk/demo/c++
</A></li>
	<LI>Next message: <A HREF="000199.html">[Mapnik-svn] r314 - trunk/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#198">[ date ]</a>
              <a href="thread.html#198">[ thread ]</a>
              <a href="subject.html#198">[ subject ]</a>
              <a href="author.html#198">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/mapnik-svn">More information about the Mapnik-svn
mailing list</a><br>
</body></html>
