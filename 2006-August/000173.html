<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Mapnik-svn] r288 - in trunk: . include src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/mapnik-svn/2006-August/index.html" >
   <LINK REL="made" HREF="mailto:mapnik-svn%40lists.berlios.de?Subject=Re%3A%20%5BMapnik-svn%5D%20r288%20-%20in%20trunk%3A%20.%20include%20src&In-Reply-To=%3C200608201849.k7KInPQb001346%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000174.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mapnik-svn] r288 - in trunk: . include src</H1>
    <B>pavlenko at BerliOS</B> 
    <A HREF="mailto:mapnik-svn%40lists.berlios.de?Subject=Re%3A%20%5BMapnik-svn%5D%20r288%20-%20in%20trunk%3A%20.%20include%20src&In-Reply-To=%3C200608201849.k7KInPQb001346%40sheep.berlios.de%3E"
       TITLE="[Mapnik-svn] r288 - in trunk: . include src">pavlenko at mail.berlios.de
       </A><BR>
    <I>Sun Aug 20 20:49:25 CEST 2006</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000174.html">[Mapnik-svn] r289 - trunk/include
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#173">[ date ]</a>
              <a href="thread.html#173">[ thread ]</a>
              <a href="subject.html#173">[ subject ]</a>
              <a href="author.html#173">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: pavlenko
Date: 2006-08-20 20:49:22 +0200 (Sun, 20 Aug 2006)
New Revision: 288

Modified:
   trunk/SConstruct
   trunk/include/coord.hpp
   trunk/include/envelope.hpp
   trunk/include/geom_util.hpp
   trunk/include/geometry.hpp
   trunk/include/layer.hpp
   trunk/include/map.hpp
   trunk/include/mapnik.hpp
   trunk/include/params.hpp
   trunk/include/vertex_vector.hpp
   trunk/src/mapnik.cpp
Log:
1. removed dependency on boost_serialization ( we don't really need it) at this time.
2. coord and envelope operator&lt;&lt; to use 16 digit precision.
3. added 'inside polygon' method impl.




Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2006-07-24 20:08:32 UTC (rev 287)
+++ trunk/SConstruct	2006-08-20 18:49:22 UTC (rev 288)
@@ -76,11 +76,6 @@
 BOOST_LIBSHEADERS = [
     ['thread', 'boost/thread/mutex.hpp', True],
     ['filesystem', 'boost/filesystem/operations.hpp', True],
-    ['serialization', ['boost/archive/text_oarchive.hpp',
-                        'boost/archive/text_iarchive.hpp',
-                        'boost/archive/xml_oarchive.hpp',
-                        'boost/archive/xml_iarchive.hpp'], True
-    ],
     ['regex', 'boost/regex.hpp', True],
     ['program_options', 'boost/program_options.hpp', False]
 ]

Modified: trunk/include/coord.hpp
===================================================================
--- trunk/include/coord.hpp	2006-07-24 20:08:32 UTC (rev 287)
+++ trunk/include/coord.hpp	2006-08-20 18:49:22 UTC (rev 288)
@@ -26,6 +26,7 @@
 #define COORD_HPP
 
 #include &lt;iostream&gt;
+#include &lt;iomanip&gt;
 #include &lt;sstream&gt;
 
 namespace mapnik 
@@ -113,7 +114,8 @@
         std::basic_ostringstream&lt;charT,traits&gt; s;
         s.copyfmt(out);
         s.width(0);
-        s&lt;&lt;&quot;coord2(&quot;&lt;&lt;c.x&lt;&lt;&quot;,&quot;&lt;&lt;c.y&lt;&lt;&quot;)&quot;;
+        s &lt;&lt; &quot;coord2(&quot; &lt;&lt; std::setprecision(16) 
+          &lt;&lt; c.x &lt;&lt; &quot;,&quot; &lt;&lt; c.y&lt;&lt; &quot;)&quot;;
         out &lt;&lt; s.str();
         return out;
     }
@@ -126,7 +128,8 @@
         std::basic_ostringstream&lt;charT,traits&gt; s;
         s.copyfmt(out);
         s.width(0);
-        s&lt;&lt;&quot;coord3(&quot;&lt;&lt;c.x&lt;&lt;&quot;,&quot;&lt;&lt;c.y&lt;&lt;&quot;,&quot;&lt;&lt;c.z&lt;&lt;&quot;)&quot;;
+        s &lt;&lt; &quot;coord3(&quot; &lt;&lt; std::setprecision(16) 
+          &lt;&lt; c.x &lt;&lt; &quot;,&quot; &lt;&lt; c.y&lt;&lt; &quot;,&quot; &lt;&lt; c.z&lt;&lt;&quot;)&quot;;
         out &lt;&lt; s.str();
         return out;
     } 

Modified: trunk/include/envelope.hpp
===================================================================
--- trunk/include/envelope.hpp	2006-07-24 20:08:32 UTC (rev 287)
+++ trunk/include/envelope.hpp	2006-08-20 18:49:22 UTC (rev 288)
@@ -26,6 +26,7 @@
 #define ENVELOPE_HPP
 
 #include &quot;config.hpp&quot;
+#include &lt;iomanip&gt;
 #include &quot;coord.hpp&quot;
 
 namespace mapnik
@@ -34,50 +35,52 @@
 	template &lt;class T&gt; class MAPNIK_DECL Envelope
     {
     public:
-	typedef Envelope&lt;T&gt; EnvelopeType;
+        typedef Envelope&lt;T&gt; EnvelopeType;
     private:
-	T minx_;
-	T miny_;
-	T maxx_;
-	T maxy_;
+        T minx_;
+        T miny_;
+        T maxx_;
+        T maxy_;
     public:
-	Envelope();
-	Envelope(T minx,T miny,T maxx,T maxy);
-	Envelope(const coord&lt;T,2&gt;&amp; c0,const coord&lt;T,2&gt;&amp; c1);
-	Envelope(const EnvelopeType&amp; rhs);
-	T minx() const;
-	T miny() const;
-	T maxx() const;
-	T maxy() const;
-	T width() const;
-	T height() const;
-	void width(T w);
-	void height(T h);
-	coord&lt;T,2&gt; center() const;
-	void expand_to_include(T x,T y);
-	void expand_to_include(const coord&lt;T,2&gt;&amp; c);
-	void expand_to_include(const EnvelopeType&amp; other);
-	bool contains(const coord&lt;T,2&gt; &amp;c) const;
-	bool contains(T x,T y) const;
-	bool contains(const EnvelopeType &amp;other) const;
-	bool intersects(const coord&lt;T,2&gt; &amp;c) const;
-	bool intersects(T x,T y) const;
-	bool intersects(const EnvelopeType &amp;other) const;
-	EnvelopeType intersect(const EnvelopeType&amp; other) const;
-	bool operator==(const EnvelopeType &amp;other) const;
-	void re_center(T cx,T cy);
-	void init(T x0,T y0,T x1,T y1);
+        Envelope();
+        Envelope(T minx,T miny,T maxx,T maxy);
+        Envelope(const coord&lt;T,2&gt;&amp; c0,const coord&lt;T,2&gt;&amp; c1);
+        Envelope(const EnvelopeType&amp; rhs);
+        T minx() const;
+        T miny() const;
+        T maxx() const;
+        T maxy() const;
+        T width() const;
+        T height() const;
+        void width(T w);
+        void height(T h);
+        coord&lt;T,2&gt; center() const;
+        void expand_to_include(T x,T y);
+        void expand_to_include(const coord&lt;T,2&gt;&amp; c);
+        void expand_to_include(const EnvelopeType&amp; other);
+        bool contains(const coord&lt;T,2&gt; &amp;c) const;
+        bool contains(T x,T y) const;
+        bool contains(const EnvelopeType &amp;other) const;
+        bool intersects(const coord&lt;T,2&gt; &amp;c) const;
+        bool intersects(T x,T y) const;
+        bool intersects(const EnvelopeType &amp;other) const;
+        EnvelopeType intersect(const EnvelopeType&amp; other) const;
+        bool operator==(const EnvelopeType &amp;other) const;
+        void re_center(T cx,T cy);
+        void init(T x0,T y0,T x1,T y1);
     };
     
     template &lt;class charT,class traits,class T&gt;
     inline std::basic_ostream&lt;charT,traits&gt;&amp;
     operator &lt;&lt; (std::basic_ostream&lt;charT,traits&gt;&amp; out,
-		 const Envelope&lt;T&gt;&amp; e)
+                 const Envelope&lt;T&gt;&amp; e)
     {
         std::basic_ostringstream&lt;charT,traits&gt; s;
         s.copyfmt(out);
         s.width(0);
-        s&lt;&lt;&quot;Envelope(&quot;&lt;&lt;e.minx()&lt;&lt;&quot;,&quot;&lt;&lt;e.miny()&lt;&lt;&quot;,&quot;&lt;&lt;e.maxx()&lt;&lt;&quot;,&quot;&lt;&lt;e.maxy()&lt;&lt;&quot;)&quot;;
+        s &lt;&lt;&quot;Envelope(&quot; &lt;&lt; std::setprecision(16) 
+          &lt;&lt; e.minx() &lt;&lt; &quot;,&quot; &lt;&lt; e.miny() &lt;&lt;&quot;,&quot; 
+          &lt;&lt; e.maxx() &lt;&lt; &quot;,&quot; &lt;&lt; e.maxy() &lt;&lt;&quot;)&quot;;
         out &lt;&lt; s.str();
         return out;
     }

Modified: trunk/include/geom_util.hpp
===================================================================
--- trunk/include/geom_util.hpp	2006-07-24 20:08:32 UTC (rev 287)
+++ trunk/include/geom_util.hpp	2006-08-20 18:49:22 UTC (rev 288)
@@ -31,7 +31,7 @@
 {
 
     template &lt;typename T&gt;
-        bool clip_test(T p,T q,double&amp; tmin,double&amp; tmax)
+    bool clip_test(T p,T q,double&amp; tmin,double&amp; tmax)
     {
         double r;
         bool result=true;
@@ -86,78 +86,80 @@
     template &lt;typename Iter&gt; 
     inline bool point_inside_path(double x,double y,Iter start,Iter end)
     {
-	bool inside=false;
-	double x0=start-&gt;x;
-	double y0=start-&gt;y;
-	double x1,y1;
-	while (++start!=end) 
-	{
-	    if (start-&gt;cmd == SEG_MOVETO)
-	    {
-		x0=start-&gt;x;
-		y0=start-&gt;y;
-		continue;
-	    }		
-	    x1=start-&gt;x;
-	    y1=start-&gt;y;
-	    if ((((y1 &lt;= y) &amp;&amp; (y &lt; y0)) ||
-		 ((y0 &lt;= y) &amp;&amp; (y &lt; y1))) &amp;&amp;
-		( x &lt; (x0 - x1) * (y - y1)/ (y0 - y1) + x1))
-		inside=!inside;
-	    x0=x1;
-	    y0=y1;
-	}
+        bool inside=false;
+        double x0=boost::get&lt;0&gt;(*start);
+        double y0=boost::get&lt;1&gt;(*start);
+        
+        double x1,y1;
+        while (++start!=end) 
+        {
+            if ( boost::get&lt;2&gt;(*start) == SEG_MOVETO)
+            {
+                x0 = boost::get&lt;0&gt;(*start);
+                y0 = boost::get&lt;1&gt;(*start);
+                continue;
+            }		
+            x1=boost::get&lt;0&gt;(*start);
+            y1=boost::get&lt;1&gt;(*start);
+            
+            if ((((y1 &lt;= y) &amp;&amp; (y &lt; y0)) ||
+                 ((y0 &lt;= y) &amp;&amp; (y &lt; y1))) &amp;&amp;
+                ( x &lt; (x0 - x1) * (y - y1)/ (y0 - y1) + x1))
+                inside=!inside;
+            x0=x1;
+            y0=y1;
+        }
     	return inside;
     }
 
 #define TOL 0.00001
 
-/*
+    /*
       (Ay-Cy)(Bx-Ax)-(Ax-Cx)(By-Ay)
-  s = -----------------------------
-                 L^2
-*/
+      s = -----------------------------
+      L^2
+    */
 
     inline bool point_in_circle(double x,double y,double cx,double cy,double r)
     {
-	double dx = x - cx;
-	double dy = y - cy;
-	double d2 = dx * dx + dy * dy;
-	return (d2 &lt;= r * r);
+        double dx = x - cx;
+        double dy = y - cy;
+        double d2 = dx * dx + dy * dy;
+        return (d2 &lt;= r * r);
     }
     
     inline bool point_on_segment(double x,double y,double x0,double y0,double x1,double y1)
     {	
-	double dx = x1 - x0;
-	double dy = y1 - y0;
-	if ( fabs(dx) &gt; TOL  ||  fabs(dy) &gt; TOL )
-	{
-	    double s = (y0 - y) * dx - (x0 - x) * dy;
-	    return ( fabs (s) &lt; TOL ) ;
-	} 
-	return false;
+        double dx = x1 - x0;
+        double dy = y1 - y0;
+        if ( fabs(dx) &gt; TOL  ||  fabs(dy) &gt; TOL )
+        {
+            double s = (y0 - y) * dx - (x0 - x) * dy;
+            return ( fabs (s) &lt; TOL ) ;
+        } 
+        return false;
     }
 
     inline bool point_on_segment2(double x,double y,double x0,double y0,double x1,double y1)
     {	 
-	double d  = sqrt ((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0));
-	double d0 = sqrt ((x0 - x) * (x0 - x) + (y0 - y) * (y0 - y));
-	double d1 = sqrt ((x1 - x) * (x1 - x) + (y1 - y) * (y1 - y));
-	double d2 = d0 + d1;
-	return ( d2 - d &lt; 0.01);
+        double d  = sqrt ((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0));
+        double d0 = sqrt ((x0 - x) * (x0 - x) + (y0 - y) * (y0 - y));
+        double d1 = sqrt ((x1 - x) * (x1 - x) + (y1 - y) * (y1 - y));
+        double d2 = d0 + d1;
+        return ( d2 - d &lt; 0.01);
     }
     
 #undef TOL
     template &lt;typename Iter&gt; 
     inline bool point_on_path(double x,double y,Iter start,Iter end)
     {
-	return false;
+        return false;
     }
     
     template &lt;typename Iter&gt; 
     inline bool point_on_points (double x,double y,Iter start,Iter end) 
     {
-	return false; 
+        return false; 
     }
 
     struct filter_in_box

Modified: trunk/include/geometry.hpp
===================================================================
--- trunk/include/geometry.hpp	2006-07-24 20:08:32 UTC (rev 287)
+++ trunk/include/geometry.hpp	2006-08-20 18:49:22 UTC (rev 288)
@@ -45,333 +45,334 @@
     class geometry : private boost::noncopyable
     {   
     public:
-	typedef T vertex_type;
-	typedef typename vertex_type::type value_type;
+        typedef T vertex_type;
+        typedef typename vertex_type::type value_type;
     private:
-	int srid_;
+        int srid_;
     public:
-	geometry (int srid=-1)
-	    : srid_(srid) {}	
+        geometry (int srid=-1)
+            : srid_(srid) {}	
 
-	int srid() const
-	{
-	    return srid_;
-	}
+        int srid() const
+        {
+            return srid_;
+        }
 	
-	Envelope&lt;double&gt; envelope()
-	{
-	    Envelope&lt;double&gt; result;		
-	    double x,y;
-	    for (unsigned i=0;i&lt;num_points();++i)
-	    {
-		vertex(&amp;x,&amp;y);
-		if (i==0)
-		{
-		    result.init(x,y,x,y);
-		}
-		else
-		{
-		    result.expand_to_include(x,y);
-		}
-	    }
-	    return result;
-	}
+        Envelope&lt;double&gt; envelope()
+        {
+            Envelope&lt;double&gt; result;		
+            double x,y;
+            for (unsigned i=0;i&lt;num_points();++i)
+            {
+                vertex(&amp;x,&amp;y);
+                if (i==0)
+                {
+                    result.init(x,y,x,y);
+                }
+                else
+                {
+                    result.expand_to_include(x,y);
+                }
+            }
+            return result;
+        }
 
-	virtual int type() const=0;
-	virtual bool hit_test(value_type x,value_type y) const=0;	
-	virtual void label_position(double *x, double *y) const=0;
-	virtual void move_to(value_type x,value_type y)=0;
-	virtual void line_to(value_type x,value_type y)=0;
-	virtual void transform(const mapnik::CoordTransform&amp; t)=0;
-	virtual unsigned num_points() const = 0;
-	virtual unsigned vertex(double* x, double* y)=0;
-	virtual void rewind(unsigned )=0;
-	virtual void set_capacity(size_t size)=0;
-	virtual ~geometry() {}
+        virtual int type() const=0;
+        virtual bool hit_test(value_type x,value_type y) const=0;	
+        virtual void label_position(double *x, double *y) const=0;
+        virtual void move_to(value_type x,value_type y)=0;
+        virtual void line_to(value_type x,value_type y)=0;
+        virtual void transform(const mapnik::CoordTransform&amp; t)=0;
+        virtual unsigned num_points() const = 0;
+        virtual unsigned vertex(double* x, double* y)=0;
+        virtual void rewind(unsigned )=0;
+        virtual void set_capacity(size_t size)=0;
+        virtual ~geometry() {}
     };
     
     template &lt;typename T&gt;
     class point : public geometry&lt;T&gt;
     {
-	typedef geometry&lt;T&gt; geometry_base;
-	typedef typename geometry&lt;T&gt;::vertex_type vertex_type;
-	typedef typename geometry&lt;T&gt;::value_type value_type;
+        typedef geometry&lt;T&gt; geometry_base;
+        typedef typename geometry&lt;T&gt;::vertex_type vertex_type;
+        typedef typename geometry&lt;T&gt;::value_type value_type;
     private:
-	vertex_type pt_;
+        vertex_type pt_;
     public:
-	point(int srid)
-	    : geometry&lt;T&gt;(srid)
-	{}
+        point(int srid)
+            : geometry&lt;T&gt;(srid)
+        {}
 	 
-	int type() const 
-	{
-	    return Point;
-	}
-	void label_position(double *x, double *y) const
-	{
-	    *x = pt_.x;
-	    *y = pt_.y;
-	}
+        int type() const 
+        {
+            return Point;
+        }
+        void label_position(double *x, double *y) const
+        {
+            *x = pt_.x;
+            *y = pt_.y;
+        }
 	
-	void move_to(value_type x,value_type y)
-	{
-	    pt_.x = x;
-	    pt_.y = y;
-	}
+        void move_to(value_type x,value_type y)
+        {
+            pt_.x = x;
+            pt_.y = y;
+        }
 	
-	void line_to(value_type ,value_type ) {}
+        void line_to(value_type ,value_type ) {}
 	
-	void transform(const mapnik::CoordTransform&amp; t)
-	{
-	    t.forward_x(&amp;pt_.x);
-	    t.forward_y(&amp;pt_.y);
-	}
+        void transform(const mapnik::CoordTransform&amp; t)
+        {
+            t.forward_x(&amp;pt_.x);
+            t.forward_y(&amp;pt_.y);
+        }
 	
-	unsigned num_points() const
-	{
-	    return 1;
-	}
+        unsigned num_points() const
+        {
+            return 1;
+        }
 	
-	unsigned vertex(double* x, double* y)
-	{
-	    *x = pt_.x;
-	    *y = pt_.y;
-	    return SEG_LINETO;
-	}
+        unsigned vertex(double* x, double* y)
+        {
+            *x = pt_.x;
+            *y = pt_.y;
+            return SEG_LINETO;
+        }
 	
-	void rewind(unsigned ) {}
+        void rewind(unsigned ) {}
 	
-	bool hit_test(value_type x,value_type y) const
-	{
-	    return false;
-	}
-	void set_capacity(size_t) {}
-	virtual ~point() {}
+        bool hit_test(value_type x,value_type y) const
+        {
+            return false;
+        }
+        void set_capacity(size_t) {}
+        virtual ~point() {}
     };
 
-    template &lt;typename T, template &lt;typename&gt; class Container=vertex_vector&gt;
+    template &lt;typename T, template &lt;typename&gt; class Container=vertex_vector2&gt;
     class polygon : public geometry&lt;T&gt;
     {
-	typedef geometry&lt;T&gt; geometry_base;
-	typedef typename geometry&lt;T&gt;::vertex_type vertex_type;
-	typedef typename geometry_base::value_type value_type;
-	typedef Container&lt;vertex_type&gt; container_type;
+        typedef geometry&lt;T&gt; geometry_base;
+        typedef typename geometry&lt;T&gt;::vertex_type vertex_type;
+        typedef typename geometry_base::value_type value_type;
+        typedef Container&lt;vertex_type&gt; container_type;
     private:
-	container_type cont_;
-	mutable unsigned itr_;
+        container_type cont_;
+        mutable unsigned itr_;
     public:
-	polygon(int srid)
-	    : geometry_base(srid),
-	      itr_(0)
-	{}
+        polygon(int srid)
+            : geometry_base(srid),
+              itr_(0)
+        {}
         
-	int type() const 
-	{
-	    return Polygon;
-	}
+        int type() const 
+        {
+            return Polygon;
+        }
 	
-	void label_position(double *x, double *y) const
-	{
+        void label_position(double *x, double *y) const
+        {
 	    
-	    unsigned size = cont_.size();
-	    if (size &lt; 3) 
-	    {
-		cont_.get_vertex(0,x,y);
-		return;
-	    }
+            unsigned size = cont_.size();
+            if (size &lt; 3) 
+            {
+                cont_.get_vertex(0,x,y);
+                return;
+            }
 	      
-	    double ai;
-	    double atmp = 0;
-	    double xtmp = 0;
-	    double ytmp = 0;
-	    double x0 =0;
-	    double y0 =0;
-	    double x1 =0;
-	    double y1 =0;
+            double ai;
+            double atmp = 0;
+            double xtmp = 0;
+            double ytmp = 0;
+            double x0 =0;
+            double y0 =0;
+            double x1 =0;
+            double y1 =0;
 	    
-	    unsigned i,j;
-	    for (i = size-1,j = 0; j &lt; size; i = j, ++j)
-	    {
+            unsigned i,j;
+            for (i = size-1,j = 0; j &lt; size; i = j, ++j)
+            {
 		
-		cont_.get_vertex(i,&amp;x0,&amp;y0);
-		cont_.get_vertex(j,&amp;x1,&amp;y1);
-		ai = x0 * y1 - x1 * y0;
-		atmp += ai;
-		xtmp += (x1 + x0) * ai;
-		ytmp += (y1 + y0) * ai;
-	    }	  
-	    if (atmp != 0)
-	    {
-		*x = xtmp/(3*atmp);
-		*y = ytmp /(3*atmp);
-		return;
-	    }
-	    *x=x0;
-	    *y=y0;	    	    
-	}
+                cont_.get_vertex(i,&amp;x0,&amp;y0);
+                cont_.get_vertex(j,&amp;x1,&amp;y1);
+                ai = x0 * y1 - x1 * y0;
+                atmp += ai;
+                xtmp += (x1 + x0) * ai;
+                ytmp += (y1 + y0) * ai;
+            }	  
+            if (atmp != 0)
+            {
+                *x = xtmp/(3*atmp);
+                *y = ytmp /(3*atmp);
+                return;
+            }
+            *x=x0;
+            *y=y0;	    	    
+        }
 
-	void line_to(value_type x,value_type y)
-	{
-	    cont_.push_back(x,y,SEG_LINETO);
-	}
+        void line_to(value_type x,value_type y)
+        {
+            cont_.push_back(x,y,SEG_LINETO);
+        }
 
-	void move_to(value_type x,value_type y)
-	{
-	    cont_.push_back(x,y,SEG_MOVETO);
-	}
+        void move_to(value_type x,value_type y)
+        {
+            cont_.push_back(x,y,SEG_MOVETO);
+        }
 	
-	void transform(mapnik::CoordTransform const&amp; t)
-	{
-	    unsigned size = cont_.size();
-	    for (unsigned pos=0; pos &lt; size; ++pos)
-	    {	
-		cont_.transform_at(pos,t);
-	    }
-	}
+        void transform(mapnik::CoordTransform const&amp; t)
+        {
+            unsigned size = cont_.size();
+            for (unsigned pos=0; pos &lt; size; ++pos)
+            {	
+                cont_.transform_at(pos,t);
+            }
+        }
 	
         unsigned num_points() const
-	{
-	    return cont_.size();
-	}
+        {
+            return cont_.size();
+        }
 	
-	unsigned vertex(double* x, double* y)
-	{
-	    return cont_.get_vertex(itr_++,x,y);
-	}
+        unsigned vertex(double* x, double* y)
+        {
+            return cont_.get_vertex(itr_++,x,y);
+        }
 	
-	void rewind(unsigned )
-	{
-	    itr_=0;
-	}
+        void rewind(unsigned )
+        {
+            itr_=0;
+        }
 	
-	bool hit_test(value_type x,value_type y) const
-	{	    
-	    return false;
-	} 
-	void set_capacity(size_t size) 
-	{
-	    cont_.set_capacity(size);
-	}
-	virtual ~polygon() {}
+        bool hit_test(value_type x,value_type y) const
+        {	    
+            return point_inside_path(x,y,cont_.begin(),cont_.end());
+        } 
+        
+        void set_capacity(size_t size) 
+        {
+            cont_.set_capacity(size);
+        }
+        virtual ~polygon() {}
     };
     
     template &lt;typename T, template &lt;typename&gt; class Container=vertex_vector&gt;
     class line_string : public geometry&lt;T&gt;
     {
-	typedef geometry&lt;T&gt; geometry_base;
-	typedef typename geometry_base::value_type value_type;
-	typedef typename geometry&lt;T&gt;::vertex_type vertex_type;
-	typedef Container&lt;vertex_type&gt; container_type;
+        typedef geometry&lt;T&gt; geometry_base;
+        typedef typename geometry_base::value_type value_type;
+        typedef typename geometry&lt;T&gt;::vertex_type vertex_type;
+        typedef Container&lt;vertex_type&gt; container_type;
     private:
-	container_type cont_;
-	mutable unsigned itr_;
+        container_type cont_;
+        mutable unsigned itr_;
     public:
-	line_string(int srid)
-	    : geometry_base(srid),
-	      itr_(0)
-	{}
+        line_string(int srid)
+            : geometry_base(srid),
+              itr_(0)
+        {}
         
-	int type() const 
-	{
-	    return LineString;
-	}
+        int type() const 
+        {
+            return LineString;
+        }
         void label_position(double *x, double *y) const
-	{
-	    // calculate mid point on line string
-	    double x0=0;
-	    double y0=0;
-	    double x1=0;
-	    double y1=0;
+        {
+            // calculate mid point on line string
+            double x0=0;
+            double y0=0;
+            double x1=0;
+            double y1=0;
 	    
-	    unsigned size = cont_.size();
-	    if (size == 1)
-	    {
-		cont_.get_vertex(0,x,y); 
-	    }
-	    else if (size == 2)
-	    {
+            unsigned size = cont_.size();
+            if (size == 1)
+            {
+                cont_.get_vertex(0,x,y); 
+            }
+            else if (size == 2)
+            {
 
-		cont_.get_vertex(0,&amp;x0,&amp;y0);
-		cont_.get_vertex(1,&amp;x1,&amp;y1);
-		*x = 0.5 * (x1 + x0);
-		*y = 0.5 * (y1 + y0);		
-	    }
-	    else
-	    {
-		double len=0.0;
-		for (unsigned pos = 1; pos &lt; size; ++pos)
-		{
-		    cont_.get_vertex(pos-1,&amp;x0,&amp;y0);
-		    cont_.get_vertex(pos,&amp;x1,&amp;y1);
-		    double dx = x1 - x0;
-		    double dy = y1 - y0;
-		    len += sqrt(dx * dx + dy * dy);
-		}
-		double midlen = 0.5 * len;
-		double dist = 0.0;
-		for (unsigned pos = 1; pos &lt; size;++pos)
-		{
-		    cont_.get_vertex(pos-1,&amp;x0,&amp;y0);
-		    cont_.get_vertex(pos,&amp;x1,&amp;y1);
-		    double dx = x1 - x0;
-		    double dy = y1 - y0; 
-		    double seg_len = sqrt(dx * dx + dy * dy);
-		    if (( dist + seg_len) &gt;= midlen)
-		    {
-			double r = (midlen - dist)/seg_len;
-			*x = x0 + (x1 - x0) * r;
-			*y = y0 + (y1 - y0) * r;
-			break;
-		    }
-		    dist += seg_len;
-		}
-	    }
+                cont_.get_vertex(0,&amp;x0,&amp;y0);
+                cont_.get_vertex(1,&amp;x1,&amp;y1);
+                *x = 0.5 * (x1 + x0);
+                *y = 0.5 * (y1 + y0);		
+            }
+            else
+            {
+                double len=0.0;
+                for (unsigned pos = 1; pos &lt; size; ++pos)
+                {
+                    cont_.get_vertex(pos-1,&amp;x0,&amp;y0);
+                    cont_.get_vertex(pos,&amp;x1,&amp;y1);
+                    double dx = x1 - x0;
+                    double dy = y1 - y0;
+                    len += sqrt(dx * dx + dy * dy);
+                }
+                double midlen = 0.5 * len;
+                double dist = 0.0;
+                for (unsigned pos = 1; pos &lt; size;++pos)
+                {
+                    cont_.get_vertex(pos-1,&amp;x0,&amp;y0);
+                    cont_.get_vertex(pos,&amp;x1,&amp;y1);
+                    double dx = x1 - x0;
+                    double dy = y1 - y0; 
+                    double seg_len = sqrt(dx * dx + dy * dy);
+                    if (( dist + seg_len) &gt;= midlen)
+                    {
+                        double r = (midlen - dist)/seg_len;
+                        *x = x0 + (x1 - x0) * r;
+                        *y = y0 + (y1 - y0) * r;
+                        break;
+                    }
+                    dist += seg_len;
+                }
+            }
 	    
-	}
-	void line_to(value_type x,value_type y)
-	{
-	    cont_.push_back(x,y,SEG_LINETO);
-	}
+        }
+        void line_to(value_type x,value_type y)
+        {
+            cont_.push_back(x,y,SEG_LINETO);
+        }
 
-	void move_to(value_type x,value_type y)
-	{
-	    cont_.push_back(x,y,SEG_MOVETO);
-	}
+        void move_to(value_type x,value_type y)
+        {
+            cont_.push_back(x,y,SEG_MOVETO);
+        }
 	
-	void transform(mapnik::CoordTransform const&amp; t)
-	{
-	    unsigned size = cont_.size();
-	    for (unsigned pos=0; pos &lt; size; ++pos)
-	    {	
-		cont_.transform_at(pos,t);
-	    }
-	}
+        void transform(mapnik::CoordTransform const&amp; t)
+        {
+            unsigned size = cont_.size();
+            for (unsigned pos=0; pos &lt; size; ++pos)
+            {	
+                cont_.transform_at(pos,t);
+            }
+        }
 	
         unsigned num_points() const
-	{
-	    return cont_.size();
-	}
+        {
+            return cont_.size();
+        }
 	
-	unsigned vertex(double* x, double* y)
-	{
-	    return cont_.get_vertex(itr_++,x,y);
-	}
+        unsigned vertex(double* x, double* y)
+        {
+            return cont_.get_vertex(itr_++,x,y);
+        }
 	
-	void rewind(unsigned )
-	{
-	    itr_=0;
-	}
+        void rewind(unsigned )
+        {
+            itr_=0;
+        }
 	
-	bool hit_test(value_type x,value_type y) const
-	{	    
-	    return false;
-	} 
+        bool hit_test(value_type x,value_type y) const
+        {	    
+            return false;
+        } 
 	
-	void set_capacity(size_t size) 
-	{
-	    cont_.set_capacity(size);
-	}
-	virtual ~line_string() {}
+        void set_capacity(size_t size) 
+        {
+            cont_.set_capacity(size);
+        }
+        virtual ~line_string() {}
     };
 
     typedef point&lt;vertex2d&gt; point_impl;

Modified: trunk/include/layer.hpp
===================================================================
--- trunk/include/layer.hpp	2006-07-24 20:08:32 UTC (rev 287)
+++ trunk/include/layer.hpp	2006-08-20 18:49:22 UTC (rev 288)
@@ -15,10 +15,11 @@
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *****************************************************************************/
+ * #include &lt;boost/serialization/serialization.hpp&gt;
+License along with this library; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*
+*****************************************************************************/
 //$Id: layer.hpp 39 2005-04-10 20:39:53Z pavlenko $
 
 #ifndef LAYER_HPP
@@ -28,27 +29,11 @@
 #include &quot;feature.hpp&quot;
 #include &quot;datasource.hpp&quot;
 #include &lt;boost/shared_ptr.hpp&gt;
-#include &lt;boost/serialization/serialization.hpp&gt;
 
 namespace mapnik
 {
     class MAPNIK_DECL Layer
     {
-        friend class boost::serialization::access;
-        template &lt;typename Archive&gt;
-        void serialize(Archive &amp; ar, const unsigned int /*version*/)
-        {
-            ar  &amp; boost::serialization::make_nvp(&quot;name&quot;,name_)
-            	&amp; boost::serialization::make_nvp(&quot;title&quot;,title_)
-            	&amp; boost::serialization::make_nvp(&quot;abstract&quot;,abstract_)
-                &amp; boost::serialization::make_nvp(&quot;params&quot;,params_)
-                &amp; boost::serialization::make_nvp(&quot;min_zoom&quot;,minZoom_)
-                &amp; boost::serialization::make_nvp(&quot;max_zoom&quot;,maxZoom_)
-                &amp; boost::serialization::make_nvp(&quot;active&quot;,active_)
-                &amp; boost::serialization::make_nvp(&quot;selectable&quot;,selectable_)
-                &amp; boost::serialization::make_nvp(&quot;styles&quot;,styles_)
-                ;
-        }
         parameters params_;
         std::string name_;
         std::string title_;
@@ -102,10 +87,4 @@
     };
 }
 
-BOOST_CLASS_IMPLEMENTATION(std::vector&lt;std::string&gt;, boost::serialization::object_serializable)
-BOOST_CLASS_TRACKING(std::vector&lt;std::string&gt;, boost::serialization::track_never)
-
-BOOST_CLASS_IMPLEMENTATION(mapnik::Layer, boost::serialization::object_serializable)
-BOOST_CLASS_TRACKING(mapnik::Layer, boost::serialization::track_never)
-
 #endif //LAYER_HPP

Modified: trunk/include/map.hpp
===================================================================
--- trunk/include/map.hpp	2006-07-24 20:08:32 UTC (rev 287)
+++ trunk/include/map.hpp	2006-08-20 18:49:22 UTC (rev 288)
@@ -24,8 +24,6 @@
 #ifndef MAP_HPP
 #define MAP_HPP
 
-#include &lt;boost/serialization/serialization.hpp&gt;
-#include &lt;boost/serialization/vector.hpp&gt;
 #include &quot;feature_type_style.hpp&quot;
 
 namespace mapnik
@@ -33,17 +31,7 @@
     class Layer;
 
     class MAPNIK_DECL Map
-    {
-        friend class boost::serialization::access;
-        template &lt;typename Archive&gt;
-        void serialize(Archive &amp; ar, const unsigned int /*version*/)
-        {
-            ar  &amp; boost::serialization::make_nvp(&quot;width&quot;,width_) 
-                &amp; boost::serialization::make_nvp(&quot;height&quot;,height_) 
-                &amp; boost::serialization::make_nvp(&quot;srid&quot;,srid_)
-                &amp; boost::serialization::make_nvp(&quot;layers&quot;,layers_);
-        }
-	
+    {	
         static const unsigned MIN_MAPSIZE=16;
         static const unsigned MAX_MAPSIZE=2048;
         unsigned width_;
@@ -94,10 +82,4 @@
     };
 }
 
-BOOST_CLASS_IMPLEMENTATION(std::vector&lt;mapnik::Layer&gt;, boost::serialization::object_serializable)
-BOOST_CLASS_TRACKING(std::vector&lt;mapnik::Layer&gt;, boost::serialization::track_never)
-
-BOOST_CLASS_IMPLEMENTATION(mapnik::Map, boost::serialization::object_serializable)
-BOOST_CLASS_TRACKING(mapnik::Map, boost::serialization::track_never)
-
 #endif //MAP_HPP

Modified: trunk/include/mapnik.hpp
===================================================================
--- trunk/include/mapnik.hpp	2006-07-24 20:08:32 UTC (rev 287)
+++ trunk/include/mapnik.hpp	2006-08-20 18:49:22 UTC (rev 288)
@@ -79,8 +79,6 @@
 
 namespace mapnik
 {
-    void MAPNIK_DECL save_to_xml(Map const&amp; map,const char* filename);  
-    void MAPNIK_DECL load_from_xml(Map &amp; map, const char * filename);
 }
 
 #endif //MAPNIK_HPP

Modified: trunk/include/params.hpp
===================================================================
--- trunk/include/params.hpp	2006-07-24 20:08:32 UTC (rev 287)
+++ trunk/include/params.hpp	2006-08-20 18:49:22 UTC (rev 288)
@@ -44,36 +44,6 @@
 
     class parameters : public param_map
     {
-        friend class boost::serialization::access;
-        
-        template &lt;typename Archive&gt;
-        void save(Archive &amp; ar, const unsigned int /*version*/) const
-        {
-            const size_t size = param_map::size();
-            ar &amp; boost::serialization::make_nvp(&quot;count&quot;,size);
-            param_map::const_iterator itr;
-            for (itr=param_map::begin();itr!=param_map::end();++itr)
-            {
-                ar &amp; boost::serialization::make_nvp(&quot;name&quot;,itr-&gt;first);
-                ar &amp; boost::serialization::make_nvp(&quot;value&quot;,itr-&gt;second);
-            }
-        }
-	
-        template &lt;typename Archive&gt;
-        void load(Archive &amp; ar, const unsigned int /*version*/)
-        {	    
-            size_t size;
-            ar &amp; boost::serialization::make_nvp(&quot;size&quot;,size);
-            for (size_t i=0;i&lt;size;++i)
-            {
-                std::string name;
-                std::string value;
-                ar &amp; boost::serialization::make_nvp(&quot;name&quot;,name);
-                ar &amp; boost::serialization::make_nvp(&quot;value&quot;,value);
-                param_map::insert(make_pair(name,value));
-            }
-        }
-        BOOST_SERIALIZATION_SPLIT_MEMBER()
      public:
 
         parameters() {}
@@ -89,10 +59,4 @@
     };
 }
 
-BOOST_CLASS_IMPLEMENTATION(mapnik::parameter, boost::serialization::object_serializable)
-BOOST_CLASS_TRACKING(mapnik::parameter, boost::serialization::track_never)
-
-BOOST_CLASS_IMPLEMENTATION(mapnik::parameters, boost::serialization::object_serializable)
-BOOST_CLASS_TRACKING(mapnik::parameters, boost::serialization::track_never)
-
 #endif //PARAMS_HPP

Modified: trunk/include/vertex_vector.hpp
===================================================================
--- trunk/include/vertex_vector.hpp	2006-07-24 20:08:32 UTC (rev 287)
+++ trunk/include/vertex_vector.hpp	2006-08-20 18:49:22 UTC (rev 288)
@@ -42,146 +42,157 @@
     template &lt;typename T&gt;
     class vertex_vector : private boost::noncopyable
     {
-	typedef typename T::type value_type;
-	typedef vertex&lt;value_type,2&gt; vertex_type;
-	enum {
-	    block_shift = 8,
-	    block_size  = 1&lt;&lt;block_shift,
-	    block_mask  = block_size - 1,
-	    grow_by     = 256
-	};
+        typedef typename T::type value_type;
+        typedef vertex&lt;value_type,2&gt; vertex_type;
+        enum {
+            block_shift = 8,
+            block_size  = 1&lt;&lt;block_shift,
+            block_mask  = block_size - 1,
+            grow_by     = 256
+        };
 
     private:
-	unsigned num_blocks_;
-	unsigned max_blocks_;
-	value_type** vertexs_;
-	unsigned char** commands_;
-	unsigned pos_;
+        unsigned num_blocks_;
+        unsigned max_blocks_;
+        value_type** vertexs_;
+        unsigned char** commands_;
+        unsigned pos_;
     public:
 	
-	vertex_vector() 
-	    : num_blocks_(0),
-	      max_blocks_(0),
-	      vertexs_(0),
-	      commands_(0),
-	      pos_(0) {}
+        vertex_vector() 
+            : num_blocks_(0),
+              max_blocks_(0),
+              vertexs_(0),
+              commands_(0),
+              pos_(0) {}
 
-	~vertex_vector()
-	{
-	    if ( num_blocks_ )
-	    {
-		value_type** vertexs=vertexs_ + num_blocks_ - 1;
-		while ( num_blocks_-- )
-		{
-		    delete [] *vertexs;
-		    --vertexs;
-		}
-		delete [] vertexs_;
-	    }
-	}
-	unsigned size() const 
-	{
-	    return pos_;
-	}
+        ~vertex_vector()
+        {
+            if ( num_blocks_ )
+            {
+                value_type** vertexs=vertexs_ + num_blocks_ - 1;
+                while ( num_blocks_-- )
+                {
+                    delete [] *vertexs;
+                    --vertexs;
+                }
+                delete [] vertexs_;
+            }
+        }
+        unsigned size() const 
+        {
+            return pos_;
+        }
 	
-	void push_back (value_type x,value_type y,unsigned command)
-	{
-	    unsigned block = pos_ &gt;&gt; block_shift;
-	    if (block &gt;= num_blocks_)
-	    {
-		allocate_block(block);
-	    }
-	    value_type* vertex = vertexs_[block] + ((pos_ &amp; block_mask) &lt;&lt; 1);
-	    unsigned char* cmd= commands_[block] + (pos_ &amp; block_mask);
+        void push_back (value_type x,value_type y,unsigned command)
+        {
+            unsigned block = pos_ &gt;&gt; block_shift;
+            if (block &gt;= num_blocks_)
+            {
+                allocate_block(block);
+            }
+            value_type* vertex = vertexs_[block] + ((pos_ &amp; block_mask) &lt;&lt; 1);
+            unsigned char* cmd= commands_[block] + (pos_ &amp; block_mask);
 	    
-	    *cmd = static_cast&lt;unsigned char&gt;(command);
-	    *vertex++ = x;
-	    *vertex   = y;
-	    ++pos_;
-	}
-	unsigned get_vertex(unsigned pos,value_type* x,value_type* y) const
-	{
-	    if (pos &gt;= pos_) return SEG_END;
-	    unsigned block = pos &gt;&gt; block_shift;
-	    const value_type* vertex = vertexs_[block] + (( pos &amp; block_mask) &lt;&lt; 1);
-	    *x = (*vertex++);
-	    *y = (*vertex);
-	    return commands_[block] [pos &amp; block_mask];
-	}
+            *cmd = static_cast&lt;unsigned char&gt;(command);
+            *vertex++ = x;
+            *vertex   = y;
+            ++pos_;
+        }
+        unsigned get_vertex(unsigned pos,value_type* x,value_type* y) const
+        {
+            if (pos &gt;= pos_) return SEG_END;
+            unsigned block = pos &gt;&gt; block_shift;
+            const value_type* vertex = vertexs_[block] + (( pos &amp; block_mask) &lt;&lt; 1);
+            *x = (*vertex++);
+            *y = (*vertex);
+            return commands_[block] [pos &amp; block_mask];
+        }
         	
-	void transform_at(unsigned pos,const CoordTransform&amp; t)
-	{
-	    if (pos &gt;= pos_) return;
-	    unsigned block = pos &gt;&gt; block_shift;
-	    value_type* vertex = vertexs_[block] + (( pos &amp; block_mask) &lt;&lt; 1);
-	    t.forward_x(vertex);
-	    ++vertex;
-	    t.forward_y(vertex);
-	}
-	void set_capacity(size_t)
-	{
-	    //do nothing
-	}
+        void transform_at(unsigned pos,const CoordTransform&amp; t)
+        {
+            if (pos &gt;= pos_) return;
+            unsigned block = pos &gt;&gt; block_shift;
+            value_type* vertex = vertexs_[block] + (( pos &amp; block_mask) &lt;&lt; 1);
+            t.forward_x(vertex);
+            ++vertex;
+            t.forward_y(vertex);
+        }
+        void set_capacity(size_t)
+        {
+            //do nothing
+        }
     private:
-	void allocate_block(unsigned block)
-	{
-	    if (block &gt;= max_blocks_)
-	    {
-		value_type** new_vertexs = new value_type* [(max_blocks_ + grow_by) * 2];
-		unsigned char** new_commands = (unsigned char**)(new_vertexs + max_blocks_ + grow_by);
-		if (vertexs_)
-		{
-		    std::memcpy(new_vertexs,vertexs_,max_blocks_ * sizeof(value_type*));
-		    std::memcpy(new_commands,commands_,max_blocks_ * sizeof(unsigned char*));
-		    delete [] vertexs_;
-		}
-		vertexs_ = new_vertexs;
-		commands_ = new_commands;
-		max_blocks_ += grow_by;
-	    }
-	    vertexs_[block] = new value_type [block_size * 2 + block_size / (sizeof(value_type))];
-	    commands_[block] = (unsigned char*)(vertexs_[block] + block_size*2);
-	    ++num_blocks_;
-	}
+        void allocate_block(unsigned block)
+        {
+            if (block &gt;= max_blocks_)
+            {
+                value_type** new_vertexs = new value_type* [(max_blocks_ + grow_by) * 2];
+                unsigned char** new_commands = (unsigned char**)(new_vertexs + max_blocks_ + grow_by);
+                if (vertexs_)
+                {
+                    std::memcpy(new_vertexs,vertexs_,max_blocks_ * sizeof(value_type*));
+                    std::memcpy(new_commands,commands_,max_blocks_ * sizeof(unsigned char*));
+                    delete [] vertexs_;
+                }
+                vertexs_ = new_vertexs;
+                commands_ = new_commands;
+                max_blocks_ += grow_by;
+            }
+            vertexs_[block] = new value_type [block_size * 2 + block_size / (sizeof(value_type))];
+            commands_[block] = (unsigned char*)(vertexs_[block] + block_size*2);
+            ++num_blocks_;
+        }
     };
 
     template &lt;typename T&gt;
     struct vertex_vector2 : boost::noncopyable
     {
-	typedef typename T::type value_type;
-	typedef boost::tuple&lt;value_type,value_type,char&gt; vertex_type;
-	vertex_vector2() {}
-	unsigned size() const 
-	{
-	    return cont_.size();
-	}
+        typedef typename T::type value_type;
+        typedef boost::tuple&lt;value_type,value_type,char&gt; vertex_type;
+        typedef typename std::vector&lt;vertex_type&gt;::const_iterator const_iterator;
+        vertex_vector2() {}
+        unsigned size() const 
+        {
+            return cont_.size();
+        }
 
-	void push_back (value_type x,value_type y,unsigned command)
-	{
-	    cont_.push_back(vertex_type(x,y,command));
-	}
-	unsigned get_vertex(unsigned pos,value_type* x,value_type* y) const
-	{
-	    if (pos &gt;= cont_.size()) return SEG_END;
-	    vertex_type const&amp; c = cont_[pos];
-	    *x = boost::get&lt;0&gt;(c);
-	    *y = boost::get&lt;1&gt;(c);
-	    return boost::get&lt;2&gt;(c);
-	}
-	
-	void transform_at(unsigned pos,const CoordTransform&amp; t)
-	{
-	    if (pos &gt;= cont_.size()) return;
-	    vertex_type &amp; c = cont_[pos];
-	    t.forward_x(&amp;boost::get&lt;0&gt;(c));
-	    t.forward_y(&amp;boost::get&lt;1&gt;(c));
-	}
-	void set_capacity(size_t size)
-	{
-	    cont_.reserve(size);
-	}
+        void push_back (value_type x,value_type y,unsigned command)
+        {
+            cont_.push_back(vertex_type(x,y,command));
+        }
+        unsigned get_vertex(unsigned pos,value_type* x,value_type* y) const
+        {
+            if (pos &gt;= cont_.size()) return SEG_END;
+            vertex_type const&amp; c = cont_[pos];
+            *x = boost::get&lt;0&gt;(c);
+            *y = boost::get&lt;1&gt;(c);
+            return boost::get&lt;2&gt;(c);
+        }
+        
+        const_iterator begin() const
+        {
+            return cont_.begin();
+        }
+        
+        const_iterator end() const
+        {
+            return cont_.end();
+        }
+
+        void transform_at(unsigned pos,const CoordTransform&amp; t)
+        {
+            if (pos &gt;= cont_.size()) return;
+            vertex_type &amp; c = cont_[pos];
+            t.forward_x(&amp;boost::get&lt;0&gt;(c));
+            t.forward_y(&amp;boost::get&lt;1&gt;(c));
+        }
+        void set_capacity(size_t size)
+        {
+            cont_.reserve(size);
+        }
     private:
-	std::vector&lt;vertex_type&gt; cont_;
+        std::vector&lt;vertex_type&gt; cont_;
     };
 }
 

Modified: trunk/src/mapnik.cpp
===================================================================
--- trunk/src/mapnik.cpp	2006-07-24 20:08:32 UTC (rev 287)
+++ trunk/src/mapnik.cpp	2006-08-20 18:49:22 UTC (rev 288)
@@ -23,27 +23,10 @@
 //$Id$
 
 #include &lt;fstream&gt;
-#include &lt;boost/archive/xml_iarchive.hpp&gt;
-#include &lt;boost/archive/xml_oarchive.hpp&gt;
 #include &quot;mapnik.hpp&quot;
 
 namespace mapnik
 {
-    void save_to_xml(Map const&amp; m,const char* filename)
-    {
-	std::ofstream ofs(filename);
-	assert(ofs.good());
-	boost::archive::xml_oarchive oa(ofs);
-	oa &lt;&lt; boost::serialization::make_nvp(&quot;map&quot;,m);
-    }
-
-    void load_from_xml(Map &amp; m,const char* filename)
-    {
-	std::ifstream ifs(filename);
-	assert(ifs.good());
-	boost::archive::xml_iarchive ia(ifs);
-	ia &gt;&gt; boost::serialization::make_nvp(&quot;map&quot;,m);
-    }
 }
 
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000174.html">[Mapnik-svn] r289 - trunk/include
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#173">[ date ]</a>
              <a href="thread.html#173">[ thread ]</a>
              <a href="subject.html#173">[ subject ]</a>
              <a href="author.html#173">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/mapnik-svn">More information about the Mapnik-svn
mailing list</a><br>
</body></html>
